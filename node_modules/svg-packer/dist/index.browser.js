var SvgPacker = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_shim();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i2 = 0, len = code.length; i2 < len; ++i2) {
        lookup[i2] = code[i2];
        revLookup[code.charCodeAt(i2)] = i2;
      }
      var i2;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1) validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i3;
        for (i3 = 0; i3 < len2; i3 += 4) {
          tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i3 = start; i3 < end; i3 += 3) {
          tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_shim();
      exports.read = function(buffer2, offset, isLE, mLen, nBytes) {
        var e2, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i2 = isLE ? nBytes - 1 : 0;
        var d2 = isLE ? -1 : 1;
        var s2 = buffer2[offset + i2];
        i2 += d2;
        e2 = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
        }
        m = e2 & (1 << -nBits) - 1;
        e2 >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
        }
        if (e2 === 0) {
          e2 = 1 - eBias;
        } else if (e2 === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e2 = e2 - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e2 - mLen);
      };
      exports.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
        var e2, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i2 = isLE ? 0 : nBytes - 1;
        var d2 = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e2 = eMax;
        } else {
          e2 = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e2)) < 1) {
            e2--;
            c *= 2;
          }
          if (e2 + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e2++;
            c /= 2;
          }
          if (e2 + eBias >= eMax) {
            m = 0;
            e2 = eMax;
          } else if (e2 + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e2 = e2 + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e2 = 0;
          }
        }
        for (; mLen >= 8; buffer2[offset + i2] = m & 255, i2 += d2, m /= 256, mLen -= 8) {
        }
        e2 = e2 << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer2[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
        }
        buffer2[offset + i2 - d2] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@5.7.1/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@5.7.1/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_shim();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer4;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer4.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          var arr = new Uint8Array(1);
          var proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e2) {
          return false;
        }
      }
      Object.defineProperty(Buffer4.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer4.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer4.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer4.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        var buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer4.prototype);
        return buf;
      }
      function Buffer4(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer4.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        var valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer4.from(valueOf, encodingOrOffset, length);
        }
        var b2 = fromObject2(value);
        if (b2) return b2;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer4.from(
            value[Symbol.toPrimitive]("string"),
            encodingOrOffset,
            length
          );
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer4.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer4.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer4, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer4.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer4.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer4.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer4.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        var length = byteLength(string, encoding) | 0;
        var buf = createBuffer(length);
        var actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        var buf = createBuffer(length);
        for (var i2 = 0; i2 < length; i2 += 1) {
          buf[i2] = array[i2] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          var copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        var buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer4.prototype);
        return buf;
      }
      function fromObject2(obj) {
        if (Buffer4.isBuffer(obj)) {
          var len = checked(obj.length) | 0;
          var buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer4.alloc(+length);
      }
      Buffer4.isBuffer = function isBuffer(b2) {
        return b2 != null && b2._isBuffer === true && b2 !== Buffer4.prototype;
      };
      Buffer4.compare = function compare(a2, b2) {
        if (isInstance(a2, Uint8Array)) a2 = Buffer4.from(a2, a2.offset, a2.byteLength);
        if (isInstance(b2, Uint8Array)) b2 = Buffer4.from(b2, b2.offset, b2.byteLength);
        if (!Buffer4.isBuffer(a2) || !Buffer4.isBuffer(b2)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a2 === b2) return 0;
        var x = a2.length;
        var y2 = b2.length;
        for (var i2 = 0, len = Math.min(x, y2); i2 < len; ++i2) {
          if (a2[i2] !== b2[i2]) {
            x = a2[i2];
            y2 = b2[i2];
            break;
          }
        }
        if (x < y2) return -1;
        if (y2 < x) return 1;
        return 0;
      };
      Buffer4.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer4.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer4.alloc(0);
        }
        var i2;
        if (length === void 0) {
          length = 0;
          for (i2 = 0; i2 < list.length; ++i2) {
            length += list[i2].length;
          }
        }
        var buffer2 = Buffer4.allocUnsafe(length);
        var pos = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          var buf = list[i2];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer2.length) {
              Buffer4.from(buf).copy(buffer2, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer2,
                buf,
                pos
              );
            }
          } else if (!Buffer4.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer2, pos);
          }
          pos += buf.length;
        }
        return buffer2;
      };
      function byteLength(string, encoding) {
        if (Buffer4.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        var len = string.length;
        var mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0) return 0;
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer4.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        var loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding) encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer4.prototype._isBuffer = true;
      function swap(b2, n2, m) {
        var i2 = b2[n2];
        b2[n2] = b2[m];
        b2[m] = i2;
      }
      Buffer4.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 2) {
          swap(this, i2, i2 + 1);
        }
        return this;
      };
      Buffer4.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 4) {
          swap(this, i2, i2 + 3);
          swap(this, i2 + 1, i2 + 2);
        }
        return this;
      };
      Buffer4.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 8) {
          swap(this, i2, i2 + 7);
          swap(this, i2 + 1, i2 + 6);
          swap(this, i2 + 2, i2 + 5);
          swap(this, i2 + 3, i2 + 4);
        }
        return this;
      };
      Buffer4.prototype.toString = function toString() {
        var length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
      Buffer4.prototype.equals = function equals(b2) {
        if (!Buffer4.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
        if (this === b2) return true;
        return Buffer4.compare(this, b2) === 0;
      };
      Buffer4.prototype.inspect = function inspect() {
        var str = "";
        var max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max) str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer4.prototype[customInspectSymbol] = Buffer4.prototype.inspect;
      }
      Buffer4.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer4.from(target, target.offset, target.byteLength);
        }
        if (!Buffer4.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        var x = thisEnd - thisStart;
        var y2 = end - start;
        var len = Math.min(x, y2);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i2 = 0; i2 < len; ++i2) {
          if (thisCopy[i2] !== targetCopy[i2]) {
            x = thisCopy[i2];
            y2 = targetCopy[i2];
            break;
          }
        }
        if (x < y2) return -1;
        if (y2 < x) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
        if (buffer2.length === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer2.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
        if (byteOffset >= buffer2.length) {
          if (dir) return -1;
          else byteOffset = buffer2.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1;
        }
        if (typeof val === "string") {
          val = Buffer4.from(val, encoding);
        }
        if (Buffer4.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i3) {
          if (indexSize === 1) {
            return buf[i3];
          } else {
            return buf.readUInt16BE(i3 * indexSize);
          }
        }
        var i2;
        if (dir) {
          var foundIndex = -1;
          for (i2 = byteOffset; i2 < arrLength; i2++) {
            if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
              if (foundIndex === -1) foundIndex = i2;
              if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i2 -= i2 - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i2 = byteOffset; i2 >= 0; i2--) {
            var found = true;
            for (var j = 0; j < valLength; j++) {
              if (read(arr, i2 + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found) return i2;
          }
        }
        return -1;
      }
      Buffer4.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer4.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        var strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        for (var i2 = 0; i2 < length; ++i2) {
          var parsed = parseInt(string.substr(i2 * 2, 2), 16);
          if (numberIsNaN(parsed)) return i2;
          buf[offset + i2] = parsed;
        }
        return i2;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer4.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining) length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer4.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i2 = start;
        while (i2 < end) {
          var firstByte = buf[i2];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i2 + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i2 + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                fourthByte = buf[i2 + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i2 += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        var res = "";
        var i2 = 0;
        while (i2 < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i2 = start; i2 < end; ++i2) {
          ret += String.fromCharCode(buf[i2] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i2 = start; i2 < end; ++i2) {
          ret += String.fromCharCode(buf[i2]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len) end = len;
        var out2 = "";
        for (var i2 = start; i2 < end; ++i2) {
          out2 += hexSliceLookupTable[buf[i2]];
        }
        return out2;
      }
      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";
        for (var i2 = 0; i2 < bytes.length - 1; i2 += 2) {
          res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
        }
        return res;
      }
      Buffer4.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start) end = start;
        var newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer4.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
        if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i2 = 0;
        while (++i2 < byteLength2 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        return val;
      };
      Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        var val = this[offset + --byteLength2];
        var mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer4.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i2 = 0;
        while (++i2 < byteLength2 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer4.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        var i2 = byteLength2;
        var mul = 1;
        var val = this[offset + --i2];
        while (i2 > 0 && (mul *= 256)) {
          val += this[offset + --i2] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer4.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128)) return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer4.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer4.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer4.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer4.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer4.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer4.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer4.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer4.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer4.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var mul = 1;
        var i2 = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength2 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var i2 = byteLength2 - 1;
        var mul = 1;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer4.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i2 = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer4.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i2 = byteLength2 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer4.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer4.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer4.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer4.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer4.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
        if (offset < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer4.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer4.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer4.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer4.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer4.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer4.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer4.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        var i2;
        if (typeof val === "number") {
          for (i2 = start; i2 < end; ++i2) {
            this[i2] = val;
          }
        } else {
          var bytes = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);
          var len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i2 = 0; i2 < end - start; ++i2) {
            this[i2 + start] = bytes[i2 % len];
          }
        }
        return this;
      };
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];
        for (var i2 = 0; i2 < length; ++i2) {
          codePoint = string.charCodeAt(i2);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i2 + 1 === length) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        var byteArray = [];
        for (var i2 = 0; i2 < str.length; ++i2) {
          byteArray.push(str.charCodeAt(i2) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        var c, hi, lo;
        var byteArray = [];
        for (var i2 = 0; i2 < str.length; ++i2) {
          if ((units -= 2) < 0) break;
          c = str.charCodeAt(i2);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        for (var i2 = 0; i2 < length; ++i2) {
          if (i2 + offset >= dst.length || i2 >= src.length) break;
          dst[i2 + offset] = src[i2];
        }
        return i2;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        var alphabet = "0123456789abcdef";
        var table = new Array(256);
        for (var i2 = 0; i2 < 16; ++i2) {
          var i16 = i2 * 16;
          for (var j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i2] + alphabet[j];
          }
        }
        return table;
      }();
    }
  });

  // node_modules/.pnpm/node-stdlib-browser@1.3.1/node_modules/node-stdlib-browser/esm/proxy/process.js
  var process_exports = {};
  __export(process_exports, {
    addListener: () => addListener,
    arch: () => arch,
    argv: () => argv,
    binding: () => binding,
    browser: () => browser,
    chdir: () => chdir,
    cwd: () => cwd,
    default: () => api,
    dlopen: () => dlopen,
    emit: () => emit,
    emitWarning: () => emitWarning,
    env: () => env,
    execArgv: () => execArgv,
    execPath: () => execPath,
    exit: () => exit,
    features: () => features,
    kill: () => kill,
    listeners: () => listeners,
    memoryUsage: () => memoryUsage,
    nextTick: () => nextTick,
    off: () => off,
    on: () => on,
    once: () => once,
    pid: () => pid,
    platform: () => platform,
    prependListener: () => prependListener,
    prependOnceListener: () => prependOnceListener,
    removeAllListeners: () => removeAllListeners,
    removeListener: () => removeListener,
    title: () => title,
    umask: () => umask,
    uptime: () => uptime,
    uvCounters: () => uvCounters,
    version: () => version,
    versions: () => versions
  });
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e2) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e3) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e2) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e3) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop$1() {
  }
  function noop() {
  }
  var browser$1, process, cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, browser, emitWarning, binding, exit, pid, features, kill, dlopen, uptime, memoryUsage, uvCounters, platform, arch, execPath, execArgv, api, addListener, argv, chdir, cwd, emit, env, listeners, nextTick, off, on, once, prependListener, prependOnceListener, removeAllListeners, removeListener, title, umask, version, versions;
  var init_process = __esm({
    "node_modules/.pnpm/node-stdlib-browser@1.3.1/node_modules/node-stdlib-browser/esm/proxy/process.js"() {
      init_shim();
      browser$1 = { exports: {} };
      process = browser$1.exports = {};
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e2) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e2) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      queue = [];
      draining = false;
      queueIndex = -1;
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            args[i2 - 1] = arguments[i2];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      process.on = noop$1;
      process.addListener = noop$1;
      process.once = noop$1;
      process.off = noop$1;
      process.removeListener = noop$1;
      process.removeAllListeners = noop$1;
      process.emit = noop$1;
      process.prependListener = noop$1;
      process.prependOnceListener = noop$1;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
      browser = /** @type {boolean} */
      browser$1.exports.browser;
      emitWarning = noop;
      binding = /** @type {Function} */
      browser$1.exports.binding;
      exit = noop;
      pid = 1;
      features = {};
      kill = noop;
      dlopen = noop;
      uptime = noop;
      memoryUsage = noop;
      uvCounters = noop;
      platform = "browser";
      arch = "browser";
      execPath = "browser";
      execArgv = /** @type {string[]} */
      [];
      api = {
        nextTick: browser$1.exports.nextTick,
        title: browser$1.exports.title,
        browser,
        env: browser$1.exports.env,
        argv: browser$1.exports.argv,
        version: browser$1.exports.version,
        versions: browser$1.exports.versions,
        on: browser$1.exports.on,
        addListener: browser$1.exports.addListener,
        once: browser$1.exports.once,
        off: browser$1.exports.off,
        removeListener: browser$1.exports.removeListener,
        removeAllListeners: browser$1.exports.removeAllListeners,
        emit: browser$1.exports.emit,
        emitWarning,
        prependListener: browser$1.exports.prependListener,
        prependOnceListener: browser$1.exports.prependOnceListener,
        listeners: browser$1.exports.listeners,
        binding,
        cwd: browser$1.exports.cwd,
        chdir: browser$1.exports.chdir,
        umask: browser$1.exports.umask,
        exit,
        pid,
        features,
        kill,
        dlopen,
        uptime,
        memoryUsage,
        uvCounters,
        platform,
        arch,
        execPath,
        execArgv
      };
      addListener = browser$1.exports.addListener;
      argv = browser$1.exports.argv;
      chdir = browser$1.exports.chdir;
      cwd = browser$1.exports.cwd;
      emit = browser$1.exports.emit;
      env = browser$1.exports.env;
      listeners = browser$1.exports.listeners;
      nextTick = browser$1.exports.nextTick;
      off = browser$1.exports.off;
      on = browser$1.exports.on;
      once = browser$1.exports.once;
      prependListener = browser$1.exports.prependListener;
      prependOnceListener = browser$1.exports.prependOnceListener;
      removeAllListeners = browser$1.exports.removeAllListeners;
      removeListener = browser$1.exports.removeListener;
      title = browser$1.exports.title;
      umask = browser$1.exports.umask;
      version = browser$1.exports.version;
      versions = browser$1.exports.versions;
    }
  });

  // node_modules/.pnpm/node-stdlib-browser@1.3.1/node_modules/node-stdlib-browser/helpers/esbuild/shim.js
  var import_buffer, _globalThis, _global;
  var init_shim = __esm({
    "node_modules/.pnpm/node-stdlib-browser@1.3.1/node_modules/node-stdlib-browser/helpers/esbuild/shim.js"() {
      import_buffer = __toESM(require_buffer());
      init_process();
      _globalThis = function(Object2) {
        function get() {
          var _global3 = this || self;
          delete Object2.prototype.__magic__;
          return _global3;
        }
        if (typeof globalThis === "object") {
          return globalThis;
        }
        if (this) {
          return get();
        } else {
          Object2.defineProperty(Object2.prototype, "__magic__", {
            configurable: true,
            get
          });
          var _global2 = __magic__;
          return _global2;
        }
      }(Object);
      _global = _globalThis;
    }
  });

  // node_modules/.pnpm/events@3.3.0/node_modules/events/events.js
  var require_events = __commonJS({
    "node_modules/.pnpm/events@3.3.0/node_modules/events/events.js"(exports, module) {
      "use strict";
      init_shim();
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      module.exports = EventEmitter;
      module.exports.once = once2;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
        if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
        }
        this._maxListeners = n2;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit2(type) {
        var args = [];
        for (var i2 = 1; i2 < arguments.length; i2++) args.push(arguments[i2]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err2 = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err2.context = er;
          throw err2;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners2 = arrayClone(handler, len);
          for (var i2 = 0; i2 < len; ++i2)
            ReflectApply(listeners2[i2], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w2.name = "MaxListenersExceededWarning";
            w2.emitter = target;
            w2.type = type;
            w2.count = existing.length;
            ProcessEmitWarning(w2);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener2(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener2(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once3(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener2(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener2(type, listener) {
        var list, events, position, i2, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i2 = list.length - 1; i2 >= 0; i2--) {
            if (list[i2] === listener || list[i2].listener === listener) {
              originalListener = list[i2].listener;
              position = i2;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type) {
        var listeners2, events, i2;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i2 = 0; i2 < keys.length; ++i2) {
            key = keys[i2];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners2 = events[type];
        if (typeof listeners2 === "function") {
          this.removeListener(type, listeners2);
        } else if (listeners2 !== void 0) {
          for (i2 = listeners2.length - 1; i2 >= 0; i2--) {
            this.removeListener(type, listeners2[i2]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners2(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n2) {
        var copy = new Array(n2);
        for (var i2 = 0; i2 < n2; ++i2)
          copy[i2] = arr[i2];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i2 = 0; i2 < ret.length; ++i2) {
          ret[i2] = arr[i2].listener || arr[i2];
        }
        return ret;
      }
      function once2(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err2) {
            emitter.removeListener(name, resolver);
            reject(err2);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports, module) {
      init_shim();
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser = __commonJS({
    "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_shim();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (var _ in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = (
            /** @type {PropertyDescriptor} */
            Object.getOwnPropertyDescriptor(obj, sym)
          );
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(exports, module) {
      "use strict";
      init_shim();
      var hasSymbols = require_shams();
      module.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js
  var require_es_object_atoms = __commonJS({
    "node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Object;
    }
  });

  // node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js
  var require_es_errors = __commonJS({
    "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Error;
    }
  });

  // node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js
  var require_eval = __commonJS({
    "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = EvalError;
    }
  });

  // node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js
  var require_range = __commonJS({
    "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = RangeError;
    }
  });

  // node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js
  var require_ref = __commonJS({
    "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = ReferenceError;
    }
  });

  // node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js
  var require_syntax = __commonJS({
    "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = SyntaxError;
    }
  });

  // node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js
  var require_type = __commonJS({
    "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = TypeError;
    }
  });

  // node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js
  var require_uri = __commonJS({
    "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = URIError;
    }
  });

  // node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js
  var require_abs = __commonJS({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Math.abs;
    }
  });

  // node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js
  var require_floor = __commonJS({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Math.floor;
    }
  });

  // node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js
  var require_max = __commonJS({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Math.max;
    }
  });

  // node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js
  var require_min = __commonJS({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Math.min;
    }
  });

  // node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js
  var require_pow = __commonJS({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Math.pow;
    }
  });

  // node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js
  var require_round = __commonJS({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Math.round;
    }
  });

  // node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js
  var require_isNaN = __commonJS({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Number.isNaN || function isNaN2(a2) {
        return a2 !== a2;
      };
    }
  });

  // node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js
  var require_sign = __commonJS({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(exports, module) {
      "use strict";
      init_shim();
      var $isNaN = require_isNaN();
      module.exports = function sign(number) {
        if ($isNaN(number) || number === 0) {
          return number;
        }
        return number < 0 ? -1 : 1;
      };
    }
  });

  // node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js
  var require_gOPD = __commonJS({
    "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Object.getOwnPropertyDescriptor;
    }
  });

  // node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js
  var require_gopd = __commonJS({
    "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(exports, module) {
      "use strict";
      init_shim();
      var $gOPD = require_gOPD();
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e2) {
          $gOPD = null;
        }
      }
      module.exports = $gOPD;
    }
  });

  // node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js
  var require_es_define_property = __commonJS({
    "node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(exports, module) {
      "use strict";
      init_shim();
      var $defineProperty = Object.defineProperty || false;
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e2) {
          $defineProperty = false;
        }
      }
      module.exports = $defineProperty;
    }
  });

  // node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(exports, module) {
      "use strict";
      init_shim();
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js
  var require_Reflect_getPrototypeOf = __commonJS({
    "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
    }
  });

  // node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js
  var require_Object_getPrototypeOf = __commonJS({
    "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
      "use strict";
      init_shim();
      var $Object = require_es_object_atoms();
      module.exports = $Object.getPrototypeOf || null;
    }
  });

  // node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
  var require_implementation = __commonJS({
    "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports, module) {
      "use strict";
      init_shim();
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var toStr = Object.prototype.toString;
      var max = Math.max;
      var funcType = "[object Function]";
      var concatty = function concatty2(a2, b2) {
        var arr = [];
        for (var i2 = 0; i2 < a2.length; i2 += 1) {
          arr[i2] = a2[i2];
        }
        for (var j = 0; j < b2.length; j += 1) {
          arr[j + a2.length] = b2[j];
        }
        return arr;
      };
      var slicy = function slicy2(arrLike, offset) {
        var arr = [];
        for (var i2 = offset || 0, j = 0; i2 < arrLike.length; i2 += 1, j += 1) {
          arr[j] = arrLike[i2];
        }
        return arr;
      };
      var joiny = function(arr, joiner) {
        var str = "";
        for (var i2 = 0; i2 < arr.length; i2 += 1) {
          str += arr[i2];
          if (i2 + 1 < arr.length) {
            str += joiner;
          }
        }
        return str;
      };
      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.apply(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slicy(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              concatty(args, arguments)
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          }
          return target.apply(
            that,
            concatty(args, arguments)
          );
        };
        var boundLength = max(0, target.length - args.length);
        var boundArgs = [];
        for (var i2 = 0; i2 < boundLength; i2++) {
          boundArgs[i2] = "$" + i2;
        }
        bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports, module) {
      "use strict";
      init_shim();
      var implementation = require_implementation();
      module.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js
  var require_functionCall = __commonJS({
    "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Function.prototype.call;
    }
  });

  // node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js
  var require_functionApply = __commonJS({
    "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Function.prototype.apply;
    }
  });

  // node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js
  var require_reflectApply = __commonJS({
    "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
    }
  });

  // node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js
  var require_actualApply = __commonJS({
    "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
      "use strict";
      init_shim();
      var bind = require_function_bind();
      var $apply = require_functionApply();
      var $call = require_functionCall();
      var $reflectApply = require_reflectApply();
      module.exports = $reflectApply || bind.call($call, $apply);
    }
  });

  // node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js
  var require_call_bind_apply_helpers = __commonJS({
    "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(exports, module) {
      "use strict";
      init_shim();
      var bind = require_function_bind();
      var $TypeError = require_type();
      var $call = require_functionCall();
      var $actualApply = require_actualApply();
      module.exports = function callBindBasic(args) {
        if (args.length < 1 || typeof args[0] !== "function") {
          throw new $TypeError("a function is required");
        }
        return $actualApply(bind, $call, args);
      };
    }
  });

  // node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js
  var require_get = __commonJS({
    "node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(exports, module) {
      "use strict";
      init_shim();
      var callBind = require_call_bind_apply_helpers();
      var gOPD = require_gopd();
      var hasProtoAccessor;
      try {
        hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
        [].__proto__ === Array.prototype;
      } catch (e2) {
        if (!e2 || typeof e2 !== "object" || !("code" in e2) || e2.code !== "ERR_PROTO_ACCESS") {
          throw e2;
        }
      }
      var desc = !!hasProtoAccessor && gOPD && gOPD(
        Object.prototype,
        /** @type {keyof typeof Object.prototype} */
        "__proto__"
      );
      var $Object = Object;
      var $getPrototypeOf = $Object.getPrototypeOf;
      module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
        /** @type {import('./get')} */
        function getDunder(value) {
          return $getPrototypeOf(value == null ? value : $Object(value));
        }
      ) : false;
    }
  });

  // node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js
  var require_get_proto = __commonJS({
    "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(exports, module) {
      "use strict";
      init_shim();
      var reflectGetProto = require_Reflect_getPrototypeOf();
      var originalGetProto = require_Object_getPrototypeOf();
      var getDunderProto = require_get();
      module.exports = reflectGetProto ? function getProto(O) {
        return reflectGetProto(O);
      } : originalGetProto ? function getProto(O) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new TypeError("getProto: not an object");
        }
        return originalGetProto(O);
      } : getDunderProto ? function getProto(O) {
        return getDunderProto(O);
      } : null;
    }
  });

  // node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js
  var require_hasown = __commonJS({
    "node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(exports, module) {
      "use strict";
      init_shim();
      var call = Function.prototype.call;
      var $hasOwn = Object.prototype.hasOwnProperty;
      var bind = require_function_bind();
      module.exports = bind.call(call, $hasOwn);
    }
  });

  // node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(exports, module) {
      "use strict";
      init_shim();
      var undefined2;
      var $Object = require_es_object_atoms();
      var $Error = require_es_errors();
      var $EvalError = require_eval();
      var $RangeError = require_range();
      var $ReferenceError = require_ref();
      var $SyntaxError = require_syntax();
      var $TypeError = require_type();
      var $URIError = require_uri();
      var abs = require_abs();
      var floor = require_floor();
      var max = require_max();
      var min = require_min();
      var pow = require_pow();
      var round = require_round();
      var sign = require_sign();
      var $Function = Function;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e2) {
        }
      };
      var $gOPD = require_gopd();
      var $defineProperty = require_es_define_property();
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var getProto = require_get_proto();
      var $ObjectGPO = require_Object_getPrototypeOf();
      var $ReflectGPO = require_Reflect_getPrototypeOf();
      var $apply = require_functionApply();
      var $call = require_functionCall();
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": $Error,
        "%eval%": eval,
        // eslint-disable-line no-eval
        "%EvalError%": $EvalError,
        "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": $Object,
        "%Object.getOwnPropertyDescriptor%": $gOPD,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": $RangeError,
        "%ReferenceError%": $ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": $URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
        "%Function.prototype.call%": $call,
        "%Function.prototype.apply%": $apply,
        "%Object.defineProperty%": $defineProperty,
        "%Object.getPrototypeOf%": $ObjectGPO,
        "%Math.abs%": abs,
        "%Math.floor%": floor,
        "%Math.max%": max,
        "%Math.min%": min,
        "%Math.pow%": pow,
        "%Math.round%": round,
        "%Math.sign%": sign,
        "%Reflect.getPrototypeOf%": $ReflectGPO
      };
      if (getProto) {
        try {
          null.error;
        } catch (e2) {
          errorProto = getProto(getProto(e2));
          INTRINSICS["%Error.prototype%"] = errorProto;
        }
      }
      var errorProto;
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen && getProto) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_hasown();
      var $concat = bind.call($call, Array.prototype.concat);
      var $spliceApply = bind.call($apply, Array.prototype.splice);
      var $replace = bind.call($call, String.prototype.replace);
      var $strSlice = bind.call($call, String.prototype.slice);
      var $exec = bind.call($call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
          var part = parts[i2];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void undefined2;
            }
            if ($gOPD && i2 + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js
  var require_call_bound = __commonJS({
    "node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js"(exports, module) {
      "use strict";
      init_shim();
      var GetIntrinsic = require_get_intrinsic();
      var callBindBasic = require_call_bind_apply_helpers();
      var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = (
          /** @type {(this: unknown, ...args: unknown[]) => unknown} */
          GetIntrinsic(name, !!allowMissing)
        );
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBindBasic(
            /** @type {const} */
            [intrinsic]
          );
        }
        return intrinsic;
      };
    }
  });

  // node_modules/.pnpm/is-arguments@1.2.0/node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "node_modules/.pnpm/is-arguments@1.2.0/node_modules/is-arguments/index.js"(exports, module) {
      "use strict";
      init_shim();
      var hasToStringTag = require_shams2()();
      var callBound = require_call_bound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && "length" in value && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && "callee" in value && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js
  var require_is_regex = __commonJS({
    "node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js"(exports, module) {
      "use strict";
      init_shim();
      var callBound = require_call_bound();
      var hasToStringTag = require_shams2()();
      var hasOwn = require_hasown();
      var gOPD = require_gopd();
      var fn;
      if (hasToStringTag) {
        $exec = callBound("RegExp.prototype.exec");
        isRegexMarker = {};
        throwRegexMarker = function() {
          throw isRegexMarker;
        };
        badStringifier = {
          toString: throwRegexMarker,
          valueOf: throwRegexMarker
        };
        if (typeof Symbol.toPrimitive === "symbol") {
          badStringifier[Symbol.toPrimitive] = throwRegexMarker;
        }
        fn = function isRegex(value) {
          if (!value || typeof value !== "object") {
            return false;
          }
          var descriptor = (
            /** @type {NonNullable<typeof gOPD>} */
            gOPD(
              /** @type {{ lastIndex?: unknown }} */
              value,
              "lastIndex"
            )
          );
          var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
          if (!hasLastIndexDataProperty) {
            return false;
          }
          try {
            $exec(
              value,
              /** @type {string} */
              /** @type {unknown} */
              badStringifier
            );
          } catch (e2) {
            return e2 === isRegexMarker;
          }
        };
      } else {
        $toString = callBound("Object.prototype.toString");
        regexClass = "[object RegExp]";
        fn = function isRegex(value) {
          if (!value || typeof value !== "object" && typeof value !== "function") {
            return false;
          }
          return $toString(value) === regexClass;
        };
      }
      var $exec;
      var isRegexMarker;
      var throwRegexMarker;
      var badStringifier;
      var $toString;
      var regexClass;
      module.exports = fn;
    }
  });

  // node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js
  var require_safe_regex_test = __commonJS({
    "node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js"(exports, module) {
      "use strict";
      init_shim();
      var callBound = require_call_bound();
      var isRegex = require_is_regex();
      var $exec = callBound("RegExp.prototype.exec");
      var $TypeError = require_type();
      module.exports = function regexTester(regex) {
        if (!isRegex(regex)) {
          throw new $TypeError("`regex` must be a RegExp");
        }
        return function test(s2) {
          return $exec(regex, s2) !== null;
        };
      };
    }
  });

  // node_modules/.pnpm/is-generator-function@1.1.0/node_modules/is-generator-function/index.js
  var require_is_generator_function = __commonJS({
    "node_modules/.pnpm/is-generator-function@1.1.0/node_modules/is-generator-function/index.js"(exports, module) {
      "use strict";
      init_shim();
      var callBound = require_call_bound();
      var safeRegexTest = require_safe_regex_test();
      var isFnRegex = safeRegexTest(/^\s*(?:function)?\*/);
      var hasToStringTag = require_shams2()();
      var getProto = require_get_proto();
      var toStr = callBound("Object.prototype.toString");
      var fnToStr = callBound("Function.prototype.toString");
      var getGeneratorFunc = function() {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function("return function*() {}")();
        } catch (e2) {
        }
      };
      var GeneratorFunction;
      module.exports = function isGeneratorFunction(fn) {
        if (typeof fn !== "function") {
          return false;
        }
        if (isFnRegex(fnToStr(fn))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr(fn);
          return str === "[object GeneratorFunction]";
        }
        if (!getProto) {
          return false;
        }
        if (typeof GeneratorFunction === "undefined") {
          var generatorFunc = getGeneratorFunc();
          GeneratorFunction = generatorFunc ? (
            /** @type {GeneratorFunctionConstructor} */
            getProto(generatorFunc)
          ) : false;
        }
        return getProto(fn) === GeneratorFunction;
      };
    }
  });

  // node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js
  var require_is_callable = __commonJS({
    "node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js"(exports, module) {
      "use strict";
      init_shim();
      var fnToStr = Function.prototype.toString;
      var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
      var badArrayLike;
      var isCallableMarker;
      if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
        try {
          badArrayLike = Object.defineProperty({}, "length", {
            get: function() {
              throw isCallableMarker;
            }
          });
          isCallableMarker = {};
          reflectApply(function() {
            throw 42;
          }, null, badArrayLike);
        } catch (_) {
          if (_ !== isCallableMarker) {
            reflectApply = null;
          }
        }
      } else {
        reflectApply = null;
      }
      var constructorRegex = /^\s*class\b/;
      var isES6ClassFn = function isES6ClassFunction(value) {
        try {
          var fnStr = fnToStr.call(value);
          return constructorRegex.test(fnStr);
        } catch (e2) {
          return false;
        }
      };
      var tryFunctionObject = function tryFunctionToStr(value) {
        try {
          if (isES6ClassFn(value)) {
            return false;
          }
          fnToStr.call(value);
          return true;
        } catch (e2) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var objectClass = "[object Object]";
      var fnClass = "[object Function]";
      var genClass = "[object GeneratorFunction]";
      var ddaClass = "[object HTMLAllCollection]";
      var ddaClass2 = "[object HTML document.all class]";
      var ddaClass3 = "[object HTMLCollection]";
      var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
      var isIE68 = !(0 in [,]);
      var isDDA = function isDocumentDotAll() {
        return false;
      };
      if (typeof document === "object") {
        all = document.all;
        if (toStr.call(all) === toStr.call(document.all)) {
          isDDA = function isDocumentDotAll(value) {
            if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
              try {
                var str = toStr.call(value);
                return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
              } catch (e2) {
              }
            }
            return false;
          };
        }
      }
      var all;
      module.exports = reflectApply ? function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        try {
          reflectApply(value, null, badArrayLike);
        } catch (e2) {
          if (e2 !== isCallableMarker) {
            return false;
          }
        }
        return !isES6ClassFn(value) && tryFunctionObject(value);
      } : function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (hasToStringTag) {
          return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
          return false;
        }
        var strClass = toStr.call(value);
        if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
          return false;
        }
        return tryFunctionObject(value);
      };
    }
  });

  // node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js
  var require_for_each = __commonJS({
    "node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js"(exports, module) {
      "use strict";
      init_shim();
      var isCallable = require_is_callable();
      var toStr = Object.prototype.toString;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var forEachArray = function forEachArray2(array, iterator, receiver) {
        for (var i2 = 0, len = array.length; i2 < len; i2++) {
          if (hasOwnProperty.call(array, i2)) {
            if (receiver == null) {
              iterator(array[i2], i2, array);
            } else {
              iterator.call(receiver, array[i2], i2, array);
            }
          }
        }
      };
      var forEachString = function forEachString2(string, iterator, receiver) {
        for (var i2 = 0, len = string.length; i2 < len; i2++) {
          if (receiver == null) {
            iterator(string.charAt(i2), i2, string);
          } else {
            iterator.call(receiver, string.charAt(i2), i2, string);
          }
        }
      };
      var forEachObject = function forEachObject2(object, iterator, receiver) {
        for (var k in object) {
          if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
              iterator(object[k], k, object);
            } else {
              iterator.call(receiver, object[k], k, object);
            }
          }
        }
      };
      function isArray(x) {
        return toStr.call(x) === "[object Array]";
      }
      module.exports = function forEach(list, iterator, thisArg) {
        if (!isCallable(iterator)) {
          throw new TypeError("iterator must be a function");
        }
        var receiver;
        if (arguments.length >= 3) {
          receiver = thisArg;
        }
        if (isArray(list)) {
          forEachArray(list, iterator, receiver);
        } else if (typeof list === "string") {
          forEachString(list, iterator, receiver);
        } else {
          forEachObject(list, iterator, receiver);
        }
      };
    }
  });

  // node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js
  var require_possible_typed_array_names = __commonJS({
    "node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = [
        "Float16Array",
        "Float32Array",
        "Float64Array",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "BigInt64Array",
        "BigUint64Array"
      ];
    }
  });

  // node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js
  var require_available_typed_arrays = __commonJS({
    "node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js"(exports, module) {
      "use strict";
      init_shim();
      var possibleNames = require_possible_typed_array_names();
      var g2 = typeof globalThis === "undefined" ? _global : globalThis;
      module.exports = function availableTypedArrays() {
        var out2 = [];
        for (var i2 = 0; i2 < possibleNames.length; i2++) {
          if (typeof g2[possibleNames[i2]] === "function") {
            out2[out2.length] = possibleNames[i2];
          }
        }
        return out2;
      };
    }
  });

  // node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js
  var require_define_data_property = __commonJS({
    "node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js"(exports, module) {
      "use strict";
      init_shim();
      var $defineProperty = require_es_define_property();
      var $SyntaxError = require_syntax();
      var $TypeError = require_type();
      var gopd = require_gopd();
      module.exports = function defineDataProperty(obj, property, value) {
        if (!obj || typeof obj !== "object" && typeof obj !== "function") {
          throw new $TypeError("`obj` must be an object or a function`");
        }
        if (typeof property !== "string" && typeof property !== "symbol") {
          throw new $TypeError("`property` must be a string or a symbol`");
        }
        if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
          throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
          throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
          throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
          throw new $TypeError("`loose`, if provided, must be a boolean");
        }
        var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
        var nonWritable = arguments.length > 4 ? arguments[4] : null;
        var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
        var loose = arguments.length > 6 ? arguments[6] : false;
        var desc = !!gopd && gopd(obj, property);
        if ($defineProperty) {
          $defineProperty(obj, property, {
            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
            value,
            writable: nonWritable === null && desc ? desc.writable : !nonWritable
          });
        } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
          obj[property] = value;
        } else {
          throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
        }
      };
    }
  });

  // node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js
  var require_has_property_descriptors = __commonJS({
    "node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js"(exports, module) {
      "use strict";
      init_shim();
      var $defineProperty = require_es_define_property();
      var hasPropertyDescriptors = function hasPropertyDescriptors2() {
        return !!$defineProperty;
      };
      hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!$defineProperty) {
          return null;
        }
        try {
          return $defineProperty([], "length", { value: 1 }).length !== 1;
        } catch (e2) {
          return true;
        }
      };
      module.exports = hasPropertyDescriptors;
    }
  });

  // node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js
  var require_set_function_length = __commonJS({
    "node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js"(exports, module) {
      "use strict";
      init_shim();
      var GetIntrinsic = require_get_intrinsic();
      var define2 = require_define_data_property();
      var hasDescriptors = require_has_property_descriptors()();
      var gOPD = require_gopd();
      var $TypeError = require_type();
      var $floor = GetIntrinsic("%Math.floor%");
      module.exports = function setFunctionLength(fn, length) {
        if (typeof fn !== "function") {
          throw new $TypeError("`fn` is not a function");
        }
        if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
          throw new $TypeError("`length` must be a positive 32-bit integer");
        }
        var loose = arguments.length > 2 && !!arguments[2];
        var functionLengthIsConfigurable = true;
        var functionLengthIsWritable = true;
        if ("length" in fn && gOPD) {
          var desc = gOPD(fn, "length");
          if (desc && !desc.configurable) {
            functionLengthIsConfigurable = false;
          }
          if (desc && !desc.writable) {
            functionLengthIsWritable = false;
          }
        }
        if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
          if (hasDescriptors) {
            define2(
              /** @type {Parameters<define>[0]} */
              fn,
              "length",
              length,
              true,
              true
            );
          } else {
            define2(
              /** @type {Parameters<define>[0]} */
              fn,
              "length",
              length
            );
          }
        }
        return fn;
      };
    }
  });

  // node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js
  var require_applyBind = __commonJS({
    "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js"(exports, module) {
      "use strict";
      init_shim();
      var bind = require_function_bind();
      var $apply = require_functionApply();
      var actualApply = require_actualApply();
      module.exports = function applyBind() {
        return actualApply(bind, $apply, arguments);
      };
    }
  });

  // node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js"(exports, module) {
      "use strict";
      init_shim();
      var setFunctionLength = require_set_function_length();
      var $defineProperty = require_es_define_property();
      var callBindBasic = require_call_bind_apply_helpers();
      var applyBind = require_applyBind();
      module.exports = function callBind(originalFunction) {
        var func = callBindBasic(arguments);
        var adjustedLength = originalFunction.length - (arguments.length - 1);
        return setFunctionLength(
          func,
          1 + (adjustedLength > 0 ? adjustedLength : 0),
          true
        );
      };
      if ($defineProperty) {
        $defineProperty(module.exports, "apply", { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }
    }
  });

  // node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js
  var require_which_typed_array = __commonJS({
    "node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js"(exports, module) {
      "use strict";
      init_shim();
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBind = require_call_bind();
      var callBound = require_call_bound();
      var gOPD = require_gopd();
      var getProto = require_get_proto();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var g2 = typeof globalThis === "undefined" ? _global : globalThis;
      var typedArrays = availableTypedArrays();
      var $slice = callBound("String.prototype.slice");
      var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
        for (var i2 = 0; i2 < array.length; i2 += 1) {
          if (array[i2] === value) {
            return i2;
          }
        }
        return -1;
      };
      var cache = { __proto__: null };
      if (hasToStringTag && gOPD && getProto) {
        forEach(typedArrays, function(typedArray) {
          var arr = new g2[typedArray]();
          if (Symbol.toStringTag in arr && getProto) {
            var proto = getProto(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor && proto) {
              var superProto = getProto(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            cache["$" + typedArray] = callBind(descriptor.get);
          }
        });
      } else {
        forEach(typedArrays, function(typedArray) {
          var arr = new g2[typedArray]();
          var fn = arr.slice || arr.set;
          if (fn) {
            cache[
              /** @type {`$${import('.').TypedArrayName}`} */
              "$" + typedArray
            ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
            // @ts-expect-error TODO FIXME
            callBind(fn);
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var found = false;
        forEach(
          /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
          cache,
          /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
          function(getter, typedArray) {
            if (!found) {
              try {
                if ("$" + getter(value) === typedArray) {
                  found = /** @type {import('.').TypedArrayName} */
                  $slice(typedArray, 1);
                }
              } catch (e2) {
              }
            }
          }
        );
        return found;
      };
      var trySlices = function tryAllSlices(value) {
        var found = false;
        forEach(
          /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
          cache,
          /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
          function(getter, name) {
            if (!found) {
              try {
                getter(value);
                found = /** @type {import('.').TypedArrayName} */
                $slice(name, 1);
              } catch (e2) {
              }
            }
          }
        );
        return found;
      };
      module.exports = function whichTypedArray(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag) {
          var tag = $slice($toString(value), 8, -1);
          if ($indexOf(typedArrays, tag) > -1) {
            return tag;
          }
          if (tag !== "Object") {
            return false;
          }
          return trySlices(value);
        }
        if (!gOPD) {
          return null;
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js
  var require_is_typed_array = __commonJS({
    "node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js"(exports, module) {
      "use strict";
      init_shim();
      var whichTypedArray = require_which_typed_array();
      module.exports = function isTypedArray(value) {
        return !!whichTypedArray(value);
      };
    }
  });

  // node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js
  var require_types = __commonJS({
    "node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js"(exports) {
      "use strict";
      init_shim();
      var isArgumentsObject = require_is_arguments();
      var isGeneratorFunction = require_is_generator_function();
      var whichTypedArray = require_which_typed_array();
      var isTypedArray = require_is_typed_array();
      function uncurryThis(f2) {
        return f2.call.bind(f2);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      var bigIntValue;
      if (SymbolSupported) {
        symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      var symbolValue;
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e2) {
          return false;
        }
      }
      exports.isArgumentsObject = isArgumentsObject;
      exports.isGeneratorFunction = isGeneratorFunction;
      exports.isTypedArray = isTypedArray;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray(value) || isDataView(value);
      }
      exports.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray(value) === "Uint8Array";
      }
      exports.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === "Uint8ClampedArray";
      }
      exports.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray(value) === "Uint16Array";
      }
      exports.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray(value) === "Uint32Array";
      }
      exports.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray(value) === "Int8Array";
      }
      exports.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray(value) === "Int16Array";
      }
      exports.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray(value) === "Int32Array";
      }
      exports.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray(value) === "Float32Array";
      }
      exports.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray(value) === "Float64Array";
      }
      exports.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray(value) === "BigInt64Array";
      }
      exports.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray(value) === "BigUint64Array";
      }
      exports.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
      function isSet(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBufferCopy === "undefined") {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === "undefined") {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
      }
      exports.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
        Object.defineProperty(exports, method, {
          enumerable: false,
          value: function() {
            throw new Error(method + " is not supported in userland");
          }
        });
      });
    }
  });

  // node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js
  var require_isBufferBrowser = __commonJS({
    "node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js"(exports, module) {
      init_shim();
      module.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }
  });

  // node_modules/.pnpm/util@0.12.5/node_modules/util/util.js
  var require_util = __commonJS({
    "node_modules/.pnpm/util@0.12.5/node_modules/util/util.js"(exports) {
      init_shim();
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i2 = 0; i2 < keys.length; i2++) {
          descriptors[keys[i2]] = Object.getOwnPropertyDescriptor(obj, keys[i2]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports.format = function(f2) {
        if (!isString(f2)) {
          var objects = [];
          for (var i2 = 0; i2 < arguments.length; i2++) {
            objects.push(inspect(arguments[i2]));
          }
          return objects.join(" ");
        }
        var i2 = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f2).replace(formatRegExp, function(x2) {
          if (x2 === "%%") return "%";
          if (i2 >= len) return x2;
          switch (x2) {
            case "%s":
              return String(args[i2++]);
            case "%d":
              return Number(args[i2++]);
            case "%j":
              try {
                return JSON.stringify(args[i2++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i2]; i2 < len; x = args[++i2]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports.deprecate = function(fn, msg) {
        if (typeof api !== "undefined" && api.noDeprecation === true) {
          return fn;
        }
        if (typeof api === "undefined") {
          return function() {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (api.throwDeprecation) {
              throw new Error(msg);
            } else if (api.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if (api.env.NODE_DEBUG) {
        debugEnv = api.env.NODE_DEBUG;
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      var debugEnv;
      exports.debuglog = function(set) {
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (debugEnvRegex.test(set)) {
            var pid2 = api.pid;
            debugs[set] = function() {
              var msg = exports.format.apply(exports, arguments);
              console.error("%s %d: %s", set, pid2, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3) ctx.depth = arguments[2];
        if (arguments.length >= 4) ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports._extend(ctx, opts);
        }
        if (isUndefined2(ctx.showHidden)) ctx.showHidden = false;
        if (isUndefined2(ctx.depth)) ctx.depth = 2;
        if (isUndefined2(ctx.colors)) ctx.colors = false;
        if (isUndefined2(ctx.customInspect)) ctx.customInspect = true;
        if (ctx.colors) ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        // "name": intentionally not styling
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
        value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n2 = value.name ? ": " + value.name : "";
          base = " [Function" + n2 + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined2(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i2 = 0, l2 = value.length; i2 < l2; ++i2) {
          if (hasOwnProperty(value, String(i2))) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              String(i2),
              true
            ));
          } else {
            output.push("");
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              true
            ));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").slice(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined2(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.slice(1, -1);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf("\n") >= 0) numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      exports.types = require_types();
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports.isSymbol = isSymbol;
      function isUndefined2(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined2;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      exports.isRegExp = isRegExp;
      exports.types.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d2) {
        return isObject(d2) && objectToString(d2) === "[object Date]";
      }
      exports.isDate = isDate;
      exports.types.isDate = isDate;
      function isError(e2) {
        return isObject(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
      }
      exports.isError = isError;
      exports.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
        typeof arg === "undefined";
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = require_isBufferBrowser();
      function objectToString(o2) {
        return Object.prototype.toString.call(o2);
      }
      function pad(n2) {
        return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d2 = /* @__PURE__ */ new Date();
        var time = [
          pad(d2.getHours()),
          pad(d2.getMinutes()),
          pad(d2.getSeconds())
        ].join(":");
        return [d2.getDate(), months[d2.getMonth()], time].join(" ");
      }
      exports.log = function() {
        console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
      };
      exports.inherits = require_inherits_browser();
      exports._extend = function(origin, add) {
        if (!add || !isObject(add)) return origin;
        var keys = Object.keys(add);
        var i2 = keys.length;
        while (i2--) {
          origin[keys[i2]] = add[keys[i2]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn = original[kCustomPromisifiedSymbol];
          if (typeof fn !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn;
        }
        function fn() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
          });
          var args = [];
          for (var i2 = 0; i2 < arguments.length; i2++) {
            args.push(arguments[i2]);
          }
          args.push(function(err2, value) {
            if (err2) {
              promiseReject(err2);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err2) {
            promiseReject(err2);
          }
          return promise;
        }
        Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return Object.defineProperties(
          fn,
          getOwnPropertyDescriptors(original)
        );
      };
      exports.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i2 = 0; i2 < arguments.length; i2++) {
            args.push(arguments[i2]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(
            function(ret) {
              api.nextTick(cb.bind(null, null, ret));
            },
            function(rej) {
              api.nextTick(callbackifyOnRejected.bind(null, rej, cb));
            }
          );
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(
          callbackified,
          getOwnPropertyDescriptors(original)
        );
        return callbackified;
      }
      exports.callbackify = callbackify;
    }
  });

  // node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list = __commonJS({
    "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_shim();
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          })), keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = null != arguments[i2] ? arguments[i2] : {};
          i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        key = _toPropertyKey(key);
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return typeof key === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (typeof input !== "object" || input === null) return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (typeof res !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      var _require = require_buffer();
      var Buffer4 = _require.Buffer;
      var _require2 = require_util();
      var inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer4.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v2) {
            var entry = {
              data: v2,
              next: null
            };
            if (this.length > 0) this.tail.next = entry;
            else this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v2) {
            var entry = {
              data: v2,
              next: this.head
            };
            if (this.length === 0) this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0) return;
            var ret = this.head.data;
            if (this.length === 1) this.head = this.tail = null;
            else this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s2) {
            if (this.length === 0) return "";
            var p2 = this.head;
            var ret = "" + p2.data;
            while (p2 = p2.next) ret += s2 + p2.data;
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n2) {
            if (this.length === 0) return Buffer4.alloc(0);
            var ret = Buffer4.allocUnsafe(n2 >>> 0);
            var p2 = this.head;
            var i2 = 0;
            while (p2) {
              copyBuffer(p2.data, ret, i2);
              i2 += p2.data.length;
              p2 = p2.next;
            }
            return ret;
          }
          // Consumes a specified amount of bytes or characters from the buffered data.
        }, {
          key: "consume",
          value: function consume(n2, hasStrings) {
            var ret;
            if (n2 < this.head.data.length) {
              ret = this.head.data.slice(0, n2);
              this.head.data = this.head.data.slice(n2);
            } else if (n2 === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n2) : this._getBuffer(n2);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
          // Consumes a specified amount of characters from the buffered data.
        }, {
          key: "_getString",
          value: function _getString(n2) {
            var p2 = this.head;
            var c = 1;
            var ret = p2.data;
            n2 -= ret.length;
            while (p2 = p2.next) {
              var str = p2.data;
              var nb = n2 > str.length ? str.length : n2;
              if (nb === str.length) ret += str;
              else ret += str.slice(0, n2);
              n2 -= nb;
              if (n2 === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p2.next) this.head = p2.next;
                  else this.head = this.tail = null;
                } else {
                  this.head = p2;
                  p2.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
          // Consumes a specified amount of bytes from the buffered data.
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n2) {
            var ret = Buffer4.allocUnsafe(n2);
            var p2 = this.head;
            var c = 1;
            p2.data.copy(ret);
            n2 -= p2.data.length;
            while (p2 = p2.next) {
              var buf = p2.data;
              var nb = n2 > buf.length ? buf.length : n2;
              buf.copy(ret, ret.length - n2, 0, nb);
              n2 -= nb;
              if (n2 === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p2.next) this.head = p2.next;
                  else this.head = this.tail = null;
                } else {
                  this.head = p2;
                  p2.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
          // Make sure the linked list only shows the minimal necessary information.
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
              // Only inspect one level.
              depth: 0,
              // It should not recurse.
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }
  });

  // node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy = __commonJS({
    "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_shim();
      function destroy(err2, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err2);
          } else if (err2) {
            if (!this._writableState) {
              api.nextTick(emitErrorNT, this, err2);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              api.nextTick(emitErrorNT, this, err2);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err2 || null, function(err3) {
          if (!cb && err3) {
            if (!_this._writableState) {
              api.nextTick(emitErrorAndCloseNT, _this, err3);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              api.nextTick(emitErrorAndCloseNT, _this, err3);
            } else {
              api.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            api.nextTick(emitCloseNT, _this);
            cb(err3);
          } else {
            api.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err2) {
        emitErrorNT(self2, err2);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose) return;
        if (self2._readableState && !self2._readableState.emitClose) return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err2) {
        self2.emit("error", err2);
      }
      function errorOrDestroy(stream, err2) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err2);
        else stream.emit("error", err2);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js
  var require_errors_browser = __commonJS({
    "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_shim();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i2) {
            return String(i2);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state = __commonJS({
    "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js"(exports, module) {
      init_shim();
      module.exports = deprecate;
      function deprecate(fn, msg) {
        if (config("noDeprecation")) {
          return fn;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (config("throwDeprecation")) {
              throw new Error(msg);
            } else if (config("traceDeprecation")) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      function config(name) {
        try {
          if (!_global.localStorage) return false;
        } catch (_) {
          return false;
        }
        var val = _global.localStorage[name];
        if (null == val) return false;
        return String(val).toLowerCase() === "true";
      }
    }
  });

  // node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable = __commonJS({
    "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex;
      Writable.WritableState = WritableState;
      var internalUtil = {
        deprecate: require_browser()
      };
      var Stream = require_stream_browser();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = (typeof _global !== "undefined" ? _global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy();
      var _require = require_state();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex();
        options = options || {};
        if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out2 = [];
        while (current) {
          out2.push(current);
          current = current.next;
        }
        return out2;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function") this._write = options.write;
          if (typeof options.writev === "function") this._writev = options.writev;
          if (typeof options.destroy === "function") this._destroy = options.destroy;
          if (typeof options.final === "function") this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        api.nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          api.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer4.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf) encoding = "buffer";
        else if (!encoding) encoding = state.defaultEncoding;
        if (typeof cb !== "function") cb = nop;
        if (state.ending) writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string") encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer4.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret) state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev) stream._writev(chunk, state.onwrite);
        else stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          api.nextTick(cb, er);
          api.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state);
        if (er) onwriteError(stream, state, sync, er, cb);
        else {
          var finished = needFinish(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            api.nextTick(afterWrite, stream, state, finished, cb);
          } else {
            afterWrite(stream, state, finished, cb);
          }
        }
      }
      function afterWrite(stream, state, finished, cb) {
        if (!finished) onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l2 = state.bufferedRequestCount;
          var buffer2 = new Array(l2);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer2[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer2.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null) state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending) endWritable(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableLength", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err2) {
          state.pendingcb--;
          if (err2) {
            errorOrDestroy(stream, err2);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            api.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished) api.nextTick(cb);
          else stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err2) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err2);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err2, cb) {
        cb(err2);
      };
    }
  });

  // node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex = __commonJS({
    "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_shim();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) keys2.push(key);
        return keys2;
      };
      module.exports = Duplex;
      var Readable = require_stream_readable();
      var Writable = require_stream_writable();
      require_inherits_browser()(Duplex, Readable);
      {
        keys = objectKeys(Writable.prototype);
        for (v2 = 0; v2 < keys.length; v2++) {
          method = keys[v2];
          if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v2;
      function Duplex(options) {
        if (!(this instanceof Duplex)) return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false) this.readable = false;
          if (options.writable === false) this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended) return;
        api.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js"(exports, module) {
      init_shim();
      var buffer2 = require_buffer();
      var Buffer4 = buffer2.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
        module.exports = buffer2;
      } else {
        copyProps(buffer2, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer4(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer4.prototype);
      copyProps(Buffer4, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer4(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer4(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer4(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer2.SlowBuffer(size);
      };
    }
  });

  // node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js
  var require_string_decoder = __commonJS({
    "node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js"(exports) {
      "use strict";
      init_shim();
      var Buffer4 = require_safe_buffer().Buffer;
      var isEncoding = Buffer4.isEncoding || function(encoding) {
        encoding = "" + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc) return "utf8";
        var retried;
        while (true) {
          switch (enc) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return enc;
            default:
              if (retried) return;
              enc = ("" + enc).toLowerCase();
              retried = true;
          }
        }
      }
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer4.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
      }
      exports.StringDecoder = StringDecoder2;
      function StringDecoder2(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer4.allocUnsafe(nb);
      }
      StringDecoder2.prototype.write = function(buf) {
        if (buf.length === 0) return "";
        var r2;
        var i2;
        if (this.lastNeed) {
          r2 = this.fillLast(buf);
          if (r2 === void 0) return "";
          i2 = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i2 = 0;
        }
        if (i2 < buf.length) return r2 ? r2 + this.text(buf, i2) : this.text(buf, i2);
        return r2 || "";
      };
      StringDecoder2.prototype.end = utf8End;
      StringDecoder2.prototype.text = utf8Text;
      StringDecoder2.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      };
      function utf8CheckByte(byte) {
        if (byte <= 127) return 0;
        else if (byte >> 5 === 6) return 2;
        else if (byte >> 4 === 14) return 3;
        else if (byte >> 3 === 30) return 4;
        return byte >> 6 === 2 ? -1 : -2;
      }
      function utf8CheckIncomplete(self2, buf, i2) {
        var j = buf.length - 1;
        if (j < i2) return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) self2.lastNeed = nb - 1;
          return nb;
        }
        if (--j < i2 || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) self2.lastNeed = nb - 2;
          return nb;
        }
        if (--j < i2 || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2) nb = 0;
            else self2.lastNeed = nb - 3;
          }
          return nb;
        }
        return 0;
      }
      function utf8CheckExtraBytes(self2, buf, p2) {
        if ((buf[0] & 192) !== 128) {
          self2.lastNeed = 0;
          return "\uFFFD";
        }
        if (self2.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 192) !== 128) {
            self2.lastNeed = 1;
            return "\uFFFD";
          }
          if (self2.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
              self2.lastNeed = 2;
              return "\uFFFD";
            }
          }
        }
      }
      function utf8FillLast(buf) {
        var p2 = this.lastTotal - this.lastNeed;
        var r2 = utf8CheckExtraBytes(this, buf, p2);
        if (r2 !== void 0) return r2;
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p2, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p2, 0, buf.length);
        this.lastNeed -= buf.length;
      }
      function utf8Text(buf, i2) {
        var total = utf8CheckIncomplete(this, buf, i2);
        if (!this.lastNeed) return buf.toString("utf8", i2);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString("utf8", i2, end);
      }
      function utf8End(buf) {
        var r2 = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) return r2 + "\uFFFD";
        return r2;
      }
      function utf16Text(buf, i2) {
        if ((buf.length - i2) % 2 === 0) {
          var r2 = buf.toString("utf16le", i2);
          if (r2) {
            var c = r2.charCodeAt(r2.length - 1);
            if (c >= 55296 && c <= 56319) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r2.slice(0, -1);
            }
          }
          return r2;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString("utf16le", i2, buf.length - 1);
      }
      function utf16End(buf) {
        var r2 = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r2 + this.lastChar.toString("utf16le", 0, end);
        }
        return r2;
      }
      function base64Text(buf, i2) {
        var n2 = (buf.length - i2) % 3;
        if (n2 === 0) return buf.toString("base64", i2);
        this.lastNeed = 3 - n2;
        this.lastTotal = 3;
        if (n2 === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString("base64", i2, buf.length - n2);
      }
      function base64End(buf) {
        var r2 = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r2;
      }
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
      }
    }
  });

  // node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream = __commonJS({
    "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once2(callback) {
        var called = false;
        return function() {
          if (called) return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop2() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function") return eos(stream, null, opts);
        if (!opts) opts = {};
        callback = once2(callback || noop2);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable) onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable) callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable) callback.call(stream);
        };
        var onerror = function onerror2(err2) {
          callback.call(stream, err2);
        };
        var onclose = function onclose2() {
          var err2;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err2 = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err2);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err2 = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err2);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req) onrequest();
          else stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false) stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req) stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator = __commonJS({
    "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_shim();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        key = _toPropertyKey(key);
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return typeof key === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (typeof input !== "object" || input === null) return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (typeof res !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      var finished = require_end_of_stream();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve = iter[kLastResolve];
        if (resolve !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        api.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve, reject) {
              api.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
          _this2[kStream].destroy(null, function(err2) {
            if (err2) {
              reject(err2);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err2) {
          if (err2 && err2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err2);
            }
            iterator[kError] = err2;
            return;
          }
          var resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser = __commonJS({
    "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_shim();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable = __commonJS({
    "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Readable;
      var Duplex;
      Readable.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = (typeof _global !== "undefined" ? _global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList = require_buffer_list();
      var destroyImpl = require_destroy();
      var _require = require_state();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder2;
      var createReadableStreamAsyncIterator;
      var from;
      require_inherits_browser()(Readable, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener2(emitter, event, fn) {
        if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
        else emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex();
        options = options || {};
        if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder2) StringDecoder2 = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder2(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable(options) {
        Duplex = Duplex || require_stream_duplex();
        if (!(this instanceof Readable)) return new Readable(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function") this._read = options.read;
          if (typeof options.destroy === "function") this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable.prototype, "destroyed", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable.prototype.destroy = destroyImpl.destroy;
      Readable.prototype._undestroy = destroyImpl.undestroy;
      Readable.prototype._destroy = function(err2, cb) {
        cb(err2);
      };
      Readable.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer4.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck) er = chunkInvalid(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                else maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);
          else state.buffer.push(chunk);
          if (state.needReadable) emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable.prototype.setEncoding = function(enc) {
        if (!StringDecoder2) StringDecoder2 = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder2(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p2 = this._readableState.buffer.head;
        var content = "";
        while (p2 !== null) {
          content += decoder.write(p2.data);
          p2 = p2.next;
        }
        this._readableState.buffer.clear();
        if (content !== "") this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n2) {
        if (n2 >= MAX_HWM) {
          n2 = MAX_HWM;
        } else {
          n2--;
          n2 |= n2 >>> 1;
          n2 |= n2 >>> 2;
          n2 |= n2 >>> 4;
          n2 |= n2 >>> 8;
          n2 |= n2 >>> 16;
          n2++;
        }
        return n2;
      }
      function howMuchToRead(n2, state) {
        if (n2 <= 0 || state.length === 0 && state.ended) return 0;
        if (state.objectMode) return 1;
        if (n2 !== n2) {
          if (state.flowing && state.length) return state.buffer.head.data.length;
          else return state.length;
        }
        if (n2 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n2);
        if (n2 <= state.length) return n2;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable.prototype.read = function(n2) {
        debug("read", n2);
        n2 = parseInt(n2, 10);
        var state = this._readableState;
        var nOrig = n2;
        if (n2 !== 0) state.emittedReadable = false;
        if (n2 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended) endReadable(this);
          else emitReadable(this);
          return null;
        }
        n2 = howMuchToRead(n2, state);
        if (n2 === 0 && state.ended) {
          if (state.length === 0) endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n2 < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0) state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading) n2 = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n2 > 0) ret = fromList(n2, state);
        else ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n2 = 0;
        } else {
          state.length -= n2;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended) state.needReadable = true;
          if (nOrig !== n2 && state.ended) endReadable(this);
        }
        if (ret !== null) this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        debug("onEofChunk");
        if (state.ended) return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
          }
        }
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          api.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        var state = stream._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          api.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable.prototype._read = function(n2) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== api.stdout && dest !== api.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted) api.nextTick(endFn);
        else src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
        }
        prependListener2(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain) state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0) return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes) return this;
          if (!dest) dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest) dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i2 = 0; i2 < len; i2++) dests[i2].emit("unpipe", this, {
            hasUnpiped: false
          });
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1) return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1) state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false) this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              api.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      Readable.prototype.removeListener = function(ev, fn) {
        var res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          api.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable.prototype.removeAllListeners = function(ev) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          api.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          api.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading) stream.read(0);
      }
      Readable.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) ;
      }
      Readable.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder) chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0)) return;
          else if (!state.objectMode && (!chunk || !chunk.length)) return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i2 in stream) {
          if (this[i2] === void 0 && typeof stream[i2] === "function") {
            this[i2] = /* @__PURE__ */ function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i2);
          }
        }
        for (var n2 = 0; n2 < kProxyEvents.length; n2++) {
          stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
        }
        this._read = function(n3) {
          debug("wrapped _read", n3);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable.prototype, "readableBuffer", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable.prototype, "readableFlowing", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable._fromList = fromList;
      Object.defineProperty(Readable.prototype, "readableLength", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._readableState.length;
        }
      });
      function fromList(n2, state) {
        if (state.length === 0) return null;
        var ret;
        if (state.objectMode) ret = state.buffer.shift();
        else if (!n2 || n2 >= state.length) {
          if (state.decoder) ret = state.buffer.join("");
          else if (state.buffer.length === 1) ret = state.buffer.first();
          else ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n2, state.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          api.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable.from = function(iterable, opts) {
          if (from === void 0) {
            from = require_from_browser();
          }
          return from(Readable, iterable, opts);
        };
      }
      function indexOf(xs, x) {
        for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
          if (xs[i2] === x) return i2;
        }
        return -1;
      }
    }
  });

  // node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform = __commonJS({
    "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Transform2;
      var _require$codes = require_errors_browser().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex();
      require_inherits_browser()(Transform2, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform2(options) {
        if (!(this instanceof Transform2)) return new Transform2(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function") this._transform = options.transform;
          if (typeof options.flush === "function") this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform2.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform2.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform2.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
        }
      };
      Transform2.prototype._read = function(n2) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform2.prototype._destroy = function(err2, cb) {
        Duplex.prototype._destroy.call(this, err2, function(err22) {
          cb(err22);
        });
      };
      function done(stream, er, data) {
        if (er) return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough = __commonJS({
    "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = PassThrough2;
      var Transform2 = require_stream_transform();
      require_inherits_browser()(PassThrough2, Transform2);
      function PassThrough2(options) {
        if (!(this instanceof PassThrough2)) return new PassThrough2(options);
        Transform2.call(this, options);
      }
      PassThrough2.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline = __commonJS({
    "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_shim();
      var eos;
      function once2(callback) {
        var called = false;
        return function() {
          if (called) return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop2(err2) {
        if (err2) throw err2;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once2(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0) eos = require_end_of_stream();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err2) {
          if (err2) return callback(err2);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err2) {
          if (closed) return;
          if (destroyed) return;
          destroyed = true;
          if (isRequest(stream)) return stream.abort();
          if (typeof stream.destroy === "function") return stream.destroy();
          callback(err2 || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length) return noop2;
        if (typeof streams[streams.length - 1] !== "function") return noop2;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0])) streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i2) {
          var reading = i2 < streams.length - 1;
          var writing = i2 > 0;
          return destroyer(stream, reading, writing, function(err2) {
            if (!error) error = err2;
            if (err2) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js
  var require_stream_browserify = __commonJS({
    "node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js"(exports, module) {
      init_shim();
      module.exports = Stream;
      var EE = require_events().EventEmitter;
      var inherits = require_inherits_browser();
      inherits(Stream, EE);
      Stream.Readable = require_stream_readable();
      Stream.Writable = require_stream_writable();
      Stream.Duplex = require_stream_duplex();
      Stream.Transform = require_stream_transform();
      Stream.PassThrough = require_stream_passthrough();
      Stream.finished = require_end_of_stream();
      Stream.pipeline = require_pipeline();
      Stream.Stream = Stream;
      function Stream() {
        EE.call(this);
      }
      Stream.prototype.pipe = function(dest, options) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on("end", onend);
          source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend() {
          if (didOnEnd) return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd) return;
          didOnEnd = true;
          if (typeof dest.destroy === "function") dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (EE.listenerCount(this, "error") === 0) {
            throw er;
          }
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js"(exports, module) {
      init_shim();
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          // Latin Extended-A block.
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof _global == "object" && _global && _global.Object === Object && _global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e2) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (comparator(value, array[index])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length, result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index = -1, length = values.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1, length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (comparator(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index = -1, length = array.length;
          while (++index < length) {
            var current = iteratee(array[index]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n2, iteratee) {
          var index = -1, result = Array(n2);
          while (++index < n2) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length = strSymbols.length;
          while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function countHolders(array, placeholder) {
          var length = array.length, result = 0;
          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue2(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map) {
          var index = -1, result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg(func, transform2) {
          return function(arg) {
            return func(transform2(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index = -1, length = array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return index;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index = string.length;
          while (index-- && reWhitespace.test(string.charAt(index))) {
          }
          return index;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer4 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer4 ? Buffer4.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e2) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer4 ? Buffer4.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = /* @__PURE__ */ function() {
            function object() {
            }
            return function(proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array[index];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined2 : data[index][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index < length) {
              this.add(values2[index]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array, n2) {
            return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index < length) {
              result2[index] = skip ? undefined2 : get(object, paths[index]);
            }
            return result2;
          }
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined2) {
                number = number <= upper ? number : upper;
              }
              if (lower !== undefined2) {
                number = number >= lower ? number : lower;
              }
            }
            return number;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array, values2, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values2, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index, collection2) {
              result2 = !!predicate(value, index, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index = -1, length = array.length;
            while (++index < length) {
              var value = array[index], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array[start++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index < length) {
              var value = array[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length = path.length;
            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }
            return index && index == length ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer:
              while (++index < length && result2.length < maxLength) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n2) {
            var length = array.length;
            if (!length) {
              return;
            }
            n2 += n2 < 0 ? length : 0;
            return isIndex(n2, length) ? array[n2] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity];
            }
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index = -1, length = paths.length, result2 = {};
            while (++index < length) {
              var path = paths[index], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array, values2, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
            if (array === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index < length) {
              var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index = indexes[length];
              if (length == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex(index)) {
                  splice.call(array, index, 1);
                } else {
                  baseUnset(array, index);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string, n2) {
            var result2 = "";
            if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n2 % 2) {
                result2 += string;
              }
              n2 = nativeFloor(n2 / 2);
              if (n2) {
                string += string;
              }
            } while (n2);
            return result2;
          }
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n2) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n2, 0, array.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object;
            }
            path = castPath(path, object);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
              var key = toKey(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length);
            while (++index < length) {
              result2[index] = array[index + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index, collection2) {
              result2 = predicate(value, index, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index = -1, length = array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set2 = iteratee2 ? null : createSet(array);
              if (set2) {
                return setToArray(set2);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index = -1, result2 = Array2(length);
            while (++index < length) {
              var array = arrays[index], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index) {
                  result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index = -1, length = props.length, valsLength = values2.length, result2 = {};
            while (++index < length) {
              var value = index < valsLength ? values2[index] : undefined2;
              assignFunc(result2, props[index], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity;
          }
          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString(value));
          }
          var castRest = baseRest;
          function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined2 ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
          };
          function cloneBuffer(buffer2, isDeep) {
            if (isDeep) {
              return buffer2.slice();
            }
            var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
            buffer2.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index < length) {
              var result2 = compareAscending(objCriteria[index], othCriteria[index]);
              if (result2) {
                if (index >= ordersLength) {
                  return result2;
                }
                var order = orders[index];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array2(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index-- : ++index < length) {
                if (iteratee2(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index = wrapper ? index : length;
              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value();
                }
                var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                while (++index2 < length) {
                  result2 = funcs[index2].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                end = step = undefined2;
              }
              start = toFinite(start);
              if (end === undefined2) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array, other);
            stack.set(other, array);
            while (++index < arrLength) {
              var arrValue = array[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop2 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
            while (length--) {
              var data = array[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map2, key) {
            var data = map2.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue2(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e2) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index = -1, length = transforms.length;
            while (++index < length) {
              var data = transforms[index], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start + size2);
                  break;
                case "takeRight":
                  start = nativeMax(start, end - size2);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length = path.length, result2 = false;
            while (++index < length) {
              var key = toKey(path[index]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length = array.length, result2 = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
              return eq(object[index], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start, transform3) {
            start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array2(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform3(array);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length--) {
              var index = indexes[length];
              array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index = -1, length = array.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index < size2) {
              var rand = baseRandom(index, lastIndex), value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e2) {
              }
              try {
                return func + "";
              } catch (e2) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array, size2, guard) {
            if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length = array == null ? 0 : array.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index < length) {
              result2[resIndex++] = baseSlice(array, index, index += size2);
            }
            return result2;
          }
          function compact(array) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array = arguments[0], index = length;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array, n2, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
            return baseSlice(array, n2 < 0 ? 0 : n2, length);
          }
          function dropRight(array, n2, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
            n2 = length - n2;
            return baseSlice(array, 0, n2 < 0 ? 0 : n2);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array, value, start, end);
          }
          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length - 1;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
          }
          function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index < length) {
              var pair = pairs[index];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseIndexOf(array, value, index);
          }
          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined2;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
          }
          function nth(array, n2) {
            return array && array.length ? baseNth(array, toInteger(n2)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
          }
          function pullAllBy(array, values2, iteratee2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values2, comparator) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result2;
          });
          function remove(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result2.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice(array, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value);
              if (index < length && eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          function take(array, n2, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
            return baseSlice(array, 0, n2 < 0 ? 0 : n2);
          }
          function takeRight(array, n2, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
            n2 = length - n2;
            return baseSlice(array, n2 < 0 ? 0 : n2, length);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq(array, undefined2, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index) {
              return arrayMap(array, baseProperty(index));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone2 = wrapperClone(parent2);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map(collection, iteratee2) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n2, guard) {
            if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined2) {
              n2 = 1;
            } else {
              n2 = toInteger(n2);
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n2);
          }
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root.Date.now();
          };
          function after(n2, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n2 = toInteger(n2);
            return function() {
              if (--n2 < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n2, guard) {
            n2 = guard ? undefined2 : n2;
            n2 = func && n2 == null ? func.length : n2;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n2);
          }
          function before(n2, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n2 = toInteger(n2);
            return function() {
              if (--n2 > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n2 <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once2(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index = -1, length = nativeMin(args.length, funcsLength);
              while (++index < length) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start === undefined2 ? start : toInteger(start);
            return baseRest(func, start);
          }
          function spread(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
              var array = args[start], otherArgs = castSlice(args, 0, start);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(/* @__PURE__ */ function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined2(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object, sources) {
            object = Object2(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length = path.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index < length) {
              var value = object == null ? undefined2 : object[toKey(path[index])];
              if (value === undefined2) {
                index = length;
                value = defaultValue;
              }
              object = isFunction(value) ? value.call(object) : value;
            }
            return object;
          }
          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform2(object, iteratee2, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject(object)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
              return iteratee2(accumulator, value, index, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp(number, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
          }
          function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber(number);
            return baseInRange(number, start, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index) {
            word = word.toLowerCase();
            return result2 + (index ? capitalize(word) : word);
          });
          function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
          }
          function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n2, guard) {
            if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined2) {
              n2 = 1;
            } else {
              n2 = toInteger(n2);
            }
            return baseRepeat(toString(string), n2);
          }
          function replace() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString(value).toLowerCase();
          }
          function toUpper(value) {
            return toString(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result2.lastIndexOf(separator);
              if (index > -1) {
                result2 = result2.slice(0, index);
              }
            }
            return result2 + omission;
          }
          function unescape(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e2) {
              return isError(e2) ? e2 : new Error2(e2);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index = -1;
              while (++index < length) {
                var pair = pairs[index];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop2() {
          }
          function nthArg(n2) {
            n2 = toInteger(n2);
            return baseRest(function(args) {
              return baseNth(args, n2);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet(object, path);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n2, iteratee2) {
            n2 = toInteger(n2);
            if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n2 -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index < n2) {
              iteratee2(index);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
          }
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
          }
          var add = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once2;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform2;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined2;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop2;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n2) {
              n2 = n2 === undefined2 ? 1 : nativeMax(toInteger(n2), 0);
              var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n2) {
              return this.reverse()[methodName](n2).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _ = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _;
          define(function() {
            return _;
          });
        } else if (freeModule) {
          (freeModule.exports = _)._ = _;
          freeExports._ = _;
        } else {
          root._ = _;
        }
      }).call(exports);
    }
  });

  // node_modules/.pnpm/svgpath@2.6.0/node_modules/svgpath/lib/path_parse.js
  var require_path_parse = __commonJS({
    "node_modules/.pnpm/svgpath@2.6.0/node_modules/svgpath/lib/path_parse.js"(exports, module) {
      "use strict";
      init_shim();
      var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 };
      var SPECIAL_SPACES = [
        5760,
        6158,
        8192,
        8193,
        8194,
        8195,
        8196,
        8197,
        8198,
        8199,
        8200,
        8201,
        8202,
        8239,
        8287,
        12288,
        65279
      ];
      function isSpace(ch) {
        return ch === 10 || ch === 13 || ch === 8232 || ch === 8233 || // Line terminators
        // White spaces
        ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && SPECIAL_SPACES.indexOf(ch) >= 0;
      }
      function isCommand(code) {
        switch (code | 32) {
          case 109:
          case 122:
          case 108:
          case 104:
          case 118:
          case 99:
          case 115:
          case 113:
          case 116:
          case 97:
          case 114:
            return true;
        }
        return false;
      }
      function isArc(code) {
        return (code | 32) === 97;
      }
      function isDigit2(code) {
        return code >= 48 && code <= 57;
      }
      function isDigitStart(code) {
        return code >= 48 && code <= 57 || /* 0..9 */
        code === 43 || /* + */
        code === 45 || /* - */
        code === 46;
      }
      function State(path) {
        this.index = 0;
        this.path = path;
        this.max = path.length;
        this.result = [];
        this.param = 0;
        this.err = "";
        this.segmentStart = 0;
        this.data = [];
      }
      function skipSpaces(state) {
        while (state.index < state.max && isSpace(state.path.charCodeAt(state.index))) {
          state.index++;
        }
      }
      function scanFlag(state) {
        var ch = state.path.charCodeAt(state.index);
        if (ch === 48) {
          state.param = 0;
          state.index++;
          return;
        }
        if (ch === 49) {
          state.param = 1;
          state.index++;
          return;
        }
        state.err = "SvgPath: arc flag can be 0 or 1 only (at pos " + state.index + ")";
      }
      function scanParam(state) {
        var start = state.index, index = start, max = state.max, zeroFirst = false, hasCeiling = false, hasDecimal = false, hasDot = false, ch;
        if (index >= max) {
          state.err = "SvgPath: missed param (at pos " + index + ")";
          return;
        }
        ch = state.path.charCodeAt(index);
        if (ch === 43 || ch === 45) {
          index++;
          ch = index < max ? state.path.charCodeAt(index) : 0;
        }
        if (!isDigit2(ch) && ch !== 46) {
          state.err = "SvgPath: param should start with 0..9 or `.` (at pos " + index + ")";
          return;
        }
        if (ch !== 46) {
          zeroFirst = ch === 48;
          index++;
          ch = index < max ? state.path.charCodeAt(index) : 0;
          if (zeroFirst && index < max) {
            if (ch && isDigit2(ch)) {
              state.err = "SvgPath: numbers started with `0` such as `09` are illegal (at pos " + start + ")";
              return;
            }
          }
          while (index < max && isDigit2(state.path.charCodeAt(index))) {
            index++;
            hasCeiling = true;
          }
          ch = index < max ? state.path.charCodeAt(index) : 0;
        }
        if (ch === 46) {
          hasDot = true;
          index++;
          while (isDigit2(state.path.charCodeAt(index))) {
            index++;
            hasDecimal = true;
          }
          ch = index < max ? state.path.charCodeAt(index) : 0;
        }
        if (ch === 101 || ch === 69) {
          if (hasDot && !hasCeiling && !hasDecimal) {
            state.err = "SvgPath: invalid float exponent (at pos " + index + ")";
            return;
          }
          index++;
          ch = index < max ? state.path.charCodeAt(index) : 0;
          if (ch === 43 || ch === 45) {
            index++;
          }
          if (index < max && isDigit2(state.path.charCodeAt(index))) {
            while (index < max && isDigit2(state.path.charCodeAt(index))) {
              index++;
            }
          } else {
            state.err = "SvgPath: invalid float exponent (at pos " + index + ")";
            return;
          }
        }
        state.index = index;
        state.param = parseFloat(state.path.slice(start, index)) + 0;
      }
      function finalizeSegment(state) {
        var cmd, cmdLC;
        cmd = state.path[state.segmentStart];
        cmdLC = cmd.toLowerCase();
        var params = state.data;
        if (cmdLC === "m" && params.length > 2) {
          state.result.push([cmd, params[0], params[1]]);
          params = params.slice(2);
          cmdLC = "l";
          cmd = cmd === "m" ? "l" : "L";
        }
        if (cmdLC === "r") {
          state.result.push([cmd].concat(params));
        } else {
          while (params.length >= paramCounts[cmdLC]) {
            state.result.push([cmd].concat(params.splice(0, paramCounts[cmdLC])));
            if (!paramCounts[cmdLC]) {
              break;
            }
          }
        }
      }
      function scanSegment(state) {
        var max = state.max, cmdCode, is_arc, comma_found, need_params, i2;
        state.segmentStart = state.index;
        cmdCode = state.path.charCodeAt(state.index);
        is_arc = isArc(cmdCode);
        if (!isCommand(cmdCode)) {
          state.err = "SvgPath: bad command " + state.path[state.index] + " (at pos " + state.index + ")";
          return;
        }
        need_params = paramCounts[state.path[state.index].toLowerCase()];
        state.index++;
        skipSpaces(state);
        state.data = [];
        if (!need_params) {
          finalizeSegment(state);
          return;
        }
        comma_found = false;
        for (; ; ) {
          for (i2 = need_params; i2 > 0; i2--) {
            if (is_arc && (i2 === 3 || i2 === 4)) scanFlag(state);
            else scanParam(state);
            if (state.err.length) {
              finalizeSegment(state);
              return;
            }
            state.data.push(state.param);
            skipSpaces(state);
            comma_found = false;
            if (state.index < max && state.path.charCodeAt(state.index) === 44) {
              state.index++;
              skipSpaces(state);
              comma_found = true;
            }
          }
          if (comma_found) {
            continue;
          }
          if (state.index >= state.max) {
            break;
          }
          if (!isDigitStart(state.path.charCodeAt(state.index))) {
            break;
          }
        }
        finalizeSegment(state);
      }
      module.exports = function pathParse(svgPath) {
        var state = new State(svgPath);
        var max = state.max;
        skipSpaces(state);
        while (state.index < max && !state.err.length) {
          scanSegment(state);
        }
        if (state.result.length) {
          if ("mM".indexOf(state.result[0][0]) < 0) {
            state.err = "SvgPath: string should start with `M` or `m`";
            state.result = [];
          } else {
            state.result[0][0] = "M";
          }
        }
        return {
          err: state.err,
          segments: state.result
        };
      };
    }
  });

  // node_modules/.pnpm/svgpath@2.6.0/node_modules/svgpath/lib/matrix.js
  var require_matrix = __commonJS({
    "node_modules/.pnpm/svgpath@2.6.0/node_modules/svgpath/lib/matrix.js"(exports, module) {
      "use strict";
      init_shim();
      function combine(m1, m2) {
        return [
          m1[0] * m2[0] + m1[2] * m2[1],
          m1[1] * m2[0] + m1[3] * m2[1],
          m1[0] * m2[2] + m1[2] * m2[3],
          m1[1] * m2[2] + m1[3] * m2[3],
          m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
          m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
        ];
      }
      function Matrix() {
        if (!(this instanceof Matrix)) {
          return new Matrix();
        }
        this.queue = [];
        this.cache = null;
      }
      Matrix.prototype.matrix = function(m) {
        if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {
          return this;
        }
        this.cache = null;
        this.queue.push(m);
        return this;
      };
      Matrix.prototype.translate = function(tx, ty) {
        if (tx !== 0 || ty !== 0) {
          this.cache = null;
          this.queue.push([1, 0, 0, 1, tx, ty]);
        }
        return this;
      };
      Matrix.prototype.scale = function(sx, sy) {
        if (sx !== 1 || sy !== 1) {
          this.cache = null;
          this.queue.push([sx, 0, 0, sy, 0, 0]);
        }
        return this;
      };
      Matrix.prototype.rotate = function(angle, rx, ry) {
        var rad, cos2, sin2;
        if (angle !== 0) {
          this.translate(rx, ry);
          rad = angle * Math.PI / 180;
          cos2 = Math.cos(rad);
          sin2 = Math.sin(rad);
          this.queue.push([cos2, sin2, -sin2, cos2, 0, 0]);
          this.cache = null;
          this.translate(-rx, -ry);
        }
        return this;
      };
      Matrix.prototype.skewX = function(angle) {
        if (angle !== 0) {
          this.cache = null;
          this.queue.push([1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0]);
        }
        return this;
      };
      Matrix.prototype.skewY = function(angle) {
        if (angle !== 0) {
          this.cache = null;
          this.queue.push([1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0]);
        }
        return this;
      };
      Matrix.prototype.toArray = function() {
        if (this.cache) {
          return this.cache;
        }
        if (!this.queue.length) {
          this.cache = [1, 0, 0, 1, 0, 0];
          return this.cache;
        }
        this.cache = this.queue[0];
        if (this.queue.length === 1) {
          return this.cache;
        }
        for (var i2 = 1; i2 < this.queue.length; i2++) {
          this.cache = combine(this.cache, this.queue[i2]);
        }
        return this.cache;
      };
      Matrix.prototype.calc = function(x, y2, isRelative) {
        var m;
        if (!this.queue.length) {
          return [x, y2];
        }
        if (!this.cache) {
          this.cache = this.toArray();
        }
        m = this.cache;
        return [
          x * m[0] + y2 * m[2] + (isRelative ? 0 : m[4]),
          x * m[1] + y2 * m[3] + (isRelative ? 0 : m[5])
        ];
      };
      module.exports = Matrix;
    }
  });

  // node_modules/.pnpm/svgpath@2.6.0/node_modules/svgpath/lib/transform_parse.js
  var require_transform_parse = __commonJS({
    "node_modules/.pnpm/svgpath@2.6.0/node_modules/svgpath/lib/transform_parse.js"(exports, module) {
      "use strict";
      init_shim();
      var Matrix = require_matrix();
      var operations = {
        matrix: true,
        scale: true,
        rotate: true,
        translate: true,
        skewX: true,
        skewY: true
      };
      var CMD_SPLIT_RE = /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
      var PARAMS_SPLIT_RE = /[\s,]+/;
      module.exports = function transformParse(transformString) {
        var matrix = new Matrix();
        var cmd, params;
        transformString.split(CMD_SPLIT_RE).forEach(function(item) {
          if (!item.length) {
            return;
          }
          if (typeof operations[item] !== "undefined") {
            cmd = item;
            return;
          }
          params = item.split(PARAMS_SPLIT_RE).map(function(i2) {
            return +i2 || 0;
          });
          switch (cmd) {
            case "matrix":
              if (params.length === 6) {
                matrix.matrix(params);
              }
              return;
            case "scale":
              if (params.length === 1) {
                matrix.scale(params[0], params[0]);
              } else if (params.length === 2) {
                matrix.scale(params[0], params[1]);
              }
              return;
            case "rotate":
              if (params.length === 1) {
                matrix.rotate(params[0], 0, 0);
              } else if (params.length === 3) {
                matrix.rotate(params[0], params[1], params[2]);
              }
              return;
            case "translate":
              if (params.length === 1) {
                matrix.translate(params[0], 0);
              } else if (params.length === 2) {
                matrix.translate(params[0], params[1]);
              }
              return;
            case "skewX":
              if (params.length === 1) {
                matrix.skewX(params[0]);
              }
              return;
            case "skewY":
              if (params.length === 1) {
                matrix.skewY(params[0]);
              }
              return;
          }
        });
        return matrix;
      };
    }
  });

  // node_modules/.pnpm/svgpath@2.6.0/node_modules/svgpath/lib/a2c.js
  var require_a2c = __commonJS({
    "node_modules/.pnpm/svgpath@2.6.0/node_modules/svgpath/lib/a2c.js"(exports, module) {
      "use strict";
      init_shim();
      var TAU = Math.PI * 2;
      function unit_vector_angle(ux, uy, vx, vy) {
        var sign = ux * vy - uy * vx < 0 ? -1 : 1;
        var dot = ux * vx + uy * vy;
        if (dot > 1) {
          dot = 1;
        }
        if (dot < -1) {
          dot = -1;
        }
        return sign * Math.acos(dot);
      }
      function get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) {
        var x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
        var y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;
        var rx_sq = rx * rx;
        var ry_sq = ry * ry;
        var x1p_sq = x1p * x1p;
        var y1p_sq = y1p * y1p;
        var radicant = rx_sq * ry_sq - rx_sq * y1p_sq - ry_sq * x1p_sq;
        if (radicant < 0) {
          radicant = 0;
        }
        radicant /= rx_sq * y1p_sq + ry_sq * x1p_sq;
        radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);
        var cxp = radicant * rx / ry * y1p;
        var cyp = radicant * -ry / rx * x1p;
        var cx = cos_phi * cxp - sin_phi * cyp + (x1 + x2) / 2;
        var cy = sin_phi * cxp + cos_phi * cyp + (y1 + y2) / 2;
        var v1x = (x1p - cxp) / rx;
        var v1y = (y1p - cyp) / ry;
        var v2x = (-x1p - cxp) / rx;
        var v2y = (-y1p - cyp) / ry;
        var theta1 = unit_vector_angle(1, 0, v1x, v1y);
        var delta_theta = unit_vector_angle(v1x, v1y, v2x, v2y);
        if (fs === 0 && delta_theta > 0) {
          delta_theta -= TAU;
        }
        if (fs === 1 && delta_theta < 0) {
          delta_theta += TAU;
        }
        return [cx, cy, theta1, delta_theta];
      }
      function approximate_unit_arc(theta1, delta_theta) {
        var alpha = 4 / 3 * Math.tan(delta_theta / 4);
        var x1 = Math.cos(theta1);
        var y1 = Math.sin(theta1);
        var x2 = Math.cos(theta1 + delta_theta);
        var y2 = Math.sin(theta1 + delta_theta);
        return [x1, y1, x1 - y1 * alpha, y1 + x1 * alpha, x2 + y2 * alpha, y2 - x2 * alpha, x2, y2];
      }
      module.exports = function a2c2(x1, y1, x2, y2, fa, fs, rx, ry, phi) {
        var sin_phi = Math.sin(phi * TAU / 360);
        var cos_phi = Math.cos(phi * TAU / 360);
        var x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
        var y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;
        if (x1p === 0 && y1p === 0) {
          return [];
        }
        if (rx === 0 || ry === 0) {
          return [];
        }
        rx = Math.abs(rx);
        ry = Math.abs(ry);
        var lambda = x1p * x1p / (rx * rx) + y1p * y1p / (ry * ry);
        if (lambda > 1) {
          rx *= Math.sqrt(lambda);
          ry *= Math.sqrt(lambda);
        }
        var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi);
        var result = [];
        var theta1 = cc[2];
        var delta_theta = cc[3];
        var segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);
        delta_theta /= segments;
        for (var i2 = 0; i2 < segments; i2++) {
          result.push(approximate_unit_arc(theta1, delta_theta));
          theta1 += delta_theta;
        }
        return result.map(function(curve) {
          for (var i3 = 0; i3 < curve.length; i3 += 2) {
            var x = curve[i3 + 0];
            var y3 = curve[i3 + 1];
            x *= rx;
            y3 *= ry;
            var xp = cos_phi * x - sin_phi * y3;
            var yp = sin_phi * x + cos_phi * y3;
            curve[i3 + 0] = xp + cc[0];
            curve[i3 + 1] = yp + cc[1];
          }
          return curve;
        });
      };
    }
  });

  // node_modules/.pnpm/svgpath@2.6.0/node_modules/svgpath/lib/ellipse.js
  var require_ellipse = __commonJS({
    "node_modules/.pnpm/svgpath@2.6.0/node_modules/svgpath/lib/ellipse.js"(exports, module) {
      "use strict";
      init_shim();
      var epsilon = 1e-10;
      var torad = Math.PI / 180;
      function Ellipse(rx, ry, ax) {
        if (!(this instanceof Ellipse)) {
          return new Ellipse(rx, ry, ax);
        }
        this.rx = rx;
        this.ry = ry;
        this.ax = ax;
      }
      Ellipse.prototype.transform = function(m) {
        var c = Math.cos(this.ax * torad), s2 = Math.sin(this.ax * torad);
        var ma = [
          this.rx * (m[0] * c + m[2] * s2),
          this.rx * (m[1] * c + m[3] * s2),
          this.ry * (-m[0] * s2 + m[2] * c),
          this.ry * (-m[1] * s2 + m[3] * c)
        ];
        var J = ma[0] * ma[0] + ma[2] * ma[2], K = ma[1] * ma[1] + ma[3] * ma[3];
        var D2 = ((ma[0] - ma[3]) * (ma[0] - ma[3]) + (ma[2] + ma[1]) * (ma[2] + ma[1])) * ((ma[0] + ma[3]) * (ma[0] + ma[3]) + (ma[2] - ma[1]) * (ma[2] - ma[1]));
        var JK = (J + K) / 2;
        if (D2 < epsilon * JK) {
          this.rx = this.ry = Math.sqrt(JK);
          this.ax = 0;
          return this;
        }
        var L = ma[0] * ma[1] + ma[2] * ma[3];
        D2 = Math.sqrt(D2);
        var l1 = JK + D2 / 2, l2 = JK - D2 / 2;
        this.ax = Math.abs(L) < epsilon && Math.abs(l1 - K) < epsilon ? 90 : Math.atan(
          Math.abs(L) > Math.abs(l1 - K) ? (l1 - J) / L : L / (l1 - K)
        ) * 180 / Math.PI;
        if (this.ax >= 0) {
          this.rx = Math.sqrt(l1);
          this.ry = Math.sqrt(l2);
        } else {
          this.ax += 90;
          this.rx = Math.sqrt(l2);
          this.ry = Math.sqrt(l1);
        }
        return this;
      };
      Ellipse.prototype.isDegenerate = function() {
        return this.rx < epsilon * this.ry || this.ry < epsilon * this.rx;
      };
      module.exports = Ellipse;
    }
  });

  // node_modules/.pnpm/svgpath@2.6.0/node_modules/svgpath/lib/svgpath.js
  var require_svgpath = __commonJS({
    "node_modules/.pnpm/svgpath@2.6.0/node_modules/svgpath/lib/svgpath.js"(exports, module) {
      "use strict";
      init_shim();
      var pathParse = require_path_parse();
      var transformParse = require_transform_parse();
      var matrix = require_matrix();
      var a2c2 = require_a2c();
      var ellipse = require_ellipse();
      function SvgPath(path) {
        if (!(this instanceof SvgPath)) {
          return new SvgPath(path);
        }
        var pstate = pathParse(path);
        this.segments = pstate.segments;
        this.err = pstate.err;
        this.__stack = [];
      }
      SvgPath.from = function(src) {
        if (typeof src === "string") return new SvgPath(src);
        if (src instanceof SvgPath) {
          var s2 = new SvgPath("");
          s2.err = src.err;
          s2.segments = src.segments.map(function(sgm) {
            return sgm.slice();
          });
          s2.__stack = src.__stack.map(function(m) {
            return matrix().matrix(m.toArray());
          });
          return s2;
        }
        throw new Error("SvgPath.from: invalid param type " + src);
      };
      SvgPath.prototype.__matrix = function(m) {
        var self2 = this, i2;
        if (!m.queue.length) {
          return;
        }
        this.iterate(function(s2, index, x, y2) {
          var p2, result, name, isRelative;
          switch (s2[0]) {
            // Process 'assymetric' commands separately
            case "v":
              p2 = m.calc(0, s2[1], true);
              result = p2[0] === 0 ? ["v", p2[1]] : ["l", p2[0], p2[1]];
              break;
            case "V":
              p2 = m.calc(x, s2[1], false);
              result = p2[0] === m.calc(x, y2, false)[0] ? ["V", p2[1]] : ["L", p2[0], p2[1]];
              break;
            case "h":
              p2 = m.calc(s2[1], 0, true);
              result = p2[1] === 0 ? ["h", p2[0]] : ["l", p2[0], p2[1]];
              break;
            case "H":
              p2 = m.calc(s2[1], y2, false);
              result = p2[1] === m.calc(x, y2, false)[1] ? ["H", p2[0]] : ["L", p2[0], p2[1]];
              break;
            case "a":
            case "A":
              var ma = m.toArray();
              var e2 = ellipse(s2[1], s2[2], s2[3]).transform(ma);
              if (ma[0] * ma[3] - ma[1] * ma[2] < 0) {
                s2[5] = s2[5] ? "0" : "1";
              }
              p2 = m.calc(s2[6], s2[7], s2[0] === "a");
              if (s2[0] === "A" && s2[6] === x && s2[7] === y2 || s2[0] === "a" && s2[6] === 0 && s2[7] === 0) {
                result = [s2[0] === "a" ? "l" : "L", p2[0], p2[1]];
                break;
              }
              if (e2.isDegenerate()) {
                result = [s2[0] === "a" ? "l" : "L", p2[0], p2[1]];
              } else {
                result = [s2[0], e2.rx, e2.ry, e2.ax, s2[4], s2[5], p2[0], p2[1]];
              }
              break;
            case "m":
              isRelative = index > 0;
              p2 = m.calc(s2[1], s2[2], isRelative);
              result = ["m", p2[0], p2[1]];
              break;
            default:
              name = s2[0];
              result = [name];
              isRelative = name.toLowerCase() === name;
              for (i2 = 1; i2 < s2.length; i2 += 2) {
                p2 = m.calc(s2[i2], s2[i2 + 1], isRelative);
                result.push(p2[0], p2[1]);
              }
          }
          self2.segments[index] = result;
        }, true);
      };
      SvgPath.prototype.__evaluateStack = function() {
        var m, i2;
        if (!this.__stack.length) {
          return;
        }
        if (this.__stack.length === 1) {
          this.__matrix(this.__stack[0]);
          this.__stack = [];
          return;
        }
        m = matrix();
        i2 = this.__stack.length;
        while (--i2 >= 0) {
          m.matrix(this.__stack[i2].toArray());
        }
        this.__matrix(m);
        this.__stack = [];
      };
      SvgPath.prototype.toString = function() {
        var result = "", prevCmd = "", cmdSkipped = false;
        this.__evaluateStack();
        for (var i2 = 0, len = this.segments.length; i2 < len; i2++) {
          var segment = this.segments[i2];
          var cmd = segment[0];
          if (cmd !== prevCmd || cmd === "m" || cmd === "M") {
            if (cmd === "m" && prevCmd === "z") result += " ";
            result += cmd;
            cmdSkipped = false;
          } else {
            cmdSkipped = true;
          }
          for (var pos = 1; pos < segment.length; pos++) {
            var val = segment[pos];
            if (pos === 1) {
              if (cmdSkipped && val >= 0) result += " ";
            } else if (val >= 0) result += " ";
            result += val;
          }
          prevCmd = cmd;
        }
        return result;
      };
      SvgPath.prototype.translate = function(x, y2) {
        this.__stack.push(matrix().translate(x, y2 || 0));
        return this;
      };
      SvgPath.prototype.scale = function(sx, sy) {
        this.__stack.push(matrix().scale(sx, !sy && sy !== 0 ? sx : sy));
        return this;
      };
      SvgPath.prototype.rotate = function(angle, rx, ry) {
        this.__stack.push(matrix().rotate(angle, rx || 0, ry || 0));
        return this;
      };
      SvgPath.prototype.skewX = function(degrees) {
        this.__stack.push(matrix().skewX(degrees));
        return this;
      };
      SvgPath.prototype.skewY = function(degrees) {
        this.__stack.push(matrix().skewY(degrees));
        return this;
      };
      SvgPath.prototype.matrix = function(m) {
        this.__stack.push(matrix().matrix(m));
        return this;
      };
      SvgPath.prototype.transform = function(transformString) {
        if (!transformString.trim()) {
          return this;
        }
        this.__stack.push(transformParse(transformString));
        return this;
      };
      SvgPath.prototype.round = function(d2) {
        var contourStartDeltaX = 0, contourStartDeltaY = 0, deltaX = 0, deltaY = 0, l2;
        d2 = d2 || 0;
        this.__evaluateStack();
        this.segments.forEach(function(s2) {
          var isRelative = s2[0].toLowerCase() === s2[0];
          switch (s2[0]) {
            case "H":
            case "h":
              if (isRelative) {
                s2[1] += deltaX;
              }
              deltaX = s2[1] - s2[1].toFixed(d2);
              s2[1] = +s2[1].toFixed(d2);
              return;
            case "V":
            case "v":
              if (isRelative) {
                s2[1] += deltaY;
              }
              deltaY = s2[1] - s2[1].toFixed(d2);
              s2[1] = +s2[1].toFixed(d2);
              return;
            case "Z":
            case "z":
              deltaX = contourStartDeltaX;
              deltaY = contourStartDeltaY;
              return;
            case "M":
            case "m":
              if (isRelative) {
                s2[1] += deltaX;
                s2[2] += deltaY;
              }
              deltaX = s2[1] - s2[1].toFixed(d2);
              deltaY = s2[2] - s2[2].toFixed(d2);
              contourStartDeltaX = deltaX;
              contourStartDeltaY = deltaY;
              s2[1] = +s2[1].toFixed(d2);
              s2[2] = +s2[2].toFixed(d2);
              return;
            case "A":
            case "a":
              if (isRelative) {
                s2[6] += deltaX;
                s2[7] += deltaY;
              }
              deltaX = s2[6] - s2[6].toFixed(d2);
              deltaY = s2[7] - s2[7].toFixed(d2);
              s2[1] = +s2[1].toFixed(d2);
              s2[2] = +s2[2].toFixed(d2);
              s2[3] = +s2[3].toFixed(d2 + 2);
              s2[6] = +s2[6].toFixed(d2);
              s2[7] = +s2[7].toFixed(d2);
              return;
            default:
              l2 = s2.length;
              if (isRelative) {
                s2[l2 - 2] += deltaX;
                s2[l2 - 1] += deltaY;
              }
              deltaX = s2[l2 - 2] - s2[l2 - 2].toFixed(d2);
              deltaY = s2[l2 - 1] - s2[l2 - 1].toFixed(d2);
              s2.forEach(function(val, i2) {
                if (!i2) {
                  return;
                }
                s2[i2] = +s2[i2].toFixed(d2);
              });
              return;
          }
        });
        return this;
      };
      SvgPath.prototype.iterate = function(iterator, keepLazyStack) {
        var segments = this.segments, replacements = {}, needReplace = false, lastX = 0, lastY = 0, countourStartX = 0, countourStartY = 0;
        var i2, j, newSegments;
        if (!keepLazyStack) {
          this.__evaluateStack();
        }
        segments.forEach(function(s2, index) {
          var res = iterator(s2, index, lastX, lastY);
          if (Array.isArray(res)) {
            replacements[index] = res;
            needReplace = true;
          }
          var isRelative = s2[0] === s2[0].toLowerCase();
          switch (s2[0]) {
            case "m":
            case "M":
              lastX = s2[1] + (isRelative ? lastX : 0);
              lastY = s2[2] + (isRelative ? lastY : 0);
              countourStartX = lastX;
              countourStartY = lastY;
              return;
            case "h":
            case "H":
              lastX = s2[1] + (isRelative ? lastX : 0);
              return;
            case "v":
            case "V":
              lastY = s2[1] + (isRelative ? lastY : 0);
              return;
            case "z":
            case "Z":
              lastX = countourStartX;
              lastY = countourStartY;
              return;
            default:
              lastX = s2[s2.length - 2] + (isRelative ? lastX : 0);
              lastY = s2[s2.length - 1] + (isRelative ? lastY : 0);
          }
        });
        if (!needReplace) {
          return this;
        }
        newSegments = [];
        for (i2 = 0; i2 < segments.length; i2++) {
          if (typeof replacements[i2] !== "undefined") {
            for (j = 0; j < replacements[i2].length; j++) {
              newSegments.push(replacements[i2][j]);
            }
          } else {
            newSegments.push(segments[i2]);
          }
        }
        this.segments = newSegments;
        return this;
      };
      SvgPath.prototype.abs = function() {
        this.iterate(function(s2, index, x, y2) {
          var name = s2[0], nameUC = name.toUpperCase(), i2;
          if (name === nameUC) {
            return;
          }
          s2[0] = nameUC;
          switch (name) {
            case "v":
              s2[1] += y2;
              return;
            case "a":
              s2[6] += x;
              s2[7] += y2;
              return;
            default:
              for (i2 = 1; i2 < s2.length; i2++) {
                s2[i2] += i2 % 2 ? x : y2;
              }
          }
        }, true);
        return this;
      };
      SvgPath.prototype.rel = function() {
        this.iterate(function(s2, index, x, y2) {
          var name = s2[0], nameLC = name.toLowerCase(), i2;
          if (name === nameLC) {
            return;
          }
          if (index === 0 && name === "M") {
            return;
          }
          s2[0] = nameLC;
          switch (name) {
            case "V":
              s2[1] -= y2;
              return;
            case "A":
              s2[6] -= x;
              s2[7] -= y2;
              return;
            default:
              for (i2 = 1; i2 < s2.length; i2++) {
                s2[i2] -= i2 % 2 ? x : y2;
              }
          }
        }, true);
        return this;
      };
      SvgPath.prototype.unarc = function() {
        this.iterate(function(s2, index, x, y2) {
          var new_segments, nextX, nextY, result = [], name = s2[0];
          if (name !== "A" && name !== "a") {
            return null;
          }
          if (name === "a") {
            nextX = x + s2[6];
            nextY = y2 + s2[7];
          } else {
            nextX = s2[6];
            nextY = s2[7];
          }
          new_segments = a2c2(x, y2, nextX, nextY, s2[4], s2[5], s2[1], s2[2], s2[3]);
          if (new_segments.length === 0) {
            return [[s2[0] === "a" ? "l" : "L", s2[6], s2[7]]];
          }
          new_segments.forEach(function(s3) {
            result.push(["C", s3[2], s3[3], s3[4], s3[5], s3[6], s3[7]]);
          });
          return result;
        });
        return this;
      };
      SvgPath.prototype.unshort = function() {
        var segments = this.segments;
        var prevControlX, prevControlY, prevSegment;
        var curControlX, curControlY;
        this.iterate(function(s2, idx, x, y2) {
          var name = s2[0], nameUC = name.toUpperCase(), isRelative;
          if (!idx) {
            return;
          }
          if (nameUC === "T") {
            isRelative = name === "t";
            prevSegment = segments[idx - 1];
            if (prevSegment[0] === "Q") {
              prevControlX = prevSegment[1] - x;
              prevControlY = prevSegment[2] - y2;
            } else if (prevSegment[0] === "q") {
              prevControlX = prevSegment[1] - prevSegment[3];
              prevControlY = prevSegment[2] - prevSegment[4];
            } else {
              prevControlX = 0;
              prevControlY = 0;
            }
            curControlX = -prevControlX;
            curControlY = -prevControlY;
            if (!isRelative) {
              curControlX += x;
              curControlY += y2;
            }
            segments[idx] = [
              isRelative ? "q" : "Q",
              curControlX,
              curControlY,
              s2[1],
              s2[2]
            ];
          } else if (nameUC === "S") {
            isRelative = name === "s";
            prevSegment = segments[idx - 1];
            if (prevSegment[0] === "C") {
              prevControlX = prevSegment[3] - x;
              prevControlY = prevSegment[4] - y2;
            } else if (prevSegment[0] === "c") {
              prevControlX = prevSegment[3] - prevSegment[5];
              prevControlY = prevSegment[4] - prevSegment[6];
            } else {
              prevControlX = 0;
              prevControlY = 0;
            }
            curControlX = -prevControlX;
            curControlY = -prevControlY;
            if (!isRelative) {
              curControlX += x;
              curControlY += y2;
            }
            segments[idx] = [
              isRelative ? "c" : "C",
              curControlX,
              curControlY,
              s2[1],
              s2[2],
              s2[3],
              s2[4]
            ];
          }
        });
        return this;
      };
      module.exports = SvgPath;
    }
  });

  // node_modules/.pnpm/svgpath@2.6.0/node_modules/svgpath/index.js
  var require_svgpath2 = __commonJS({
    "node_modules/.pnpm/svgpath@2.6.0/node_modules/svgpath/index.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = require_svgpath();
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ucs2.js
  var require_ucs2 = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ucs2.js"(exports, module) {
      "use strict";
      init_shim();
      var _ = require_lodash();
      function ucs2encode(array) {
        return _.map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += String.fromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += String.fromCharCode(value);
          return output;
        }).join("");
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) === 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      module.exports = {
        encode: ucs2encode,
        decode: ucs2decode
      };
    }
  });

  // node_modules/.pnpm/cubic2quad@1.2.1/node_modules/cubic2quad/index.js
  var require_cubic2quad = __commonJS({
    "node_modules/.pnpm/cubic2quad@1.2.1/node_modules/cubic2quad/index.js"(exports, module) {
      "use strict";
      init_shim();
      var epsilon = 1e-16;
      function Point(x, y2) {
        this.x = x;
        this.y = y2;
      }
      Point.prototype.add = function(point) {
        return new Point(this.x + point.x, this.y + point.y);
      };
      Point.prototype.sub = function(point) {
        return new Point(this.x - point.x, this.y - point.y);
      };
      Point.prototype.mul = function(value) {
        return new Point(this.x * value, this.y * value);
      };
      Point.prototype.div = function(value) {
        return new Point(this.x / value, this.y / value);
      };
      Point.prototype.sqr = function() {
        return this.x * this.x + this.y * this.y;
      };
      Point.prototype.dot = function(point) {
        return this.x * point.x + this.y * point.y;
      };
      function calcPowerCoefficients(p1, c1, c2, p2) {
        var a2 = p2.sub(p1).add(c1.sub(c2).mul(3));
        var b2 = p1.add(c2).mul(3).sub(c1.mul(6));
        var c = c1.sub(p1).mul(3);
        var d2 = p1;
        return [a2, b2, c, d2];
      }
      function calcPowerCoefficientsQuad(p1, c1, p2) {
        var a2 = c1.mul(-2).add(p1).add(p2);
        var b2 = c1.sub(p1).mul(2);
        var c = p1;
        return [a2, b2, c];
      }
      function calcPoint(a2, b2, c, d2, t2) {
        return a2.mul(t2).add(b2).mul(t2).add(c).mul(t2).add(d2);
      }
      function calcPointQuad(a2, b2, c, t2) {
        return a2.mul(t2).add(b2).mul(t2).add(c);
      }
      function calcPointDerivative(a2, b2, c, d2, t2) {
        return a2.mul(3 * t2).add(b2.mul(2)).mul(t2).add(c);
      }
      function quadSolve(a2, b2, c) {
        if (a2 === 0) {
          return b2 === 0 ? [] : [-c / b2];
        }
        var D2 = b2 * b2 - 4 * a2 * c;
        if (Math.abs(D2) < epsilon) {
          return [-b2 / (2 * a2)];
        } else if (D2 < 0) {
          return [];
        }
        var DSqrt = Math.sqrt(D2);
        return [(-b2 - DSqrt) / (2 * a2), (-b2 + DSqrt) / (2 * a2)];
      }
      function minDistanceToLineSq(point, p1, p2) {
        var p1p2 = p2.sub(p1);
        var dot = point.sub(p1).dot(p1p2);
        var lenSq = p1p2.sqr();
        var param = 0;
        var diff;
        if (lenSq !== 0) param = dot / lenSq;
        if (param <= 0) {
          diff = point.sub(p1);
        } else if (param >= 1) {
          diff = point.sub(p2);
        } else {
          diff = point.sub(p1.add(p1p2.mul(param)));
        }
        return diff.sqr();
      }
      function processSegment(a2, b2, c, d2, t1, t2) {
        var f1 = calcPoint(a2, b2, c, d2, t1);
        var f2 = calcPoint(a2, b2, c, d2, t2);
        var f1_ = calcPointDerivative(a2, b2, c, d2, t1);
        var f2_ = calcPointDerivative(a2, b2, c, d2, t2);
        var D2 = -f1_.x * f2_.y + f2_.x * f1_.y;
        if (Math.abs(D2) < 1e-8) {
          return [f1, f1.add(f2).div(2), f2];
        }
        var cx = (f1_.x * (f2.y * f2_.x - f2.x * f2_.y) + f2_.x * (f1.x * f1_.y - f1.y * f1_.x)) / D2;
        var cy = (f1_.y * (f2.y * f2_.x - f2.x * f2_.y) + f2_.y * (f1.x * f1_.y - f1.y * f1_.x)) / D2;
        return [f1, new Point(cx, cy), f2];
      }
      function isSegmentApproximationClose(a2, b2, c, d2, tmin, tmax, p1, c1, p2, errorBound) {
        var n2 = 10;
        var t2, dt;
        var p3 = calcPowerCoefficientsQuad(p1, c1, p2);
        var qa = p3[0], qb = p3[1], qc = p3[2];
        var i2, j, distSq;
        var errorBoundSq = errorBound * errorBound;
        var cubicPoints = [];
        var quadPoints = [];
        var minDistSq;
        dt = (tmax - tmin) / n2;
        for (i2 = 0, t2 = tmin; i2 <= n2; i2++, t2 += dt) {
          cubicPoints.push(calcPoint(a2, b2, c, d2, t2));
        }
        dt = 1 / n2;
        for (i2 = 0, t2 = 0; i2 <= n2; i2++, t2 += dt) {
          quadPoints.push(calcPointQuad(qa, qb, qc, t2));
        }
        for (i2 = 1; i2 < cubicPoints.length - 1; i2++) {
          minDistSq = Infinity;
          for (j = 0; j < quadPoints.length - 1; j++) {
            distSq = minDistanceToLineSq(cubicPoints[i2], quadPoints[j], quadPoints[j + 1]);
            minDistSq = Math.min(minDistSq, distSq);
          }
          if (minDistSq > errorBoundSq) return false;
        }
        for (i2 = 1; i2 < quadPoints.length - 1; i2++) {
          minDistSq = Infinity;
          for (j = 0; j < cubicPoints.length - 1; j++) {
            distSq = minDistanceToLineSq(quadPoints[i2], cubicPoints[j], cubicPoints[j + 1]);
            minDistSq = Math.min(minDistSq, distSq);
          }
          if (minDistSq > errorBoundSq) return false;
        }
        return true;
      }
      function _isApproximationClose(a2, b2, c, d2, quadCurves, errorBound) {
        var dt = 1 / quadCurves.length;
        for (var i2 = 0; i2 < quadCurves.length; i2++) {
          var p1 = quadCurves[i2][0];
          var c1 = quadCurves[i2][1];
          var p2 = quadCurves[i2][2];
          if (!isSegmentApproximationClose(a2, b2, c, d2, i2 * dt, (i2 + 1) * dt, p1, c1, p2, errorBound)) {
            return false;
          }
        }
        return true;
      }
      function fromFlatArray(points) {
        var result = [];
        var segmentsNumber = (points.length - 2) / 4;
        for (var i2 = 0; i2 < segmentsNumber; i2++) {
          result.push([
            new Point(points[4 * i2], points[4 * i2 + 1]),
            new Point(points[4 * i2 + 2], points[4 * i2 + 3]),
            new Point(points[4 * i2 + 4], points[4 * i2 + 5])
          ]);
        }
        return result;
      }
      function toFlatArray(quadsList) {
        var result = [];
        result.push(quadsList[0][0].x);
        result.push(quadsList[0][0].y);
        for (var i2 = 0; i2 < quadsList.length; i2++) {
          result.push(quadsList[i2][1].x);
          result.push(quadsList[i2][1].y);
          result.push(quadsList[i2][2].x);
          result.push(quadsList[i2][2].y);
        }
        return result;
      }
      function isApproximationClose(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, quads, errorBound) {
        var pc = calcPowerCoefficients(
          new Point(p1x, p1y),
          new Point(c1x, c1y),
          new Point(c2x, c2y),
          new Point(p2x, p2y)
        );
        return _isApproximationClose(pc[0], pc[1], pc[2], pc[3], fromFlatArray(quads), errorBound);
      }
      function subdivideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t2) {
        var u2 = 1 - t2;
        var v2 = t2;
        var bx = x1 * u2 + x2 * v2;
        var sx = x2 * u2 + x3 * v2;
        var fx = x3 * u2 + x4 * v2;
        var cx = bx * u2 + sx * v2;
        var ex = sx * u2 + fx * v2;
        var dx = cx * u2 + ex * v2;
        var by = y1 * u2 + y2 * v2;
        var sy = y2 * u2 + y3 * v2;
        var fy = y3 * u2 + y4 * v2;
        var cy = by * u2 + sy * v2;
        var ey = sy * u2 + fy * v2;
        var dy = cy * u2 + ey * v2;
        return [
          [x1, y1, bx, by, cx, cy, dx, dy],
          [dx, dy, ex, ey, fx, fy, x4, y4]
        ];
      }
      function byNumber(x, y2) {
        return x - y2;
      }
      function solveInflections(x1, y1, x2, y2, x3, y3, x4, y4) {
        var p2 = -(x4 * (y1 - 2 * y2 + y3)) + x3 * (2 * y1 - 3 * y2 + y4) + x1 * (y2 - 2 * y3 + y4) - x2 * (y1 - 3 * y3 + 2 * y4);
        var q = x4 * (y1 - y2) + 3 * x3 * (-y1 + y2) + x2 * (2 * y1 - 3 * y3 + y4) - x1 * (2 * y2 - 3 * y3 + y4);
        var r2 = x3 * (y1 - y2) + x1 * (y2 - y3) + x2 * (-y1 + y3);
        return quadSolve(p2, q, r2).filter(function(t2) {
          return t2 > 1e-8 && t2 < 1 - 1e-8;
        }).sort(byNumber);
      }
      function _cubicToQuad(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, errorBound) {
        var p1 = new Point(p1x, p1y);
        var c1 = new Point(c1x, c1y);
        var c2 = new Point(c2x, c2y);
        var p2 = new Point(p2x, p2y);
        var pc = calcPowerCoefficients(p1, c1, c2, p2);
        var a2 = pc[0], b2 = pc[1], c = pc[2], d2 = pc[3];
        var approximation;
        for (var segmentsCount = 1; segmentsCount <= 8; segmentsCount++) {
          approximation = [];
          for (var t2 = 0; t2 < 1; t2 += 1 / segmentsCount) {
            approximation.push(processSegment(a2, b2, c, d2, t2, t2 + 1 / segmentsCount));
          }
          if (segmentsCount === 1 && (approximation[0][1].sub(p1).dot(c1.sub(p1)) < 0 || approximation[0][1].sub(p2).dot(c2.sub(p2)) < 0)) {
            continue;
          }
          if (_isApproximationClose(a2, b2, c, d2, approximation, errorBound)) {
            break;
          }
        }
        return toFlatArray(approximation);
      }
      function cubicToQuad(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, errorBound) {
        var inflections = solveInflections(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        if (!inflections.length) {
          return _cubicToQuad(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, errorBound);
        }
        var result = [];
        var curve = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        var prevPoint = 0;
        var quad, split;
        for (var inflectionIdx = 0; inflectionIdx < inflections.length; inflectionIdx++) {
          split = subdivideCubic(
            curve[0],
            curve[1],
            curve[2],
            curve[3],
            curve[4],
            curve[5],
            curve[6],
            curve[7],
            // we make a new curve, so adjust inflection point accordingly
            1 - (1 - inflections[inflectionIdx]) / (1 - prevPoint)
          );
          quad = _cubicToQuad(
            split[0][0],
            split[0][1],
            split[0][2],
            split[0][3],
            split[0][4],
            split[0][5],
            split[0][6],
            split[0][7],
            errorBound
          );
          result = result.concat(quad.slice(0, -2));
          curve = split[1];
          prevPoint = inflections[inflectionIdx];
        }
        quad = _cubicToQuad(
          curve[0],
          curve[1],
          curve[2],
          curve[3],
          curve[4],
          curve[5],
          curve[6],
          curve[7],
          errorBound
        );
        return result.concat(quad);
      }
      module.exports = cubicToQuad;
      module.exports.isApproximationClose = isApproximationClose;
      module.exports.quadSolve = quadSolve;
    }
  });

  // node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/conventions.js
  var require_conventions = __commonJS({
    "node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/conventions.js"(exports) {
      "use strict";
      init_shim();
      function find(list, predicate, ac) {
        if (ac === void 0) {
          ac = Array.prototype;
        }
        if (list && typeof ac.find === "function") {
          return ac.find.call(list, predicate);
        }
        for (var i2 = 0; i2 < list.length; i2++) {
          if (Object.prototype.hasOwnProperty.call(list, i2)) {
            var item = list[i2];
            if (predicate.call(void 0, item, i2, list)) {
              return item;
            }
          }
        }
      }
      function freeze(object, oc) {
        if (oc === void 0) {
          oc = Object;
        }
        return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
      }
      var MIME_TYPE = freeze({
        /**
         * `text/html`, the only mime type that triggers treating an XML document as HTML.
         *
         * @see DOMParser.SupportedType.isHTML
         * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
         * @see https://en.wikipedia.org/wiki/HTML Wikipedia
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
         * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
         */
        HTML: "text/html",
        /**
         * Helper method to check a mime type if it indicates an HTML document
         *
         * @param {string} [value]
         * @returns {boolean}
         *
         * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
         * @see https://en.wikipedia.org/wiki/HTML Wikipedia
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
         * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
        isHTML: function(value) {
          return value === MIME_TYPE.HTML;
        },
        /**
         * `application/xml`, the standard mime type for XML documents.
         *
         * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
         * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
         * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
         */
        XML_APPLICATION: "application/xml",
        /**
         * `text/html`, an alias for `application/xml`.
         *
         * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
         * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
         * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
         */
        XML_TEXT: "text/xml",
        /**
         * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
         * but is parsed as an XML document.
         *
         * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
         * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
         */
        XML_XHTML_APPLICATION: "application/xhtml+xml",
        /**
         * `image/svg+xml`,
         *
         * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
         * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
         * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
         */
        XML_SVG_IMAGE: "image/svg+xml"
      });
      var NAMESPACE = freeze({
        /**
         * The XHTML namespace.
         *
         * @see http://www.w3.org/1999/xhtml
         */
        HTML: "http://www.w3.org/1999/xhtml",
        /**
         * Checks if `uri` equals `NAMESPACE.HTML`.
         *
         * @param {string} [uri]
         *
         * @see NAMESPACE.HTML
         */
        isHTML: function(uri) {
          return uri === NAMESPACE.HTML;
        },
        /**
         * The SVG namespace.
         *
         * @see http://www.w3.org/2000/svg
         */
        SVG: "http://www.w3.org/2000/svg",
        /**
         * The `xml:` namespace.
         *
         * @see http://www.w3.org/XML/1998/namespace
         */
        XML: "http://www.w3.org/XML/1998/namespace",
        /**
         * The `xmlns:` namespace
         *
         * @see https://www.w3.org/2000/xmlns/
         */
        XMLNS: "http://www.w3.org/2000/xmlns/"
      });
      exports.find = find;
      exports.freeze = freeze;
      exports.MIME_TYPE = MIME_TYPE;
      exports.NAMESPACE = NAMESPACE;
    }
  });

  // node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/dom.js
  var require_dom = __commonJS({
    "node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/dom.js"(exports) {
      init_shim();
      var conventions = require_conventions();
      var find = conventions.find;
      var NAMESPACE = conventions.NAMESPACE;
      function notEmptyString(input) {
        return input !== "";
      }
      function splitOnASCIIWhitespace(input) {
        return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
      }
      function orderedSetReducer(current, element) {
        if (!current.hasOwnProperty(element)) {
          current[element] = true;
        }
        return current;
      }
      function toOrderedSet(input) {
        if (!input) return [];
        var list = splitOnASCIIWhitespace(input);
        return Object.keys(list.reduce(orderedSetReducer, {}));
      }
      function arrayIncludes(list) {
        return function(element) {
          return list && list.indexOf(element) !== -1;
        };
      }
      function copy(src, dest) {
        for (var p2 in src) {
          if (Object.prototype.hasOwnProperty.call(src, p2)) {
            dest[p2] = src[p2];
          }
        }
      }
      function _extends(Class, Super) {
        var pt = Class.prototype;
        if (!(pt instanceof Super)) {
          let t3 = function() {
          };
          var t2 = t3;
          ;
          t3.prototype = Super.prototype;
          t3 = new t3();
          copy(pt, t3);
          Class.prototype = pt = t3;
        }
        if (pt.constructor != Class) {
          if (typeof Class != "function") {
            console.error("unknown Class:" + Class);
          }
          pt.constructor = Class;
        }
      }
      var NodeType = {};
      var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
      var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
      var TEXT_NODE = NodeType.TEXT_NODE = 3;
      var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
      var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
      var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
      var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
      var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
      var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
      var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
      var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
      var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
      var ExceptionCode = {};
      var ExceptionMessage = {};
      var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
      var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
      var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
      var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
      var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
      var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
      var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
      var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
      var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
      var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
      var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
      var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
      var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
      var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
      var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
      function DOMException(code, message) {
        if (message instanceof Error) {
          var error = message;
        } else {
          error = this;
          Error.call(this, ExceptionMessage[code]);
          this.message = ExceptionMessage[code];
          if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
        }
        error.code = code;
        if (message) this.message = this.message + ": " + message;
        return error;
      }
      DOMException.prototype = Error.prototype;
      copy(ExceptionCode, DOMException);
      function NodeList() {
      }
      NodeList.prototype = {
        /**
         * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
         * @standard level1
         */
        length: 0,
        /**
         * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
         * @standard level1
         * @param index  unsigned long
         *   Index into the collection.
         * @return Node
         * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
         */
        item: function(index) {
          return index >= 0 && index < this.length ? this[index] : null;
        },
        toString: function(isHTML, nodeFilter) {
          for (var buf = [], i2 = 0; i2 < this.length; i2++) {
            serializeToString(this[i2], buf, isHTML, nodeFilter);
          }
          return buf.join("");
        },
        /**
         * @private
         * @param {function (Node):boolean} predicate
         * @returns {Node[]}
         */
        filter: function(predicate) {
          return Array.prototype.filter.call(this, predicate);
        },
        /**
         * @private
         * @param {Node} item
         * @returns {number}
         */
        indexOf: function(item) {
          return Array.prototype.indexOf.call(this, item);
        }
      };
      function LiveNodeList(node, refresh) {
        this._node = node;
        this._refresh = refresh;
        _updateLiveList(this);
      }
      function _updateLiveList(list) {
        var inc = list._node._inc || list._node.ownerDocument._inc;
        if (list._inc !== inc) {
          var ls = list._refresh(list._node);
          __set__(list, "length", ls.length);
          if (!list.$$length || ls.length < list.$$length) {
            for (var i2 = ls.length; i2 in list; i2++) {
              if (Object.prototype.hasOwnProperty.call(list, i2)) {
                delete list[i2];
              }
            }
          }
          copy(ls, list);
          list._inc = inc;
        }
      }
      LiveNodeList.prototype.item = function(i2) {
        _updateLiveList(this);
        return this[i2] || null;
      };
      _extends(LiveNodeList, NodeList);
      function NamedNodeMap() {
      }
      function _findNodeIndex(list, node) {
        var i2 = list.length;
        while (i2--) {
          if (list[i2] === node) {
            return i2;
          }
        }
      }
      function _addNamedNode(el, list, newAttr, oldAttr) {
        if (oldAttr) {
          list[_findNodeIndex(list, oldAttr)] = newAttr;
        } else {
          list[list.length++] = newAttr;
        }
        if (el) {
          newAttr.ownerElement = el;
          var doc = el.ownerDocument;
          if (doc) {
            oldAttr && _onRemoveAttribute(doc, el, oldAttr);
            _onAddAttribute(doc, el, newAttr);
          }
        }
      }
      function _removeNamedNode(el, list, attr) {
        var i2 = _findNodeIndex(list, attr);
        if (i2 >= 0) {
          var lastIndex = list.length - 1;
          while (i2 < lastIndex) {
            list[i2] = list[++i2];
          }
          list.length = lastIndex;
          if (el) {
            var doc = el.ownerDocument;
            if (doc) {
              _onRemoveAttribute(doc, el, attr);
              attr.ownerElement = null;
            }
          }
        } else {
          throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
        }
      }
      NamedNodeMap.prototype = {
        length: 0,
        item: NodeList.prototype.item,
        getNamedItem: function(key) {
          var i2 = this.length;
          while (i2--) {
            var attr = this[i2];
            if (attr.nodeName == key) {
              return attr;
            }
          }
        },
        setNamedItem: function(attr) {
          var el = attr.ownerElement;
          if (el && el != this._ownerElement) {
            throw new DOMException(INUSE_ATTRIBUTE_ERR);
          }
          var oldAttr = this.getNamedItem(attr.nodeName);
          _addNamedNode(this._ownerElement, this, attr, oldAttr);
          return oldAttr;
        },
        /* returns Node */
        setNamedItemNS: function(attr) {
          var el = attr.ownerElement, oldAttr;
          if (el && el != this._ownerElement) {
            throw new DOMException(INUSE_ATTRIBUTE_ERR);
          }
          oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
          _addNamedNode(this._ownerElement, this, attr, oldAttr);
          return oldAttr;
        },
        /* returns Node */
        removeNamedItem: function(key) {
          var attr = this.getNamedItem(key);
          _removeNamedNode(this._ownerElement, this, attr);
          return attr;
        },
        // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
        //for level2
        removeNamedItemNS: function(namespaceURI, localName) {
          var attr = this.getNamedItemNS(namespaceURI, localName);
          _removeNamedNode(this._ownerElement, this, attr);
          return attr;
        },
        getNamedItemNS: function(namespaceURI, localName) {
          var i2 = this.length;
          while (i2--) {
            var node = this[i2];
            if (node.localName == localName && node.namespaceURI == namespaceURI) {
              return node;
            }
          }
          return null;
        }
      };
      function DOMImplementation() {
      }
      DOMImplementation.prototype = {
        /**
         * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
         * The different implementations fairly diverged in what kind of features were reported.
         * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
         *
         * @deprecated It is deprecated and modern browsers return true in all cases.
         *
         * @param {string} feature
         * @param {string} [version]
         * @returns {boolean} always true
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
         * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
         */
        hasFeature: function(feature, version2) {
          return true;
        },
        /**
         * Creates an XML Document object of the specified type with its document element.
         *
         * __It behaves slightly different from the description in the living standard__:
         * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
         * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
         * - this implementation is not validating names or qualified names
         *   (when parsing XML strings, the SAX parser takes care of that)
         *
         * @param {string|null} namespaceURI
         * @param {string} qualifiedName
         * @param {DocumentType=null} doctype
         * @returns {Document}
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
         * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
         *
         * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
         * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
         * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
         */
        createDocument: function(namespaceURI, qualifiedName, doctype) {
          var doc = new Document();
          doc.implementation = this;
          doc.childNodes = new NodeList();
          doc.doctype = doctype || null;
          if (doctype) {
            doc.appendChild(doctype);
          }
          if (qualifiedName) {
            var root = doc.createElementNS(namespaceURI, qualifiedName);
            doc.appendChild(root);
          }
          return doc;
        },
        /**
         * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
         *
         * __This behavior is slightly different from the in the specs__:
         * - this implementation is not validating names or qualified names
         *   (when parsing XML strings, the SAX parser takes care of that)
         *
         * @param {string} qualifiedName
         * @param {string} [publicId]
         * @param {string} [systemId]
         * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
         * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
         * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
         *
         * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
         * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
         * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
         */
        createDocumentType: function(qualifiedName, publicId, systemId) {
          var node = new DocumentType();
          node.name = qualifiedName;
          node.nodeName = qualifiedName;
          node.publicId = publicId || "";
          node.systemId = systemId || "";
          return node;
        }
      };
      function Node() {
      }
      Node.prototype = {
        firstChild: null,
        lastChild: null,
        previousSibling: null,
        nextSibling: null,
        attributes: null,
        parentNode: null,
        childNodes: null,
        ownerDocument: null,
        nodeValue: null,
        namespaceURI: null,
        prefix: null,
        localName: null,
        // Modified in DOM Level 2:
        insertBefore: function(newChild, refChild) {
          return _insertBefore(this, newChild, refChild);
        },
        replaceChild: function(newChild, oldChild) {
          _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
          if (oldChild) {
            this.removeChild(oldChild);
          }
        },
        removeChild: function(oldChild) {
          return _removeChild(this, oldChild);
        },
        appendChild: function(newChild) {
          return this.insertBefore(newChild, null);
        },
        hasChildNodes: function() {
          return this.firstChild != null;
        },
        cloneNode: function(deep) {
          return cloneNode(this.ownerDocument || this, this, deep);
        },
        // Modified in DOM Level 2:
        normalize: function() {
          var child = this.firstChild;
          while (child) {
            var next = child.nextSibling;
            if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
              this.removeChild(next);
              child.appendData(next.data);
            } else {
              child.normalize();
              child = next;
            }
          }
        },
        // Introduced in DOM Level 2:
        isSupported: function(feature, version2) {
          return this.ownerDocument.implementation.hasFeature(feature, version2);
        },
        // Introduced in DOM Level 2:
        hasAttributes: function() {
          return this.attributes.length > 0;
        },
        /**
         * Look up the prefix associated to the given namespace URI, starting from this node.
         * **The default namespace declarations are ignored by this method.**
         * See Namespace Prefix Lookup for details on the algorithm used by this method.
         *
         * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
         *
         * @param {string | null} namespaceURI
         * @returns {string | null}
         * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
         * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
         * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
         * @see https://github.com/xmldom/xmldom/issues/322
         */
        lookupPrefix: function(namespaceURI) {
          var el = this;
          while (el) {
            var map = el._nsMap;
            if (map) {
              for (var n2 in map) {
                if (Object.prototype.hasOwnProperty.call(map, n2) && map[n2] === namespaceURI) {
                  return n2;
                }
              }
            }
            el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
          }
          return null;
        },
        // Introduced in DOM Level 3:
        lookupNamespaceURI: function(prefix) {
          var el = this;
          while (el) {
            var map = el._nsMap;
            if (map) {
              if (prefix in map) {
                if (Object.prototype.hasOwnProperty.call(map, prefix)) {
                  return map[prefix];
                }
              }
            }
            el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
          }
          return null;
        },
        // Introduced in DOM Level 3:
        isDefaultNamespace: function(namespaceURI) {
          var prefix = this.lookupPrefix(namespaceURI);
          return prefix == null;
        }
      };
      function _xmlEncoder(c) {
        return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
      }
      copy(NodeType, Node);
      copy(NodeType, Node.prototype);
      function _visitNode(node, callback) {
        if (callback(node)) {
          return true;
        }
        if (node = node.firstChild) {
          do {
            if (_visitNode(node, callback)) {
              return true;
            }
          } while (node = node.nextSibling);
        }
      }
      function Document() {
        this.ownerDocument = this;
      }
      function _onAddAttribute(doc, el, newAttr) {
        doc && doc._inc++;
        var ns = newAttr.namespaceURI;
        if (ns === NAMESPACE.XMLNS) {
          el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
        }
      }
      function _onRemoveAttribute(doc, el, newAttr, remove) {
        doc && doc._inc++;
        var ns = newAttr.namespaceURI;
        if (ns === NAMESPACE.XMLNS) {
          delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
        }
      }
      function _onUpdateChild(doc, el, newChild) {
        if (doc && doc._inc) {
          doc._inc++;
          var cs = el.childNodes;
          if (newChild) {
            cs[cs.length++] = newChild;
          } else {
            var child = el.firstChild;
            var i2 = 0;
            while (child) {
              cs[i2++] = child;
              child = child.nextSibling;
            }
            cs.length = i2;
            delete cs[cs.length];
          }
        }
      }
      function _removeChild(parentNode, child) {
        var previous = child.previousSibling;
        var next = child.nextSibling;
        if (previous) {
          previous.nextSibling = next;
        } else {
          parentNode.firstChild = next;
        }
        if (next) {
          next.previousSibling = previous;
        } else {
          parentNode.lastChild = previous;
        }
        child.parentNode = null;
        child.previousSibling = null;
        child.nextSibling = null;
        _onUpdateChild(parentNode.ownerDocument, parentNode);
        return child;
      }
      function hasValidParentNodeType(node) {
        return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
      }
      function hasInsertableNodeType(node) {
        return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
      }
      function isDocTypeNode(node) {
        return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
      }
      function isElementNode(node) {
        return node && node.nodeType === Node.ELEMENT_NODE;
      }
      function isTextNode(node) {
        return node && node.nodeType === Node.TEXT_NODE;
      }
      function isElementInsertionPossible(doc, child) {
        var parentChildNodes = doc.childNodes || [];
        if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
          return false;
        }
        var docTypeNode = find(parentChildNodes, isDocTypeNode);
        return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
      }
      function isElementReplacementPossible(doc, child) {
        var parentChildNodes = doc.childNodes || [];
        function hasElementChildThatIsNotChild(node) {
          return isElementNode(node) && node !== child;
        }
        if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
          return false;
        }
        var docTypeNode = find(parentChildNodes, isDocTypeNode);
        return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
      }
      function assertPreInsertionValidity1to5(parent, node, child) {
        if (!hasValidParentNodeType(parent)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
        }
        if (child && child.parentNode !== parent) {
          throw new DOMException(NOT_FOUND_ERR, "child not in parent");
        }
        if (
          // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
          !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
          // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
          // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
          // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
          isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
        ) {
          throw new DOMException(
            HIERARCHY_REQUEST_ERR,
            "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
          );
        }
      }
      function assertPreInsertionValidityInDocument(parent, node, child) {
        var parentChildNodes = parent.childNodes || [];
        var nodeChildNodes = node.childNodes || [];
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var nodeChildElements = nodeChildNodes.filter(isElementNode);
          if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
          }
          if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
          }
        }
        if (isElementNode(node)) {
          if (!isElementInsertionPossible(parent, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
          }
        }
        if (isDocTypeNode(node)) {
          if (find(parentChildNodes, isDocTypeNode)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
          }
          var parentElementChild = find(parentChildNodes, isElementNode);
          if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
          }
          if (!child && parentElementChild) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
          }
        }
      }
      function assertPreReplacementValidityInDocument(parent, node, child) {
        var parentChildNodes = parent.childNodes || [];
        var nodeChildNodes = node.childNodes || [];
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var nodeChildElements = nodeChildNodes.filter(isElementNode);
          if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
          }
          if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
          }
        }
        if (isElementNode(node)) {
          if (!isElementReplacementPossible(parent, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
          }
        }
        if (isDocTypeNode(node)) {
          let hasDoctypeChildThatIsNotChild2 = function(node2) {
            return isDocTypeNode(node2) && node2 !== child;
          };
          var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
          if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
          }
          var parentElementChild = find(parentChildNodes, isElementNode);
          if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
          }
        }
      }
      function _insertBefore(parent, node, child, _inDocumentAssertion) {
        assertPreInsertionValidity1to5(parent, node, child);
        if (parent.nodeType === Node.DOCUMENT_NODE) {
          (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
        }
        var cp = node.parentNode;
        if (cp) {
          cp.removeChild(node);
        }
        if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
          var newFirst = node.firstChild;
          if (newFirst == null) {
            return node;
          }
          var newLast = node.lastChild;
        } else {
          newFirst = newLast = node;
        }
        var pre = child ? child.previousSibling : parent.lastChild;
        newFirst.previousSibling = pre;
        newLast.nextSibling = child;
        if (pre) {
          pre.nextSibling = newFirst;
        } else {
          parent.firstChild = newFirst;
        }
        if (child == null) {
          parent.lastChild = newLast;
        } else {
          child.previousSibling = newLast;
        }
        do {
          newFirst.parentNode = parent;
        } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
        _onUpdateChild(parent.ownerDocument || parent, parent);
        if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
          node.firstChild = node.lastChild = null;
        }
        return node;
      }
      function _appendSingleChild(parentNode, newChild) {
        if (newChild.parentNode) {
          newChild.parentNode.removeChild(newChild);
        }
        newChild.parentNode = parentNode;
        newChild.previousSibling = parentNode.lastChild;
        newChild.nextSibling = null;
        if (newChild.previousSibling) {
          newChild.previousSibling.nextSibling = newChild;
        } else {
          parentNode.firstChild = newChild;
        }
        parentNode.lastChild = newChild;
        _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
        return newChild;
      }
      Document.prototype = {
        //implementation : null,
        nodeName: "#document",
        nodeType: DOCUMENT_NODE,
        /**
         * The DocumentType node of the document.
         *
         * @readonly
         * @type DocumentType
         */
        doctype: null,
        documentElement: null,
        _inc: 1,
        insertBefore: function(newChild, refChild) {
          if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
            var child = newChild.firstChild;
            while (child) {
              var next = child.nextSibling;
              this.insertBefore(child, refChild);
              child = next;
            }
            return newChild;
          }
          _insertBefore(this, newChild, refChild);
          newChild.ownerDocument = this;
          if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
            this.documentElement = newChild;
          }
          return newChild;
        },
        removeChild: function(oldChild) {
          if (this.documentElement == oldChild) {
            this.documentElement = null;
          }
          return _removeChild(this, oldChild);
        },
        replaceChild: function(newChild, oldChild) {
          _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
          newChild.ownerDocument = this;
          if (oldChild) {
            this.removeChild(oldChild);
          }
          if (isElementNode(newChild)) {
            this.documentElement = newChild;
          }
        },
        // Introduced in DOM Level 2:
        importNode: function(importedNode, deep) {
          return importNode(this, importedNode, deep);
        },
        // Introduced in DOM Level 2:
        getElementById: function(id) {
          var rtv = null;
          _visitNode(this.documentElement, function(node) {
            if (node.nodeType == ELEMENT_NODE) {
              if (node.getAttribute("id") == id) {
                rtv = node;
                return true;
              }
            }
          });
          return rtv;
        },
        /**
         * The `getElementsByClassName` method of `Document` interface returns an array-like object
         * of all child elements which have **all** of the given class name(s).
         *
         * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
         *
         *
         * Warning: This is a live LiveNodeList.
         * Changes in the DOM will reflect in the array as the changes occur.
         * If an element selected by this array no longer qualifies for the selector,
         * it will automatically be removed. Be aware of this for iteration purposes.
         *
         * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
         * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
         */
        getElementsByClassName: function(classNames) {
          var classNamesSet = toOrderedSet(classNames);
          return new LiveNodeList(this, function(base) {
            var ls = [];
            if (classNamesSet.length > 0) {
              _visitNode(base.documentElement, function(node) {
                if (node !== base && node.nodeType === ELEMENT_NODE) {
                  var nodeClassNames = node.getAttribute("class");
                  if (nodeClassNames) {
                    var matches = classNames === nodeClassNames;
                    if (!matches) {
                      var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                      matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                    }
                    if (matches) {
                      ls.push(node);
                    }
                  }
                }
              });
            }
            return ls;
          });
        },
        //document factory method:
        createElement: function(tagName) {
          var node = new Element();
          node.ownerDocument = this;
          node.nodeName = tagName;
          node.tagName = tagName;
          node.localName = tagName;
          node.childNodes = new NodeList();
          var attrs = node.attributes = new NamedNodeMap();
          attrs._ownerElement = node;
          return node;
        },
        createDocumentFragment: function() {
          var node = new DocumentFragment();
          node.ownerDocument = this;
          node.childNodes = new NodeList();
          return node;
        },
        createTextNode: function(data) {
          var node = new Text();
          node.ownerDocument = this;
          node.appendData(data);
          return node;
        },
        createComment: function(data) {
          var node = new Comment();
          node.ownerDocument = this;
          node.appendData(data);
          return node;
        },
        createCDATASection: function(data) {
          var node = new CDATASection();
          node.ownerDocument = this;
          node.appendData(data);
          return node;
        },
        createProcessingInstruction: function(target, data) {
          var node = new ProcessingInstruction();
          node.ownerDocument = this;
          node.tagName = node.nodeName = node.target = target;
          node.nodeValue = node.data = data;
          return node;
        },
        createAttribute: function(name) {
          var node = new Attr();
          node.ownerDocument = this;
          node.name = name;
          node.nodeName = name;
          node.localName = name;
          node.specified = true;
          return node;
        },
        createEntityReference: function(name) {
          var node = new EntityReference();
          node.ownerDocument = this;
          node.nodeName = name;
          return node;
        },
        // Introduced in DOM Level 2:
        createElementNS: function(namespaceURI, qualifiedName) {
          var node = new Element();
          var pl = qualifiedName.split(":");
          var attrs = node.attributes = new NamedNodeMap();
          node.childNodes = new NodeList();
          node.ownerDocument = this;
          node.nodeName = qualifiedName;
          node.tagName = qualifiedName;
          node.namespaceURI = namespaceURI;
          if (pl.length == 2) {
            node.prefix = pl[0];
            node.localName = pl[1];
          } else {
            node.localName = qualifiedName;
          }
          attrs._ownerElement = node;
          return node;
        },
        // Introduced in DOM Level 2:
        createAttributeNS: function(namespaceURI, qualifiedName) {
          var node = new Attr();
          var pl = qualifiedName.split(":");
          node.ownerDocument = this;
          node.nodeName = qualifiedName;
          node.name = qualifiedName;
          node.namespaceURI = namespaceURI;
          node.specified = true;
          if (pl.length == 2) {
            node.prefix = pl[0];
            node.localName = pl[1];
          } else {
            node.localName = qualifiedName;
          }
          return node;
        }
      };
      _extends(Document, Node);
      function Element() {
        this._nsMap = {};
      }
      Element.prototype = {
        nodeType: ELEMENT_NODE,
        hasAttribute: function(name) {
          return this.getAttributeNode(name) != null;
        },
        getAttribute: function(name) {
          var attr = this.getAttributeNode(name);
          return attr && attr.value || "";
        },
        getAttributeNode: function(name) {
          return this.attributes.getNamedItem(name);
        },
        setAttribute: function(name, value) {
          var attr = this.ownerDocument.createAttribute(name);
          attr.value = attr.nodeValue = "" + value;
          this.setAttributeNode(attr);
        },
        removeAttribute: function(name) {
          var attr = this.getAttributeNode(name);
          attr && this.removeAttributeNode(attr);
        },
        //four real opeartion method
        appendChild: function(newChild) {
          if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
            return this.insertBefore(newChild, null);
          } else {
            return _appendSingleChild(this, newChild);
          }
        },
        setAttributeNode: function(newAttr) {
          return this.attributes.setNamedItem(newAttr);
        },
        setAttributeNodeNS: function(newAttr) {
          return this.attributes.setNamedItemNS(newAttr);
        },
        removeAttributeNode: function(oldAttr) {
          return this.attributes.removeNamedItem(oldAttr.nodeName);
        },
        //get real attribute name,and remove it by removeAttributeNode
        removeAttributeNS: function(namespaceURI, localName) {
          var old = this.getAttributeNodeNS(namespaceURI, localName);
          old && this.removeAttributeNode(old);
        },
        hasAttributeNS: function(namespaceURI, localName) {
          return this.getAttributeNodeNS(namespaceURI, localName) != null;
        },
        getAttributeNS: function(namespaceURI, localName) {
          var attr = this.getAttributeNodeNS(namespaceURI, localName);
          return attr && attr.value || "";
        },
        setAttributeNS: function(namespaceURI, qualifiedName, value) {
          var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
          attr.value = attr.nodeValue = "" + value;
          this.setAttributeNode(attr);
        },
        getAttributeNodeNS: function(namespaceURI, localName) {
          return this.attributes.getNamedItemNS(namespaceURI, localName);
        },
        getElementsByTagName: function(tagName) {
          return new LiveNodeList(this, function(base) {
            var ls = [];
            _visitNode(base, function(node) {
              if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
                ls.push(node);
              }
            });
            return ls;
          });
        },
        getElementsByTagNameNS: function(namespaceURI, localName) {
          return new LiveNodeList(this, function(base) {
            var ls = [];
            _visitNode(base, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
                ls.push(node);
              }
            });
            return ls;
          });
        }
      };
      Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
      Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
      _extends(Element, Node);
      function Attr() {
      }
      Attr.prototype.nodeType = ATTRIBUTE_NODE;
      _extends(Attr, Node);
      function CharacterData() {
      }
      CharacterData.prototype = {
        data: "",
        substringData: function(offset, count) {
          return this.data.substring(offset, offset + count);
        },
        appendData: function(text) {
          text = this.data + text;
          this.nodeValue = this.data = text;
          this.length = text.length;
        },
        insertData: function(offset, text) {
          this.replaceData(offset, 0, text);
        },
        appendChild: function(newChild) {
          throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
        },
        deleteData: function(offset, count) {
          this.replaceData(offset, count, "");
        },
        replaceData: function(offset, count, text) {
          var start = this.data.substring(0, offset);
          var end = this.data.substring(offset + count);
          text = start + text + end;
          this.nodeValue = this.data = text;
          this.length = text.length;
        }
      };
      _extends(CharacterData, Node);
      function Text() {
      }
      Text.prototype = {
        nodeName: "#text",
        nodeType: TEXT_NODE,
        splitText: function(offset) {
          var text = this.data;
          var newText = text.substring(offset);
          text = text.substring(0, offset);
          this.data = this.nodeValue = text;
          this.length = text.length;
          var newNode = this.ownerDocument.createTextNode(newText);
          if (this.parentNode) {
            this.parentNode.insertBefore(newNode, this.nextSibling);
          }
          return newNode;
        }
      };
      _extends(Text, CharacterData);
      function Comment() {
      }
      Comment.prototype = {
        nodeName: "#comment",
        nodeType: COMMENT_NODE
      };
      _extends(Comment, CharacterData);
      function CDATASection() {
      }
      CDATASection.prototype = {
        nodeName: "#cdata-section",
        nodeType: CDATA_SECTION_NODE
      };
      _extends(CDATASection, CharacterData);
      function DocumentType() {
      }
      DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
      _extends(DocumentType, Node);
      function Notation() {
      }
      Notation.prototype.nodeType = NOTATION_NODE;
      _extends(Notation, Node);
      function Entity() {
      }
      Entity.prototype.nodeType = ENTITY_NODE;
      _extends(Entity, Node);
      function EntityReference() {
      }
      EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
      _extends(EntityReference, Node);
      function DocumentFragment() {
      }
      DocumentFragment.prototype.nodeName = "#document-fragment";
      DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
      _extends(DocumentFragment, Node);
      function ProcessingInstruction() {
      }
      ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
      _extends(ProcessingInstruction, Node);
      function XMLSerializer() {
      }
      XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
        return nodeSerializeToString.call(node, isHtml, nodeFilter);
      };
      Node.prototype.toString = nodeSerializeToString;
      function nodeSerializeToString(isHtml, nodeFilter) {
        var buf = [];
        var refNode = this.nodeType == 9 && this.documentElement || this;
        var prefix = refNode.prefix;
        var uri = refNode.namespaceURI;
        if (uri && prefix == null) {
          var prefix = refNode.lookupPrefix(uri);
          if (prefix == null) {
            var visibleNamespaces = [
              { namespace: uri, prefix: null }
              //{namespace:uri,prefix:''}
            ];
          }
        }
        serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
        return buf.join("");
      }
      function needNamespaceDefine(node, isHTML, visibleNamespaces) {
        var prefix = node.prefix || "";
        var uri = node.namespaceURI;
        if (!uri) {
          return false;
        }
        if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
          return false;
        }
        var i2 = visibleNamespaces.length;
        while (i2--) {
          var ns = visibleNamespaces[i2];
          if (ns.prefix === prefix) {
            return ns.namespace !== uri;
          }
        }
        return true;
      }
      function addSerializedAttribute(buf, qualifiedName, value) {
        buf.push(" ", qualifiedName, '="', value.replace(/[<&"]/g, _xmlEncoder), '"');
      }
      function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
        if (!visibleNamespaces) {
          visibleNamespaces = [];
        }
        if (nodeFilter) {
          node = nodeFilter(node);
          if (node) {
            if (typeof node == "string") {
              buf.push(node);
              return;
            }
          } else {
            return;
          }
        }
        switch (node.nodeType) {
          case ELEMENT_NODE:
            var attrs = node.attributes;
            var len = attrs.length;
            var child = node.firstChild;
            var nodeName = node.tagName;
            isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
            var prefixedNodeName = nodeName;
            if (!isHTML && !node.prefix && node.namespaceURI) {
              var defaultNS;
              for (var ai = 0; ai < attrs.length; ai++) {
                if (attrs.item(ai).name === "xmlns") {
                  defaultNS = attrs.item(ai).value;
                  break;
                }
              }
              if (!defaultNS) {
                for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                  var namespace = visibleNamespaces[nsi];
                  if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                    defaultNS = namespace.namespace;
                    break;
                  }
                }
              }
              if (defaultNS !== node.namespaceURI) {
                for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                  var namespace = visibleNamespaces[nsi];
                  if (namespace.namespace === node.namespaceURI) {
                    if (namespace.prefix) {
                      prefixedNodeName = namespace.prefix + ":" + nodeName;
                    }
                    break;
                  }
                }
              }
            }
            buf.push("<", prefixedNodeName);
            for (var i2 = 0; i2 < len; i2++) {
              var attr = attrs.item(i2);
              if (attr.prefix == "xmlns") {
                visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
              } else if (attr.nodeName == "xmlns") {
                visibleNamespaces.push({ prefix: "", namespace: attr.value });
              }
            }
            for (var i2 = 0; i2 < len; i2++) {
              var attr = attrs.item(i2);
              if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
                var prefix = attr.prefix || "";
                var uri = attr.namespaceURI;
                addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
                visibleNamespaces.push({ prefix, namespace: uri });
              }
              serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
            }
            if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
              var prefix = node.prefix || "";
              var uri = node.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
              buf.push(">");
              if (isHTML && /^script$/i.test(nodeName)) {
                while (child) {
                  if (child.data) {
                    buf.push(child.data);
                  } else {
                    serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                  }
                  child = child.nextSibling;
                }
              } else {
                while (child) {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                  child = child.nextSibling;
                }
              }
              buf.push("</", prefixedNodeName, ">");
            } else {
              buf.push("/>");
            }
            return;
          case DOCUMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            var child = node.firstChild;
            while (child) {
              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
              child = child.nextSibling;
            }
            return;
          case ATTRIBUTE_NODE:
            return addSerializedAttribute(buf, node.name, node.value);
          case TEXT_NODE:
            return buf.push(
              node.data.replace(/[<&]/g, _xmlEncoder).replace(/]]>/g, "]]&gt;")
            );
          case CDATA_SECTION_NODE:
            return buf.push("<![CDATA[", node.data, "]]>");
          case COMMENT_NODE:
            return buf.push("<!--", node.data, "-->");
          case DOCUMENT_TYPE_NODE:
            var pubid = node.publicId;
            var sysid = node.systemId;
            buf.push("<!DOCTYPE ", node.name);
            if (pubid) {
              buf.push(" PUBLIC ", pubid);
              if (sysid && sysid != ".") {
                buf.push(" ", sysid);
              }
              buf.push(">");
            } else if (sysid && sysid != ".") {
              buf.push(" SYSTEM ", sysid, ">");
            } else {
              var sub = node.internalSubset;
              if (sub) {
                buf.push(" [", sub, "]");
              }
              buf.push(">");
            }
            return;
          case PROCESSING_INSTRUCTION_NODE:
            return buf.push("<?", node.target, " ", node.data, "?>");
          case ENTITY_REFERENCE_NODE:
            return buf.push("&", node.nodeName, ";");
          //case ENTITY_NODE:
          //case NOTATION_NODE:
          default:
            buf.push("??", node.nodeName);
        }
      }
      function importNode(doc, node, deep) {
        var node2;
        switch (node.nodeType) {
          case ELEMENT_NODE:
            node2 = node.cloneNode(false);
            node2.ownerDocument = doc;
          //var attrs = node2.attributes;
          //var len = attrs.length;
          //for(var i=0;i<len;i++){
          //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
          //}
          case DOCUMENT_FRAGMENT_NODE:
            break;
          case ATTRIBUTE_NODE:
            deep = true;
            break;
        }
        if (!node2) {
          node2 = node.cloneNode(false);
        }
        node2.ownerDocument = doc;
        node2.parentNode = null;
        if (deep) {
          var child = node.firstChild;
          while (child) {
            node2.appendChild(importNode(doc, child, deep));
            child = child.nextSibling;
          }
        }
        return node2;
      }
      function cloneNode(doc, node, deep) {
        var node2 = new node.constructor();
        for (var n2 in node) {
          if (Object.prototype.hasOwnProperty.call(node, n2)) {
            var v2 = node[n2];
            if (typeof v2 != "object") {
              if (v2 != node2[n2]) {
                node2[n2] = v2;
              }
            }
          }
        }
        if (node.childNodes) {
          node2.childNodes = new NodeList();
        }
        node2.ownerDocument = doc;
        switch (node2.nodeType) {
          case ELEMENT_NODE:
            var attrs = node.attributes;
            var attrs2 = node2.attributes = new NamedNodeMap();
            var len = attrs.length;
            attrs2._ownerElement = node2;
            for (var i2 = 0; i2 < len; i2++) {
              node2.setAttributeNode(cloneNode(doc, attrs.item(i2), true));
            }
            break;
            ;
          case ATTRIBUTE_NODE:
            deep = true;
        }
        if (deep) {
          var child = node.firstChild;
          while (child) {
            node2.appendChild(cloneNode(doc, child, deep));
            child = child.nextSibling;
          }
        }
        return node2;
      }
      function __set__(object, key, value) {
        object[key] = value;
      }
      try {
        if (Object.defineProperty) {
          let getTextContent2 = function(node) {
            switch (node.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                var buf = [];
                node = node.firstChild;
                while (node) {
                  if (node.nodeType !== 7 && node.nodeType !== 8) {
                    buf.push(getTextContent2(node));
                  }
                  node = node.nextSibling;
                }
                return buf.join("");
              default:
                return node.nodeValue;
            }
          };
          getTextContent = getTextContent2;
          Object.defineProperty(LiveNodeList.prototype, "length", {
            get: function() {
              _updateLiveList(this);
              return this.$$length;
            }
          });
          Object.defineProperty(Node.prototype, "textContent", {
            get: function() {
              return getTextContent2(this);
            },
            set: function(data) {
              switch (this.nodeType) {
                case ELEMENT_NODE:
                case DOCUMENT_FRAGMENT_NODE:
                  while (this.firstChild) {
                    this.removeChild(this.firstChild);
                  }
                  if (data || String(data)) {
                    this.appendChild(this.ownerDocument.createTextNode(data));
                  }
                  break;
                default:
                  this.data = data;
                  this.value = data;
                  this.nodeValue = data;
              }
            }
          });
          __set__ = function(object, key, value) {
            object["$$" + key] = value;
          };
        }
      } catch (e2) {
      }
      var getTextContent;
      exports.DocumentType = DocumentType;
      exports.DOMException = DOMException;
      exports.DOMImplementation = DOMImplementation;
      exports.Element = Element;
      exports.Node = Node;
      exports.NodeList = NodeList;
      exports.XMLSerializer = XMLSerializer;
    }
  });

  // node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/entities.js
  var require_entities = __commonJS({
    "node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/entities.js"(exports) {
      "use strict";
      init_shim();
      var freeze = require_conventions().freeze;
      exports.XML_ENTITIES = freeze({
        amp: "&",
        apos: "'",
        gt: ">",
        lt: "<",
        quot: '"'
      });
      exports.HTML_ENTITIES = freeze({
        Aacute: "\xC1",
        aacute: "\xE1",
        Abreve: "\u0102",
        abreve: "\u0103",
        ac: "\u223E",
        acd: "\u223F",
        acE: "\u223E\u0333",
        Acirc: "\xC2",
        acirc: "\xE2",
        acute: "\xB4",
        Acy: "\u0410",
        acy: "\u0430",
        AElig: "\xC6",
        aelig: "\xE6",
        af: "\u2061",
        Afr: "\u{1D504}",
        afr: "\u{1D51E}",
        Agrave: "\xC0",
        agrave: "\xE0",
        alefsym: "\u2135",
        aleph: "\u2135",
        Alpha: "\u0391",
        alpha: "\u03B1",
        Amacr: "\u0100",
        amacr: "\u0101",
        amalg: "\u2A3F",
        AMP: "&",
        amp: "&",
        And: "\u2A53",
        and: "\u2227",
        andand: "\u2A55",
        andd: "\u2A5C",
        andslope: "\u2A58",
        andv: "\u2A5A",
        ang: "\u2220",
        ange: "\u29A4",
        angle: "\u2220",
        angmsd: "\u2221",
        angmsdaa: "\u29A8",
        angmsdab: "\u29A9",
        angmsdac: "\u29AA",
        angmsdad: "\u29AB",
        angmsdae: "\u29AC",
        angmsdaf: "\u29AD",
        angmsdag: "\u29AE",
        angmsdah: "\u29AF",
        angrt: "\u221F",
        angrtvb: "\u22BE",
        angrtvbd: "\u299D",
        angsph: "\u2222",
        angst: "\xC5",
        angzarr: "\u237C",
        Aogon: "\u0104",
        aogon: "\u0105",
        Aopf: "\u{1D538}",
        aopf: "\u{1D552}",
        ap: "\u2248",
        apacir: "\u2A6F",
        apE: "\u2A70",
        ape: "\u224A",
        apid: "\u224B",
        apos: "'",
        ApplyFunction: "\u2061",
        approx: "\u2248",
        approxeq: "\u224A",
        Aring: "\xC5",
        aring: "\xE5",
        Ascr: "\u{1D49C}",
        ascr: "\u{1D4B6}",
        Assign: "\u2254",
        ast: "*",
        asymp: "\u2248",
        asympeq: "\u224D",
        Atilde: "\xC3",
        atilde: "\xE3",
        Auml: "\xC4",
        auml: "\xE4",
        awconint: "\u2233",
        awint: "\u2A11",
        backcong: "\u224C",
        backepsilon: "\u03F6",
        backprime: "\u2035",
        backsim: "\u223D",
        backsimeq: "\u22CD",
        Backslash: "\u2216",
        Barv: "\u2AE7",
        barvee: "\u22BD",
        Barwed: "\u2306",
        barwed: "\u2305",
        barwedge: "\u2305",
        bbrk: "\u23B5",
        bbrktbrk: "\u23B6",
        bcong: "\u224C",
        Bcy: "\u0411",
        bcy: "\u0431",
        bdquo: "\u201E",
        becaus: "\u2235",
        Because: "\u2235",
        because: "\u2235",
        bemptyv: "\u29B0",
        bepsi: "\u03F6",
        bernou: "\u212C",
        Bernoullis: "\u212C",
        Beta: "\u0392",
        beta: "\u03B2",
        beth: "\u2136",
        between: "\u226C",
        Bfr: "\u{1D505}",
        bfr: "\u{1D51F}",
        bigcap: "\u22C2",
        bigcirc: "\u25EF",
        bigcup: "\u22C3",
        bigodot: "\u2A00",
        bigoplus: "\u2A01",
        bigotimes: "\u2A02",
        bigsqcup: "\u2A06",
        bigstar: "\u2605",
        bigtriangledown: "\u25BD",
        bigtriangleup: "\u25B3",
        biguplus: "\u2A04",
        bigvee: "\u22C1",
        bigwedge: "\u22C0",
        bkarow: "\u290D",
        blacklozenge: "\u29EB",
        blacksquare: "\u25AA",
        blacktriangle: "\u25B4",
        blacktriangledown: "\u25BE",
        blacktriangleleft: "\u25C2",
        blacktriangleright: "\u25B8",
        blank: "\u2423",
        blk12: "\u2592",
        blk14: "\u2591",
        blk34: "\u2593",
        block: "\u2588",
        bne: "=\u20E5",
        bnequiv: "\u2261\u20E5",
        bNot: "\u2AED",
        bnot: "\u2310",
        Bopf: "\u{1D539}",
        bopf: "\u{1D553}",
        bot: "\u22A5",
        bottom: "\u22A5",
        bowtie: "\u22C8",
        boxbox: "\u29C9",
        boxDL: "\u2557",
        boxDl: "\u2556",
        boxdL: "\u2555",
        boxdl: "\u2510",
        boxDR: "\u2554",
        boxDr: "\u2553",
        boxdR: "\u2552",
        boxdr: "\u250C",
        boxH: "\u2550",
        boxh: "\u2500",
        boxHD: "\u2566",
        boxHd: "\u2564",
        boxhD: "\u2565",
        boxhd: "\u252C",
        boxHU: "\u2569",
        boxHu: "\u2567",
        boxhU: "\u2568",
        boxhu: "\u2534",
        boxminus: "\u229F",
        boxplus: "\u229E",
        boxtimes: "\u22A0",
        boxUL: "\u255D",
        boxUl: "\u255C",
        boxuL: "\u255B",
        boxul: "\u2518",
        boxUR: "\u255A",
        boxUr: "\u2559",
        boxuR: "\u2558",
        boxur: "\u2514",
        boxV: "\u2551",
        boxv: "\u2502",
        boxVH: "\u256C",
        boxVh: "\u256B",
        boxvH: "\u256A",
        boxvh: "\u253C",
        boxVL: "\u2563",
        boxVl: "\u2562",
        boxvL: "\u2561",
        boxvl: "\u2524",
        boxVR: "\u2560",
        boxVr: "\u255F",
        boxvR: "\u255E",
        boxvr: "\u251C",
        bprime: "\u2035",
        Breve: "\u02D8",
        breve: "\u02D8",
        brvbar: "\xA6",
        Bscr: "\u212C",
        bscr: "\u{1D4B7}",
        bsemi: "\u204F",
        bsim: "\u223D",
        bsime: "\u22CD",
        bsol: "\\",
        bsolb: "\u29C5",
        bsolhsub: "\u27C8",
        bull: "\u2022",
        bullet: "\u2022",
        bump: "\u224E",
        bumpE: "\u2AAE",
        bumpe: "\u224F",
        Bumpeq: "\u224E",
        bumpeq: "\u224F",
        Cacute: "\u0106",
        cacute: "\u0107",
        Cap: "\u22D2",
        cap: "\u2229",
        capand: "\u2A44",
        capbrcup: "\u2A49",
        capcap: "\u2A4B",
        capcup: "\u2A47",
        capdot: "\u2A40",
        CapitalDifferentialD: "\u2145",
        caps: "\u2229\uFE00",
        caret: "\u2041",
        caron: "\u02C7",
        Cayleys: "\u212D",
        ccaps: "\u2A4D",
        Ccaron: "\u010C",
        ccaron: "\u010D",
        Ccedil: "\xC7",
        ccedil: "\xE7",
        Ccirc: "\u0108",
        ccirc: "\u0109",
        Cconint: "\u2230",
        ccups: "\u2A4C",
        ccupssm: "\u2A50",
        Cdot: "\u010A",
        cdot: "\u010B",
        cedil: "\xB8",
        Cedilla: "\xB8",
        cemptyv: "\u29B2",
        cent: "\xA2",
        CenterDot: "\xB7",
        centerdot: "\xB7",
        Cfr: "\u212D",
        cfr: "\u{1D520}",
        CHcy: "\u0427",
        chcy: "\u0447",
        check: "\u2713",
        checkmark: "\u2713",
        Chi: "\u03A7",
        chi: "\u03C7",
        cir: "\u25CB",
        circ: "\u02C6",
        circeq: "\u2257",
        circlearrowleft: "\u21BA",
        circlearrowright: "\u21BB",
        circledast: "\u229B",
        circledcirc: "\u229A",
        circleddash: "\u229D",
        CircleDot: "\u2299",
        circledR: "\xAE",
        circledS: "\u24C8",
        CircleMinus: "\u2296",
        CirclePlus: "\u2295",
        CircleTimes: "\u2297",
        cirE: "\u29C3",
        cire: "\u2257",
        cirfnint: "\u2A10",
        cirmid: "\u2AEF",
        cirscir: "\u29C2",
        ClockwiseContourIntegral: "\u2232",
        CloseCurlyDoubleQuote: "\u201D",
        CloseCurlyQuote: "\u2019",
        clubs: "\u2663",
        clubsuit: "\u2663",
        Colon: "\u2237",
        colon: ":",
        Colone: "\u2A74",
        colone: "\u2254",
        coloneq: "\u2254",
        comma: ",",
        commat: "@",
        comp: "\u2201",
        compfn: "\u2218",
        complement: "\u2201",
        complexes: "\u2102",
        cong: "\u2245",
        congdot: "\u2A6D",
        Congruent: "\u2261",
        Conint: "\u222F",
        conint: "\u222E",
        ContourIntegral: "\u222E",
        Copf: "\u2102",
        copf: "\u{1D554}",
        coprod: "\u2210",
        Coproduct: "\u2210",
        COPY: "\xA9",
        copy: "\xA9",
        copysr: "\u2117",
        CounterClockwiseContourIntegral: "\u2233",
        crarr: "\u21B5",
        Cross: "\u2A2F",
        cross: "\u2717",
        Cscr: "\u{1D49E}",
        cscr: "\u{1D4B8}",
        csub: "\u2ACF",
        csube: "\u2AD1",
        csup: "\u2AD0",
        csupe: "\u2AD2",
        ctdot: "\u22EF",
        cudarrl: "\u2938",
        cudarrr: "\u2935",
        cuepr: "\u22DE",
        cuesc: "\u22DF",
        cularr: "\u21B6",
        cularrp: "\u293D",
        Cup: "\u22D3",
        cup: "\u222A",
        cupbrcap: "\u2A48",
        CupCap: "\u224D",
        cupcap: "\u2A46",
        cupcup: "\u2A4A",
        cupdot: "\u228D",
        cupor: "\u2A45",
        cups: "\u222A\uFE00",
        curarr: "\u21B7",
        curarrm: "\u293C",
        curlyeqprec: "\u22DE",
        curlyeqsucc: "\u22DF",
        curlyvee: "\u22CE",
        curlywedge: "\u22CF",
        curren: "\xA4",
        curvearrowleft: "\u21B6",
        curvearrowright: "\u21B7",
        cuvee: "\u22CE",
        cuwed: "\u22CF",
        cwconint: "\u2232",
        cwint: "\u2231",
        cylcty: "\u232D",
        Dagger: "\u2021",
        dagger: "\u2020",
        daleth: "\u2138",
        Darr: "\u21A1",
        dArr: "\u21D3",
        darr: "\u2193",
        dash: "\u2010",
        Dashv: "\u2AE4",
        dashv: "\u22A3",
        dbkarow: "\u290F",
        dblac: "\u02DD",
        Dcaron: "\u010E",
        dcaron: "\u010F",
        Dcy: "\u0414",
        dcy: "\u0434",
        DD: "\u2145",
        dd: "\u2146",
        ddagger: "\u2021",
        ddarr: "\u21CA",
        DDotrahd: "\u2911",
        ddotseq: "\u2A77",
        deg: "\xB0",
        Del: "\u2207",
        Delta: "\u0394",
        delta: "\u03B4",
        demptyv: "\u29B1",
        dfisht: "\u297F",
        Dfr: "\u{1D507}",
        dfr: "\u{1D521}",
        dHar: "\u2965",
        dharl: "\u21C3",
        dharr: "\u21C2",
        DiacriticalAcute: "\xB4",
        DiacriticalDot: "\u02D9",
        DiacriticalDoubleAcute: "\u02DD",
        DiacriticalGrave: "`",
        DiacriticalTilde: "\u02DC",
        diam: "\u22C4",
        Diamond: "\u22C4",
        diamond: "\u22C4",
        diamondsuit: "\u2666",
        diams: "\u2666",
        die: "\xA8",
        DifferentialD: "\u2146",
        digamma: "\u03DD",
        disin: "\u22F2",
        div: "\xF7",
        divide: "\xF7",
        divideontimes: "\u22C7",
        divonx: "\u22C7",
        DJcy: "\u0402",
        djcy: "\u0452",
        dlcorn: "\u231E",
        dlcrop: "\u230D",
        dollar: "$",
        Dopf: "\u{1D53B}",
        dopf: "\u{1D555}",
        Dot: "\xA8",
        dot: "\u02D9",
        DotDot: "\u20DC",
        doteq: "\u2250",
        doteqdot: "\u2251",
        DotEqual: "\u2250",
        dotminus: "\u2238",
        dotplus: "\u2214",
        dotsquare: "\u22A1",
        doublebarwedge: "\u2306",
        DoubleContourIntegral: "\u222F",
        DoubleDot: "\xA8",
        DoubleDownArrow: "\u21D3",
        DoubleLeftArrow: "\u21D0",
        DoubleLeftRightArrow: "\u21D4",
        DoubleLeftTee: "\u2AE4",
        DoubleLongLeftArrow: "\u27F8",
        DoubleLongLeftRightArrow: "\u27FA",
        DoubleLongRightArrow: "\u27F9",
        DoubleRightArrow: "\u21D2",
        DoubleRightTee: "\u22A8",
        DoubleUpArrow: "\u21D1",
        DoubleUpDownArrow: "\u21D5",
        DoubleVerticalBar: "\u2225",
        DownArrow: "\u2193",
        Downarrow: "\u21D3",
        downarrow: "\u2193",
        DownArrowBar: "\u2913",
        DownArrowUpArrow: "\u21F5",
        DownBreve: "\u0311",
        downdownarrows: "\u21CA",
        downharpoonleft: "\u21C3",
        downharpoonright: "\u21C2",
        DownLeftRightVector: "\u2950",
        DownLeftTeeVector: "\u295E",
        DownLeftVector: "\u21BD",
        DownLeftVectorBar: "\u2956",
        DownRightTeeVector: "\u295F",
        DownRightVector: "\u21C1",
        DownRightVectorBar: "\u2957",
        DownTee: "\u22A4",
        DownTeeArrow: "\u21A7",
        drbkarow: "\u2910",
        drcorn: "\u231F",
        drcrop: "\u230C",
        Dscr: "\u{1D49F}",
        dscr: "\u{1D4B9}",
        DScy: "\u0405",
        dscy: "\u0455",
        dsol: "\u29F6",
        Dstrok: "\u0110",
        dstrok: "\u0111",
        dtdot: "\u22F1",
        dtri: "\u25BF",
        dtrif: "\u25BE",
        duarr: "\u21F5",
        duhar: "\u296F",
        dwangle: "\u29A6",
        DZcy: "\u040F",
        dzcy: "\u045F",
        dzigrarr: "\u27FF",
        Eacute: "\xC9",
        eacute: "\xE9",
        easter: "\u2A6E",
        Ecaron: "\u011A",
        ecaron: "\u011B",
        ecir: "\u2256",
        Ecirc: "\xCA",
        ecirc: "\xEA",
        ecolon: "\u2255",
        Ecy: "\u042D",
        ecy: "\u044D",
        eDDot: "\u2A77",
        Edot: "\u0116",
        eDot: "\u2251",
        edot: "\u0117",
        ee: "\u2147",
        efDot: "\u2252",
        Efr: "\u{1D508}",
        efr: "\u{1D522}",
        eg: "\u2A9A",
        Egrave: "\xC8",
        egrave: "\xE8",
        egs: "\u2A96",
        egsdot: "\u2A98",
        el: "\u2A99",
        Element: "\u2208",
        elinters: "\u23E7",
        ell: "\u2113",
        els: "\u2A95",
        elsdot: "\u2A97",
        Emacr: "\u0112",
        emacr: "\u0113",
        empty: "\u2205",
        emptyset: "\u2205",
        EmptySmallSquare: "\u25FB",
        emptyv: "\u2205",
        EmptyVerySmallSquare: "\u25AB",
        emsp: "\u2003",
        emsp13: "\u2004",
        emsp14: "\u2005",
        ENG: "\u014A",
        eng: "\u014B",
        ensp: "\u2002",
        Eogon: "\u0118",
        eogon: "\u0119",
        Eopf: "\u{1D53C}",
        eopf: "\u{1D556}",
        epar: "\u22D5",
        eparsl: "\u29E3",
        eplus: "\u2A71",
        epsi: "\u03B5",
        Epsilon: "\u0395",
        epsilon: "\u03B5",
        epsiv: "\u03F5",
        eqcirc: "\u2256",
        eqcolon: "\u2255",
        eqsim: "\u2242",
        eqslantgtr: "\u2A96",
        eqslantless: "\u2A95",
        Equal: "\u2A75",
        equals: "=",
        EqualTilde: "\u2242",
        equest: "\u225F",
        Equilibrium: "\u21CC",
        equiv: "\u2261",
        equivDD: "\u2A78",
        eqvparsl: "\u29E5",
        erarr: "\u2971",
        erDot: "\u2253",
        Escr: "\u2130",
        escr: "\u212F",
        esdot: "\u2250",
        Esim: "\u2A73",
        esim: "\u2242",
        Eta: "\u0397",
        eta: "\u03B7",
        ETH: "\xD0",
        eth: "\xF0",
        Euml: "\xCB",
        euml: "\xEB",
        euro: "\u20AC",
        excl: "!",
        exist: "\u2203",
        Exists: "\u2203",
        expectation: "\u2130",
        ExponentialE: "\u2147",
        exponentiale: "\u2147",
        fallingdotseq: "\u2252",
        Fcy: "\u0424",
        fcy: "\u0444",
        female: "\u2640",
        ffilig: "\uFB03",
        fflig: "\uFB00",
        ffllig: "\uFB04",
        Ffr: "\u{1D509}",
        ffr: "\u{1D523}",
        filig: "\uFB01",
        FilledSmallSquare: "\u25FC",
        FilledVerySmallSquare: "\u25AA",
        fjlig: "fj",
        flat: "\u266D",
        fllig: "\uFB02",
        fltns: "\u25B1",
        fnof: "\u0192",
        Fopf: "\u{1D53D}",
        fopf: "\u{1D557}",
        ForAll: "\u2200",
        forall: "\u2200",
        fork: "\u22D4",
        forkv: "\u2AD9",
        Fouriertrf: "\u2131",
        fpartint: "\u2A0D",
        frac12: "\xBD",
        frac13: "\u2153",
        frac14: "\xBC",
        frac15: "\u2155",
        frac16: "\u2159",
        frac18: "\u215B",
        frac23: "\u2154",
        frac25: "\u2156",
        frac34: "\xBE",
        frac35: "\u2157",
        frac38: "\u215C",
        frac45: "\u2158",
        frac56: "\u215A",
        frac58: "\u215D",
        frac78: "\u215E",
        frasl: "\u2044",
        frown: "\u2322",
        Fscr: "\u2131",
        fscr: "\u{1D4BB}",
        gacute: "\u01F5",
        Gamma: "\u0393",
        gamma: "\u03B3",
        Gammad: "\u03DC",
        gammad: "\u03DD",
        gap: "\u2A86",
        Gbreve: "\u011E",
        gbreve: "\u011F",
        Gcedil: "\u0122",
        Gcirc: "\u011C",
        gcirc: "\u011D",
        Gcy: "\u0413",
        gcy: "\u0433",
        Gdot: "\u0120",
        gdot: "\u0121",
        gE: "\u2267",
        ge: "\u2265",
        gEl: "\u2A8C",
        gel: "\u22DB",
        geq: "\u2265",
        geqq: "\u2267",
        geqslant: "\u2A7E",
        ges: "\u2A7E",
        gescc: "\u2AA9",
        gesdot: "\u2A80",
        gesdoto: "\u2A82",
        gesdotol: "\u2A84",
        gesl: "\u22DB\uFE00",
        gesles: "\u2A94",
        Gfr: "\u{1D50A}",
        gfr: "\u{1D524}",
        Gg: "\u22D9",
        gg: "\u226B",
        ggg: "\u22D9",
        gimel: "\u2137",
        GJcy: "\u0403",
        gjcy: "\u0453",
        gl: "\u2277",
        gla: "\u2AA5",
        glE: "\u2A92",
        glj: "\u2AA4",
        gnap: "\u2A8A",
        gnapprox: "\u2A8A",
        gnE: "\u2269",
        gne: "\u2A88",
        gneq: "\u2A88",
        gneqq: "\u2269",
        gnsim: "\u22E7",
        Gopf: "\u{1D53E}",
        gopf: "\u{1D558}",
        grave: "`",
        GreaterEqual: "\u2265",
        GreaterEqualLess: "\u22DB",
        GreaterFullEqual: "\u2267",
        GreaterGreater: "\u2AA2",
        GreaterLess: "\u2277",
        GreaterSlantEqual: "\u2A7E",
        GreaterTilde: "\u2273",
        Gscr: "\u{1D4A2}",
        gscr: "\u210A",
        gsim: "\u2273",
        gsime: "\u2A8E",
        gsiml: "\u2A90",
        Gt: "\u226B",
        GT: ">",
        gt: ">",
        gtcc: "\u2AA7",
        gtcir: "\u2A7A",
        gtdot: "\u22D7",
        gtlPar: "\u2995",
        gtquest: "\u2A7C",
        gtrapprox: "\u2A86",
        gtrarr: "\u2978",
        gtrdot: "\u22D7",
        gtreqless: "\u22DB",
        gtreqqless: "\u2A8C",
        gtrless: "\u2277",
        gtrsim: "\u2273",
        gvertneqq: "\u2269\uFE00",
        gvnE: "\u2269\uFE00",
        Hacek: "\u02C7",
        hairsp: "\u200A",
        half: "\xBD",
        hamilt: "\u210B",
        HARDcy: "\u042A",
        hardcy: "\u044A",
        hArr: "\u21D4",
        harr: "\u2194",
        harrcir: "\u2948",
        harrw: "\u21AD",
        Hat: "^",
        hbar: "\u210F",
        Hcirc: "\u0124",
        hcirc: "\u0125",
        hearts: "\u2665",
        heartsuit: "\u2665",
        hellip: "\u2026",
        hercon: "\u22B9",
        Hfr: "\u210C",
        hfr: "\u{1D525}",
        HilbertSpace: "\u210B",
        hksearow: "\u2925",
        hkswarow: "\u2926",
        hoarr: "\u21FF",
        homtht: "\u223B",
        hookleftarrow: "\u21A9",
        hookrightarrow: "\u21AA",
        Hopf: "\u210D",
        hopf: "\u{1D559}",
        horbar: "\u2015",
        HorizontalLine: "\u2500",
        Hscr: "\u210B",
        hscr: "\u{1D4BD}",
        hslash: "\u210F",
        Hstrok: "\u0126",
        hstrok: "\u0127",
        HumpDownHump: "\u224E",
        HumpEqual: "\u224F",
        hybull: "\u2043",
        hyphen: "\u2010",
        Iacute: "\xCD",
        iacute: "\xED",
        ic: "\u2063",
        Icirc: "\xCE",
        icirc: "\xEE",
        Icy: "\u0418",
        icy: "\u0438",
        Idot: "\u0130",
        IEcy: "\u0415",
        iecy: "\u0435",
        iexcl: "\xA1",
        iff: "\u21D4",
        Ifr: "\u2111",
        ifr: "\u{1D526}",
        Igrave: "\xCC",
        igrave: "\xEC",
        ii: "\u2148",
        iiiint: "\u2A0C",
        iiint: "\u222D",
        iinfin: "\u29DC",
        iiota: "\u2129",
        IJlig: "\u0132",
        ijlig: "\u0133",
        Im: "\u2111",
        Imacr: "\u012A",
        imacr: "\u012B",
        image: "\u2111",
        ImaginaryI: "\u2148",
        imagline: "\u2110",
        imagpart: "\u2111",
        imath: "\u0131",
        imof: "\u22B7",
        imped: "\u01B5",
        Implies: "\u21D2",
        in: "\u2208",
        incare: "\u2105",
        infin: "\u221E",
        infintie: "\u29DD",
        inodot: "\u0131",
        Int: "\u222C",
        int: "\u222B",
        intcal: "\u22BA",
        integers: "\u2124",
        Integral: "\u222B",
        intercal: "\u22BA",
        Intersection: "\u22C2",
        intlarhk: "\u2A17",
        intprod: "\u2A3C",
        InvisibleComma: "\u2063",
        InvisibleTimes: "\u2062",
        IOcy: "\u0401",
        iocy: "\u0451",
        Iogon: "\u012E",
        iogon: "\u012F",
        Iopf: "\u{1D540}",
        iopf: "\u{1D55A}",
        Iota: "\u0399",
        iota: "\u03B9",
        iprod: "\u2A3C",
        iquest: "\xBF",
        Iscr: "\u2110",
        iscr: "\u{1D4BE}",
        isin: "\u2208",
        isindot: "\u22F5",
        isinE: "\u22F9",
        isins: "\u22F4",
        isinsv: "\u22F3",
        isinv: "\u2208",
        it: "\u2062",
        Itilde: "\u0128",
        itilde: "\u0129",
        Iukcy: "\u0406",
        iukcy: "\u0456",
        Iuml: "\xCF",
        iuml: "\xEF",
        Jcirc: "\u0134",
        jcirc: "\u0135",
        Jcy: "\u0419",
        jcy: "\u0439",
        Jfr: "\u{1D50D}",
        jfr: "\u{1D527}",
        jmath: "\u0237",
        Jopf: "\u{1D541}",
        jopf: "\u{1D55B}",
        Jscr: "\u{1D4A5}",
        jscr: "\u{1D4BF}",
        Jsercy: "\u0408",
        jsercy: "\u0458",
        Jukcy: "\u0404",
        jukcy: "\u0454",
        Kappa: "\u039A",
        kappa: "\u03BA",
        kappav: "\u03F0",
        Kcedil: "\u0136",
        kcedil: "\u0137",
        Kcy: "\u041A",
        kcy: "\u043A",
        Kfr: "\u{1D50E}",
        kfr: "\u{1D528}",
        kgreen: "\u0138",
        KHcy: "\u0425",
        khcy: "\u0445",
        KJcy: "\u040C",
        kjcy: "\u045C",
        Kopf: "\u{1D542}",
        kopf: "\u{1D55C}",
        Kscr: "\u{1D4A6}",
        kscr: "\u{1D4C0}",
        lAarr: "\u21DA",
        Lacute: "\u0139",
        lacute: "\u013A",
        laemptyv: "\u29B4",
        lagran: "\u2112",
        Lambda: "\u039B",
        lambda: "\u03BB",
        Lang: "\u27EA",
        lang: "\u27E8",
        langd: "\u2991",
        langle: "\u27E8",
        lap: "\u2A85",
        Laplacetrf: "\u2112",
        laquo: "\xAB",
        Larr: "\u219E",
        lArr: "\u21D0",
        larr: "\u2190",
        larrb: "\u21E4",
        larrbfs: "\u291F",
        larrfs: "\u291D",
        larrhk: "\u21A9",
        larrlp: "\u21AB",
        larrpl: "\u2939",
        larrsim: "\u2973",
        larrtl: "\u21A2",
        lat: "\u2AAB",
        lAtail: "\u291B",
        latail: "\u2919",
        late: "\u2AAD",
        lates: "\u2AAD\uFE00",
        lBarr: "\u290E",
        lbarr: "\u290C",
        lbbrk: "\u2772",
        lbrace: "{",
        lbrack: "[",
        lbrke: "\u298B",
        lbrksld: "\u298F",
        lbrkslu: "\u298D",
        Lcaron: "\u013D",
        lcaron: "\u013E",
        Lcedil: "\u013B",
        lcedil: "\u013C",
        lceil: "\u2308",
        lcub: "{",
        Lcy: "\u041B",
        lcy: "\u043B",
        ldca: "\u2936",
        ldquo: "\u201C",
        ldquor: "\u201E",
        ldrdhar: "\u2967",
        ldrushar: "\u294B",
        ldsh: "\u21B2",
        lE: "\u2266",
        le: "\u2264",
        LeftAngleBracket: "\u27E8",
        LeftArrow: "\u2190",
        Leftarrow: "\u21D0",
        leftarrow: "\u2190",
        LeftArrowBar: "\u21E4",
        LeftArrowRightArrow: "\u21C6",
        leftarrowtail: "\u21A2",
        LeftCeiling: "\u2308",
        LeftDoubleBracket: "\u27E6",
        LeftDownTeeVector: "\u2961",
        LeftDownVector: "\u21C3",
        LeftDownVectorBar: "\u2959",
        LeftFloor: "\u230A",
        leftharpoondown: "\u21BD",
        leftharpoonup: "\u21BC",
        leftleftarrows: "\u21C7",
        LeftRightArrow: "\u2194",
        Leftrightarrow: "\u21D4",
        leftrightarrow: "\u2194",
        leftrightarrows: "\u21C6",
        leftrightharpoons: "\u21CB",
        leftrightsquigarrow: "\u21AD",
        LeftRightVector: "\u294E",
        LeftTee: "\u22A3",
        LeftTeeArrow: "\u21A4",
        LeftTeeVector: "\u295A",
        leftthreetimes: "\u22CB",
        LeftTriangle: "\u22B2",
        LeftTriangleBar: "\u29CF",
        LeftTriangleEqual: "\u22B4",
        LeftUpDownVector: "\u2951",
        LeftUpTeeVector: "\u2960",
        LeftUpVector: "\u21BF",
        LeftUpVectorBar: "\u2958",
        LeftVector: "\u21BC",
        LeftVectorBar: "\u2952",
        lEg: "\u2A8B",
        leg: "\u22DA",
        leq: "\u2264",
        leqq: "\u2266",
        leqslant: "\u2A7D",
        les: "\u2A7D",
        lescc: "\u2AA8",
        lesdot: "\u2A7F",
        lesdoto: "\u2A81",
        lesdotor: "\u2A83",
        lesg: "\u22DA\uFE00",
        lesges: "\u2A93",
        lessapprox: "\u2A85",
        lessdot: "\u22D6",
        lesseqgtr: "\u22DA",
        lesseqqgtr: "\u2A8B",
        LessEqualGreater: "\u22DA",
        LessFullEqual: "\u2266",
        LessGreater: "\u2276",
        lessgtr: "\u2276",
        LessLess: "\u2AA1",
        lesssim: "\u2272",
        LessSlantEqual: "\u2A7D",
        LessTilde: "\u2272",
        lfisht: "\u297C",
        lfloor: "\u230A",
        Lfr: "\u{1D50F}",
        lfr: "\u{1D529}",
        lg: "\u2276",
        lgE: "\u2A91",
        lHar: "\u2962",
        lhard: "\u21BD",
        lharu: "\u21BC",
        lharul: "\u296A",
        lhblk: "\u2584",
        LJcy: "\u0409",
        ljcy: "\u0459",
        Ll: "\u22D8",
        ll: "\u226A",
        llarr: "\u21C7",
        llcorner: "\u231E",
        Lleftarrow: "\u21DA",
        llhard: "\u296B",
        lltri: "\u25FA",
        Lmidot: "\u013F",
        lmidot: "\u0140",
        lmoust: "\u23B0",
        lmoustache: "\u23B0",
        lnap: "\u2A89",
        lnapprox: "\u2A89",
        lnE: "\u2268",
        lne: "\u2A87",
        lneq: "\u2A87",
        lneqq: "\u2268",
        lnsim: "\u22E6",
        loang: "\u27EC",
        loarr: "\u21FD",
        lobrk: "\u27E6",
        LongLeftArrow: "\u27F5",
        Longleftarrow: "\u27F8",
        longleftarrow: "\u27F5",
        LongLeftRightArrow: "\u27F7",
        Longleftrightarrow: "\u27FA",
        longleftrightarrow: "\u27F7",
        longmapsto: "\u27FC",
        LongRightArrow: "\u27F6",
        Longrightarrow: "\u27F9",
        longrightarrow: "\u27F6",
        looparrowleft: "\u21AB",
        looparrowright: "\u21AC",
        lopar: "\u2985",
        Lopf: "\u{1D543}",
        lopf: "\u{1D55D}",
        loplus: "\u2A2D",
        lotimes: "\u2A34",
        lowast: "\u2217",
        lowbar: "_",
        LowerLeftArrow: "\u2199",
        LowerRightArrow: "\u2198",
        loz: "\u25CA",
        lozenge: "\u25CA",
        lozf: "\u29EB",
        lpar: "(",
        lparlt: "\u2993",
        lrarr: "\u21C6",
        lrcorner: "\u231F",
        lrhar: "\u21CB",
        lrhard: "\u296D",
        lrm: "\u200E",
        lrtri: "\u22BF",
        lsaquo: "\u2039",
        Lscr: "\u2112",
        lscr: "\u{1D4C1}",
        Lsh: "\u21B0",
        lsh: "\u21B0",
        lsim: "\u2272",
        lsime: "\u2A8D",
        lsimg: "\u2A8F",
        lsqb: "[",
        lsquo: "\u2018",
        lsquor: "\u201A",
        Lstrok: "\u0141",
        lstrok: "\u0142",
        Lt: "\u226A",
        LT: "<",
        lt: "<",
        ltcc: "\u2AA6",
        ltcir: "\u2A79",
        ltdot: "\u22D6",
        lthree: "\u22CB",
        ltimes: "\u22C9",
        ltlarr: "\u2976",
        ltquest: "\u2A7B",
        ltri: "\u25C3",
        ltrie: "\u22B4",
        ltrif: "\u25C2",
        ltrPar: "\u2996",
        lurdshar: "\u294A",
        luruhar: "\u2966",
        lvertneqq: "\u2268\uFE00",
        lvnE: "\u2268\uFE00",
        macr: "\xAF",
        male: "\u2642",
        malt: "\u2720",
        maltese: "\u2720",
        Map: "\u2905",
        map: "\u21A6",
        mapsto: "\u21A6",
        mapstodown: "\u21A7",
        mapstoleft: "\u21A4",
        mapstoup: "\u21A5",
        marker: "\u25AE",
        mcomma: "\u2A29",
        Mcy: "\u041C",
        mcy: "\u043C",
        mdash: "\u2014",
        mDDot: "\u223A",
        measuredangle: "\u2221",
        MediumSpace: "\u205F",
        Mellintrf: "\u2133",
        Mfr: "\u{1D510}",
        mfr: "\u{1D52A}",
        mho: "\u2127",
        micro: "\xB5",
        mid: "\u2223",
        midast: "*",
        midcir: "\u2AF0",
        middot: "\xB7",
        minus: "\u2212",
        minusb: "\u229F",
        minusd: "\u2238",
        minusdu: "\u2A2A",
        MinusPlus: "\u2213",
        mlcp: "\u2ADB",
        mldr: "\u2026",
        mnplus: "\u2213",
        models: "\u22A7",
        Mopf: "\u{1D544}",
        mopf: "\u{1D55E}",
        mp: "\u2213",
        Mscr: "\u2133",
        mscr: "\u{1D4C2}",
        mstpos: "\u223E",
        Mu: "\u039C",
        mu: "\u03BC",
        multimap: "\u22B8",
        mumap: "\u22B8",
        nabla: "\u2207",
        Nacute: "\u0143",
        nacute: "\u0144",
        nang: "\u2220\u20D2",
        nap: "\u2249",
        napE: "\u2A70\u0338",
        napid: "\u224B\u0338",
        napos: "\u0149",
        napprox: "\u2249",
        natur: "\u266E",
        natural: "\u266E",
        naturals: "\u2115",
        nbsp: "\xA0",
        nbump: "\u224E\u0338",
        nbumpe: "\u224F\u0338",
        ncap: "\u2A43",
        Ncaron: "\u0147",
        ncaron: "\u0148",
        Ncedil: "\u0145",
        ncedil: "\u0146",
        ncong: "\u2247",
        ncongdot: "\u2A6D\u0338",
        ncup: "\u2A42",
        Ncy: "\u041D",
        ncy: "\u043D",
        ndash: "\u2013",
        ne: "\u2260",
        nearhk: "\u2924",
        neArr: "\u21D7",
        nearr: "\u2197",
        nearrow: "\u2197",
        nedot: "\u2250\u0338",
        NegativeMediumSpace: "\u200B",
        NegativeThickSpace: "\u200B",
        NegativeThinSpace: "\u200B",
        NegativeVeryThinSpace: "\u200B",
        nequiv: "\u2262",
        nesear: "\u2928",
        nesim: "\u2242\u0338",
        NestedGreaterGreater: "\u226B",
        NestedLessLess: "\u226A",
        NewLine: "\n",
        nexist: "\u2204",
        nexists: "\u2204",
        Nfr: "\u{1D511}",
        nfr: "\u{1D52B}",
        ngE: "\u2267\u0338",
        nge: "\u2271",
        ngeq: "\u2271",
        ngeqq: "\u2267\u0338",
        ngeqslant: "\u2A7E\u0338",
        nges: "\u2A7E\u0338",
        nGg: "\u22D9\u0338",
        ngsim: "\u2275",
        nGt: "\u226B\u20D2",
        ngt: "\u226F",
        ngtr: "\u226F",
        nGtv: "\u226B\u0338",
        nhArr: "\u21CE",
        nharr: "\u21AE",
        nhpar: "\u2AF2",
        ni: "\u220B",
        nis: "\u22FC",
        nisd: "\u22FA",
        niv: "\u220B",
        NJcy: "\u040A",
        njcy: "\u045A",
        nlArr: "\u21CD",
        nlarr: "\u219A",
        nldr: "\u2025",
        nlE: "\u2266\u0338",
        nle: "\u2270",
        nLeftarrow: "\u21CD",
        nleftarrow: "\u219A",
        nLeftrightarrow: "\u21CE",
        nleftrightarrow: "\u21AE",
        nleq: "\u2270",
        nleqq: "\u2266\u0338",
        nleqslant: "\u2A7D\u0338",
        nles: "\u2A7D\u0338",
        nless: "\u226E",
        nLl: "\u22D8\u0338",
        nlsim: "\u2274",
        nLt: "\u226A\u20D2",
        nlt: "\u226E",
        nltri: "\u22EA",
        nltrie: "\u22EC",
        nLtv: "\u226A\u0338",
        nmid: "\u2224",
        NoBreak: "\u2060",
        NonBreakingSpace: "\xA0",
        Nopf: "\u2115",
        nopf: "\u{1D55F}",
        Not: "\u2AEC",
        not: "\xAC",
        NotCongruent: "\u2262",
        NotCupCap: "\u226D",
        NotDoubleVerticalBar: "\u2226",
        NotElement: "\u2209",
        NotEqual: "\u2260",
        NotEqualTilde: "\u2242\u0338",
        NotExists: "\u2204",
        NotGreater: "\u226F",
        NotGreaterEqual: "\u2271",
        NotGreaterFullEqual: "\u2267\u0338",
        NotGreaterGreater: "\u226B\u0338",
        NotGreaterLess: "\u2279",
        NotGreaterSlantEqual: "\u2A7E\u0338",
        NotGreaterTilde: "\u2275",
        NotHumpDownHump: "\u224E\u0338",
        NotHumpEqual: "\u224F\u0338",
        notin: "\u2209",
        notindot: "\u22F5\u0338",
        notinE: "\u22F9\u0338",
        notinva: "\u2209",
        notinvb: "\u22F7",
        notinvc: "\u22F6",
        NotLeftTriangle: "\u22EA",
        NotLeftTriangleBar: "\u29CF\u0338",
        NotLeftTriangleEqual: "\u22EC",
        NotLess: "\u226E",
        NotLessEqual: "\u2270",
        NotLessGreater: "\u2278",
        NotLessLess: "\u226A\u0338",
        NotLessSlantEqual: "\u2A7D\u0338",
        NotLessTilde: "\u2274",
        NotNestedGreaterGreater: "\u2AA2\u0338",
        NotNestedLessLess: "\u2AA1\u0338",
        notni: "\u220C",
        notniva: "\u220C",
        notnivb: "\u22FE",
        notnivc: "\u22FD",
        NotPrecedes: "\u2280",
        NotPrecedesEqual: "\u2AAF\u0338",
        NotPrecedesSlantEqual: "\u22E0",
        NotReverseElement: "\u220C",
        NotRightTriangle: "\u22EB",
        NotRightTriangleBar: "\u29D0\u0338",
        NotRightTriangleEqual: "\u22ED",
        NotSquareSubset: "\u228F\u0338",
        NotSquareSubsetEqual: "\u22E2",
        NotSquareSuperset: "\u2290\u0338",
        NotSquareSupersetEqual: "\u22E3",
        NotSubset: "\u2282\u20D2",
        NotSubsetEqual: "\u2288",
        NotSucceeds: "\u2281",
        NotSucceedsEqual: "\u2AB0\u0338",
        NotSucceedsSlantEqual: "\u22E1",
        NotSucceedsTilde: "\u227F\u0338",
        NotSuperset: "\u2283\u20D2",
        NotSupersetEqual: "\u2289",
        NotTilde: "\u2241",
        NotTildeEqual: "\u2244",
        NotTildeFullEqual: "\u2247",
        NotTildeTilde: "\u2249",
        NotVerticalBar: "\u2224",
        npar: "\u2226",
        nparallel: "\u2226",
        nparsl: "\u2AFD\u20E5",
        npart: "\u2202\u0338",
        npolint: "\u2A14",
        npr: "\u2280",
        nprcue: "\u22E0",
        npre: "\u2AAF\u0338",
        nprec: "\u2280",
        npreceq: "\u2AAF\u0338",
        nrArr: "\u21CF",
        nrarr: "\u219B",
        nrarrc: "\u2933\u0338",
        nrarrw: "\u219D\u0338",
        nRightarrow: "\u21CF",
        nrightarrow: "\u219B",
        nrtri: "\u22EB",
        nrtrie: "\u22ED",
        nsc: "\u2281",
        nsccue: "\u22E1",
        nsce: "\u2AB0\u0338",
        Nscr: "\u{1D4A9}",
        nscr: "\u{1D4C3}",
        nshortmid: "\u2224",
        nshortparallel: "\u2226",
        nsim: "\u2241",
        nsime: "\u2244",
        nsimeq: "\u2244",
        nsmid: "\u2224",
        nspar: "\u2226",
        nsqsube: "\u22E2",
        nsqsupe: "\u22E3",
        nsub: "\u2284",
        nsubE: "\u2AC5\u0338",
        nsube: "\u2288",
        nsubset: "\u2282\u20D2",
        nsubseteq: "\u2288",
        nsubseteqq: "\u2AC5\u0338",
        nsucc: "\u2281",
        nsucceq: "\u2AB0\u0338",
        nsup: "\u2285",
        nsupE: "\u2AC6\u0338",
        nsupe: "\u2289",
        nsupset: "\u2283\u20D2",
        nsupseteq: "\u2289",
        nsupseteqq: "\u2AC6\u0338",
        ntgl: "\u2279",
        Ntilde: "\xD1",
        ntilde: "\xF1",
        ntlg: "\u2278",
        ntriangleleft: "\u22EA",
        ntrianglelefteq: "\u22EC",
        ntriangleright: "\u22EB",
        ntrianglerighteq: "\u22ED",
        Nu: "\u039D",
        nu: "\u03BD",
        num: "#",
        numero: "\u2116",
        numsp: "\u2007",
        nvap: "\u224D\u20D2",
        nVDash: "\u22AF",
        nVdash: "\u22AE",
        nvDash: "\u22AD",
        nvdash: "\u22AC",
        nvge: "\u2265\u20D2",
        nvgt: ">\u20D2",
        nvHarr: "\u2904",
        nvinfin: "\u29DE",
        nvlArr: "\u2902",
        nvle: "\u2264\u20D2",
        nvlt: "<\u20D2",
        nvltrie: "\u22B4\u20D2",
        nvrArr: "\u2903",
        nvrtrie: "\u22B5\u20D2",
        nvsim: "\u223C\u20D2",
        nwarhk: "\u2923",
        nwArr: "\u21D6",
        nwarr: "\u2196",
        nwarrow: "\u2196",
        nwnear: "\u2927",
        Oacute: "\xD3",
        oacute: "\xF3",
        oast: "\u229B",
        ocir: "\u229A",
        Ocirc: "\xD4",
        ocirc: "\xF4",
        Ocy: "\u041E",
        ocy: "\u043E",
        odash: "\u229D",
        Odblac: "\u0150",
        odblac: "\u0151",
        odiv: "\u2A38",
        odot: "\u2299",
        odsold: "\u29BC",
        OElig: "\u0152",
        oelig: "\u0153",
        ofcir: "\u29BF",
        Ofr: "\u{1D512}",
        ofr: "\u{1D52C}",
        ogon: "\u02DB",
        Ograve: "\xD2",
        ograve: "\xF2",
        ogt: "\u29C1",
        ohbar: "\u29B5",
        ohm: "\u03A9",
        oint: "\u222E",
        olarr: "\u21BA",
        olcir: "\u29BE",
        olcross: "\u29BB",
        oline: "\u203E",
        olt: "\u29C0",
        Omacr: "\u014C",
        omacr: "\u014D",
        Omega: "\u03A9",
        omega: "\u03C9",
        Omicron: "\u039F",
        omicron: "\u03BF",
        omid: "\u29B6",
        ominus: "\u2296",
        Oopf: "\u{1D546}",
        oopf: "\u{1D560}",
        opar: "\u29B7",
        OpenCurlyDoubleQuote: "\u201C",
        OpenCurlyQuote: "\u2018",
        operp: "\u29B9",
        oplus: "\u2295",
        Or: "\u2A54",
        or: "\u2228",
        orarr: "\u21BB",
        ord: "\u2A5D",
        order: "\u2134",
        orderof: "\u2134",
        ordf: "\xAA",
        ordm: "\xBA",
        origof: "\u22B6",
        oror: "\u2A56",
        orslope: "\u2A57",
        orv: "\u2A5B",
        oS: "\u24C8",
        Oscr: "\u{1D4AA}",
        oscr: "\u2134",
        Oslash: "\xD8",
        oslash: "\xF8",
        osol: "\u2298",
        Otilde: "\xD5",
        otilde: "\xF5",
        Otimes: "\u2A37",
        otimes: "\u2297",
        otimesas: "\u2A36",
        Ouml: "\xD6",
        ouml: "\xF6",
        ovbar: "\u233D",
        OverBar: "\u203E",
        OverBrace: "\u23DE",
        OverBracket: "\u23B4",
        OverParenthesis: "\u23DC",
        par: "\u2225",
        para: "\xB6",
        parallel: "\u2225",
        parsim: "\u2AF3",
        parsl: "\u2AFD",
        part: "\u2202",
        PartialD: "\u2202",
        Pcy: "\u041F",
        pcy: "\u043F",
        percnt: "%",
        period: ".",
        permil: "\u2030",
        perp: "\u22A5",
        pertenk: "\u2031",
        Pfr: "\u{1D513}",
        pfr: "\u{1D52D}",
        Phi: "\u03A6",
        phi: "\u03C6",
        phiv: "\u03D5",
        phmmat: "\u2133",
        phone: "\u260E",
        Pi: "\u03A0",
        pi: "\u03C0",
        pitchfork: "\u22D4",
        piv: "\u03D6",
        planck: "\u210F",
        planckh: "\u210E",
        plankv: "\u210F",
        plus: "+",
        plusacir: "\u2A23",
        plusb: "\u229E",
        pluscir: "\u2A22",
        plusdo: "\u2214",
        plusdu: "\u2A25",
        pluse: "\u2A72",
        PlusMinus: "\xB1",
        plusmn: "\xB1",
        plussim: "\u2A26",
        plustwo: "\u2A27",
        pm: "\xB1",
        Poincareplane: "\u210C",
        pointint: "\u2A15",
        Popf: "\u2119",
        popf: "\u{1D561}",
        pound: "\xA3",
        Pr: "\u2ABB",
        pr: "\u227A",
        prap: "\u2AB7",
        prcue: "\u227C",
        prE: "\u2AB3",
        pre: "\u2AAF",
        prec: "\u227A",
        precapprox: "\u2AB7",
        preccurlyeq: "\u227C",
        Precedes: "\u227A",
        PrecedesEqual: "\u2AAF",
        PrecedesSlantEqual: "\u227C",
        PrecedesTilde: "\u227E",
        preceq: "\u2AAF",
        precnapprox: "\u2AB9",
        precneqq: "\u2AB5",
        precnsim: "\u22E8",
        precsim: "\u227E",
        Prime: "\u2033",
        prime: "\u2032",
        primes: "\u2119",
        prnap: "\u2AB9",
        prnE: "\u2AB5",
        prnsim: "\u22E8",
        prod: "\u220F",
        Product: "\u220F",
        profalar: "\u232E",
        profline: "\u2312",
        profsurf: "\u2313",
        prop: "\u221D",
        Proportion: "\u2237",
        Proportional: "\u221D",
        propto: "\u221D",
        prsim: "\u227E",
        prurel: "\u22B0",
        Pscr: "\u{1D4AB}",
        pscr: "\u{1D4C5}",
        Psi: "\u03A8",
        psi: "\u03C8",
        puncsp: "\u2008",
        Qfr: "\u{1D514}",
        qfr: "\u{1D52E}",
        qint: "\u2A0C",
        Qopf: "\u211A",
        qopf: "\u{1D562}",
        qprime: "\u2057",
        Qscr: "\u{1D4AC}",
        qscr: "\u{1D4C6}",
        quaternions: "\u210D",
        quatint: "\u2A16",
        quest: "?",
        questeq: "\u225F",
        QUOT: '"',
        quot: '"',
        rAarr: "\u21DB",
        race: "\u223D\u0331",
        Racute: "\u0154",
        racute: "\u0155",
        radic: "\u221A",
        raemptyv: "\u29B3",
        Rang: "\u27EB",
        rang: "\u27E9",
        rangd: "\u2992",
        range: "\u29A5",
        rangle: "\u27E9",
        raquo: "\xBB",
        Rarr: "\u21A0",
        rArr: "\u21D2",
        rarr: "\u2192",
        rarrap: "\u2975",
        rarrb: "\u21E5",
        rarrbfs: "\u2920",
        rarrc: "\u2933",
        rarrfs: "\u291E",
        rarrhk: "\u21AA",
        rarrlp: "\u21AC",
        rarrpl: "\u2945",
        rarrsim: "\u2974",
        Rarrtl: "\u2916",
        rarrtl: "\u21A3",
        rarrw: "\u219D",
        rAtail: "\u291C",
        ratail: "\u291A",
        ratio: "\u2236",
        rationals: "\u211A",
        RBarr: "\u2910",
        rBarr: "\u290F",
        rbarr: "\u290D",
        rbbrk: "\u2773",
        rbrace: "}",
        rbrack: "]",
        rbrke: "\u298C",
        rbrksld: "\u298E",
        rbrkslu: "\u2990",
        Rcaron: "\u0158",
        rcaron: "\u0159",
        Rcedil: "\u0156",
        rcedil: "\u0157",
        rceil: "\u2309",
        rcub: "}",
        Rcy: "\u0420",
        rcy: "\u0440",
        rdca: "\u2937",
        rdldhar: "\u2969",
        rdquo: "\u201D",
        rdquor: "\u201D",
        rdsh: "\u21B3",
        Re: "\u211C",
        real: "\u211C",
        realine: "\u211B",
        realpart: "\u211C",
        reals: "\u211D",
        rect: "\u25AD",
        REG: "\xAE",
        reg: "\xAE",
        ReverseElement: "\u220B",
        ReverseEquilibrium: "\u21CB",
        ReverseUpEquilibrium: "\u296F",
        rfisht: "\u297D",
        rfloor: "\u230B",
        Rfr: "\u211C",
        rfr: "\u{1D52F}",
        rHar: "\u2964",
        rhard: "\u21C1",
        rharu: "\u21C0",
        rharul: "\u296C",
        Rho: "\u03A1",
        rho: "\u03C1",
        rhov: "\u03F1",
        RightAngleBracket: "\u27E9",
        RightArrow: "\u2192",
        Rightarrow: "\u21D2",
        rightarrow: "\u2192",
        RightArrowBar: "\u21E5",
        RightArrowLeftArrow: "\u21C4",
        rightarrowtail: "\u21A3",
        RightCeiling: "\u2309",
        RightDoubleBracket: "\u27E7",
        RightDownTeeVector: "\u295D",
        RightDownVector: "\u21C2",
        RightDownVectorBar: "\u2955",
        RightFloor: "\u230B",
        rightharpoondown: "\u21C1",
        rightharpoonup: "\u21C0",
        rightleftarrows: "\u21C4",
        rightleftharpoons: "\u21CC",
        rightrightarrows: "\u21C9",
        rightsquigarrow: "\u219D",
        RightTee: "\u22A2",
        RightTeeArrow: "\u21A6",
        RightTeeVector: "\u295B",
        rightthreetimes: "\u22CC",
        RightTriangle: "\u22B3",
        RightTriangleBar: "\u29D0",
        RightTriangleEqual: "\u22B5",
        RightUpDownVector: "\u294F",
        RightUpTeeVector: "\u295C",
        RightUpVector: "\u21BE",
        RightUpVectorBar: "\u2954",
        RightVector: "\u21C0",
        RightVectorBar: "\u2953",
        ring: "\u02DA",
        risingdotseq: "\u2253",
        rlarr: "\u21C4",
        rlhar: "\u21CC",
        rlm: "\u200F",
        rmoust: "\u23B1",
        rmoustache: "\u23B1",
        rnmid: "\u2AEE",
        roang: "\u27ED",
        roarr: "\u21FE",
        robrk: "\u27E7",
        ropar: "\u2986",
        Ropf: "\u211D",
        ropf: "\u{1D563}",
        roplus: "\u2A2E",
        rotimes: "\u2A35",
        RoundImplies: "\u2970",
        rpar: ")",
        rpargt: "\u2994",
        rppolint: "\u2A12",
        rrarr: "\u21C9",
        Rrightarrow: "\u21DB",
        rsaquo: "\u203A",
        Rscr: "\u211B",
        rscr: "\u{1D4C7}",
        Rsh: "\u21B1",
        rsh: "\u21B1",
        rsqb: "]",
        rsquo: "\u2019",
        rsquor: "\u2019",
        rthree: "\u22CC",
        rtimes: "\u22CA",
        rtri: "\u25B9",
        rtrie: "\u22B5",
        rtrif: "\u25B8",
        rtriltri: "\u29CE",
        RuleDelayed: "\u29F4",
        ruluhar: "\u2968",
        rx: "\u211E",
        Sacute: "\u015A",
        sacute: "\u015B",
        sbquo: "\u201A",
        Sc: "\u2ABC",
        sc: "\u227B",
        scap: "\u2AB8",
        Scaron: "\u0160",
        scaron: "\u0161",
        sccue: "\u227D",
        scE: "\u2AB4",
        sce: "\u2AB0",
        Scedil: "\u015E",
        scedil: "\u015F",
        Scirc: "\u015C",
        scirc: "\u015D",
        scnap: "\u2ABA",
        scnE: "\u2AB6",
        scnsim: "\u22E9",
        scpolint: "\u2A13",
        scsim: "\u227F",
        Scy: "\u0421",
        scy: "\u0441",
        sdot: "\u22C5",
        sdotb: "\u22A1",
        sdote: "\u2A66",
        searhk: "\u2925",
        seArr: "\u21D8",
        searr: "\u2198",
        searrow: "\u2198",
        sect: "\xA7",
        semi: ";",
        seswar: "\u2929",
        setminus: "\u2216",
        setmn: "\u2216",
        sext: "\u2736",
        Sfr: "\u{1D516}",
        sfr: "\u{1D530}",
        sfrown: "\u2322",
        sharp: "\u266F",
        SHCHcy: "\u0429",
        shchcy: "\u0449",
        SHcy: "\u0428",
        shcy: "\u0448",
        ShortDownArrow: "\u2193",
        ShortLeftArrow: "\u2190",
        shortmid: "\u2223",
        shortparallel: "\u2225",
        ShortRightArrow: "\u2192",
        ShortUpArrow: "\u2191",
        shy: "\xAD",
        Sigma: "\u03A3",
        sigma: "\u03C3",
        sigmaf: "\u03C2",
        sigmav: "\u03C2",
        sim: "\u223C",
        simdot: "\u2A6A",
        sime: "\u2243",
        simeq: "\u2243",
        simg: "\u2A9E",
        simgE: "\u2AA0",
        siml: "\u2A9D",
        simlE: "\u2A9F",
        simne: "\u2246",
        simplus: "\u2A24",
        simrarr: "\u2972",
        slarr: "\u2190",
        SmallCircle: "\u2218",
        smallsetminus: "\u2216",
        smashp: "\u2A33",
        smeparsl: "\u29E4",
        smid: "\u2223",
        smile: "\u2323",
        smt: "\u2AAA",
        smte: "\u2AAC",
        smtes: "\u2AAC\uFE00",
        SOFTcy: "\u042C",
        softcy: "\u044C",
        sol: "/",
        solb: "\u29C4",
        solbar: "\u233F",
        Sopf: "\u{1D54A}",
        sopf: "\u{1D564}",
        spades: "\u2660",
        spadesuit: "\u2660",
        spar: "\u2225",
        sqcap: "\u2293",
        sqcaps: "\u2293\uFE00",
        sqcup: "\u2294",
        sqcups: "\u2294\uFE00",
        Sqrt: "\u221A",
        sqsub: "\u228F",
        sqsube: "\u2291",
        sqsubset: "\u228F",
        sqsubseteq: "\u2291",
        sqsup: "\u2290",
        sqsupe: "\u2292",
        sqsupset: "\u2290",
        sqsupseteq: "\u2292",
        squ: "\u25A1",
        Square: "\u25A1",
        square: "\u25A1",
        SquareIntersection: "\u2293",
        SquareSubset: "\u228F",
        SquareSubsetEqual: "\u2291",
        SquareSuperset: "\u2290",
        SquareSupersetEqual: "\u2292",
        SquareUnion: "\u2294",
        squarf: "\u25AA",
        squf: "\u25AA",
        srarr: "\u2192",
        Sscr: "\u{1D4AE}",
        sscr: "\u{1D4C8}",
        ssetmn: "\u2216",
        ssmile: "\u2323",
        sstarf: "\u22C6",
        Star: "\u22C6",
        star: "\u2606",
        starf: "\u2605",
        straightepsilon: "\u03F5",
        straightphi: "\u03D5",
        strns: "\xAF",
        Sub: "\u22D0",
        sub: "\u2282",
        subdot: "\u2ABD",
        subE: "\u2AC5",
        sube: "\u2286",
        subedot: "\u2AC3",
        submult: "\u2AC1",
        subnE: "\u2ACB",
        subne: "\u228A",
        subplus: "\u2ABF",
        subrarr: "\u2979",
        Subset: "\u22D0",
        subset: "\u2282",
        subseteq: "\u2286",
        subseteqq: "\u2AC5",
        SubsetEqual: "\u2286",
        subsetneq: "\u228A",
        subsetneqq: "\u2ACB",
        subsim: "\u2AC7",
        subsub: "\u2AD5",
        subsup: "\u2AD3",
        succ: "\u227B",
        succapprox: "\u2AB8",
        succcurlyeq: "\u227D",
        Succeeds: "\u227B",
        SucceedsEqual: "\u2AB0",
        SucceedsSlantEqual: "\u227D",
        SucceedsTilde: "\u227F",
        succeq: "\u2AB0",
        succnapprox: "\u2ABA",
        succneqq: "\u2AB6",
        succnsim: "\u22E9",
        succsim: "\u227F",
        SuchThat: "\u220B",
        Sum: "\u2211",
        sum: "\u2211",
        sung: "\u266A",
        Sup: "\u22D1",
        sup: "\u2283",
        sup1: "\xB9",
        sup2: "\xB2",
        sup3: "\xB3",
        supdot: "\u2ABE",
        supdsub: "\u2AD8",
        supE: "\u2AC6",
        supe: "\u2287",
        supedot: "\u2AC4",
        Superset: "\u2283",
        SupersetEqual: "\u2287",
        suphsol: "\u27C9",
        suphsub: "\u2AD7",
        suplarr: "\u297B",
        supmult: "\u2AC2",
        supnE: "\u2ACC",
        supne: "\u228B",
        supplus: "\u2AC0",
        Supset: "\u22D1",
        supset: "\u2283",
        supseteq: "\u2287",
        supseteqq: "\u2AC6",
        supsetneq: "\u228B",
        supsetneqq: "\u2ACC",
        supsim: "\u2AC8",
        supsub: "\u2AD4",
        supsup: "\u2AD6",
        swarhk: "\u2926",
        swArr: "\u21D9",
        swarr: "\u2199",
        swarrow: "\u2199",
        swnwar: "\u292A",
        szlig: "\xDF",
        Tab: "	",
        target: "\u2316",
        Tau: "\u03A4",
        tau: "\u03C4",
        tbrk: "\u23B4",
        Tcaron: "\u0164",
        tcaron: "\u0165",
        Tcedil: "\u0162",
        tcedil: "\u0163",
        Tcy: "\u0422",
        tcy: "\u0442",
        tdot: "\u20DB",
        telrec: "\u2315",
        Tfr: "\u{1D517}",
        tfr: "\u{1D531}",
        there4: "\u2234",
        Therefore: "\u2234",
        therefore: "\u2234",
        Theta: "\u0398",
        theta: "\u03B8",
        thetasym: "\u03D1",
        thetav: "\u03D1",
        thickapprox: "\u2248",
        thicksim: "\u223C",
        ThickSpace: "\u205F\u200A",
        thinsp: "\u2009",
        ThinSpace: "\u2009",
        thkap: "\u2248",
        thksim: "\u223C",
        THORN: "\xDE",
        thorn: "\xFE",
        Tilde: "\u223C",
        tilde: "\u02DC",
        TildeEqual: "\u2243",
        TildeFullEqual: "\u2245",
        TildeTilde: "\u2248",
        times: "\xD7",
        timesb: "\u22A0",
        timesbar: "\u2A31",
        timesd: "\u2A30",
        tint: "\u222D",
        toea: "\u2928",
        top: "\u22A4",
        topbot: "\u2336",
        topcir: "\u2AF1",
        Topf: "\u{1D54B}",
        topf: "\u{1D565}",
        topfork: "\u2ADA",
        tosa: "\u2929",
        tprime: "\u2034",
        TRADE: "\u2122",
        trade: "\u2122",
        triangle: "\u25B5",
        triangledown: "\u25BF",
        triangleleft: "\u25C3",
        trianglelefteq: "\u22B4",
        triangleq: "\u225C",
        triangleright: "\u25B9",
        trianglerighteq: "\u22B5",
        tridot: "\u25EC",
        trie: "\u225C",
        triminus: "\u2A3A",
        TripleDot: "\u20DB",
        triplus: "\u2A39",
        trisb: "\u29CD",
        tritime: "\u2A3B",
        trpezium: "\u23E2",
        Tscr: "\u{1D4AF}",
        tscr: "\u{1D4C9}",
        TScy: "\u0426",
        tscy: "\u0446",
        TSHcy: "\u040B",
        tshcy: "\u045B",
        Tstrok: "\u0166",
        tstrok: "\u0167",
        twixt: "\u226C",
        twoheadleftarrow: "\u219E",
        twoheadrightarrow: "\u21A0",
        Uacute: "\xDA",
        uacute: "\xFA",
        Uarr: "\u219F",
        uArr: "\u21D1",
        uarr: "\u2191",
        Uarrocir: "\u2949",
        Ubrcy: "\u040E",
        ubrcy: "\u045E",
        Ubreve: "\u016C",
        ubreve: "\u016D",
        Ucirc: "\xDB",
        ucirc: "\xFB",
        Ucy: "\u0423",
        ucy: "\u0443",
        udarr: "\u21C5",
        Udblac: "\u0170",
        udblac: "\u0171",
        udhar: "\u296E",
        ufisht: "\u297E",
        Ufr: "\u{1D518}",
        ufr: "\u{1D532}",
        Ugrave: "\xD9",
        ugrave: "\xF9",
        uHar: "\u2963",
        uharl: "\u21BF",
        uharr: "\u21BE",
        uhblk: "\u2580",
        ulcorn: "\u231C",
        ulcorner: "\u231C",
        ulcrop: "\u230F",
        ultri: "\u25F8",
        Umacr: "\u016A",
        umacr: "\u016B",
        uml: "\xA8",
        UnderBar: "_",
        UnderBrace: "\u23DF",
        UnderBracket: "\u23B5",
        UnderParenthesis: "\u23DD",
        Union: "\u22C3",
        UnionPlus: "\u228E",
        Uogon: "\u0172",
        uogon: "\u0173",
        Uopf: "\u{1D54C}",
        uopf: "\u{1D566}",
        UpArrow: "\u2191",
        Uparrow: "\u21D1",
        uparrow: "\u2191",
        UpArrowBar: "\u2912",
        UpArrowDownArrow: "\u21C5",
        UpDownArrow: "\u2195",
        Updownarrow: "\u21D5",
        updownarrow: "\u2195",
        UpEquilibrium: "\u296E",
        upharpoonleft: "\u21BF",
        upharpoonright: "\u21BE",
        uplus: "\u228E",
        UpperLeftArrow: "\u2196",
        UpperRightArrow: "\u2197",
        Upsi: "\u03D2",
        upsi: "\u03C5",
        upsih: "\u03D2",
        Upsilon: "\u03A5",
        upsilon: "\u03C5",
        UpTee: "\u22A5",
        UpTeeArrow: "\u21A5",
        upuparrows: "\u21C8",
        urcorn: "\u231D",
        urcorner: "\u231D",
        urcrop: "\u230E",
        Uring: "\u016E",
        uring: "\u016F",
        urtri: "\u25F9",
        Uscr: "\u{1D4B0}",
        uscr: "\u{1D4CA}",
        utdot: "\u22F0",
        Utilde: "\u0168",
        utilde: "\u0169",
        utri: "\u25B5",
        utrif: "\u25B4",
        uuarr: "\u21C8",
        Uuml: "\xDC",
        uuml: "\xFC",
        uwangle: "\u29A7",
        vangrt: "\u299C",
        varepsilon: "\u03F5",
        varkappa: "\u03F0",
        varnothing: "\u2205",
        varphi: "\u03D5",
        varpi: "\u03D6",
        varpropto: "\u221D",
        vArr: "\u21D5",
        varr: "\u2195",
        varrho: "\u03F1",
        varsigma: "\u03C2",
        varsubsetneq: "\u228A\uFE00",
        varsubsetneqq: "\u2ACB\uFE00",
        varsupsetneq: "\u228B\uFE00",
        varsupsetneqq: "\u2ACC\uFE00",
        vartheta: "\u03D1",
        vartriangleleft: "\u22B2",
        vartriangleright: "\u22B3",
        Vbar: "\u2AEB",
        vBar: "\u2AE8",
        vBarv: "\u2AE9",
        Vcy: "\u0412",
        vcy: "\u0432",
        VDash: "\u22AB",
        Vdash: "\u22A9",
        vDash: "\u22A8",
        vdash: "\u22A2",
        Vdashl: "\u2AE6",
        Vee: "\u22C1",
        vee: "\u2228",
        veebar: "\u22BB",
        veeeq: "\u225A",
        vellip: "\u22EE",
        Verbar: "\u2016",
        verbar: "|",
        Vert: "\u2016",
        vert: "|",
        VerticalBar: "\u2223",
        VerticalLine: "|",
        VerticalSeparator: "\u2758",
        VerticalTilde: "\u2240",
        VeryThinSpace: "\u200A",
        Vfr: "\u{1D519}",
        vfr: "\u{1D533}",
        vltri: "\u22B2",
        vnsub: "\u2282\u20D2",
        vnsup: "\u2283\u20D2",
        Vopf: "\u{1D54D}",
        vopf: "\u{1D567}",
        vprop: "\u221D",
        vrtri: "\u22B3",
        Vscr: "\u{1D4B1}",
        vscr: "\u{1D4CB}",
        vsubnE: "\u2ACB\uFE00",
        vsubne: "\u228A\uFE00",
        vsupnE: "\u2ACC\uFE00",
        vsupne: "\u228B\uFE00",
        Vvdash: "\u22AA",
        vzigzag: "\u299A",
        Wcirc: "\u0174",
        wcirc: "\u0175",
        wedbar: "\u2A5F",
        Wedge: "\u22C0",
        wedge: "\u2227",
        wedgeq: "\u2259",
        weierp: "\u2118",
        Wfr: "\u{1D51A}",
        wfr: "\u{1D534}",
        Wopf: "\u{1D54E}",
        wopf: "\u{1D568}",
        wp: "\u2118",
        wr: "\u2240",
        wreath: "\u2240",
        Wscr: "\u{1D4B2}",
        wscr: "\u{1D4CC}",
        xcap: "\u22C2",
        xcirc: "\u25EF",
        xcup: "\u22C3",
        xdtri: "\u25BD",
        Xfr: "\u{1D51B}",
        xfr: "\u{1D535}",
        xhArr: "\u27FA",
        xharr: "\u27F7",
        Xi: "\u039E",
        xi: "\u03BE",
        xlArr: "\u27F8",
        xlarr: "\u27F5",
        xmap: "\u27FC",
        xnis: "\u22FB",
        xodot: "\u2A00",
        Xopf: "\u{1D54F}",
        xopf: "\u{1D569}",
        xoplus: "\u2A01",
        xotime: "\u2A02",
        xrArr: "\u27F9",
        xrarr: "\u27F6",
        Xscr: "\u{1D4B3}",
        xscr: "\u{1D4CD}",
        xsqcup: "\u2A06",
        xuplus: "\u2A04",
        xutri: "\u25B3",
        xvee: "\u22C1",
        xwedge: "\u22C0",
        Yacute: "\xDD",
        yacute: "\xFD",
        YAcy: "\u042F",
        yacy: "\u044F",
        Ycirc: "\u0176",
        ycirc: "\u0177",
        Ycy: "\u042B",
        ycy: "\u044B",
        yen: "\xA5",
        Yfr: "\u{1D51C}",
        yfr: "\u{1D536}",
        YIcy: "\u0407",
        yicy: "\u0457",
        Yopf: "\u{1D550}",
        yopf: "\u{1D56A}",
        Yscr: "\u{1D4B4}",
        yscr: "\u{1D4CE}",
        YUcy: "\u042E",
        yucy: "\u044E",
        Yuml: "\u0178",
        yuml: "\xFF",
        Zacute: "\u0179",
        zacute: "\u017A",
        Zcaron: "\u017D",
        zcaron: "\u017E",
        Zcy: "\u0417",
        zcy: "\u0437",
        Zdot: "\u017B",
        zdot: "\u017C",
        zeetrf: "\u2128",
        ZeroWidthSpace: "\u200B",
        Zeta: "\u0396",
        zeta: "\u03B6",
        Zfr: "\u2128",
        zfr: "\u{1D537}",
        ZHcy: "\u0416",
        zhcy: "\u0436",
        zigrarr: "\u21DD",
        Zopf: "\u2124",
        zopf: "\u{1D56B}",
        Zscr: "\u{1D4B5}",
        zscr: "\u{1D4CF}",
        zwj: "\u200D",
        zwnj: "\u200C"
      });
      exports.entityMap = exports.HTML_ENTITIES;
    }
  });

  // node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/sax.js
  var require_sax = __commonJS({
    "node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/sax.js"(exports) {
      init_shim();
      var NAMESPACE = require_conventions().NAMESPACE;
      var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
      var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
      var S_TAG = 0;
      var S_ATTR = 1;
      var S_ATTR_SPACE = 2;
      var S_EQ = 3;
      var S_ATTR_NOQUOT_VALUE = 4;
      var S_ATTR_END = 5;
      var S_TAG_SPACE = 6;
      var S_TAG_CLOSE = 7;
      function ParseError(message, locator) {
        this.message = message;
        this.locator = locator;
        if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
      }
      ParseError.prototype = new Error();
      ParseError.prototype.name = ParseError.name;
      function XMLReader() {
      }
      XMLReader.prototype = {
        parse: function(source, defaultNSMap, entityMap) {
          var domBuilder = this.domBuilder;
          domBuilder.startDocument();
          _copy(defaultNSMap, defaultNSMap = {});
          parse(
            source,
            defaultNSMap,
            entityMap,
            domBuilder,
            this.errorHandler
          );
          domBuilder.endDocument();
        }
      };
      function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
        function fixedFromCharCode(code) {
          if (code > 65535) {
            code -= 65536;
            var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
            return String.fromCharCode(surrogate1, surrogate2);
          } else {
            return String.fromCharCode(code);
          }
        }
        function entityReplacer(a3) {
          var k = a3.slice(1, -1);
          if (k in entityMap) {
            return entityMap[k];
          } else if (k.charAt(0) === "#") {
            return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
          } else {
            errorHandler.error("entity not found:" + a3);
            return a3;
          }
        }
        function appendText(end2) {
          if (end2 > start) {
            var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
            locator && position(start);
            domBuilder.characters(xt, 0, end2 - start);
            start = end2;
          }
        }
        function position(p2, m) {
          while (p2 >= lineEnd && (m = linePattern.exec(source))) {
            lineStart = m.index;
            lineEnd = lineStart + m[0].length;
            locator.lineNumber++;
          }
          locator.columnNumber = p2 - lineStart + 1;
        }
        var lineStart = 0;
        var lineEnd = 0;
        var linePattern = /.*(?:\r\n?|\n)|.*$/g;
        var locator = domBuilder.locator;
        var parseStack = [{ currentNSMap: defaultNSMapCopy }];
        var closeMap = {};
        var start = 0;
        while (true) {
          try {
            var tagStart = source.indexOf("<", start);
            if (tagStart < 0) {
              if (!source.substr(start).match(/^\s*$/)) {
                var doc = domBuilder.doc;
                var text = doc.createTextNode(source.substr(start));
                doc.appendChild(text);
                domBuilder.currentElement = text;
              }
              return;
            }
            if (tagStart > start) {
              appendText(tagStart);
            }
            switch (source.charAt(tagStart + 1)) {
              case "/":
                var end = source.indexOf(">", tagStart + 3);
                var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
                var config = parseStack.pop();
                if (end < 0) {
                  tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                  errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                  end = tagStart + 1 + tagName.length;
                } else if (tagName.match(/\s</)) {
                  tagName = tagName.replace(/[\s<].*/, "");
                  errorHandler.error("end tag name: " + tagName + " maybe not complete");
                  end = tagStart + 1 + tagName.length;
                }
                var localNSMap = config.localNSMap;
                var endMatch = config.tagName == tagName;
                var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
                if (endIgnoreCaseMach) {
                  domBuilder.endElement(config.uri, config.localName, tagName);
                  if (localNSMap) {
                    for (var prefix in localNSMap) {
                      if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                        domBuilder.endPrefixMapping(prefix);
                      }
                    }
                  }
                  if (!endMatch) {
                    errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                  }
                } else {
                  parseStack.push(config);
                }
                end++;
                break;
              // end elment
              case "?":
                locator && position(tagStart);
                end = parseInstruction(source, tagStart, domBuilder);
                break;
              case "!":
                locator && position(tagStart);
                end = parseDCC(source, tagStart, domBuilder, errorHandler);
                break;
              default:
                locator && position(tagStart);
                var el = new ElementAttributes();
                var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
                var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
                var len = el.length;
                if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                  el.closed = true;
                  if (!entityMap.nbsp) {
                    errorHandler.warning("unclosed xml attribute");
                  }
                }
                if (locator && len) {
                  var locator2 = copyLocator(locator, {});
                  for (var i2 = 0; i2 < len; i2++) {
                    var a2 = el[i2];
                    position(a2.offset);
                    a2.locator = copyLocator(locator, {});
                  }
                  domBuilder.locator = locator2;
                  if (appendElement(el, domBuilder, currentNSMap)) {
                    parseStack.push(el);
                  }
                  domBuilder.locator = locator;
                } else {
                  if (appendElement(el, domBuilder, currentNSMap)) {
                    parseStack.push(el);
                  }
                }
                if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                  end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
                } else {
                  end++;
                }
            }
          } catch (e2) {
            if (e2 instanceof ParseError) {
              throw e2;
            }
            errorHandler.error("element parse error: " + e2);
            end = -1;
          }
          if (end > start) {
            start = end;
          } else {
            appendText(Math.max(tagStart, start) + 1);
          }
        }
      }
      function copyLocator(f2, t2) {
        t2.lineNumber = f2.lineNumber;
        t2.columnNumber = f2.columnNumber;
        return t2;
      }
      function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
        function addAttribute(qname, value2, startIndex) {
          if (el.attributeNames.hasOwnProperty(qname)) {
            errorHandler.fatalError("Attribute " + qname + " redefined");
          }
          el.addValue(qname, value2, startIndex);
        }
        var attrName;
        var value;
        var p2 = ++start;
        var s2 = S_TAG;
        while (true) {
          var c = source.charAt(p2);
          switch (c) {
            case "=":
              if (s2 === S_ATTR) {
                attrName = source.slice(start, p2);
                s2 = S_EQ;
              } else if (s2 === S_ATTR_SPACE) {
                s2 = S_EQ;
              } else {
                throw new Error("attribute equal must after attrName");
              }
              break;
            case "'":
            case '"':
              if (s2 === S_EQ || s2 === S_ATTR) {
                if (s2 === S_ATTR) {
                  errorHandler.warning('attribute value must after "="');
                  attrName = source.slice(start, p2);
                }
                start = p2 + 1;
                p2 = source.indexOf(c, start);
                if (p2 > 0) {
                  value = source.slice(start, p2).replace(/&#?\w+;/g, entityReplacer);
                  addAttribute(attrName, value, start - 1);
                  s2 = S_ATTR_END;
                } else {
                  throw new Error("attribute value no end '" + c + "' match");
                }
              } else if (s2 == S_ATTR_NOQUOT_VALUE) {
                value = source.slice(start, p2).replace(/&#?\w+;/g, entityReplacer);
                addAttribute(attrName, value, start);
                errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
                start = p2 + 1;
                s2 = S_ATTR_END;
              } else {
                throw new Error('attribute value must after "="');
              }
              break;
            case "/":
              switch (s2) {
                case S_TAG:
                  el.setTagName(source.slice(start, p2));
                case S_ATTR_END:
                case S_TAG_SPACE:
                case S_TAG_CLOSE:
                  s2 = S_TAG_CLOSE;
                  el.closed = true;
                case S_ATTR_NOQUOT_VALUE:
                case S_ATTR:
                  break;
                case S_ATTR_SPACE:
                  el.closed = true;
                  break;
                //case S_EQ:
                default:
                  throw new Error("attribute invalid close char('/')");
              }
              break;
            case "":
              errorHandler.error("unexpected end of input");
              if (s2 == S_TAG) {
                el.setTagName(source.slice(start, p2));
              }
              return p2;
            case ">":
              switch (s2) {
                case S_TAG:
                  el.setTagName(source.slice(start, p2));
                case S_ATTR_END:
                case S_TAG_SPACE:
                case S_TAG_CLOSE:
                  break;
                //normal
                case S_ATTR_NOQUOT_VALUE:
                //Compatible state
                case S_ATTR:
                  value = source.slice(start, p2);
                  if (value.slice(-1) === "/") {
                    el.closed = true;
                    value = value.slice(0, -1);
                  }
                case S_ATTR_SPACE:
                  if (s2 === S_ATTR_SPACE) {
                    value = attrName;
                  }
                  if (s2 == S_ATTR_NOQUOT_VALUE) {
                    errorHandler.warning('attribute "' + value + '" missed quot(")!');
                    addAttribute(attrName, value.replace(/&#?\w+;/g, entityReplacer), start);
                  } else {
                    if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                      errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                    }
                    addAttribute(value, value, start);
                  }
                  break;
                case S_EQ:
                  throw new Error("attribute value missed!!");
              }
              return p2;
            /*xml space '\x20' | #x9 | #xD | #xA; */
            case "\x80":
              c = " ";
            default:
              if (c <= " ") {
                switch (s2) {
                  case S_TAG:
                    el.setTagName(source.slice(start, p2));
                    s2 = S_TAG_SPACE;
                    break;
                  case S_ATTR:
                    attrName = source.slice(start, p2);
                    s2 = S_ATTR_SPACE;
                    break;
                  case S_ATTR_NOQUOT_VALUE:
                    var value = source.slice(start, p2).replace(/&#?\w+;/g, entityReplacer);
                    errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                    addAttribute(attrName, value, start);
                  case S_ATTR_END:
                    s2 = S_TAG_SPACE;
                    break;
                }
              } else {
                switch (s2) {
                  //case S_TAG:void();break;
                  //case S_ATTR:void();break;
                  //case S_ATTR_NOQUOT_VALUE:void();break;
                  case S_ATTR_SPACE:
                    var tagName = el.tagName;
                    if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                      errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                    }
                    addAttribute(attrName, attrName, start);
                    start = p2;
                    s2 = S_ATTR;
                    break;
                  case S_ATTR_END:
                    errorHandler.warning('attribute space is required"' + attrName + '"!!');
                  case S_TAG_SPACE:
                    s2 = S_ATTR;
                    start = p2;
                    break;
                  case S_EQ:
                    s2 = S_ATTR_NOQUOT_VALUE;
                    start = p2;
                    break;
                  case S_TAG_CLOSE:
                    throw new Error("elements closed character '/' and '>' must be connected to");
                }
              }
          }
          p2++;
        }
      }
      function appendElement(el, domBuilder, currentNSMap) {
        var tagName = el.tagName;
        var localNSMap = null;
        var i2 = el.length;
        while (i2--) {
          var a2 = el[i2];
          var qName = a2.qName;
          var value = a2.value;
          var nsp = qName.indexOf(":");
          if (nsp > 0) {
            var prefix = a2.prefix = qName.slice(0, nsp);
            var localName = qName.slice(nsp + 1);
            var nsPrefix = prefix === "xmlns" && localName;
          } else {
            localName = qName;
            prefix = null;
            nsPrefix = qName === "xmlns" && "";
          }
          a2.localName = localName;
          if (nsPrefix !== false) {
            if (localNSMap == null) {
              localNSMap = {};
              _copy(currentNSMap, currentNSMap = {});
            }
            currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
            a2.uri = NAMESPACE.XMLNS;
            domBuilder.startPrefixMapping(nsPrefix, value);
          }
        }
        var i2 = el.length;
        while (i2--) {
          a2 = el[i2];
          var prefix = a2.prefix;
          if (prefix) {
            if (prefix === "xml") {
              a2.uri = NAMESPACE.XML;
            }
            if (prefix !== "xmlns") {
              a2.uri = currentNSMap[prefix || ""];
            }
          }
        }
        var nsp = tagName.indexOf(":");
        if (nsp > 0) {
          prefix = el.prefix = tagName.slice(0, nsp);
          localName = el.localName = tagName.slice(nsp + 1);
        } else {
          prefix = null;
          localName = el.localName = tagName;
        }
        var ns = el.uri = currentNSMap[prefix || ""];
        domBuilder.startElement(ns, localName, tagName, el);
        if (el.closed) {
          domBuilder.endElement(ns, localName, tagName);
          if (localNSMap) {
            for (prefix in localNSMap) {
              if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                domBuilder.endPrefixMapping(prefix);
              }
            }
          }
        } else {
          el.currentNSMap = currentNSMap;
          el.localNSMap = localNSMap;
          return true;
        }
      }
      function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
        if (/^(?:script|textarea)$/i.test(tagName)) {
          var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
          var text = source.substring(elStartEnd + 1, elEndStart);
          if (/[&<]/.test(text)) {
            if (/^script$/i.test(tagName)) {
              domBuilder.characters(text, 0, text.length);
              return elEndStart;
            }
            text = text.replace(/&#?\w+;/g, entityReplacer);
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
        }
        return elStartEnd + 1;
      }
      function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
        var pos = closeMap[tagName];
        if (pos == null) {
          pos = source.lastIndexOf("</" + tagName + ">");
          if (pos < elStartEnd) {
            pos = source.lastIndexOf("</" + tagName);
          }
          closeMap[tagName] = pos;
        }
        return pos < elStartEnd;
      }
      function _copy(source, target) {
        for (var n2 in source) {
          if (Object.prototype.hasOwnProperty.call(source, n2)) {
            target[n2] = source[n2];
          }
        }
      }
      function parseDCC(source, start, domBuilder, errorHandler) {
        var next = source.charAt(start + 2);
        switch (next) {
          case "-":
            if (source.charAt(start + 3) === "-") {
              var end = source.indexOf("-->", start + 4);
              if (end > start) {
                domBuilder.comment(source, start + 4, end - start - 4);
                return end + 3;
              } else {
                errorHandler.error("Unclosed comment");
                return -1;
              }
            } else {
              return -1;
            }
          default:
            if (source.substr(start + 3, 6) == "CDATA[") {
              var end = source.indexOf("]]>", start + 9);
              domBuilder.startCDATA();
              domBuilder.characters(source, start + 9, end - start - 9);
              domBuilder.endCDATA();
              return end + 3;
            }
            var matchs = split(source, start);
            var len = matchs.length;
            if (len > 1 && /!doctype/i.test(matchs[0][0])) {
              var name = matchs[1][0];
              var pubid = false;
              var sysid = false;
              if (len > 3) {
                if (/^public$/i.test(matchs[2][0])) {
                  pubid = matchs[3][0];
                  sysid = len > 4 && matchs[4][0];
                } else if (/^system$/i.test(matchs[2][0])) {
                  sysid = matchs[3][0];
                }
              }
              var lastMatch = matchs[len - 1];
              domBuilder.startDTD(name, pubid, sysid);
              domBuilder.endDTD();
              return lastMatch.index + lastMatch[0].length;
            }
        }
        return -1;
      }
      function parseInstruction(source, start, domBuilder) {
        var end = source.indexOf("?>", start);
        if (end) {
          var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
          if (match) {
            var len = match[0].length;
            domBuilder.processingInstruction(match[1], match[2]);
            return end + 2;
          } else {
            return -1;
          }
        }
        return -1;
      }
      function ElementAttributes() {
        this.attributeNames = {};
      }
      ElementAttributes.prototype = {
        setTagName: function(tagName) {
          if (!tagNamePattern.test(tagName)) {
            throw new Error("invalid tagName:" + tagName);
          }
          this.tagName = tagName;
        },
        addValue: function(qName, value, offset) {
          if (!tagNamePattern.test(qName)) {
            throw new Error("invalid attribute:" + qName);
          }
          this.attributeNames[qName] = this.length;
          this[this.length++] = { qName, value, offset };
        },
        length: 0,
        getLocalName: function(i2) {
          return this[i2].localName;
        },
        getLocator: function(i2) {
          return this[i2].locator;
        },
        getQName: function(i2) {
          return this[i2].qName;
        },
        getURI: function(i2) {
          return this[i2].uri;
        },
        getValue: function(i2) {
          return this[i2].value;
        }
        //	,getIndex:function(uri, localName)){
        //		if(localName){
        //
        //		}else{
        //			var qName = uri
        //		}
        //	},
        //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
        //	getType:function(uri,localName){}
        //	getType:function(i){},
      };
      function split(source, start) {
        var match;
        var buf = [];
        var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
        reg.lastIndex = start;
        reg.exec(source);
        while (match = reg.exec(source)) {
          buf.push(match);
          if (match[1]) return buf;
        }
      }
      exports.XMLReader = XMLReader;
      exports.ParseError = ParseError;
    }
  });

  // node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/dom-parser.js
  var require_dom_parser = __commonJS({
    "node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports) {
      init_shim();
      var conventions = require_conventions();
      var dom = require_dom();
      var entities = require_entities();
      var sax = require_sax();
      var DOMImplementation = dom.DOMImplementation;
      var NAMESPACE = conventions.NAMESPACE;
      var ParseError = sax.ParseError;
      var XMLReader = sax.XMLReader;
      function DOMParser(options) {
        this.options = options || { locator: {} };
      }
      DOMParser.prototype.parseFromString = function(source, mimeType) {
        var options = this.options;
        var sax2 = new XMLReader();
        var domBuilder = options.domBuilder || new DOMHandler();
        var errorHandler = options.errorHandler;
        var locator = options.locator;
        var defaultNSMap = options.xmlns || {};
        var isHTML = /\/x?html?$/.test(mimeType);
        var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
        if (locator) {
          domBuilder.setDocumentLocator(locator);
        }
        sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
        sax2.domBuilder = options.domBuilder || domBuilder;
        if (isHTML) {
          defaultNSMap[""] = NAMESPACE.HTML;
        }
        defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
        if (source && typeof source === "string") {
          sax2.parse(source, defaultNSMap, entityMap);
        } else {
          sax2.errorHandler.error("invalid doc source");
        }
        return domBuilder.doc;
      };
      function buildErrorHandler(errorImpl, domBuilder, locator) {
        if (!errorImpl) {
          if (domBuilder instanceof DOMHandler) {
            return domBuilder;
          }
          errorImpl = domBuilder;
        }
        var errorHandler = {};
        var isCallback = errorImpl instanceof Function;
        locator = locator || {};
        function build(key) {
          var fn = errorImpl[key];
          if (!fn && isCallback) {
            fn = errorImpl.length == 2 ? function(msg) {
              errorImpl(key, msg);
            } : errorImpl;
          }
          errorHandler[key] = fn && function(msg) {
            fn("[xmldom " + key + "]	" + msg + _locator(locator));
          } || function() {
          };
        }
        build("warning");
        build("error");
        build("fatalError");
        return errorHandler;
      }
      function DOMHandler() {
        this.cdata = false;
      }
      function position(locator, node) {
        node.lineNumber = locator.lineNumber;
        node.columnNumber = locator.columnNumber;
      }
      DOMHandler.prototype = {
        startDocument: function() {
          this.doc = new DOMImplementation().createDocument(null, null, null);
          if (this.locator) {
            this.doc.documentURI = this.locator.systemId;
          }
        },
        startElement: function(namespaceURI, localName, qName, attrs) {
          var doc = this.doc;
          var el = doc.createElementNS(namespaceURI, qName || localName);
          var len = attrs.length;
          appendElement(this, el);
          this.currentElement = el;
          this.locator && position(this.locator, el);
          for (var i2 = 0; i2 < len; i2++) {
            var namespaceURI = attrs.getURI(i2);
            var value = attrs.getValue(i2);
            var qName = attrs.getQName(i2);
            var attr = doc.createAttributeNS(namespaceURI, qName);
            this.locator && position(attrs.getLocator(i2), attr);
            attr.value = attr.nodeValue = value;
            el.setAttributeNode(attr);
          }
        },
        endElement: function(namespaceURI, localName, qName) {
          var current = this.currentElement;
          var tagName = current.tagName;
          this.currentElement = current.parentNode;
        },
        startPrefixMapping: function(prefix, uri) {
        },
        endPrefixMapping: function(prefix) {
        },
        processingInstruction: function(target, data) {
          var ins = this.doc.createProcessingInstruction(target, data);
          this.locator && position(this.locator, ins);
          appendElement(this, ins);
        },
        ignorableWhitespace: function(ch, start, length) {
        },
        characters: function(chars, start, length) {
          chars = _toString.apply(this, arguments);
          if (chars) {
            if (this.cdata) {
              var charNode = this.doc.createCDATASection(chars);
            } else {
              var charNode = this.doc.createTextNode(chars);
            }
            if (this.currentElement) {
              this.currentElement.appendChild(charNode);
            } else if (/^\s*$/.test(chars)) {
              this.doc.appendChild(charNode);
            }
            this.locator && position(this.locator, charNode);
          }
        },
        skippedEntity: function(name) {
        },
        endDocument: function() {
          this.doc.normalize();
        },
        setDocumentLocator: function(locator) {
          if (this.locator = locator) {
            locator.lineNumber = 0;
          }
        },
        //LexicalHandler
        comment: function(chars, start, length) {
          chars = _toString.apply(this, arguments);
          var comm = this.doc.createComment(chars);
          this.locator && position(this.locator, comm);
          appendElement(this, comm);
        },
        startCDATA: function() {
          this.cdata = true;
        },
        endCDATA: function() {
          this.cdata = false;
        },
        startDTD: function(name, publicId, systemId) {
          var impl = this.doc.implementation;
          if (impl && impl.createDocumentType) {
            var dt = impl.createDocumentType(name, publicId, systemId);
            this.locator && position(this.locator, dt);
            appendElement(this, dt);
            this.doc.doctype = dt;
          }
        },
        /**
         * @see org.xml.sax.ErrorHandler
         * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
         */
        warning: function(error) {
          console.warn("[xmldom warning]	" + error, _locator(this.locator));
        },
        error: function(error) {
          console.error("[xmldom error]	" + error, _locator(this.locator));
        },
        fatalError: function(error) {
          throw new ParseError(error, this.locator);
        }
      };
      function _locator(l2) {
        if (l2) {
          return "\n@" + (l2.systemId || "") + "#[line:" + l2.lineNumber + ",col:" + l2.columnNumber + "]";
        }
      }
      function _toString(chars, start, length) {
        if (typeof chars == "string") {
          return chars.substr(start, length);
        } else {
          if (chars.length >= start + length || start) {
            return new java.lang.String(chars, start, length) + "";
          }
          return chars;
        }
      }
      "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
        DOMHandler.prototype[key] = function() {
          return null;
        };
      });
      function appendElement(hander, node) {
        if (!hander.currentElement) {
          hander.doc.appendChild(node);
        } else {
          hander.currentElement.appendChild(node);
        }
      }
      exports.__DOMHandler = DOMHandler;
      exports.DOMParser = DOMParser;
      exports.DOMImplementation = dom.DOMImplementation;
      exports.XMLSerializer = dom.XMLSerializer;
    }
  });

  // node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/index.js
  var require_lib = __commonJS({
    "node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/index.js"(exports) {
      init_shim();
      var dom = require_dom();
      exports.DOMImplementation = dom.DOMImplementation;
      exports.XMLSerializer = dom.XMLSerializer;
      exports.DOMParser = require_dom_parser().DOMParser;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/svg.js
  var require_svg = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/svg.js"(exports, module) {
      "use strict";
      init_shim();
      var _ = require_lodash();
      var cubic2quad = require_cubic2quad();
      var svgpath = require_svgpath2();
      var DOMParser = require_lib().DOMParser;
      var ucs2 = require_ucs2();
      function getGlyph(glyphElem, fontInfo) {
        var glyph = {};
        if (glyphElem.hasAttribute("d")) {
          glyph.d = glyphElem.getAttribute("d").trim();
        } else {
          var pathElem = glyphElem.getElementsByTagName("path")[0];
          if (pathElem.hasAttribute("d")) {
            glyph.d = svgpath(pathElem.getAttribute("d")).scale(1, -1).translate(0, fontInfo.ascent).toString();
          } else {
            throw new Error("Can't find 'd' attribute of <glyph> tag.");
          }
        }
        glyph.unicode = [];
        if (glyphElem.getAttribute("unicode")) {
          glyph.character = glyphElem.getAttribute("unicode");
          var unicode = ucs2.decode(glyph.character);
          if (unicode.length > 1) {
            glyph.ligature = glyph.character;
            glyph.ligatureCodes = unicode;
          } else {
            glyph.unicode.push(unicode[0]);
          }
        }
        glyph.name = glyphElem.getAttribute("glyph-name");
        if (glyphElem.getAttribute("horiz-adv-x")) {
          glyph.width = parseInt(glyphElem.getAttribute("horiz-adv-x"), 10);
        }
        return glyph;
      }
      function deduplicateGlyps(glyphs, ligatures) {
        var result = [];
        _.forEach(glyphs, function(glyph) {
          var canonical = _.find(result, { width: glyph.width, d: glyph.d });
          if (canonical) {
            canonical.unicode = canonical.unicode.concat(glyph.unicode);
            glyph.canonical = canonical;
          } else {
            result.push(glyph);
          }
        });
        _.forEach(ligatures, function(ligature) {
          while (_.has(ligature.glyph, "canonical")) {
            ligature.glyph = ligature.glyph.canonical;
          }
        });
        return result;
      }
      function load(str) {
        var attrs;
        var doc = new DOMParser().parseFromString(str, "application/xml");
        var metadata, fontElem, fontFaceElem;
        metadata = doc.getElementsByTagName("metadata")[0];
        fontElem = doc.getElementsByTagName("font")[0];
        if (!fontElem) {
          throw new Error("Can't find <font> tag. Make sure you SVG file is font, not image.");
        }
        fontFaceElem = fontElem.getElementsByTagName("font-face")[0];
        var familyName = fontFaceElem.getAttribute("font-family") || "fontello";
        var subfamilyName = fontFaceElem.getAttribute("font-style") || "Regular";
        var id = fontElem.getAttribute("id") || (familyName + "-" + subfamilyName).replace(/[\s\(\)\[\]<>%\/]/g, "").substr(0, 62);
        var font = {
          id,
          familyName,
          subfamilyName,
          stretch: fontFaceElem.getAttribute("font-stretch") || "normal"
        };
        if (metadata && metadata.textContent) {
          font.metadata = metadata.textContent;
        }
        attrs = {
          width: "horiz-adv-x",
          //height:       'vert-adv-y',
          horizOriginX: "horiz-origin-x",
          horizOriginY: "horiz-origin-y",
          vertOriginX: "vert-origin-x",
          vertOriginY: "vert-origin-y"
        };
        _.forEach(attrs, function(val, key) {
          if (fontElem.hasAttribute(val)) {
            font[key] = parseInt(fontElem.getAttribute(val), 10);
          }
        });
        attrs = {
          ascent: "ascent",
          descent: "descent",
          unitsPerEm: "units-per-em",
          capHeight: "cap-height",
          xHeight: "x-height",
          underlineThickness: "underline-thickness",
          underlinePosition: "underline-position"
        };
        _.forEach(attrs, function(val, key) {
          if (fontFaceElem.hasAttribute(val)) {
            font[key] = parseInt(fontFaceElem.getAttribute(val), 10);
          }
        });
        if (fontFaceElem.hasAttribute("font-weight")) {
          font.weightClass = fontFaceElem.getAttribute("font-weight");
        }
        var missingGlyphElem = fontElem.getElementsByTagName("missing-glyph")[0];
        if (missingGlyphElem) {
          font.missingGlyph = {};
          font.missingGlyph.d = missingGlyphElem.getAttribute("d") || "";
          if (missingGlyphElem.getAttribute("horiz-adv-x")) {
            font.missingGlyph.width = parseInt(missingGlyphElem.getAttribute("horiz-adv-x"), 10);
          }
        }
        var glyphs = [];
        var ligatures = [];
        _.forEach(fontElem.getElementsByTagName("glyph"), function(glyphElem) {
          var glyph = getGlyph(glyphElem, font);
          if (_.has(glyph, "ligature")) {
            ligatures.push({
              ligature: glyph.ligature,
              unicode: glyph.ligatureCodes,
              glyph
            });
          }
          glyphs.push(glyph);
        });
        glyphs = deduplicateGlyps(glyphs, ligatures);
        font.glyphs = glyphs;
        font.ligatures = ligatures;
        return font;
      }
      function cubicToQuad(segment, index, x, y2, accuracy) {
        if (segment[0] === "C") {
          var quadCurves = cubic2quad(
            x,
            y2,
            segment[1],
            segment[2],
            segment[3],
            segment[4],
            segment[5],
            segment[6],
            accuracy
          );
          var res = [];
          for (var i2 = 2; i2 < quadCurves.length; i2 += 4) {
            res.push(["Q", quadCurves[i2], quadCurves[i2 + 1], quadCurves[i2 + 2], quadCurves[i2 + 3]]);
          }
          return res;
        }
      }
      function toSfntCoutours(svgPath) {
        var resContours = [];
        var resContour = [];
        svgPath.iterate(function(segment, index, x, y2) {
          if (index === 0 || segment[0] === "M") {
            resContour = [];
            resContours.push(resContour);
          }
          var name = segment[0];
          if (name === "Q") {
            resContour.push({ x: segment[1], y: segment[2], onCurve: false });
          }
          if (name === "H") {
            resContour.push({ x: segment[1], y: y2, onCurve: true });
          } else if (name === "V") {
            resContour.push({ x, y: segment[1], onCurve: true });
          } else if (name !== "Z") {
            resContour.push({ x: segment[segment.length - 2], y: segment[segment.length - 1], onCurve: true });
          }
        });
        return resContours;
      }
      module.exports.load = load;
      module.exports.cubicToQuad = cubicToQuad;
      module.exports.toSfntCoutours = toSfntCoutours;
    }
  });

  // node_modules/.pnpm/microbuffer@1.0.0/node_modules/microbuffer/index.js
  var require_microbuffer = __commonJS({
    "node_modules/.pnpm/microbuffer@1.0.0/node_modules/microbuffer/index.js"(exports, module) {
      "use strict";
      init_shim();
      var TYPED_OK = typeof Uint8Array !== "undefined";
      function createArray(size) {
        return TYPED_OK ? new Uint8Array(size) : Array(size);
      }
      function MicroBuffer(buffer2, start, length) {
        var isInherited = buffer2 instanceof MicroBuffer;
        this.buffer = isInherited ? buffer2.buffer : typeof buffer2 === "number" ? createArray(buffer2) : buffer2;
        this.start = (start || 0) + (isInherited ? buffer2.start : 0);
        this.length = length || this.buffer.length - this.start;
        this.offset = 0;
        this.isTyped = !Array.isArray(this.buffer);
      }
      MicroBuffer.prototype.getUint8 = function(pos) {
        return this.buffer[pos + this.start];
      };
      MicroBuffer.prototype.getUint16 = function(pos, littleEndian) {
        var val;
        if (littleEndian) {
          throw new Error("not implemented");
        } else {
          val = this.buffer[pos + 1 + this.start];
          val += this.buffer[pos + this.start] << 8 >>> 0;
        }
        return val;
      };
      MicroBuffer.prototype.getUint32 = function(pos, littleEndian) {
        var val;
        if (littleEndian) {
          throw new Error("not implemented");
        } else {
          val = this.buffer[pos + 1 + this.start] << 16;
          val |= this.buffer[pos + 2 + this.start] << 8;
          val |= this.buffer[pos + 3 + this.start];
          val += this.buffer[pos + this.start] << 24 >>> 0;
        }
        return val;
      };
      MicroBuffer.prototype.setUint8 = function(pos, value) {
        this.buffer[pos + this.start] = value & 255;
      };
      MicroBuffer.prototype.setUint16 = function(pos, value, littleEndian) {
        var offset = pos + this.start;
        var buf = this.buffer;
        if (littleEndian) {
          buf[offset] = value & 255;
          buf[offset + 1] = value >>> 8 & 255;
        } else {
          buf[offset] = value >>> 8 & 255;
          buf[offset + 1] = value & 255;
        }
      };
      MicroBuffer.prototype.setUint32 = function(pos, value, littleEndian) {
        var offset = pos + this.start;
        var buf = this.buffer;
        if (littleEndian) {
          buf[offset] = value & 255;
          buf[offset + 1] = value >>> 8 & 255;
          buf[offset + 2] = value >>> 16 & 255;
          buf[offset + 3] = value >>> 24 & 255;
        } else {
          buf[offset] = value >>> 24 & 255;
          buf[offset + 1] = value >>> 16 & 255;
          buf[offset + 2] = value >>> 8 & 255;
          buf[offset + 3] = value & 255;
        }
      };
      MicroBuffer.prototype.writeUint8 = function(value) {
        this.buffer[this.offset + this.start] = value & 255;
        this.offset++;
      };
      MicroBuffer.prototype.writeInt8 = function(value) {
        this.setUint8(this.offset, value < 0 ? 255 + value + 1 : value);
        this.offset++;
      };
      MicroBuffer.prototype.writeUint16 = function(value, littleEndian) {
        this.setUint16(this.offset, value, littleEndian);
        this.offset += 2;
      };
      MicroBuffer.prototype.writeInt16 = function(value, littleEndian) {
        this.setUint16(this.offset, value < 0 ? 65535 + value + 1 : value, littleEndian);
        this.offset += 2;
      };
      MicroBuffer.prototype.writeUint32 = function(value, littleEndian) {
        this.setUint32(this.offset, value, littleEndian);
        this.offset += 4;
      };
      MicroBuffer.prototype.writeInt32 = function(value, littleEndian) {
        this.setUint32(this.offset, value < 0 ? 4294967295 + value + 1 : value, littleEndian);
        this.offset += 4;
      };
      MicroBuffer.prototype.tell = function() {
        return this.offset;
      };
      MicroBuffer.prototype.seek = function(pos) {
        this.offset = pos;
      };
      MicroBuffer.prototype.fill = function(value) {
        var index = this.length - 1;
        while (index >= 0) {
          this.buffer[index + this.start] = value;
          index--;
        }
      };
      MicroBuffer.prototype.writeUint64 = function(value) {
        var hi = Math.floor(value / 4294967296);
        var lo = value - hi * 4294967296;
        this.writeUint32(hi);
        this.writeUint32(lo);
      };
      MicroBuffer.prototype.writeBytes = function(data) {
        var buffer2 = this.buffer;
        var offset = this.offset + this.start;
        if (this.isTyped) {
          buffer2.set(data, offset);
        } else {
          for (var i2 = 0; i2 < data.length; i2++) {
            buffer2[i2 + offset] = data[i2];
          }
        }
        this.offset += data.length;
      };
      MicroBuffer.prototype.toString = function(offset, length) {
        offset = offset || 0;
        length = length || this.length - offset;
        var start = offset + this.start;
        var end = start + length;
        var string = "";
        for (var i2 = start; i2 < end; i2++) {
          string += String.fromCharCode(this.buffer[i2]);
        }
        return string;
      };
      MicroBuffer.prototype.toArray = function() {
        if (this.isTyped) {
          return this.buffer.subarray(this.start, this.start + this.length);
        }
        return this.buffer.slice(this.start, this.start + this.length);
      };
      module.exports = MicroBuffer;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/math.js
  var require_math = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/math.js"(exports, module) {
      "use strict";
      init_shim();
      function Point(x, y2) {
        this.x = x;
        this.y = y2;
      }
      Point.prototype.add = function(point) {
        return new Point(this.x + point.x, this.y + point.y);
      };
      Point.prototype.sub = function(point) {
        return new Point(this.x - point.x, this.y - point.y);
      };
      Point.prototype.mul = function(value) {
        return new Point(this.x * value, this.y * value);
      };
      Point.prototype.div = function(value) {
        return new Point(this.x / value, this.y / value);
      };
      Point.prototype.dist = function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      };
      Point.prototype.sqr = function() {
        return this.x * this.x + this.y * this.y;
      };
      function isInLine(p1, m, p2, accuracy) {
        var a2 = p1.sub(m).sqr();
        var b2 = p2.sub(m).sqr();
        var c = p1.sub(p2).sqr();
        if (a2 > b2 + c || b2 > a2 + c) {
          return false;
        }
        var distance = Math.sqrt(Math.pow((p1.x - m.x) * (p2.y - m.y) - (p2.x - m.x) * (p1.y - m.y), 2) / c);
        return distance < accuracy ? true : false;
      }
      module.exports.Point = Point;
      module.exports.isInLine = isInLine;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/utils.js
  var require_utils = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/utils.js"(exports, module) {
      "use strict";
      init_shim();
      var _ = require_lodash();
      var math = require_math();
      function simplify(contours, accuracy) {
        return _.map(contours, function(contour) {
          var i2, curr, prev, next;
          var p2, pPrev, pNext;
          for (i2 = contour.length - 2; i2 > 1; i2--) {
            prev = contour[i2 - 1];
            next = contour[i2 + 1];
            curr = contour[i2];
            if (prev.onCurve && next.onCurve) {
              p2 = new math.Point(curr.x, curr.y);
              pPrev = new math.Point(prev.x, prev.y);
              pNext = new math.Point(next.x, next.y);
              if (math.isInLine(pPrev, p2, pNext, accuracy)) {
                contour.splice(i2, 1);
              }
            }
          }
          return contour;
        });
      }
      function interpolate(contours, accuracy) {
        return _.map(contours, function(contour) {
          var resContour = [];
          _.forEach(contour, function(point, idx) {
            if (idx === 0 || idx === contour.length - 1) {
              resContour.push(point);
              return;
            }
            var prev = contour[idx - 1];
            var next = contour[idx + 1];
            var p2, pPrev, pNext;
            if (!prev.onCurve && point.onCurve && !next.onCurve) {
              p2 = new math.Point(point.x, point.y);
              pPrev = new math.Point(prev.x, prev.y);
              pNext = new math.Point(next.x, next.y);
              if (pPrev.add(pNext).div(2).sub(p2).dist() < accuracy) {
                return;
              }
            }
            resContour.push(point);
          });
          return resContour;
        });
      }
      function roundPoints(contours) {
        return _.map(contours, function(contour) {
          return _.map(contour, function(point) {
            return { x: Math.round(point.x), y: Math.round(point.y), onCurve: point.onCurve };
          });
        });
      }
      function removeClosingReturnPoints(contours) {
        return _.map(contours, function(contour) {
          var length = contour.length;
          if (length > 1 && contour[0].x === contour[length - 1].x && contour[0].y === contour[length - 1].y) {
            contour.splice(length - 1);
          }
          return contour;
        });
      }
      function toRelative(contours) {
        var prevPoint = { x: 0, y: 0 };
        var resContours = [];
        var resContour;
        _.forEach(contours, function(contour) {
          resContour = [];
          resContours.push(resContour);
          _.forEach(contour, function(point) {
            resContour.push({
              x: point.x - prevPoint.x,
              y: point.y - prevPoint.y,
              onCurve: point.onCurve
            });
            prevPoint = point;
          });
        });
        return resContours;
      }
      function identifier(string, littleEndian) {
        var result = 0;
        for (var i2 = 0; i2 < string.length; i2++) {
          result = result << 8;
          var index = littleEndian ? string.length - i2 - 1 : i2;
          result += string.charCodeAt(index);
        }
        return result;
      }
      module.exports.interpolate = interpolate;
      module.exports.simplify = simplify;
      module.exports.roundPoints = roundPoints;
      module.exports.removeClosingReturnPoints = removeClosingReturnPoints;
      module.exports.toRelative = toRelative;
      module.exports.identifier = identifier;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/gsub.js
  var require_gsub = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/gsub.js"(exports, module) {
      "use strict";
      init_shim();
      var _ = require_lodash();
      var identifier = require_utils().identifier;
      var ByteBuffer = require_microbuffer();
      function createScript() {
        var scriptRecord = 0 + 2 + 2;
        var langSys = 0 + 2 + 2 + 2 + 2;
        var length = 0 + scriptRecord + langSys;
        var buffer2 = new ByteBuffer(length);
        buffer2.writeUint16(scriptRecord);
        buffer2.writeUint16(0);
        buffer2.writeUint16(0);
        buffer2.writeUint16(0);
        buffer2.writeUint16(1);
        buffer2.writeUint16(0);
        return buffer2;
      }
      function createScriptList() {
        var scriptSize = 0 + 4 + 2;
        var scripts = [
          ["DFLT", createScript()],
          ["latn", createScript()]
        ];
        var header = 0 + 2 + scripts.length * scriptSize;
        var tableLengths = _.reduce(_.map(scripts, function(script) {
          return script[1].length;
        }), function(result, count) {
          return result + count;
        }, 0);
        var length = 0 + header + tableLengths;
        var buffer2 = new ByteBuffer(length);
        buffer2.writeUint16(scripts.length);
        var offset = header;
        _.forEach(scripts, function(script) {
          var name = script[0], table = script[1];
          buffer2.writeUint32(identifier(name));
          buffer2.writeUint16(offset);
          offset += table.length;
        });
        _.forEach(scripts, function(script) {
          var table = script[1];
          buffer2.writeBytes(table.buffer);
        });
        return buffer2;
      }
      function createFeatureList() {
        var header = 0 + 2 + 4 + 2;
        var length = 0 + header + 2 + 2 + 2;
        var buffer2 = new ByteBuffer(length);
        buffer2.writeUint16(1);
        buffer2.writeUint32(identifier("liga"));
        buffer2.writeUint16(header);
        buffer2.writeUint16(0);
        buffer2.writeUint16(1);
        buffer2.writeUint16(0);
        return buffer2;
      }
      function createLigatureCoverage(font, ligatureGroups) {
        var glyphCount = ligatureGroups.length;
        var length = 0 + 2 + 2 + 2 * glyphCount;
        var buffer2 = new ByteBuffer(length);
        buffer2.writeUint16(1);
        buffer2.writeUint16(glyphCount);
        _.forEach(ligatureGroups, function(group) {
          buffer2.writeUint16(group.startGlyph.id);
        });
        return buffer2;
      }
      function createLigatureTable(font, ligature) {
        var allCodePoints = font.codePoints;
        var unicode = ligature.unicode;
        var length = 0 + 2 + 2 + 2 * (unicode.length - 1);
        var buffer2 = new ByteBuffer(length);
        var glyph = ligature.glyph;
        buffer2.writeUint16(glyph.id);
        buffer2.writeUint16(unicode.length);
        for (var i2 = 1; i2 < unicode.length; i2++) {
          glyph = allCodePoints[unicode[i2]];
          buffer2.writeUint16(glyph.id);
        }
        return buffer2;
      }
      function createLigatureSet(font, codePoint, ligatures) {
        var ligatureTables = [];
        _.forEach(ligatures, function(ligature) {
          ligatureTables.push(createLigatureTable(font, ligature));
        });
        var tableLengths = _.reduce(_.map(ligatureTables, "length"), function(result, count) {
          return result + count;
        }, 0);
        var offset = 0 + 2 + 2 * ligatures.length;
        var length = 0 + offset + tableLengths;
        var buffer2 = new ByteBuffer(length);
        buffer2.writeUint16(ligatures.length);
        _.forEach(ligatureTables, function(table) {
          buffer2.writeUint16(offset);
          offset += table.length;
        });
        _.forEach(ligatureTables, function(table) {
          buffer2.writeBytes(table.buffer);
        });
        return buffer2;
      }
      function createLigatureList(font, ligatureGroups) {
        var sets = [];
        _.forEach(ligatureGroups, function(group) {
          var set = createLigatureSet(font, group.codePoint, group.ligatures);
          sets.push(set);
        });
        var setLengths = _.reduce(_.map(sets, "length"), function(result, count) {
          return result + count;
        }, 0);
        var coverage = createLigatureCoverage(font, ligatureGroups);
        var tableOffset = 0 + 2 + 2 + 2 + 2;
        var setOffset = 0 + 2 + 2 + 2 + 2 * sets.length;
        var coverageOffset = setOffset + setLengths;
        var length = 0 + tableOffset + coverageOffset + coverage.length;
        var buffer2 = new ByteBuffer(length);
        buffer2.writeUint16(4);
        buffer2.writeUint16(0);
        buffer2.writeUint16(1);
        buffer2.writeUint16(tableOffset);
        buffer2.writeUint16(1);
        buffer2.writeUint16(coverageOffset);
        buffer2.writeUint16(sets.length);
        _.forEach(sets, function(set) {
          buffer2.writeUint16(setOffset);
          setOffset += set.length;
        });
        _.forEach(sets, function(set) {
          buffer2.writeBytes(set.buffer);
        });
        buffer2.writeBytes(coverage.buffer);
        return buffer2;
      }
      function createLookupList(font) {
        var ligatures = font.ligatures;
        var groupedLigatures = {};
        _.forEach(ligatures, function(ligature) {
          var first = ligature.unicode[0];
          if (!_.has(groupedLigatures, first)) {
            groupedLigatures[first] = [];
          }
          groupedLigatures[first].push(ligature);
        });
        var ligatureGroups = [];
        _.forEach(groupedLigatures, function(ligatures2, codePoint) {
          codePoint = parseInt(codePoint, 10);
          ligatures2.sort(function(ligA, ligB) {
            return ligB.unicode.length - ligA.unicode.length;
          });
          ligatureGroups.push({
            codePoint,
            ligatures: ligatures2,
            startGlyph: font.codePoints[codePoint]
          });
        });
        ligatureGroups.sort(function(a2, b2) {
          return a2.startGlyph.id - b2.startGlyph.id;
        });
        var offset = 0 + 2 + 2;
        var set = createLigatureList(font, ligatureGroups);
        var length = 0 + offset + set.length;
        var buffer2 = new ByteBuffer(length);
        buffer2.writeUint16(1);
        buffer2.writeUint16(offset);
        buffer2.writeBytes(set.buffer);
        return buffer2;
      }
      function createGSUB(font) {
        var scriptList = createScriptList();
        var featureList = createFeatureList();
        var lookupList = createLookupList(font);
        var lists = [scriptList, featureList, lookupList];
        var offset = 0 + 4 + 2 * lists.length;
        _.forEach(lists, function(list) {
          list._listOffset = offset;
          offset += list.length;
        });
        var length = offset;
        var buffer2 = new ByteBuffer(length);
        buffer2.writeUint32(65536);
        _.forEach(lists, function(list) {
          buffer2.writeUint16(list._listOffset);
        });
        _.forEach(lists, function(list) {
          buffer2.writeBytes(list.buffer);
        });
        return buffer2;
      }
      module.exports = createGSUB;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/os2.js
  var require_os2 = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/os2.js"(exports, module) {
      "use strict";
      init_shim();
      var _ = require_lodash();
      var identifier = require_utils().identifier;
      var ByteBuffer = require_microbuffer();
      function getFirstCharIndex(font) {
        return Math.max(0, Math.min(65535, Math.abs(_.minBy(Object.keys(font.codePoints), function(point) {
          return parseInt(point, 10);
        }))));
      }
      function getLastCharIndex(font) {
        return Math.max(0, Math.min(65535, Math.abs(_.maxBy(Object.keys(font.codePoints), function(point) {
          return parseInt(point, 10);
        }))));
      }
      function createOS2Table(font) {
        var maxContext = font.ligatures.map(function(l2) {
          return l2.unicode.length;
        }).reduce(function(a2, b2) {
          return Math.max(a2, b2);
        }, 2);
        var buf = new ByteBuffer(96);
        buf.writeUint16(4);
        buf.writeInt16(font.avgWidth);
        buf.writeUint16(font.weightClass);
        buf.writeUint16(font.widthClass);
        buf.writeInt16(font.fsType);
        buf.writeInt16(font.ySubscriptXSize);
        buf.writeInt16(font.ySubscriptYSize);
        buf.writeInt16(font.ySubscriptXOffset);
        buf.writeInt16(font.ySubscriptYOffset);
        buf.writeInt16(font.ySuperscriptXSize);
        buf.writeInt16(font.ySuperscriptYSize);
        buf.writeInt16(font.ySuperscriptXOffset);
        buf.writeInt16(font.ySuperscriptYOffset);
        buf.writeInt16(font.yStrikeoutSize);
        buf.writeInt16(font.yStrikeoutPosition);
        buf.writeInt16(font.familyClass);
        buf.writeUint8(font.panose.familyType);
        buf.writeUint8(font.panose.serifStyle);
        buf.writeUint8(font.panose.weight);
        buf.writeUint8(font.panose.proportion);
        buf.writeUint8(font.panose.contrast);
        buf.writeUint8(font.panose.strokeVariation);
        buf.writeUint8(font.panose.armStyle);
        buf.writeUint8(font.panose.letterform);
        buf.writeUint8(font.panose.midline);
        buf.writeUint8(font.panose.xHeight);
        buf.writeUint32(0);
        buf.writeUint32(0);
        buf.writeUint32(0);
        buf.writeUint32(0);
        buf.writeUint32(identifier("PfEd"));
        buf.writeUint16(font.fsSelection);
        buf.writeUint16(getFirstCharIndex(font));
        buf.writeUint16(getLastCharIndex(font));
        buf.writeInt16(font.ascent);
        buf.writeInt16(font.descent);
        buf.writeInt16(font.lineGap);
        buf.writeInt16(Math.max(font.yMax, font.ascent + font.lineGap));
        buf.writeInt16(-Math.min(font.yMin, font.descent));
        buf.writeInt32(1);
        buf.writeInt32(0);
        buf.writeInt16(font.xHeight);
        buf.writeInt16(font.capHeight);
        buf.writeUint16(0);
        buf.writeUint16(0);
        buf.writeUint16(maxContext);
        return buf;
      }
      module.exports = createOS2Table;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/cmap.js
  var require_cmap = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/cmap.js"(exports, module) {
      "use strict";
      init_shim();
      var _ = require_lodash();
      var ByteBuffer = require_microbuffer();
      function getIDByUnicode(font, unicode) {
        return font.codePoints[unicode] ? font.codePoints[unicode].id : 0;
      }
      function getSegments(font, bounds) {
        bounds = bounds || Number.MAX_VALUE;
        var result = [];
        var segment;
        _.forEach(font.codePoints, function(glyph, unicode) {
          unicode = parseInt(unicode, 10);
          if (unicode >= bounds) {
            return false;
          }
          if (!segment || unicode !== segment.end + 1) {
            if (segment) {
              result.push(segment);
            }
            segment = {
              start: unicode
            };
          }
          segment.end = unicode;
        });
        if (segment) {
          result.push(segment);
        }
        _.forEach(result, function(segment2) {
          segment2.length = segment2.end - segment2.start + 1;
        });
        return result;
      }
      function getCodePoints(codePoints, bounds) {
        bounds = bounds || Number.MAX_VALUE;
        var result = [];
        _.forEach(codePoints, function(glyph, unicode) {
          unicode = parseInt(unicode, 10);
          if (unicode > bounds) {
            return false;
          }
          result.push({
            unicode,
            glyph
          });
        });
        return result;
      }
      function bufferForTable(format, length) {
        var fieldWidth = format === 8 || format === 10 || format === 12 || format === 13 ? 4 : 2;
        length += 0 + fieldWidth + fieldWidth + fieldWidth;
        var LANGUAGE = 0;
        var buffer2 = new ByteBuffer(length);
        var writer = fieldWidth === 4 ? buffer2.writeUint32 : buffer2.writeUint16;
        buffer2.writeUint16(format);
        if (fieldWidth === 4) {
          buffer2.writeUint16(0);
        }
        writer.call(buffer2, length);
        writer.call(buffer2, LANGUAGE);
        return buffer2;
      }
      function createFormat0Table(font) {
        var FORMAT = 0;
        var i2;
        var length = 255 + 1;
        var buffer2 = bufferForTable(FORMAT, length);
        for (i2 = 0; i2 < length; i2++) {
          buffer2.writeUint8(getIDByUnicode(font, i2));
        }
        return buffer2;
      }
      function createFormat4Table(font) {
        var FORMAT = 4;
        var i2;
        var segments = getSegments(font, 65535);
        var glyphIndexArrays = [];
        _.forEach(segments, function(segment) {
          var glyphIndexArray = [];
          for (var unicode = segment.start; unicode <= segment.end; unicode++) {
            glyphIndexArray.push(getIDByUnicode(font, unicode));
          }
          glyphIndexArrays.push(glyphIndexArray);
        });
        var segCount = segments.length + 1;
        var glyphIndexArrayLength = _.reduce(_.map(glyphIndexArrays, "length"), function(result, count) {
          return result + count;
        }, 0);
        var length = 0 + 2 + 2 + 2 + 2 + 2 * segCount + 2 + 2 * segCount + 2 * segCount + 2 * segCount + 2 * glyphIndexArrayLength;
        var buffer2 = bufferForTable(FORMAT, length);
        buffer2.writeUint16(segCount * 2);
        var maxExponent = Math.floor(Math.log(segCount) / Math.LN2);
        var searchRange = 2 * Math.pow(2, maxExponent);
        buffer2.writeUint16(searchRange);
        buffer2.writeUint16(maxExponent);
        buffer2.writeUint16(2 * segCount - searchRange);
        _.forEach(segments, function(segment) {
          buffer2.writeUint16(segment.end);
        });
        buffer2.writeUint16(65535);
        buffer2.writeUint16(0);
        _.forEach(segments, function(segment) {
          buffer2.writeUint16(segment.start);
        });
        buffer2.writeUint16(65535);
        for (i2 = 0; i2 < segments.length; i2++) {
          buffer2.writeUint16(0);
        }
        buffer2.writeUint16(1);
        var offset = 0;
        for (i2 = 0; i2 < segments.length; i2++) {
          buffer2.writeUint16(2 * (segments.length - i2 + 1 + offset));
          offset += glyphIndexArrays[i2].length;
        }
        buffer2.writeUint16(0);
        _.forEach(glyphIndexArrays, function(glyphIndexArray) {
          _.forEach(glyphIndexArray, function(glyphId) {
            buffer2.writeUint16(glyphId);
          });
        });
        return buffer2;
      }
      function createFormat12Table(font) {
        var FORMAT = 12;
        var codePoints = getCodePoints(font.codePoints);
        var length = 0 + 4 + 4 * codePoints.length + 4 * codePoints.length + 4 * codePoints.length;
        var buffer2 = bufferForTable(FORMAT, length);
        buffer2.writeUint32(codePoints.length);
        _.forEach(codePoints, function(codePoint) {
          buffer2.writeUint32(codePoint.unicode);
          buffer2.writeUint32(codePoint.unicode);
          buffer2.writeUint32(codePoint.glyph.id);
        });
        return buffer2;
      }
      function createCMapTable(font) {
        var TABLE_HEAD = 0 + 2 + 2 + 4;
        var singleByteTable = createFormat0Table(font);
        var twoByteTable = createFormat4Table(font);
        var fourByteTable = createFormat12Table(font);
        var tableHeaders = [
          // subtable 4, unicode
          {
            platformID: 0,
            encodingID: 3,
            table: twoByteTable
          },
          // subtable 12, unicode
          {
            platformID: 0,
            encodingID: 4,
            table: fourByteTable
          },
          // subtable 0, mac standard
          {
            platformID: 1,
            encodingID: 0,
            table: singleByteTable
          },
          // subtable 4, windows standard, identical to the unicode table
          {
            platformID: 3,
            encodingID: 1,
            table: twoByteTable
          },
          // subtable 12, windows ucs4
          {
            platformID: 3,
            encodingID: 10,
            table: fourByteTable
          }
        ];
        var tables = [
          twoByteTable,
          singleByteTable,
          fourByteTable
        ];
        var tableOffset = 0 + 2 + 2 + tableHeaders.length * TABLE_HEAD;
        _.forEach(tables, function(table) {
          table._tableOffset = tableOffset;
          tableOffset += table.length;
        });
        var length = tableOffset;
        var buffer2 = new ByteBuffer(length);
        buffer2.writeUint16(0);
        buffer2.writeUint16(tableHeaders.length);
        _.forEach(tableHeaders, function(header) {
          buffer2.writeUint16(header.platformID);
          buffer2.writeUint16(header.encodingID);
          buffer2.writeUint32(header.table._tableOffset);
        });
        _.forEach(tables, function(table) {
          buffer2.writeBytes(table.buffer);
        });
        return buffer2;
      }
      module.exports = createCMapTable;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/glyf.js
  var require_glyf = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/glyf.js"(exports, module) {
      "use strict";
      init_shim();
      var _ = require_lodash();
      var ByteBuffer = require_microbuffer();
      function getFlags(glyph) {
        var result = [];
        _.forEach(glyph.ttfContours, function(contour) {
          _.forEach(contour, function(point) {
            var flag = point.onCurve ? 1 : 0;
            if (point.x === 0) {
              flag += 16;
            } else {
              if (-255 <= point.x && point.x <= 255) {
                flag += 2;
              }
              if (point.x > 0 && point.x <= 255) {
                flag += 16;
              }
            }
            if (point.y === 0) {
              flag += 32;
            } else {
              if (-255 <= point.y && point.y <= 255) {
                flag += 4;
              }
              if (point.y > 0 && point.y <= 255) {
                flag += 32;
              }
            }
            result.push(flag);
          });
        });
        return result;
      }
      function compactFlags(flags) {
        var result = [];
        var prevFlag = -1;
        var firstRepeat = false;
        _.forEach(flags, function(flag) {
          if (prevFlag === flag) {
            if (firstRepeat) {
              result[result.length - 1] += 8;
              result.push(1);
              firstRepeat = false;
            } else {
              result[result.length - 1]++;
            }
          } else {
            firstRepeat = true;
            prevFlag = flag;
            result.push(flag);
          }
        });
        return result;
      }
      function getCoords(glyph, coordName) {
        var result = [];
        _.forEach(glyph.ttfContours, function(contour) {
          result.push.apply(result, _.map(contour, coordName));
        });
        return result;
      }
      function compactCoords(coords) {
        return _.filter(coords, function(coord) {
          return coord !== 0;
        });
      }
      function glyphDataSize(glyph) {
        if (!glyph.contours.length) {
          return 0;
        }
        var result = 12;
        result += glyph.contours.length * 2;
        _.forEach(glyph.ttf_x, function(x) {
          result += -255 <= x && x <= 255 ? 1 : 2;
        });
        _.forEach(glyph.ttf_y, function(y2) {
          result += -255 <= y2 && y2 <= 255 ? 1 : 2;
        });
        result += glyph.ttf_flags.length;
        if (result % 4 !== 0) {
          result += 4 - result % 4;
        }
        return result;
      }
      function tableSize(font) {
        var result = 0;
        _.forEach(font.glyphs, function(glyph) {
          glyph.ttf_size = glyphDataSize(glyph);
          result += glyph.ttf_size;
        });
        font.ttf_glyph_size = result;
        return result;
      }
      function createGlyfTable(font) {
        _.forEach(font.glyphs, function(glyph) {
          glyph.ttf_flags = getFlags(glyph);
          glyph.ttf_flags = compactFlags(glyph.ttf_flags);
          glyph.ttf_x = getCoords(glyph, "x");
          glyph.ttf_x = compactCoords(glyph.ttf_x);
          glyph.ttf_y = getCoords(glyph, "y");
          glyph.ttf_y = compactCoords(glyph.ttf_y);
        });
        var buf = new ByteBuffer(tableSize(font));
        _.forEach(font.glyphs, function(glyph) {
          if (!glyph.contours.length) {
            return;
          }
          var offset = buf.tell();
          buf.writeInt16(glyph.contours.length);
          buf.writeInt16(glyph.xMin);
          buf.writeInt16(glyph.yMin);
          buf.writeInt16(glyph.xMax);
          buf.writeInt16(glyph.yMax);
          var endPtsOfContours = -1;
          var ttfContours = glyph.ttfContours;
          _.forEach(ttfContours, function(contour) {
            endPtsOfContours += contour.length;
            buf.writeInt16(endPtsOfContours);
          });
          buf.writeInt16(0);
          _.forEach(glyph.ttf_flags, function(flag) {
            buf.writeInt8(flag);
          });
          _.forEach(glyph.ttf_x, function(x) {
            if (-255 <= x && x <= 255) {
              buf.writeUint8(Math.abs(x));
            } else {
              buf.writeInt16(x);
            }
          });
          _.forEach(glyph.ttf_y, function(y2) {
            if (-255 <= y2 && y2 <= 255) {
              buf.writeUint8(Math.abs(y2));
            } else {
              buf.writeInt16(y2);
            }
          });
          var tail = (buf.tell() - offset) % 4;
          if (tail !== 0) {
            for (; tail < 4; tail++) {
              buf.writeUint8(0);
            }
          }
        });
        return buf;
      }
      module.exports = createGlyfTable;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/head.js
  var require_head = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/head.js"(exports, module) {
      "use strict";
      init_shim();
      var ByteBuffer = require_microbuffer();
      function dateToUInt64(date) {
        var startDate = /* @__PURE__ */ new Date("1904-01-01T00:00:00.000Z");
        return Math.floor((date - startDate) / 1e3);
      }
      function createHeadTable(font) {
        var buf = new ByteBuffer(54);
        buf.writeInt32(65536);
        buf.writeInt32(font.revision * 65536);
        buf.writeUint32(0);
        buf.writeUint32(1594834165);
        buf.writeUint16(11);
        buf.writeUint16(font.unitsPerEm);
        buf.writeUint64(dateToUInt64(font.createdDate));
        buf.writeUint64(dateToUInt64(font.modifiedDate));
        buf.writeInt16(font.xMin);
        buf.writeInt16(font.yMin);
        buf.writeInt16(font.xMax);
        buf.writeInt16(font.yMax);
        buf.writeUint16(font.macStyle);
        buf.writeUint16(font.lowestRecPPEM);
        buf.writeInt16(2);
        buf.writeInt16(font.ttf_glyph_size < 131072 ? 0 : 1);
        buf.writeInt16(0);
        return buf;
      }
      module.exports = createHeadTable;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/hhea.js
  var require_hhea = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/hhea.js"(exports, module) {
      "use strict";
      init_shim();
      var ByteBuffer = require_microbuffer();
      function createHHeadTable(font) {
        var buf = new ByteBuffer(36);
        buf.writeInt32(65536);
        buf.writeInt16(font.ascent);
        buf.writeInt16(font.descent);
        buf.writeInt16(0);
        buf.writeUint16(font.maxWidth);
        buf.writeInt16(font.minLsb);
        buf.writeInt16(font.minRsb);
        buf.writeInt16(font.maxExtent);
        buf.writeInt16(1);
        buf.writeInt16(0);
        buf.writeUint32(0);
        buf.writeUint32(0);
        buf.writeUint16(0);
        buf.writeInt16(0);
        buf.writeUint16(font.glyphs.length);
        return buf;
      }
      module.exports = createHHeadTable;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/hmtx.js
  var require_hmtx = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/hmtx.js"(exports, module) {
      "use strict";
      init_shim();
      var _ = require_lodash();
      var ByteBuffer = require_microbuffer();
      function createHtmxTable(font) {
        var buf = new ByteBuffer(font.glyphs.length * 4);
        _.forEach(font.glyphs, function(glyph) {
          buf.writeUint16(glyph.width);
          buf.writeInt16(glyph.xMin);
        });
        return buf;
      }
      module.exports = createHtmxTable;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/loca.js
  var require_loca = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/loca.js"(exports, module) {
      "use strict";
      init_shim();
      var _ = require_lodash();
      var ByteBuffer = require_microbuffer();
      function tableSize(font, isShortFormat) {
        var result = (font.glyphs.length + 1) * (isShortFormat ? 2 : 4);
        return result;
      }
      function createLocaTable(font) {
        var isShortFormat = font.ttf_glyph_size < 131072;
        var buf = new ByteBuffer(tableSize(font, isShortFormat));
        var location2 = 0;
        _.forEach(font.glyphs, function(glyph) {
          if (isShortFormat) {
            buf.writeUint16(location2);
            location2 += glyph.ttf_size / 2;
          } else {
            buf.writeUint32(location2);
            location2 += glyph.ttf_size;
          }
        });
        if (isShortFormat) {
          buf.writeUint16(location2);
        } else {
          buf.writeUint32(location2);
        }
        return buf;
      }
      module.exports = createLocaTable;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/maxp.js
  var require_maxp = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/maxp.js"(exports, module) {
      "use strict";
      init_shim();
      var _ = require_lodash();
      var ByteBuffer = require_microbuffer();
      function getMaxPoints(font) {
        return _.max(_.map(font.glyphs, function(glyph) {
          return _.reduce(glyph.ttfContours, function(sum, ctr) {
            return sum + ctr.length;
          }, 0);
        }));
      }
      function getMaxContours(font) {
        return _.max(_.map(font.glyphs, function(glyph) {
          return glyph.ttfContours.length;
        }));
      }
      function createMaxpTable(font) {
        var buf = new ByteBuffer(32);
        buf.writeInt32(65536);
        buf.writeUint16(font.glyphs.length);
        buf.writeUint16(getMaxPoints(font));
        buf.writeUint16(getMaxContours(font));
        buf.writeUint16(0);
        buf.writeUint16(0);
        buf.writeUint16(2);
        buf.writeUint16(0);
        buf.writeUint16(10);
        buf.writeUint16(10);
        buf.writeUint16(0);
        buf.writeUint16(255);
        buf.writeUint16(0);
        buf.writeUint16(0);
        buf.writeUint16(0);
        return buf;
      }
      module.exports = createMaxpTable;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/str.js
  var require_str = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/str.js"(exports, module) {
      "use strict";
      init_shim();
      function Str(str) {
        if (!(this instanceof Str)) {
          return new Str(str);
        }
        this.str = str;
        this.toUTF8Bytes = function() {
          var byteArray = [];
          for (var i2 = 0; i2 < str.length; i2++) {
            if (str.charCodeAt(i2) <= 127) {
              byteArray.push(str.charCodeAt(i2));
            } else {
              var h2 = encodeURIComponent(str.charAt(i2)).substr(1).split("%");
              for (var j = 0; j < h2.length; j++) {
                byteArray.push(parseInt(h2[j], 16));
              }
            }
          }
          return byteArray;
        };
        this.toUCS2Bytes = function() {
          var byteArray = [];
          var ch;
          for (var i2 = 0; i2 < str.length; ++i2) {
            ch = str.charCodeAt(i2);
            byteArray.push(ch >> 8);
            byteArray.push(ch & 255);
          }
          return byteArray;
        };
      }
      module.exports = Str;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/name.js
  var require_name = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/name.js"(exports, module) {
      "use strict";
      init_shim();
      var _ = require_lodash();
      var ByteBuffer = require_microbuffer();
      var Str = require_str();
      var TTF_NAMES = {
        COPYRIGHT: 0,
        FONT_FAMILY: 1,
        ID: 3,
        DESCRIPTION: 10,
        URL_VENDOR: 11
      };
      function tableSize(names) {
        var result = 6;
        _.forEach(names, function(name) {
          result += 12 + name.data.length;
        });
        return result;
      }
      function getStrings(name, id) {
        var result = [];
        var str = new Str(name);
        result.push({ data: str.toUTF8Bytes(), id, platformID: 1, encodingID: 0, languageID: 0 });
        result.push({ data: str.toUCS2Bytes(), id, platformID: 3, encodingID: 1, languageID: 1033 });
        return result;
      }
      function getNames(font) {
        var result = [];
        if (font.copyright) {
          result.push.apply(result, getStrings(font.copyright, TTF_NAMES.COPYRIGHT));
        }
        if (font.familyName) {
          result.push.apply(result, getStrings(font.familyName, TTF_NAMES.FONT_FAMILY));
        }
        if (font.id) {
          result.push.apply(result, getStrings(font.id, TTF_NAMES.ID));
        }
        result.push.apply(result, getStrings(font.description, TTF_NAMES.DESCRIPTION));
        result.push.apply(result, getStrings(font.url, TTF_NAMES.URL_VENDOR));
        _.forEach(font.sfntNames, function(sfntName) {
          result.push.apply(result, getStrings(sfntName.value, sfntName.id));
        });
        result.sort(function(a2, b2) {
          var orderFields = ["platformID", "encodingID", "languageID", "id"];
          var i2;
          for (i2 = 0; i2 < orderFields.length; i2++) {
            if (a2[orderFields[i2]] !== b2[orderFields[i2]]) {
              return a2[orderFields[i2]] < b2[orderFields[i2]] ? -1 : 1;
            }
          }
          return 0;
        });
        return result;
      }
      function createNameTable(font) {
        var names = getNames(font);
        var buf = new ByteBuffer(tableSize(names));
        buf.writeUint16(0);
        buf.writeUint16(names.length);
        var offsetPosition = buf.tell();
        buf.writeUint16(0);
        var nameOffset = 0;
        _.forEach(names, function(name) {
          buf.writeUint16(name.platformID);
          buf.writeUint16(name.encodingID);
          buf.writeUint16(name.languageID);
          buf.writeUint16(name.id);
          buf.writeUint16(name.data.length);
          buf.writeUint16(nameOffset);
          nameOffset += name.data.length;
        });
        var actualStringDataOffset = buf.tell();
        _.forEach(names, function(name) {
          buf.writeBytes(name.data);
        });
        buf.seek(offsetPosition);
        buf.writeUint16(actualStringDataOffset);
        return buf;
      }
      module.exports = createNameTable;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/post.js
  var require_post = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf/tables/post.js"(exports, module) {
      "use strict";
      init_shim();
      var _ = require_lodash();
      var ByteBuffer = require_microbuffer();
      function tableSize(font, names) {
        var result = 36;
        result += font.glyphs.length * 2;
        _.forEach(names, function(name) {
          result += name.length;
        });
        return result;
      }
      function pascalString(str) {
        var bytes = [];
        var len = str ? str.length < 256 ? str.length : 255 : 0;
        bytes.push(len);
        for (var i2 = 0; i2 < len; i2++) {
          var char = str.charCodeAt(i2);
          bytes.push(char < 128 ? char : 95);
        }
        return bytes;
      }
      function createPostTable(font) {
        var names = [];
        _.forEach(font.glyphs, function(glyph) {
          if (glyph.unicode !== 0) {
            names.push(pascalString(glyph.name));
          }
        });
        var buf = new ByteBuffer(tableSize(font, names));
        buf.writeInt32(131072);
        buf.writeInt32(font.italicAngle);
        buf.writeInt16(font.underlinePosition);
        buf.writeInt16(font.underlineThickness);
        buf.writeUint32(font.isFixedPitch);
        buf.writeUint32(0);
        buf.writeUint32(0);
        buf.writeUint32(0);
        buf.writeUint32(0);
        buf.writeUint16(font.glyphs.length);
        var index = 258;
        _.forEach(font.glyphs, function(glyph) {
          if (glyph.unicode === 0) {
            buf.writeUint16(0);
          } else {
            buf.writeUint16(index++);
          }
        });
        _.forEach(names, function(name) {
          buf.writeBytes(name);
        });
        return buf;
      }
      module.exports = createPostTable;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf.js
  var require_ttf = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/ttf.js"(exports, module) {
      "use strict";
      init_shim();
      var _ = require_lodash();
      var ByteBuffer = require_microbuffer();
      var createGSUBTable = require_gsub();
      var createOS2Table = require_os2();
      var createCMapTable = require_cmap();
      var createGlyfTable = require_glyf();
      var createHeadTable = require_head();
      var createHHeadTable = require_hhea();
      var createHtmxTable = require_hmtx();
      var createLocaTable = require_loca();
      var createMaxpTable = require_maxp();
      var createNameTable = require_name();
      var createPostTable = require_post();
      var utils = require_utils();
      var TABLES = [
        { innerName: "GSUB", order: 4, create: createGSUBTable },
        // GSUB
        { innerName: "OS/2", order: 4, create: createOS2Table },
        // OS/2
        { innerName: "cmap", order: 6, create: createCMapTable },
        // cmap
        { innerName: "glyf", order: 8, create: createGlyfTable },
        // glyf
        { innerName: "head", order: 2, create: createHeadTable },
        // head
        { innerName: "hhea", order: 1, create: createHHeadTable },
        // hhea
        { innerName: "hmtx", order: 5, create: createHtmxTable },
        // hmtx
        { innerName: "loca", order: 7, create: createLocaTable },
        // loca
        { innerName: "maxp", order: 3, create: createMaxpTable },
        // maxp
        { innerName: "name", order: 9, create: createNameTable },
        // name
        { innerName: "post", order: 10, create: createPostTable }
        // post
      ];
      var CONST = {
        VERSION: 65536,
        CHECKSUM_ADJUSTMENT: 2981146554
      };
      function ulong(t2) {
        t2 &= 4294967295;
        if (t2 < 0) {
          t2 += 4294967296;
        }
        return t2;
      }
      function calc_checksum(buf) {
        var sum = 0;
        var nlongs = Math.floor(buf.length / 4);
        var i2;
        for (i2 = 0; i2 < nlongs; ++i2) {
          var t2 = buf.getUint32(i2 * 4);
          sum = ulong(sum + t2);
        }
        var leftBytes = buf.length - nlongs * 4;
        if (leftBytes > 0) {
          var leftRes = 0;
          for (i2 = 0; i2 < 4; i2++) {
            leftRes = (leftRes << 8) + (i2 < leftBytes ? buf.getUint8(nlongs * 4 + i2) : 0);
          }
          sum = ulong(sum + leftRes);
        }
        return sum;
      }
      function generateTTF(font) {
        _.forEach(font.glyphs, function(glyph) {
          glyph.ttfContours = _.map(glyph.contours, function(contour) {
            return contour.points;
          });
        });
        _.forEach(font.glyphs, function(glyph) {
          glyph.ttfContours = utils.simplify(glyph.ttfContours, 0.3);
          glyph.ttfContours = utils.simplify(glyph.ttfContours, 0.3);
          glyph.ttfContours = utils.interpolate(glyph.ttfContours, 1.1);
          glyph.ttfContours = utils.roundPoints(glyph.ttfContours);
          glyph.ttfContours = utils.removeClosingReturnPoints(glyph.ttfContours);
          glyph.ttfContours = utils.toRelative(glyph.ttfContours);
        });
        var headerSize = 12 + 16 * TABLES.length;
        var bufSize = headerSize;
        _.forEach(TABLES, function(table) {
          table.buffer = table.create(font);
          table.length = table.buffer.length;
          table.corLength = table.length + (4 - table.length % 4) % 4;
          table.checkSum = calc_checksum(table.buffer);
          bufSize += table.corLength;
        });
        var offset = headerSize;
        _.forEach(_.sortBy(TABLES, "order"), function(table) {
          table.offset = offset;
          offset += table.corLength;
        });
        var buf = new ByteBuffer(bufSize);
        var entrySelector = Math.floor(Math.log(TABLES.length) / Math.LN2);
        var searchRange = Math.pow(2, entrySelector) * 16;
        var rangeShift = TABLES.length * 16 - searchRange;
        buf.writeUint32(CONST.VERSION);
        buf.writeUint16(TABLES.length);
        buf.writeUint16(searchRange);
        buf.writeUint16(entrySelector);
        buf.writeUint16(rangeShift);
        _.forEach(TABLES, function(table) {
          buf.writeUint32(utils.identifier(table.innerName));
          buf.writeUint32(table.checkSum);
          buf.writeUint32(table.offset);
          buf.writeUint32(table.length);
        });
        var headOffset = 0;
        _.forEach(_.sortBy(TABLES, "order"), function(table) {
          if (table.innerName === "head") {
            headOffset = buf.tell();
          }
          buf.writeBytes(table.buffer.buffer);
          for (var i2 = table.length; i2 < table.corLength; i2++) {
            buf.writeUint8(0);
          }
        });
        buf.setUint32(headOffset + 8, ulong(CONST.CHECKSUM_ADJUSTMENT - calc_checksum(buf)));
        return buf;
      }
      module.exports = generateTTF;
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/sfnt.js
  var require_sfnt = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/lib/sfnt.js"(exports, module) {
      "use strict";
      init_shim();
      var _ = require_lodash();
      function Font() {
        this.ascent = 850;
        this.copyright = "";
        this.createdDate = /* @__PURE__ */ new Date();
        this.glyphs = [];
        this.ligatures = [];
        this.codePoints = {};
        this.isFixedPitch = 0;
        this.italicAngle = 0;
        this.familyClass = 0;
        this.familyName = "";
        this.fsSelection = 64 | 128;
        this.fsType = 0;
        this.lowestRecPPEM = 8;
        this.macStyle = 0;
        this.modifiedDate = /* @__PURE__ */ new Date();
        this.panose = {
          familyType: 2,
          // Latin Text
          serifStyle: 0,
          // any
          weight: 5,
          // book
          proportion: 3,
          //modern
          contrast: 0,
          //any
          strokeVariation: 0,
          //any,
          armStyle: 0,
          //any,
          letterform: 0,
          //any,
          midline: 0,
          //any,
          xHeight: 0
          //any,
        };
        this.revision = 1;
        this.sfntNames = [];
        this.underlineThickness = 0;
        this.unitsPerEm = 1e3;
        this.weightClass = 400;
        this.width = 1e3;
        this.widthClass = 5;
        this.ySubscriptXOffset = 0;
        this.ySuperscriptXOffset = 0;
        this.int_descent = -150;
        this.xHeight = 0;
        this.capHeight = 0;
        Object.defineProperty(this, "descent", {
          get: function() {
            return this.int_descent;
          },
          set: function(value) {
            this.int_descent = parseInt(Math.round(-Math.abs(value)), 10);
          }
        });
        this.__defineGetter__("avgCharWidth", function() {
          if (this.glyphs.length === 0) {
            return 0;
          }
          var widths = _.map(this.glyphs, "width");
          return parseInt(widths.reduce(function(prev, cur) {
            return prev + cur;
          }) / widths.length, 10);
        });
        Object.defineProperty(this, "ySubscriptXSize", {
          get: function() {
            return parseInt(!_.isUndefined(this.int_ySubscriptXSize) ? this.int_ySubscriptXSize : this.width * 0.6347, 10);
          },
          set: function(value) {
            this.int_ySubscriptXSize = value;
          }
        });
        Object.defineProperty(this, "ySubscriptYSize", {
          get: function() {
            return parseInt(!_.isUndefined(this.int_ySubscriptYSize) ? this.int_ySubscriptYSize : (this.ascent - this.descent) * 0.7, 10);
          },
          set: function(value) {
            this.int_ySubscriptYSize = value;
          }
        });
        Object.defineProperty(this, "ySubscriptYOffset", {
          get: function() {
            return parseInt(!_.isUndefined(this.int_ySubscriptYOffset) ? this.int_ySubscriptYOffset : (this.ascent - this.descent) * 0.14, 10);
          },
          set: function(value) {
            this.int_ySubscriptYOffset = value;
          }
        });
        Object.defineProperty(this, "ySuperscriptXSize", {
          get: function() {
            return parseInt(!_.isUndefined(this.int_ySuperscriptXSize) ? this.int_ySuperscriptXSize : this.width * 0.6347, 10);
          },
          set: function(value) {
            this.int_ySuperscriptXSize = value;
          }
        });
        Object.defineProperty(this, "ySuperscriptYSize", {
          get: function() {
            return parseInt(!_.isUndefined(this.int_ySuperscriptYSize) ? this.int_ySuperscriptYSize : (this.ascent - this.descent) * 0.7, 10);
          },
          set: function(value) {
            this.int_ySuperscriptYSize = value;
          }
        });
        Object.defineProperty(this, "ySuperscriptYOffset", {
          get: function() {
            return parseInt(!_.isUndefined(this.int_ySuperscriptYOffset) ? this.int_ySuperscriptYOffset : (this.ascent - this.descent) * 0.48, 10);
          },
          set: function(value) {
            this.int_ySuperscriptYOffset = value;
          }
        });
        Object.defineProperty(this, "yStrikeoutSize", {
          get: function() {
            return parseInt(!_.isUndefined(this.int_yStrikeoutSize) ? this.int_yStrikeoutSize : (this.ascent - this.descent) * 0.049, 10);
          },
          set: function(value) {
            this.int_yStrikeoutSize = value;
          }
        });
        Object.defineProperty(this, "yStrikeoutPosition", {
          get: function() {
            return parseInt(!_.isUndefined(this.int_yStrikeoutPosition) ? this.int_yStrikeoutPosition : (this.ascent - this.descent) * 0.258, 10);
          },
          set: function(value) {
            this.int_yStrikeoutPosition = value;
          }
        });
        Object.defineProperty(this, "minLsb", {
          get: function() {
            return parseInt(_.min(_.map(this.glyphs, "xMin")), 10);
          }
        });
        Object.defineProperty(this, "minRsb", {
          get: function() {
            if (!this.glyphs.length) return parseInt(this.width, 10);
            return parseInt(_.reduce(this.glyphs, function(minRsb, glyph) {
              return Math.min(minRsb, glyph.width - glyph.xMax);
            }, 0), 10);
          }
        });
        Object.defineProperty(this, "xMin", {
          get: function() {
            if (!this.glyphs.length) return this.width;
            return _.reduce(this.glyphs, function(xMin, glyph) {
              return Math.min(xMin, glyph.xMin);
            }, 0);
          }
        });
        Object.defineProperty(this, "yMin", {
          get: function() {
            if (!this.glyphs.length) return this.width;
            return _.reduce(this.glyphs, function(yMin, glyph) {
              return Math.min(yMin, glyph.yMin);
            }, 0);
          }
        });
        Object.defineProperty(this, "xMax", {
          get: function() {
            if (!this.glyphs.length) return this.width;
            return _.reduce(this.glyphs, function(xMax, glyph) {
              return Math.max(xMax, glyph.xMax);
            }, 0);
          }
        });
        Object.defineProperty(this, "yMax", {
          get: function() {
            if (!this.glyphs.length) return this.width;
            return _.reduce(this.glyphs, function(yMax, glyph) {
              return Math.max(yMax, glyph.yMax);
            }, 0);
          }
        });
        Object.defineProperty(this, "avgWidth", {
          get: function() {
            var len = this.glyphs.length;
            if (len === 0) {
              return this.width;
            }
            var sumWidth = _.reduce(this.glyphs, function(sumWidth2, glyph) {
              return sumWidth2 + glyph.width;
            }, 0);
            return Math.round(sumWidth / len);
          }
        });
        Object.defineProperty(this, "maxWidth", {
          get: function() {
            if (!this.glyphs.length) return this.width;
            return _.reduce(this.glyphs, function(maxWidth, glyph) {
              return Math.max(maxWidth, glyph.width);
            }, 0);
          }
        });
        Object.defineProperty(this, "maxExtent", {
          get: function() {
            if (!this.glyphs.length) return this.width;
            return _.reduce(this.glyphs, function(maxExtent, glyph) {
              return Math.max(
                maxExtent,
                glyph.xMax
                /*- glyph.xMin*/
              );
            }, 0);
          }
        });
        Object.defineProperty(this, "lineGap", {
          get: function() {
            return parseInt(!_.isUndefined(this.int_lineGap) ? this.int_lineGap : (this.ascent - this.descent) * 0.09, 10);
          },
          set: function(value) {
            this.int_lineGap = value;
          }
        });
        Object.defineProperty(this, "underlinePosition", {
          get: function() {
            return parseInt(!_.isUndefined(this.int_underlinePosition) ? this.int_underlinePosition : (this.ascent - this.descent) * 0.01, 10);
          },
          set: function(value) {
            this.int_underlinePosition = value;
          }
        });
      }
      function Glyph() {
        this.contours = [];
        this.d = "";
        this.id = "";
        this.codes = [];
        this.height = 0;
        this.name = "";
        this.width = 0;
      }
      Object.defineProperty(Glyph.prototype, "xMin", {
        get: function() {
          var xMin = 0;
          var hasPoints = false;
          _.forEach(this.contours, function(contour) {
            _.forEach(contour.points, function(point) {
              xMin = Math.min(xMin, Math.floor(point.x));
              hasPoints = true;
            });
          });
          if (xMin < -32768) {
            throw new Error("xMin value for glyph " + (this.name ? '"' + this.name + '"' : JSON.stringify(this.codes)) + " is out of bounds (actual " + xMin + ', expected -32768..32767, d="' + this.d + '")');
          }
          return hasPoints ? xMin : 0;
        }
      });
      Object.defineProperty(Glyph.prototype, "xMax", {
        get: function() {
          var xMax = 0;
          var hasPoints = false;
          _.forEach(this.contours, function(contour) {
            _.forEach(contour.points, function(point) {
              xMax = Math.max(xMax, -Math.floor(-point.x));
              hasPoints = true;
            });
          });
          if (xMax > 32767) {
            throw new Error("xMax value for glyph " + (this.name ? '"' + this.name + '"' : JSON.stringify(this.codes)) + " is out of bounds (actual " + xMax + ', expected -32768..32767, d="' + this.d + '")');
          }
          return hasPoints ? xMax : this.width;
        }
      });
      Object.defineProperty(Glyph.prototype, "yMin", {
        get: function() {
          var yMin = 0;
          var hasPoints = false;
          _.forEach(this.contours, function(contour) {
            _.forEach(contour.points, function(point) {
              yMin = Math.min(yMin, Math.floor(point.y));
              hasPoints = true;
            });
          });
          if (yMin < -32768) {
            throw new Error("yMin value for glyph " + (this.name ? '"' + this.name + '"' : JSON.stringify(this.codes)) + " is out of bounds (actual " + yMin + ', expected -32768..32767, d="' + this.d + '")');
          }
          return hasPoints ? yMin : 0;
        }
      });
      Object.defineProperty(Glyph.prototype, "yMax", {
        get: function() {
          var yMax = 0;
          var hasPoints = false;
          _.forEach(this.contours, function(contour) {
            _.forEach(contour.points, function(point) {
              yMax = Math.max(yMax, -Math.floor(-point.y));
              hasPoints = true;
            });
          });
          if (yMax > 32767) {
            throw new Error("yMax value for glyph " + (this.name ? '"' + this.name + '"' : JSON.stringify(this.codes)) + " is out of bounds (actual " + yMax + ', expected -32768..32767, d="' + this.d + '")');
          }
          return hasPoints ? yMax : 0;
        }
      });
      function Contour() {
        this.points = [];
      }
      function Point() {
        this.onCurve = true;
        this.x = 0;
        this.y = 0;
      }
      function SfntName() {
        this.id = 0;
        this.value = "";
      }
      module.exports.Font = Font;
      module.exports.Glyph = Glyph;
      module.exports.Contour = Contour;
      module.exports.Point = Point;
      module.exports.SfntName = SfntName;
      module.exports.toTTF = require_ttf();
    }
  });

  // node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/index.js
  var require_svg2ttf = __commonJS({
    "node_modules/.pnpm/svg2ttf@6.0.3/node_modules/svg2ttf/index.js"(exports, module) {
      "use strict";
      init_shim();
      var _ = require_lodash();
      var SvgPath = require_svgpath2();
      var ucs2 = require_ucs2();
      var svg = require_svg();
      var sfnt = require_sfnt();
      var VERSION_RE = /^(Version )?(\d+[.]\d+)$/i;
      function svg2ttf2(svgString, options) {
        var font = new sfnt.Font();
        var svgFont = svg.load(svgString);
        options = options || {};
        font.id = options.id || svgFont.id;
        font.familyName = options.familyname || svgFont.familyName || svgFont.id;
        font.copyright = options.copyright || svgFont.metadata;
        font.description = options.description || "Generated by svg2ttf from Fontello project.";
        font.url = options.url || "http://fontello.com";
        font.sfntNames.push({ id: 2, value: options.subfamilyname || svgFont.subfamilyName || "Regular" });
        font.sfntNames.push({ id: 4, value: options.fullname || svgFont.id });
        var versionString = options.version || "Version 1.0";
        if (typeof versionString !== "string") {
          throw new Error("svg2ttf: version option should be a string");
        }
        if (!VERSION_RE.test(versionString)) {
          throw new Error('svg2ttf: invalid option, version - "' + options.version + '"');
        }
        versionString = "Version " + versionString.match(VERSION_RE)[2];
        font.sfntNames.push({ id: 5, value: versionString });
        font.sfntNames.push({ id: 6, value: (options.fullname || svgFont.id).replace(/[\s\(\)\[\]<>%\/]/g, "").substr(0, 62) });
        if (typeof options.ts !== "undefined") {
          font.createdDate = font.modifiedDate = new Date(parseInt(options.ts, 10) * 1e3);
        }
        font.unitsPerEm = svgFont.unitsPerEm || 1e3;
        font.horizOriginX = svgFont.horizOriginX || 0;
        font.horizOriginY = svgFont.horizOriginY || 0;
        font.vertOriginX = svgFont.vertOriginX || 0;
        font.vertOriginY = svgFont.vertOriginY || 0;
        font.width = svgFont.width || svgFont.unitsPerEm;
        font.height = svgFont.height || svgFont.unitsPerEm;
        font.descent = !isNaN(svgFont.descent) ? svgFont.descent : -font.vertOriginY;
        font.ascent = svgFont.ascent || font.unitsPerEm - font.vertOriginY;
        font.capHeight = svgFont.capHeight || 0;
        font.xHeight = svgFont.xHeight || 0;
        if (typeof svgFont.weightClass !== "undefined") {
          var wght = parseInt(svgFont.weightClass, 10);
          if (!isNaN(wght)) font.weightClass = wght;
          else {
            if (svgFont.weightClass === "normal") font.weightClass = 400;
            if (svgFont.weightClass === "bold") font.weightClass = 700;
          }
        }
        if (typeof svgFont.underlinePosition !== "undefined") {
          font.underlinePosition = svgFont.underlinePosition;
        }
        if (typeof svgFont.underlineThickness !== "undefined") {
          font.underlineThickness = svgFont.underlineThickness;
        }
        var glyphs = font.glyphs;
        var codePoints = font.codePoints;
        var ligatures = font.ligatures;
        function addCodePoint(codePoint, glyph) {
          if (codePoints[codePoint]) {
            return false;
          }
          codePoints[codePoint] = glyph;
          return true;
        }
        _.forEach(svgFont.glyphs, function(svgGlyph) {
          var glyph = new sfnt.Glyph();
          glyph.name = svgGlyph.name;
          glyph.codes = svgGlyph.ligatureCodes || svgGlyph.unicode;
          glyph.d = svgGlyph.d;
          glyph.height = !isNaN(svgGlyph.height) ? svgGlyph.height : font.height;
          glyph.width = !isNaN(svgGlyph.width) ? svgGlyph.width : font.width;
          glyphs.push(glyph);
          svgGlyph.sfntGlyph = glyph;
          _.forEach(svgGlyph.unicode, function(codePoint) {
            addCodePoint(codePoint, glyph);
          });
        });
        var missingGlyph;
        if (svgFont.missingGlyph) {
          missingGlyph = new sfnt.Glyph();
          missingGlyph.d = svgFont.missingGlyph.d;
          missingGlyph.height = !isNaN(svgFont.missingGlyph.height) ? svgFont.missingGlyph.height : font.height;
          missingGlyph.width = !isNaN(svgFont.missingGlyph.width) ? svgFont.missingGlyph.width : font.width;
        } else {
          missingGlyph = _.find(glyphs, function(glyph) {
            return glyph.name === ".notdef";
          });
        }
        if (!missingGlyph) {
          missingGlyph = new sfnt.Glyph();
        }
        _.forEach(svgFont.ligatures, function(svgLigature) {
          var ligature = {
            ligature: svgLigature.ligature,
            unicode: svgLigature.unicode,
            glyph: svgLigature.glyph.sfntGlyph
          };
          _.forEach(ligature.unicode, function(charPoint) {
            var glyph = new sfnt.Glyph();
            var added = addCodePoint(charPoint, glyph);
            if (added) {
              glyph.name = ucs2.encode([charPoint]);
              glyphs.push(glyph);
            }
          });
          ligatures.push(ligature);
        });
        if (glyphs.indexOf(missingGlyph) !== -1) {
          glyphs.splice(glyphs.indexOf(missingGlyph), 1);
        }
        glyphs.unshift(missingGlyph);
        var nextID = 0;
        _.forEach(glyphs, function(glyph) {
          glyph.id = nextID;
          nextID++;
        });
        _.forEach(glyphs, function(glyph) {
          var glyphSize = Math.max(glyph.width, glyph.height);
          var accuracy = glyphSize > 500 ? 0.3 : glyphSize * 6e-4;
          var svgPath = new SvgPath(glyph.d).abs().unshort().unarc().iterate(function(segment, index, x, y2) {
            return svg.cubicToQuad(segment, index, x, y2, accuracy);
          });
          var sfntContours = svg.toSfntCoutours(svgPath);
          glyph.contours = _.map(sfntContours, function(sfntContour) {
            var contour = new sfnt.Contour();
            contour.points = _.map(sfntContour, function(sfntPoint) {
              var point = new sfnt.Point();
              point.x = sfntPoint.x;
              point.y = sfntPoint.y;
              point.onCurve = sfntPoint.onCurve;
              return point;
            });
            return contour;
          });
        });
        var ttf = sfnt.toTTF(font);
        return ttf;
      }
      module.exports = svg2ttf2;
    }
  });

  // node_modules/.pnpm/sax@1.4.1/node_modules/sax/lib/sax.js
  var require_sax2 = __commonJS({
    "node_modules/.pnpm/sax@1.4.1/node_modules/sax/lib/sax.js"(exports) {
      init_shim();
      (function(sax) {
        sax.parser = function(strict, opt) {
          return new SAXParser(strict, opt);
        };
        sax.SAXParser = SAXParser;
        sax.SAXStream = SAXStream;
        sax.createStream = createStream;
        sax.MAX_BUFFER_LENGTH = 64 * 1024;
        var buffers = [
          "comment",
          "sgmlDecl",
          "textNode",
          "tagName",
          "doctype",
          "procInstName",
          "procInstBody",
          "entity",
          "attribName",
          "attribValue",
          "cdata",
          "script"
        ];
        sax.EVENTS = [
          "text",
          "processinginstruction",
          "sgmldeclaration",
          "doctype",
          "comment",
          "opentagstart",
          "attribute",
          "opentag",
          "closetag",
          "opencdata",
          "cdata",
          "closecdata",
          "error",
          "end",
          "ready",
          "script",
          "opennamespace",
          "closenamespace"
        ];
        function SAXParser(strict, opt) {
          if (!(this instanceof SAXParser)) {
            return new SAXParser(strict, opt);
          }
          var parser = this;
          clearBuffers(parser);
          parser.q = parser.c = "";
          parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
          parser.opt = opt || {};
          parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
          parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
          parser.tags = [];
          parser.closed = parser.closedRoot = parser.sawRoot = false;
          parser.tag = parser.error = null;
          parser.strict = !!strict;
          parser.noscript = !!(strict || parser.opt.noscript);
          parser.state = S2.BEGIN;
          parser.strictEntities = parser.opt.strictEntities;
          parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
          parser.attribList = [];
          if (parser.opt.xmlns) {
            parser.ns = Object.create(rootNS);
          }
          if (parser.opt.unquotedAttributeValues === void 0) {
            parser.opt.unquotedAttributeValues = !strict;
          }
          parser.trackPosition = parser.opt.position !== false;
          if (parser.trackPosition) {
            parser.position = parser.line = parser.column = 0;
          }
          emit2(parser, "onready");
        }
        if (!Object.create) {
          Object.create = function(o2) {
            function F() {
            }
            F.prototype = o2;
            var newf = new F();
            return newf;
          };
        }
        if (!Object.keys) {
          Object.keys = function(o2) {
            var a2 = [];
            for (var i2 in o2) if (o2.hasOwnProperty(i2)) a2.push(i2);
            return a2;
          };
        }
        function checkBufferLength(parser) {
          var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
          var maxActual = 0;
          for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
            var len = parser[buffers[i2]].length;
            if (len > maxAllowed) {
              switch (buffers[i2]) {
                case "textNode":
                  closeText(parser);
                  break;
                case "cdata":
                  emitNode(parser, "oncdata", parser.cdata);
                  parser.cdata = "";
                  break;
                case "script":
                  emitNode(parser, "onscript", parser.script);
                  parser.script = "";
                  break;
                default:
                  error(parser, "Max buffer length exceeded: " + buffers[i2]);
              }
            }
            maxActual = Math.max(maxActual, len);
          }
          var m = sax.MAX_BUFFER_LENGTH - maxActual;
          parser.bufferCheckPosition = m + parser.position;
        }
        function clearBuffers(parser) {
          for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
            parser[buffers[i2]] = "";
          }
        }
        function flushBuffers(parser) {
          closeText(parser);
          if (parser.cdata !== "") {
            emitNode(parser, "oncdata", parser.cdata);
            parser.cdata = "";
          }
          if (parser.script !== "") {
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }
        }
        SAXParser.prototype = {
          end: function() {
            end(this);
          },
          write,
          resume: function() {
            this.error = null;
            return this;
          },
          close: function() {
            return this.write(null);
          },
          flush: function() {
            flushBuffers(this);
          }
        };
        var Stream;
        try {
          Stream = require_stream_browserify().Stream;
        } catch (ex) {
          Stream = function() {
          };
        }
        if (!Stream) Stream = function() {
        };
        var streamWraps = sax.EVENTS.filter(function(ev) {
          return ev !== "error" && ev !== "end";
        });
        function createStream(strict, opt) {
          return new SAXStream(strict, opt);
        }
        function SAXStream(strict, opt) {
          if (!(this instanceof SAXStream)) {
            return new SAXStream(strict, opt);
          }
          Stream.apply(this);
          this._parser = new SAXParser(strict, opt);
          this.writable = true;
          this.readable = true;
          var me = this;
          this._parser.onend = function() {
            me.emit("end");
          };
          this._parser.onerror = function(er) {
            me.emit("error", er);
            me._parser.error = null;
          };
          this._decoder = null;
          streamWraps.forEach(function(ev) {
            Object.defineProperty(me, "on" + ev, {
              get: function() {
                return me._parser["on" + ev];
              },
              set: function(h2) {
                if (!h2) {
                  me.removeAllListeners(ev);
                  me._parser["on" + ev] = h2;
                  return h2;
                }
                me.on(ev, h2);
              },
              enumerable: true,
              configurable: false
            });
          });
        }
        SAXStream.prototype = Object.create(Stream.prototype, {
          constructor: {
            value: SAXStream
          }
        });
        SAXStream.prototype.write = function(data) {
          if (typeof import_buffer.Buffer === "function" && typeof import_buffer.Buffer.isBuffer === "function" && import_buffer.Buffer.isBuffer(data)) {
            if (!this._decoder) {
              var SD = require_string_decoder().StringDecoder;
              this._decoder = new SD("utf8");
            }
            data = this._decoder.write(data);
          }
          this._parser.write(data.toString());
          this.emit("data", data);
          return true;
        };
        SAXStream.prototype.end = function(chunk) {
          if (chunk && chunk.length) {
            this.write(chunk);
          }
          this._parser.end();
          return true;
        };
        SAXStream.prototype.on = function(ev, handler) {
          var me = this;
          if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
            me._parser["on" + ev] = function() {
              var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
              args.splice(0, 0, ev);
              me.emit.apply(me, args);
            };
          }
          return Stream.prototype.on.call(me, ev, handler);
        };
        var CDATA = "[CDATA[";
        var DOCTYPE = "DOCTYPE";
        var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
        var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
        var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
        var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
        var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
        var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
        var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
        function isWhitespace(c) {
          return c === " " || c === "\n" || c === "\r" || c === "	";
        }
        function isQuote(c) {
          return c === '"' || c === "'";
        }
        function isAttribEnd(c) {
          return c === ">" || isWhitespace(c);
        }
        function isMatch(regex, c) {
          return regex.test(c);
        }
        function notMatch(regex, c) {
          return !isMatch(regex, c);
        }
        var S2 = 0;
        sax.STATE = {
          BEGIN: S2++,
          // leading byte order mark or whitespace
          BEGIN_WHITESPACE: S2++,
          // leading whitespace
          TEXT: S2++,
          // general stuff
          TEXT_ENTITY: S2++,
          // &amp and such.
          OPEN_WAKA: S2++,
          // <
          SGML_DECL: S2++,
          // <!BLARG
          SGML_DECL_QUOTED: S2++,
          // <!BLARG foo "bar
          DOCTYPE: S2++,
          // <!DOCTYPE
          DOCTYPE_QUOTED: S2++,
          // <!DOCTYPE "//blah
          DOCTYPE_DTD: S2++,
          // <!DOCTYPE "//blah" [ ...
          DOCTYPE_DTD_QUOTED: S2++,
          // <!DOCTYPE "//blah" [ "foo
          COMMENT_STARTING: S2++,
          // <!-
          COMMENT: S2++,
          // <!--
          COMMENT_ENDING: S2++,
          // <!-- blah -
          COMMENT_ENDED: S2++,
          // <!-- blah --
          CDATA: S2++,
          // <![CDATA[ something
          CDATA_ENDING: S2++,
          // ]
          CDATA_ENDING_2: S2++,
          // ]]
          PROC_INST: S2++,
          // <?hi
          PROC_INST_BODY: S2++,
          // <?hi there
          PROC_INST_ENDING: S2++,
          // <?hi "there" ?
          OPEN_TAG: S2++,
          // <strong
          OPEN_TAG_SLASH: S2++,
          // <strong /
          ATTRIB: S2++,
          // <a
          ATTRIB_NAME: S2++,
          // <a foo
          ATTRIB_NAME_SAW_WHITE: S2++,
          // <a foo _
          ATTRIB_VALUE: S2++,
          // <a foo=
          ATTRIB_VALUE_QUOTED: S2++,
          // <a foo="bar
          ATTRIB_VALUE_CLOSED: S2++,
          // <a foo="bar"
          ATTRIB_VALUE_UNQUOTED: S2++,
          // <a foo=bar
          ATTRIB_VALUE_ENTITY_Q: S2++,
          // <foo bar="&quot;"
          ATTRIB_VALUE_ENTITY_U: S2++,
          // <foo bar=&quot
          CLOSE_TAG: S2++,
          // </a
          CLOSE_TAG_SAW_WHITE: S2++,
          // </a   >
          SCRIPT: S2++,
          // <script> ...
          SCRIPT_ENDING: S2++
          // <script> ... <
        };
        sax.XML_ENTITIES = {
          "amp": "&",
          "gt": ">",
          "lt": "<",
          "quot": '"',
          "apos": "'"
        };
        sax.ENTITIES = {
          "amp": "&",
          "gt": ">",
          "lt": "<",
          "quot": '"',
          "apos": "'",
          "AElig": 198,
          "Aacute": 193,
          "Acirc": 194,
          "Agrave": 192,
          "Aring": 197,
          "Atilde": 195,
          "Auml": 196,
          "Ccedil": 199,
          "ETH": 208,
          "Eacute": 201,
          "Ecirc": 202,
          "Egrave": 200,
          "Euml": 203,
          "Iacute": 205,
          "Icirc": 206,
          "Igrave": 204,
          "Iuml": 207,
          "Ntilde": 209,
          "Oacute": 211,
          "Ocirc": 212,
          "Ograve": 210,
          "Oslash": 216,
          "Otilde": 213,
          "Ouml": 214,
          "THORN": 222,
          "Uacute": 218,
          "Ucirc": 219,
          "Ugrave": 217,
          "Uuml": 220,
          "Yacute": 221,
          "aacute": 225,
          "acirc": 226,
          "aelig": 230,
          "agrave": 224,
          "aring": 229,
          "atilde": 227,
          "auml": 228,
          "ccedil": 231,
          "eacute": 233,
          "ecirc": 234,
          "egrave": 232,
          "eth": 240,
          "euml": 235,
          "iacute": 237,
          "icirc": 238,
          "igrave": 236,
          "iuml": 239,
          "ntilde": 241,
          "oacute": 243,
          "ocirc": 244,
          "ograve": 242,
          "oslash": 248,
          "otilde": 245,
          "ouml": 246,
          "szlig": 223,
          "thorn": 254,
          "uacute": 250,
          "ucirc": 251,
          "ugrave": 249,
          "uuml": 252,
          "yacute": 253,
          "yuml": 255,
          "copy": 169,
          "reg": 174,
          "nbsp": 160,
          "iexcl": 161,
          "cent": 162,
          "pound": 163,
          "curren": 164,
          "yen": 165,
          "brvbar": 166,
          "sect": 167,
          "uml": 168,
          "ordf": 170,
          "laquo": 171,
          "not": 172,
          "shy": 173,
          "macr": 175,
          "deg": 176,
          "plusmn": 177,
          "sup1": 185,
          "sup2": 178,
          "sup3": 179,
          "acute": 180,
          "micro": 181,
          "para": 182,
          "middot": 183,
          "cedil": 184,
          "ordm": 186,
          "raquo": 187,
          "frac14": 188,
          "frac12": 189,
          "frac34": 190,
          "iquest": 191,
          "times": 215,
          "divide": 247,
          "OElig": 338,
          "oelig": 339,
          "Scaron": 352,
          "scaron": 353,
          "Yuml": 376,
          "fnof": 402,
          "circ": 710,
          "tilde": 732,
          "Alpha": 913,
          "Beta": 914,
          "Gamma": 915,
          "Delta": 916,
          "Epsilon": 917,
          "Zeta": 918,
          "Eta": 919,
          "Theta": 920,
          "Iota": 921,
          "Kappa": 922,
          "Lambda": 923,
          "Mu": 924,
          "Nu": 925,
          "Xi": 926,
          "Omicron": 927,
          "Pi": 928,
          "Rho": 929,
          "Sigma": 931,
          "Tau": 932,
          "Upsilon": 933,
          "Phi": 934,
          "Chi": 935,
          "Psi": 936,
          "Omega": 937,
          "alpha": 945,
          "beta": 946,
          "gamma": 947,
          "delta": 948,
          "epsilon": 949,
          "zeta": 950,
          "eta": 951,
          "theta": 952,
          "iota": 953,
          "kappa": 954,
          "lambda": 955,
          "mu": 956,
          "nu": 957,
          "xi": 958,
          "omicron": 959,
          "pi": 960,
          "rho": 961,
          "sigmaf": 962,
          "sigma": 963,
          "tau": 964,
          "upsilon": 965,
          "phi": 966,
          "chi": 967,
          "psi": 968,
          "omega": 969,
          "thetasym": 977,
          "upsih": 978,
          "piv": 982,
          "ensp": 8194,
          "emsp": 8195,
          "thinsp": 8201,
          "zwnj": 8204,
          "zwj": 8205,
          "lrm": 8206,
          "rlm": 8207,
          "ndash": 8211,
          "mdash": 8212,
          "lsquo": 8216,
          "rsquo": 8217,
          "sbquo": 8218,
          "ldquo": 8220,
          "rdquo": 8221,
          "bdquo": 8222,
          "dagger": 8224,
          "Dagger": 8225,
          "bull": 8226,
          "hellip": 8230,
          "permil": 8240,
          "prime": 8242,
          "Prime": 8243,
          "lsaquo": 8249,
          "rsaquo": 8250,
          "oline": 8254,
          "frasl": 8260,
          "euro": 8364,
          "image": 8465,
          "weierp": 8472,
          "real": 8476,
          "trade": 8482,
          "alefsym": 8501,
          "larr": 8592,
          "uarr": 8593,
          "rarr": 8594,
          "darr": 8595,
          "harr": 8596,
          "crarr": 8629,
          "lArr": 8656,
          "uArr": 8657,
          "rArr": 8658,
          "dArr": 8659,
          "hArr": 8660,
          "forall": 8704,
          "part": 8706,
          "exist": 8707,
          "empty": 8709,
          "nabla": 8711,
          "isin": 8712,
          "notin": 8713,
          "ni": 8715,
          "prod": 8719,
          "sum": 8721,
          "minus": 8722,
          "lowast": 8727,
          "radic": 8730,
          "prop": 8733,
          "infin": 8734,
          "ang": 8736,
          "and": 8743,
          "or": 8744,
          "cap": 8745,
          "cup": 8746,
          "int": 8747,
          "there4": 8756,
          "sim": 8764,
          "cong": 8773,
          "asymp": 8776,
          "ne": 8800,
          "equiv": 8801,
          "le": 8804,
          "ge": 8805,
          "sub": 8834,
          "sup": 8835,
          "nsub": 8836,
          "sube": 8838,
          "supe": 8839,
          "oplus": 8853,
          "otimes": 8855,
          "perp": 8869,
          "sdot": 8901,
          "lceil": 8968,
          "rceil": 8969,
          "lfloor": 8970,
          "rfloor": 8971,
          "lang": 9001,
          "rang": 9002,
          "loz": 9674,
          "spades": 9824,
          "clubs": 9827,
          "hearts": 9829,
          "diams": 9830
        };
        Object.keys(sax.ENTITIES).forEach(function(key) {
          var e2 = sax.ENTITIES[key];
          var s3 = typeof e2 === "number" ? String.fromCharCode(e2) : e2;
          sax.ENTITIES[key] = s3;
        });
        for (var s2 in sax.STATE) {
          sax.STATE[sax.STATE[s2]] = s2;
        }
        S2 = sax.STATE;
        function emit2(parser, event, data) {
          parser[event] && parser[event](data);
        }
        function emitNode(parser, nodeType, data) {
          if (parser.textNode) closeText(parser);
          emit2(parser, nodeType, data);
        }
        function closeText(parser) {
          parser.textNode = textopts(parser.opt, parser.textNode);
          if (parser.textNode) emit2(parser, "ontext", parser.textNode);
          parser.textNode = "";
        }
        function textopts(opt, text) {
          if (opt.trim) text = text.trim();
          if (opt.normalize) text = text.replace(/\s+/g, " ");
          return text;
        }
        function error(parser, er) {
          closeText(parser);
          if (parser.trackPosition) {
            er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
          }
          er = new Error(er);
          parser.error = er;
          emit2(parser, "onerror", er);
          return parser;
        }
        function end(parser) {
          if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
          if (parser.state !== S2.BEGIN && parser.state !== S2.BEGIN_WHITESPACE && parser.state !== S2.TEXT) {
            error(parser, "Unexpected end");
          }
          closeText(parser);
          parser.c = "";
          parser.closed = true;
          emit2(parser, "onend");
          SAXParser.call(parser, parser.strict, parser.opt);
          return parser;
        }
        function strictFail(parser, message) {
          if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
            throw new Error("bad call to strictFail");
          }
          if (parser.strict) {
            error(parser, message);
          }
        }
        function newTag(parser) {
          if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
          var parent = parser.tags[parser.tags.length - 1] || parser;
          var tag = parser.tag = { name: parser.tagName, attributes: {} };
          if (parser.opt.xmlns) {
            tag.ns = parent.ns;
          }
          parser.attribList.length = 0;
          emitNode(parser, "onopentagstart", tag);
        }
        function qname(name, attribute) {
          var i2 = name.indexOf(":");
          var qualName = i2 < 0 ? ["", name] : name.split(":");
          var prefix = qualName[0];
          var local = qualName[1];
          if (attribute && name === "xmlns") {
            prefix = "xmlns";
            local = "";
          }
          return { prefix, local };
        }
        function attrib(parser) {
          if (!parser.strict) {
            parser.attribName = parser.attribName[parser.looseCase]();
          }
          if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
            parser.attribName = parser.attribValue = "";
            return;
          }
          if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;
            if (prefix === "xmlns") {
              if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                strictFail(
                  parser,
                  "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
                );
              } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
                strictFail(
                  parser,
                  "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
                );
              } else {
                var tag = parser.tag;
                var parent = parser.tags[parser.tags.length - 1] || parser;
                if (tag.ns === parent.ns) {
                  tag.ns = Object.create(parent.ns);
                }
                tag.ns[local] = parser.attribValue;
              }
            }
            parser.attribList.push([parser.attribName, parser.attribValue]);
          } else {
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, "onattribute", {
              name: parser.attribName,
              value: parser.attribValue
            });
          }
          parser.attribName = parser.attribValue = "";
        }
        function openTag(parser, selfClosing) {
          if (parser.opt.xmlns) {
            var tag = parser.tag;
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || "";
            if (tag.prefix && !tag.uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
              tag.uri = qn.prefix;
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) {
              Object.keys(tag.ns).forEach(function(p2) {
                emitNode(parser, "onopennamespace", {
                  prefix: p2,
                  uri: tag.ns[p2]
                });
              });
            }
            for (var i2 = 0, l2 = parser.attribList.length; i2 < l2; i2++) {
              var nv = parser.attribList[i2];
              var name = nv[0];
              var value = nv[1];
              var qualName = qname(name, true);
              var prefix = qualName.prefix;
              var local = qualName.local;
              var uri = prefix === "" ? "" : tag.ns[prefix] || "";
              var a2 = {
                name,
                value,
                prefix,
                local,
                uri
              };
              if (prefix && prefix !== "xmlns" && !uri) {
                strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
                a2.uri = prefix;
              }
              parser.tag.attributes[name] = a2;
              emitNode(parser, "onattribute", a2);
            }
            parser.attribList.length = 0;
          }
          parser.tag.isSelfClosing = !!selfClosing;
          parser.sawRoot = true;
          parser.tags.push(parser.tag);
          emitNode(parser, "onopentag", parser.tag);
          if (!selfClosing) {
            if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
              parser.state = S2.SCRIPT;
            } else {
              parser.state = S2.TEXT;
            }
            parser.tag = null;
            parser.tagName = "";
          }
          parser.attribName = parser.attribValue = "";
          parser.attribList.length = 0;
        }
        function closeTag(parser) {
          if (!parser.tagName) {
            strictFail(parser, "Weird empty close tag.");
            parser.textNode += "</>";
            parser.state = S2.TEXT;
            return;
          }
          if (parser.script) {
            if (parser.tagName !== "script") {
              parser.script += "</" + parser.tagName + ">";
              parser.tagName = "";
              parser.state = S2.SCRIPT;
              return;
            }
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }
          var t2 = parser.tags.length;
          var tagName = parser.tagName;
          if (!parser.strict) {
            tagName = tagName[parser.looseCase]();
          }
          var closeTo = tagName;
          while (t2--) {
            var close = parser.tags[t2];
            if (close.name !== closeTo) {
              strictFail(parser, "Unexpected close tag");
            } else {
              break;
            }
          }
          if (t2 < 0) {
            strictFail(parser, "Unmatched closing tag: " + parser.tagName);
            parser.textNode += "</" + parser.tagName + ">";
            parser.state = S2.TEXT;
            return;
          }
          parser.tagName = tagName;
          var s3 = parser.tags.length;
          while (s3-- > t2) {
            var tag = parser.tag = parser.tags.pop();
            parser.tagName = parser.tag.name;
            emitNode(parser, "onclosetag", parser.tagName);
            var x = {};
            for (var i2 in tag.ns) {
              x[i2] = tag.ns[i2];
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) {
              Object.keys(tag.ns).forEach(function(p2) {
                var n2 = tag.ns[p2];
                emitNode(parser, "onclosenamespace", { prefix: p2, uri: n2 });
              });
            }
          }
          if (t2 === 0) parser.closedRoot = true;
          parser.tagName = parser.attribValue = parser.attribName = "";
          parser.attribList.length = 0;
          parser.state = S2.TEXT;
        }
        function parseEntity(parser) {
          var entity = parser.entity;
          var entityLC = entity.toLowerCase();
          var num;
          var numStr = "";
          if (parser.ENTITIES[entity]) {
            return parser.ENTITIES[entity];
          }
          if (parser.ENTITIES[entityLC]) {
            return parser.ENTITIES[entityLC];
          }
          entity = entityLC;
          if (entity.charAt(0) === "#") {
            if (entity.charAt(1) === "x") {
              entity = entity.slice(2);
              num = parseInt(entity, 16);
              numStr = num.toString(16);
            } else {
              entity = entity.slice(1);
              num = parseInt(entity, 10);
              numStr = num.toString(10);
            }
          }
          entity = entity.replace(/^0+/, "");
          if (isNaN(num) || numStr.toLowerCase() !== entity) {
            strictFail(parser, "Invalid character entity");
            return "&" + parser.entity + ";";
          }
          return String.fromCodePoint(num);
        }
        function beginWhiteSpace(parser, c) {
          if (c === "<") {
            parser.state = S2.OPEN_WAKA;
            parser.startTagPosition = parser.position;
          } else if (!isWhitespace(c)) {
            strictFail(parser, "Non-whitespace before first tag.");
            parser.textNode = c;
            parser.state = S2.TEXT;
          }
        }
        function charAt(chunk, i2) {
          var result = "";
          if (i2 < chunk.length) {
            result = chunk.charAt(i2);
          }
          return result;
        }
        function write(chunk) {
          var parser = this;
          if (this.error) {
            throw this.error;
          }
          if (parser.closed) {
            return error(
              parser,
              "Cannot write after close. Assign an onready handler."
            );
          }
          if (chunk === null) {
            return end(parser);
          }
          if (typeof chunk === "object") {
            chunk = chunk.toString();
          }
          var i2 = 0;
          var c = "";
          while (true) {
            c = charAt(chunk, i2++);
            parser.c = c;
            if (!c) {
              break;
            }
            if (parser.trackPosition) {
              parser.position++;
              if (c === "\n") {
                parser.line++;
                parser.column = 0;
              } else {
                parser.column++;
              }
            }
            switch (parser.state) {
              case S2.BEGIN:
                parser.state = S2.BEGIN_WHITESPACE;
                if (c === "\uFEFF") {
                  continue;
                }
                beginWhiteSpace(parser, c);
                continue;
              case S2.BEGIN_WHITESPACE:
                beginWhiteSpace(parser, c);
                continue;
              case S2.TEXT:
                if (parser.sawRoot && !parser.closedRoot) {
                  var starti = i2 - 1;
                  while (c && c !== "<" && c !== "&") {
                    c = charAt(chunk, i2++);
                    if (c && parser.trackPosition) {
                      parser.position++;
                      if (c === "\n") {
                        parser.line++;
                        parser.column = 0;
                      } else {
                        parser.column++;
                      }
                    }
                  }
                  parser.textNode += chunk.substring(starti, i2 - 1);
                }
                if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                  parser.state = S2.OPEN_WAKA;
                  parser.startTagPosition = parser.position;
                } else {
                  if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                    strictFail(parser, "Text data outside of root node.");
                  }
                  if (c === "&") {
                    parser.state = S2.TEXT_ENTITY;
                  } else {
                    parser.textNode += c;
                  }
                }
                continue;
              case S2.SCRIPT:
                if (c === "<") {
                  parser.state = S2.SCRIPT_ENDING;
                } else {
                  parser.script += c;
                }
                continue;
              case S2.SCRIPT_ENDING:
                if (c === "/") {
                  parser.state = S2.CLOSE_TAG;
                } else {
                  parser.script += "<" + c;
                  parser.state = S2.SCRIPT;
                }
                continue;
              case S2.OPEN_WAKA:
                if (c === "!") {
                  parser.state = S2.SGML_DECL;
                  parser.sgmlDecl = "";
                } else if (isWhitespace(c)) {
                } else if (isMatch(nameStart, c)) {
                  parser.state = S2.OPEN_TAG;
                  parser.tagName = c;
                } else if (c === "/") {
                  parser.state = S2.CLOSE_TAG;
                  parser.tagName = "";
                } else if (c === "?") {
                  parser.state = S2.PROC_INST;
                  parser.procInstName = parser.procInstBody = "";
                } else {
                  strictFail(parser, "Unencoded <");
                  if (parser.startTagPosition + 1 < parser.position) {
                    var pad = parser.position - parser.startTagPosition;
                    c = new Array(pad).join(" ") + c;
                  }
                  parser.textNode += "<" + c;
                  parser.state = S2.TEXT;
                }
                continue;
              case S2.SGML_DECL:
                if (parser.sgmlDecl + c === "--") {
                  parser.state = S2.COMMENT;
                  parser.comment = "";
                  parser.sgmlDecl = "";
                  continue;
                }
                if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                  parser.state = S2.DOCTYPE_DTD;
                  parser.doctype += "<!" + parser.sgmlDecl + c;
                  parser.sgmlDecl = "";
                } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                  emitNode(parser, "onopencdata");
                  parser.state = S2.CDATA;
                  parser.sgmlDecl = "";
                  parser.cdata = "";
                } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                  parser.state = S2.DOCTYPE;
                  if (parser.doctype || parser.sawRoot) {
                    strictFail(
                      parser,
                      "Inappropriately located doctype declaration"
                    );
                  }
                  parser.doctype = "";
                  parser.sgmlDecl = "";
                } else if (c === ">") {
                  emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                  parser.sgmlDecl = "";
                  parser.state = S2.TEXT;
                } else if (isQuote(c)) {
                  parser.state = S2.SGML_DECL_QUOTED;
                  parser.sgmlDecl += c;
                } else {
                  parser.sgmlDecl += c;
                }
                continue;
              case S2.SGML_DECL_QUOTED:
                if (c === parser.q) {
                  parser.state = S2.SGML_DECL;
                  parser.q = "";
                }
                parser.sgmlDecl += c;
                continue;
              case S2.DOCTYPE:
                if (c === ">") {
                  parser.state = S2.TEXT;
                  emitNode(parser, "ondoctype", parser.doctype);
                  parser.doctype = true;
                } else {
                  parser.doctype += c;
                  if (c === "[") {
                    parser.state = S2.DOCTYPE_DTD;
                  } else if (isQuote(c)) {
                    parser.state = S2.DOCTYPE_QUOTED;
                    parser.q = c;
                  }
                }
                continue;
              case S2.DOCTYPE_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                  parser.q = "";
                  parser.state = S2.DOCTYPE;
                }
                continue;
              case S2.DOCTYPE_DTD:
                if (c === "]") {
                  parser.doctype += c;
                  parser.state = S2.DOCTYPE;
                } else if (c === "<") {
                  parser.state = S2.OPEN_WAKA;
                  parser.startTagPosition = parser.position;
                } else if (isQuote(c)) {
                  parser.doctype += c;
                  parser.state = S2.DOCTYPE_DTD_QUOTED;
                  parser.q = c;
                } else {
                  parser.doctype += c;
                }
                continue;
              case S2.DOCTYPE_DTD_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                  parser.state = S2.DOCTYPE_DTD;
                  parser.q = "";
                }
                continue;
              case S2.COMMENT:
                if (c === "-") {
                  parser.state = S2.COMMENT_ENDING;
                } else {
                  parser.comment += c;
                }
                continue;
              case S2.COMMENT_ENDING:
                if (c === "-") {
                  parser.state = S2.COMMENT_ENDED;
                  parser.comment = textopts(parser.opt, parser.comment);
                  if (parser.comment) {
                    emitNode(parser, "oncomment", parser.comment);
                  }
                  parser.comment = "";
                } else {
                  parser.comment += "-" + c;
                  parser.state = S2.COMMENT;
                }
                continue;
              case S2.COMMENT_ENDED:
                if (c !== ">") {
                  strictFail(parser, "Malformed comment");
                  parser.comment += "--" + c;
                  parser.state = S2.COMMENT;
                } else if (parser.doctype && parser.doctype !== true) {
                  parser.state = S2.DOCTYPE_DTD;
                } else {
                  parser.state = S2.TEXT;
                }
                continue;
              case S2.CDATA:
                if (c === "]") {
                  parser.state = S2.CDATA_ENDING;
                } else {
                  parser.cdata += c;
                }
                continue;
              case S2.CDATA_ENDING:
                if (c === "]") {
                  parser.state = S2.CDATA_ENDING_2;
                } else {
                  parser.cdata += "]" + c;
                  parser.state = S2.CDATA;
                }
                continue;
              case S2.CDATA_ENDING_2:
                if (c === ">") {
                  if (parser.cdata) {
                    emitNode(parser, "oncdata", parser.cdata);
                  }
                  emitNode(parser, "onclosecdata");
                  parser.cdata = "";
                  parser.state = S2.TEXT;
                } else if (c === "]") {
                  parser.cdata += "]";
                } else {
                  parser.cdata += "]]" + c;
                  parser.state = S2.CDATA;
                }
                continue;
              case S2.PROC_INST:
                if (c === "?") {
                  parser.state = S2.PROC_INST_ENDING;
                } else if (isWhitespace(c)) {
                  parser.state = S2.PROC_INST_BODY;
                } else {
                  parser.procInstName += c;
                }
                continue;
              case S2.PROC_INST_BODY:
                if (!parser.procInstBody && isWhitespace(c)) {
                  continue;
                } else if (c === "?") {
                  parser.state = S2.PROC_INST_ENDING;
                } else {
                  parser.procInstBody += c;
                }
                continue;
              case S2.PROC_INST_ENDING:
                if (c === ">") {
                  emitNode(parser, "onprocessinginstruction", {
                    name: parser.procInstName,
                    body: parser.procInstBody
                  });
                  parser.procInstName = parser.procInstBody = "";
                  parser.state = S2.TEXT;
                } else {
                  parser.procInstBody += "?" + c;
                  parser.state = S2.PROC_INST_BODY;
                }
                continue;
              case S2.OPEN_TAG:
                if (isMatch(nameBody, c)) {
                  parser.tagName += c;
                } else {
                  newTag(parser);
                  if (c === ">") {
                    openTag(parser);
                  } else if (c === "/") {
                    parser.state = S2.OPEN_TAG_SLASH;
                  } else {
                    if (!isWhitespace(c)) {
                      strictFail(parser, "Invalid character in tag name");
                    }
                    parser.state = S2.ATTRIB;
                  }
                }
                continue;
              case S2.OPEN_TAG_SLASH:
                if (c === ">") {
                  openTag(parser, true);
                  closeTag(parser);
                } else {
                  strictFail(parser, "Forward-slash in opening tag not followed by >");
                  parser.state = S2.ATTRIB;
                }
                continue;
              case S2.ATTRIB:
                if (isWhitespace(c)) {
                  continue;
                } else if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S2.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.attribValue = "";
                  parser.state = S2.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S2.ATTRIB_NAME:
                if (c === "=") {
                  parser.state = S2.ATTRIB_VALUE;
                } else if (c === ">") {
                  strictFail(parser, "Attribute without value");
                  parser.attribValue = parser.attribName;
                  attrib(parser);
                  openTag(parser);
                } else if (isWhitespace(c)) {
                  parser.state = S2.ATTRIB_NAME_SAW_WHITE;
                } else if (isMatch(nameBody, c)) {
                  parser.attribName += c;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S2.ATTRIB_NAME_SAW_WHITE:
                if (c === "=") {
                  parser.state = S2.ATTRIB_VALUE;
                } else if (isWhitespace(c)) {
                  continue;
                } else {
                  strictFail(parser, "Attribute without value");
                  parser.tag.attributes[parser.attribName] = "";
                  parser.attribValue = "";
                  emitNode(parser, "onattribute", {
                    name: parser.attribName,
                    value: ""
                  });
                  parser.attribName = "";
                  if (c === ">") {
                    openTag(parser);
                  } else if (isMatch(nameStart, c)) {
                    parser.attribName = c;
                    parser.state = S2.ATTRIB_NAME;
                  } else {
                    strictFail(parser, "Invalid attribute name");
                    parser.state = S2.ATTRIB;
                  }
                }
                continue;
              case S2.ATTRIB_VALUE:
                if (isWhitespace(c)) {
                  continue;
                } else if (isQuote(c)) {
                  parser.q = c;
                  parser.state = S2.ATTRIB_VALUE_QUOTED;
                } else {
                  if (!parser.opt.unquotedAttributeValues) {
                    error(parser, "Unquoted attribute value");
                  }
                  parser.state = S2.ATTRIB_VALUE_UNQUOTED;
                  parser.attribValue = c;
                }
                continue;
              case S2.ATTRIB_VALUE_QUOTED:
                if (c !== parser.q) {
                  if (c === "&") {
                    parser.state = S2.ATTRIB_VALUE_ENTITY_Q;
                  } else {
                    parser.attribValue += c;
                  }
                  continue;
                }
                attrib(parser);
                parser.q = "";
                parser.state = S2.ATTRIB_VALUE_CLOSED;
                continue;
              case S2.ATTRIB_VALUE_CLOSED:
                if (isWhitespace(c)) {
                  parser.state = S2.ATTRIB;
                } else if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S2.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c)) {
                  strictFail(parser, "No whitespace between attributes");
                  parser.attribName = c;
                  parser.attribValue = "";
                  parser.state = S2.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S2.ATTRIB_VALUE_UNQUOTED:
                if (!isAttribEnd(c)) {
                  if (c === "&") {
                    parser.state = S2.ATTRIB_VALUE_ENTITY_U;
                  } else {
                    parser.attribValue += c;
                  }
                  continue;
                }
                attrib(parser);
                if (c === ">") {
                  openTag(parser);
                } else {
                  parser.state = S2.ATTRIB;
                }
                continue;
              case S2.CLOSE_TAG:
                if (!parser.tagName) {
                  if (isWhitespace(c)) {
                    continue;
                  } else if (notMatch(nameStart, c)) {
                    if (parser.script) {
                      parser.script += "</" + c;
                      parser.state = S2.SCRIPT;
                    } else {
                      strictFail(parser, "Invalid tagname in closing tag.");
                    }
                  } else {
                    parser.tagName = c;
                  }
                } else if (c === ">") {
                  closeTag(parser);
                } else if (isMatch(nameBody, c)) {
                  parser.tagName += c;
                } else if (parser.script) {
                  parser.script += "</" + parser.tagName;
                  parser.tagName = "";
                  parser.state = S2.SCRIPT;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid tagname in closing tag");
                  }
                  parser.state = S2.CLOSE_TAG_SAW_WHITE;
                }
                continue;
              case S2.CLOSE_TAG_SAW_WHITE:
                if (isWhitespace(c)) {
                  continue;
                }
                if (c === ">") {
                  closeTag(parser);
                } else {
                  strictFail(parser, "Invalid characters in closing tag");
                }
                continue;
              case S2.TEXT_ENTITY:
              case S2.ATTRIB_VALUE_ENTITY_Q:
              case S2.ATTRIB_VALUE_ENTITY_U:
                var returnState;
                var buffer2;
                switch (parser.state) {
                  case S2.TEXT_ENTITY:
                    returnState = S2.TEXT;
                    buffer2 = "textNode";
                    break;
                  case S2.ATTRIB_VALUE_ENTITY_Q:
                    returnState = S2.ATTRIB_VALUE_QUOTED;
                    buffer2 = "attribValue";
                    break;
                  case S2.ATTRIB_VALUE_ENTITY_U:
                    returnState = S2.ATTRIB_VALUE_UNQUOTED;
                    buffer2 = "attribValue";
                    break;
                }
                if (c === ";") {
                  var parsedEntity = parseEntity(parser);
                  if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
                    parser.entity = "";
                    parser.state = returnState;
                    parser.write(parsedEntity);
                  } else {
                    parser[buffer2] += parsedEntity;
                    parser.entity = "";
                    parser.state = returnState;
                  }
                } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                  parser.entity += c;
                } else {
                  strictFail(parser, "Invalid character in entity name");
                  parser[buffer2] += "&" + parser.entity + c;
                  parser.entity = "";
                  parser.state = returnState;
                }
                continue;
              default: {
                throw new Error(parser, "Unknown state: " + parser.state);
              }
            }
          }
          if (parser.position >= parser.bufferCheckPosition) {
            checkBufferLength(parser);
          }
          return parser;
        }
        if (!String.fromCodePoint) {
          (function() {
            var stringFromCharCode = String.fromCharCode;
            var floor = Math.floor;
            var fromCodePoint = function() {
              var MAX_SIZE = 16384;
              var codeUnits = [];
              var highSurrogate;
              var lowSurrogate;
              var index = -1;
              var length = arguments.length;
              if (!length) {
                return "";
              }
              var result = "";
              while (++index < length) {
                var codePoint = Number(arguments[index]);
                if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                codePoint < 0 || // not a valid Unicode code point
                codePoint > 1114111 || // not a valid Unicode code point
                floor(codePoint) !== codePoint) {
                  throw RangeError("Invalid code point: " + codePoint);
                }
                if (codePoint <= 65535) {
                  codeUnits.push(codePoint);
                } else {
                  codePoint -= 65536;
                  highSurrogate = (codePoint >> 10) + 55296;
                  lowSurrogate = codePoint % 1024 + 56320;
                  codeUnits.push(highSurrogate, lowSurrogate);
                }
                if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                  result += stringFromCharCode.apply(null, codeUnits);
                  codeUnits.length = 0;
                }
              }
              return result;
            };
            if (Object.defineProperty) {
              Object.defineProperty(String, "fromCodePoint", {
                value: fromCodePoint,
                configurable: true,
                writable: true
              });
            } else {
              String.fromCodePoint = fromCodePoint;
            }
          })();
        }
      })(typeof exports === "undefined" ? exports.sax = {} : exports);
    }
  });

  // node_modules/.pnpm/os-browserify@0.3.0/node_modules/os-browserify/browser.js
  var require_browser2 = __commonJS({
    "node_modules/.pnpm/os-browserify@0.3.0/node_modules/os-browserify/browser.js"(exports) {
      init_shim();
      exports.endianness = function() {
        return "LE";
      };
      exports.hostname = function() {
        if (typeof location !== "undefined") {
          return location.hostname;
        } else return "";
      };
      exports.loadavg = function() {
        return [];
      };
      exports.uptime = function() {
        return 0;
      };
      exports.freemem = function() {
        return Number.MAX_VALUE;
      };
      exports.totalmem = function() {
        return Number.MAX_VALUE;
      };
      exports.cpus = function() {
        return [];
      };
      exports.type = function() {
        return "Browser";
      };
      exports.release = function() {
        if (typeof navigator !== "undefined") {
          return navigator.appVersion;
        }
        return "";
      };
      exports.networkInterfaces = exports.getNetworkInterfaces = function() {
        return {};
      };
      exports.arch = function() {
        return "javascript";
      };
      exports.platform = function() {
        return "browser";
      };
      exports.tmpdir = exports.tmpDir = function() {
        return "/tmp";
      };
      exports.EOL = "\n";
      exports.homedir = function() {
        return "/";
      };
    }
  });

  // node_modules/.pnpm/node-stdlib-browser@1.3.1/node_modules/node-stdlib-browser/esm/mock/empty.js
  var empty_exports = {};
  __export(empty_exports, {
    default: () => empty
  });
  var empty;
  var init_empty = __esm({
    "node_modules/.pnpm/node-stdlib-browser@1.3.1/node_modules/node-stdlib-browser/esm/mock/empty.js"() {
      init_shim();
      empty = null;
    }
  });

  // node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js
  var require_path_browserify = __commonJS({
    "node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js"(exports, module) {
      "use strict";
      init_shim();
      function assertPath(path) {
        if (typeof path !== "string") {
          throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
        }
      }
      function normalizeStringPosix(path, allowAboveRoot) {
        var res = "";
        var lastSegmentLength = 0;
        var lastSlash = -1;
        var dots = 0;
        var code;
        for (var i2 = 0; i2 <= path.length; ++i2) {
          if (i2 < path.length)
            code = path.charCodeAt(i2);
          else if (code === 47)
            break;
          else
            code = 47;
          if (code === 47) {
            if (lastSlash === i2 - 1 || dots === 1) {
            } else if (lastSlash !== i2 - 1 && dots === 2) {
              if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                if (res.length > 2) {
                  var lastSlashIndex = res.lastIndexOf("/");
                  if (lastSlashIndex !== res.length - 1) {
                    if (lastSlashIndex === -1) {
                      res = "";
                      lastSegmentLength = 0;
                    } else {
                      res = res.slice(0, lastSlashIndex);
                      lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                    }
                    lastSlash = i2;
                    dots = 0;
                    continue;
                  }
                } else if (res.length === 2 || res.length === 1) {
                  res = "";
                  lastSegmentLength = 0;
                  lastSlash = i2;
                  dots = 0;
                  continue;
                }
              }
              if (allowAboveRoot) {
                if (res.length > 0)
                  res += "/..";
                else
                  res = "..";
                lastSegmentLength = 2;
              }
            } else {
              if (res.length > 0)
                res += "/" + path.slice(lastSlash + 1, i2);
              else
                res = path.slice(lastSlash + 1, i2);
              lastSegmentLength = i2 - lastSlash - 1;
            }
            lastSlash = i2;
            dots = 0;
          } else if (code === 46 && dots !== -1) {
            ++dots;
          } else {
            dots = -1;
          }
        }
        return res;
      }
      function _format(sep, pathObject) {
        var dir = pathObject.dir || pathObject.root;
        var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
        if (!dir) {
          return base;
        }
        if (dir === pathObject.root) {
          return dir + base;
        }
        return dir + sep + base;
      }
      var posix = {
        // path.resolve([from ...], to)
        resolve: function resolve() {
          var resolvedPath = "";
          var resolvedAbsolute = false;
          var cwd2;
          for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
            var path;
            if (i2 >= 0)
              path = arguments[i2];
            else {
              if (cwd2 === void 0)
                cwd2 = api.cwd();
              path = cwd2;
            }
            assertPath(path);
            if (path.length === 0) {
              continue;
            }
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charCodeAt(0) === 47;
          }
          resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
          if (resolvedAbsolute) {
            if (resolvedPath.length > 0)
              return "/" + resolvedPath;
            else
              return "/";
          } else if (resolvedPath.length > 0) {
            return resolvedPath;
          } else {
            return ".";
          }
        },
        normalize: function normalize(path) {
          assertPath(path);
          if (path.length === 0) return ".";
          var isAbsolute = path.charCodeAt(0) === 47;
          var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
          path = normalizeStringPosix(path, !isAbsolute);
          if (path.length === 0 && !isAbsolute) path = ".";
          if (path.length > 0 && trailingSeparator) path += "/";
          if (isAbsolute) return "/" + path;
          return path;
        },
        isAbsolute: function isAbsolute(path) {
          assertPath(path);
          return path.length > 0 && path.charCodeAt(0) === 47;
        },
        join: function join() {
          if (arguments.length === 0)
            return ".";
          var joined;
          for (var i2 = 0; i2 < arguments.length; ++i2) {
            var arg = arguments[i2];
            assertPath(arg);
            if (arg.length > 0) {
              if (joined === void 0)
                joined = arg;
              else
                joined += "/" + arg;
            }
          }
          if (joined === void 0)
            return ".";
          return posix.normalize(joined);
        },
        relative: function relative(from, to) {
          assertPath(from);
          assertPath(to);
          if (from === to) return "";
          from = posix.resolve(from);
          to = posix.resolve(to);
          if (from === to) return "";
          var fromStart = 1;
          for (; fromStart < from.length; ++fromStart) {
            if (from.charCodeAt(fromStart) !== 47)
              break;
          }
          var fromEnd = from.length;
          var fromLen = fromEnd - fromStart;
          var toStart = 1;
          for (; toStart < to.length; ++toStart) {
            if (to.charCodeAt(toStart) !== 47)
              break;
          }
          var toEnd = to.length;
          var toLen = toEnd - toStart;
          var length = fromLen < toLen ? fromLen : toLen;
          var lastCommonSep = -1;
          var i2 = 0;
          for (; i2 <= length; ++i2) {
            if (i2 === length) {
              if (toLen > length) {
                if (to.charCodeAt(toStart + i2) === 47) {
                  return to.slice(toStart + i2 + 1);
                } else if (i2 === 0) {
                  return to.slice(toStart + i2);
                }
              } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i2) === 47) {
                  lastCommonSep = i2;
                } else if (i2 === 0) {
                  lastCommonSep = 0;
                }
              }
              break;
            }
            var fromCode = from.charCodeAt(fromStart + i2);
            var toCode = to.charCodeAt(toStart + i2);
            if (fromCode !== toCode)
              break;
            else if (fromCode === 47)
              lastCommonSep = i2;
          }
          var out2 = "";
          for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
            if (i2 === fromEnd || from.charCodeAt(i2) === 47) {
              if (out2.length === 0)
                out2 += "..";
              else
                out2 += "/..";
            }
          }
          if (out2.length > 0)
            return out2 + to.slice(toStart + lastCommonSep);
          else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === 47)
              ++toStart;
            return to.slice(toStart);
          }
        },
        _makeLong: function _makeLong(path) {
          return path;
        },
        dirname: function dirname(path) {
          assertPath(path);
          if (path.length === 0) return ".";
          var code = path.charCodeAt(0);
          var hasRoot = code === 47;
          var end = -1;
          var matchedSlash = true;
          for (var i2 = path.length - 1; i2 >= 1; --i2) {
            code = path.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                end = i2;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1) return hasRoot ? "/" : ".";
          if (hasRoot && end === 1) return "//";
          return path.slice(0, end);
        },
        basename: function basename(path, ext) {
          if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
          assertPath(path);
          var start = 0;
          var end = -1;
          var matchedSlash = true;
          var i2;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path) return "";
            var extIdx = ext.length - 1;
            var firstNonSlashEnd = -1;
            for (i2 = path.length - 1; i2 >= 0; --i2) {
              var code = path.charCodeAt(i2);
              if (code === 47) {
                if (!matchedSlash) {
                  start = i2 + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i2 + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i2;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end) end = firstNonSlashEnd;
            else if (end === -1) end = path.length;
            return path.slice(start, end);
          } else {
            for (i2 = path.length - 1; i2 >= 0; --i2) {
              if (path.charCodeAt(i2) === 47) {
                if (!matchedSlash) {
                  start = i2 + 1;
                  break;
                }
              } else if (end === -1) {
                matchedSlash = false;
                end = i2 + 1;
              }
            }
            if (end === -1) return "";
            return path.slice(start, end);
          }
        },
        extname: function extname(path) {
          assertPath(path);
          var startDot = -1;
          var startPart = 0;
          var end = -1;
          var matchedSlash = true;
          var preDotState = 0;
          for (var i2 = path.length - 1; i2 >= 0; --i2) {
            var code = path.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i2 + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i2;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
          preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
          preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path.slice(startDot, end);
        },
        format: function format(pathObject) {
          if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
          }
          return _format("/", pathObject);
        },
        parse: function parse(path) {
          assertPath(path);
          var ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path.length === 0) return ret;
          var code = path.charCodeAt(0);
          var isAbsolute = code === 47;
          var start;
          if (isAbsolute) {
            ret.root = "/";
            start = 1;
          } else {
            start = 0;
          }
          var startDot = -1;
          var startPart = 0;
          var end = -1;
          var matchedSlash = true;
          var i2 = path.length - 1;
          var preDotState = 0;
          for (; i2 >= start; --i2) {
            code = path.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i2 + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
            if (code === 46) {
              if (startDot === -1) startDot = i2;
              else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
          preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
          preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
              if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
              else ret.base = ret.name = path.slice(startPart, end);
            }
          } else {
            if (startPart === 0 && isAbsolute) {
              ret.name = path.slice(1, startDot);
              ret.base = path.slice(1, end);
            } else {
              ret.name = path.slice(startPart, startDot);
              ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
          }
          if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
          else if (isAbsolute) ret.dir = "/";
          return ret;
        },
        sep: "/",
        delimiter: ":",
        win32: null,
        posix: null
      };
      posix.posix = posix;
      module.exports = posix;
    }
  });

  // node_modules/.pnpm/ttf2eot@3.1.0/node_modules/ttf2eot/index.js
  var require_ttf2eot = __commonJS({
    "node_modules/.pnpm/ttf2eot@3.1.0/node_modules/ttf2eot/index.js"(exports, module) {
      "use strict";
      init_shim();
      var EOT_OFFSET = {
        LENGTH: 0,
        FONT_LENGTH: 4,
        VERSION: 8,
        CHARSET: 26,
        MAGIC: 34,
        FONT_PANOSE: 16,
        ITALIC: 27,
        WEIGHT: 28,
        UNICODE_RANGE: 36,
        CODEPAGE_RANGE: 52,
        CHECKSUM_ADJUSTMENT: 60
      };
      var SFNT_OFFSET = {
        // sfntHeader:
        NUMTABLES: 4,
        // TableDirectoryEntry
        TABLE_TAG: 0,
        TABLE_OFFSET: 8,
        TABLE_LENGTH: 12,
        // OS2Table
        OS2_WEIGHT: 4,
        OS2_FONT_PANOSE: 32,
        OS2_UNICODE_RANGE: 42,
        OS2_FS_SELECTION: 62,
        OS2_CODEPAGE_RANGE: 78,
        // headTable
        HEAD_CHECKSUM_ADJUSTMENT: 8,
        // nameTable
        NAMETABLE_FORMAT: 0,
        NAMETABLE_COUNT: 2,
        NAMETABLE_STRING_OFFSET: 4,
        // nameRecord
        NAME_PLATFORM_ID: 0,
        NAME_ENCODING_ID: 2,
        NAME_LANGUAGE_ID: 4,
        NAME_NAME_ID: 6,
        NAME_LENGTH: 8,
        NAME_OFFSET: 10
      };
      var SIZEOF = {
        SFNT_TABLE_ENTRY: 16,
        SFNT_HEADER: 12,
        SFNT_NAMETABLE: 6,
        SFNT_NAMETABLE_ENTRY: 12,
        EOT_PREFIX: 82
      };
      var MAGIC = {
        EOT_VERSION: 131073,
        EOT_MAGIC: 20556,
        EOT_CHARSET: 1,
        LANGUAGE_ENGLISH: 1033
      };
      function strbuf(str) {
        var arr = import_buffer.Buffer.alloc(str.length + 4);
        arr.writeUint16LE(str.length, 0);
        for (var i2 = 0; i2 < str.length; i2 += 2) {
          arr.writeUint16LE(str.readUint16BE(i2), i2 + 2);
        }
        arr.writeUint16LE(0, arr.length - 2);
        return arr;
      }
      function ttf2eot2(arr) {
        arr = import_buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.length);
        var out2 = import_buffer.Buffer.alloc(SIZEOF.EOT_PREFIX, 0);
        var i2, j;
        out2.writeUint32LE(arr.length, EOT_OFFSET.FONT_LENGTH);
        out2.writeUint32LE(MAGIC.EOT_VERSION, EOT_OFFSET.VERSION);
        out2.writeUint8(MAGIC.EOT_CHARSET, EOT_OFFSET.CHARSET);
        out2.writeUint16LE(MAGIC.EOT_MAGIC, EOT_OFFSET.MAGIC);
        var familyName = import_buffer.Buffer.of(0);
        var subfamilyName = import_buffer.Buffer.of(0);
        var fullName = import_buffer.Buffer.of(0);
        var versionString = import_buffer.Buffer.of(0);
        var haveOS2 = false;
        var haveName = false;
        var haveHead = false;
        var numTables = arr.readUint16BE(SFNT_OFFSET.NUMTABLES);
        for (i2 = 0; i2 < numTables; ++i2) {
          var data = arr.subarray(SIZEOF.SFNT_HEADER + i2 * SIZEOF.SFNT_TABLE_ENTRY);
          var tableEntry = {
            tag: String.fromCharCode.apply(null, data.subarray(SFNT_OFFSET.TABLE_TAG, SFNT_OFFSET.TABLE_TAG + 4)),
            offset: data.readUint32BE(SFNT_OFFSET.TABLE_OFFSET),
            length: data.readUint32BE(SFNT_OFFSET.TABLE_LENGTH)
          };
          var table = arr.subarray(tableEntry.offset, tableEntry.offset + tableEntry.length);
          if (tableEntry.tag === "OS/2") {
            haveOS2 = true;
            var OS2Version = table.readUint16BE();
            for (j = 0; j < 10; ++j) {
              out2.writeUint8(table.readUint8(SFNT_OFFSET.OS2_FONT_PANOSE + j), EOT_OFFSET.FONT_PANOSE + j);
            }
            out2.writeUint8(table.readUint16BE(SFNT_OFFSET.OS2_FS_SELECTION) & 1, EOT_OFFSET.ITALIC);
            out2.writeUint32LE(table.readUint16BE(SFNT_OFFSET.OS2_WEIGHT), EOT_OFFSET.WEIGHT);
            for (j = 0; j < 4; ++j) {
              out2.writeUint32LE(
                table.readUint32BE(SFNT_OFFSET.OS2_UNICODE_RANGE + j * 4),
                EOT_OFFSET.UNICODE_RANGE + j * 4
              );
            }
            if (OS2Version >= 1) {
              for (j = 0; j < 2; ++j) {
                out2.writeUint32LE(
                  table.readUint32BE(SFNT_OFFSET.OS2_CODEPAGE_RANGE + j * 4),
                  EOT_OFFSET.CODEPAGE_RANGE + j * 4
                );
              }
            }
          } else if (tableEntry.tag === "head") {
            haveHead = true;
            out2.writeUint32LE(table.readUint32BE(SFNT_OFFSET.HEAD_CHECKSUM_ADJUSTMENT), EOT_OFFSET.CHECKSUM_ADJUSTMENT);
          } else if (tableEntry.tag === "name") {
            haveName = true;
            var nameTable = {
              format: table.readUint16BE(SFNT_OFFSET.NAMETABLE_FORMAT),
              count: table.readUint16BE(SFNT_OFFSET.NAMETABLE_COUNT),
              stringOffset: table.readUint16BE(SFNT_OFFSET.NAMETABLE_STRING_OFFSET)
            };
            for (j = 0; j < nameTable.count; ++j) {
              var nameRecord = table.subarray(SIZEOF.SFNT_NAMETABLE + j * SIZEOF.SFNT_NAMETABLE_ENTRY);
              var name = {
                platformID: nameRecord.readUint16BE(SFNT_OFFSET.NAME_PLATFORM_ID),
                encodingID: nameRecord.readUint16BE(SFNT_OFFSET.NAME_ENCODING_ID),
                languageID: nameRecord.readUint16BE(SFNT_OFFSET.NAME_LANGUAGE_ID),
                nameID: nameRecord.readUint16BE(SFNT_OFFSET.NAME_NAME_ID),
                length: nameRecord.readUint16BE(SFNT_OFFSET.NAME_LENGTH),
                offset: nameRecord.readUint16BE(SFNT_OFFSET.NAME_OFFSET)
              };
              if (name.platformID === 3 && name.encodingID === 1 && name.languageID === MAGIC.LANGUAGE_ENGLISH) {
                var s2 = strbuf(table.subarray(
                  nameTable.stringOffset + name.offset,
                  nameTable.stringOffset + name.offset + name.length
                ));
                switch (name.nameID) {
                  case 1:
                    familyName = s2;
                    break;
                  case 2:
                    subfamilyName = s2;
                    break;
                  case 4:
                    fullName = s2;
                    break;
                  case 5:
                    versionString = s2;
                    break;
                }
              }
            }
          }
          if (haveOS2 && haveName && haveHead) {
            break;
          }
        }
        if (!(haveOS2 && haveName && haveHead)) {
          throw new Error("Required section not found");
        }
        var eot = import_buffer.Buffer.concat([
          out2,
          familyName,
          subfamilyName,
          versionString,
          fullName,
          import_buffer.Buffer.from([0, 0]),
          arr
        ]);
        eot.writeUint32LE(eot.length, EOT_OFFSET.LENGTH);
        return new Uint8Array(eot.buffer, eot.byteOffset, eot.length);
      }
      module.exports = ttf2eot2;
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js
  var require_common = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js"(exports) {
      "use strict";
      init_shim();
      var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
      function _has(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
      exports.assign = function(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          var source = sources.shift();
          if (!source) {
            continue;
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object");
          }
          for (var p2 in source) {
            if (_has(source, p2)) {
              obj[p2] = source[p2];
            }
          }
        }
        return obj;
      };
      exports.shrinkBuf = function(buf, size) {
        if (buf.length === size) {
          return buf;
        }
        if (buf.subarray) {
          return buf.subarray(0, size);
        }
        buf.length = size;
        return buf;
      };
      var fnTyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          if (src.subarray && dest.subarray) {
            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
            return;
          }
          for (var i2 = 0; i2 < len; i2++) {
            dest[dest_offs + i2] = src[src_offs + i2];
          }
        },
        // Join array of chunks to single array.
        flattenChunks: function(chunks) {
          var i2, l2, len, pos, chunk, result;
          len = 0;
          for (i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
            len += chunks[i2].length;
          }
          result = new Uint8Array(len);
          pos = 0;
          for (i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
            chunk = chunks[i2];
            result.set(chunk, pos);
            pos += chunk.length;
          }
          return result;
        }
      };
      var fnUntyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          for (var i2 = 0; i2 < len; i2++) {
            dest[dest_offs + i2] = src[src_offs + i2];
          }
        },
        // Join array of chunks to single array.
        flattenChunks: function(chunks) {
          return [].concat.apply([], chunks);
        }
      };
      exports.setTyped = function(on2) {
        if (on2) {
          exports.Buf8 = Uint8Array;
          exports.Buf16 = Uint16Array;
          exports.Buf32 = Int32Array;
          exports.assign(exports, fnTyped);
        } else {
          exports.Buf8 = Array;
          exports.Buf16 = Array;
          exports.Buf32 = Array;
          exports.assign(exports, fnUntyped);
        }
      };
      exports.setTyped(TYPED_OK);
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js
  var require_trees = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js"(exports) {
      "use strict";
      init_shim();
      var utils = require_common();
      var Z_FIXED = 4;
      var Z_BINARY = 0;
      var Z_TEXT = 1;
      var Z_UNKNOWN = 2;
      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var Buf_size = 16;
      var MAX_BL_BITS = 7;
      var END_BLOCK = 256;
      var REP_3_6 = 16;
      var REPZ_3_10 = 17;
      var REPZ_11_138 = 18;
      var extra_lbits = (
        /* extra bits for each length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
      );
      var extra_dbits = (
        /* extra bits for each distance code */
        [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
      );
      var extra_blbits = (
        /* extra bits for each bit length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
      );
      var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      var DIST_CODE_LEN = 512;
      var static_ltree = new Array((L_CODES + 2) * 2);
      zero(static_ltree);
      var static_dtree = new Array(D_CODES * 2);
      zero(static_dtree);
      var _dist_code = new Array(DIST_CODE_LEN);
      zero(_dist_code);
      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
      zero(_length_code);
      var base_length = new Array(LENGTH_CODES);
      zero(base_length);
      var base_dist = new Array(D_CODES);
      zero(base_dist);
      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
      }
      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;
      function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
      }
      function d_code(dist) {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
      }
      function put_short(s2, w2) {
        s2.pending_buf[s2.pending++] = w2 & 255;
        s2.pending_buf[s2.pending++] = w2 >>> 8 & 255;
      }
      function send_bits(s2, value, length) {
        if (s2.bi_valid > Buf_size - length) {
          s2.bi_buf |= value << s2.bi_valid & 65535;
          put_short(s2, s2.bi_buf);
          s2.bi_buf = value >> Buf_size - s2.bi_valid;
          s2.bi_valid += length - Buf_size;
        } else {
          s2.bi_buf |= value << s2.bi_valid & 65535;
          s2.bi_valid += length;
        }
      }
      function send_code(s2, c, tree) {
        send_bits(
          s2,
          tree[c * 2],
          tree[c * 2 + 1]
          /*.Len*/
        );
      }
      function bi_reverse(code, len) {
        var res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1;
        } while (--len > 0);
        return res >>> 1;
      }
      function bi_flush(s2) {
        if (s2.bi_valid === 16) {
          put_short(s2, s2.bi_buf);
          s2.bi_buf = 0;
          s2.bi_valid = 0;
        } else if (s2.bi_valid >= 8) {
          s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
          s2.bi_buf >>= 8;
          s2.bi_valid -= 8;
        }
      }
      function gen_bitlen(s2, desc) {
        var tree = desc.dyn_tree;
        var max_code = desc.max_code;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var extra = desc.stat_desc.extra_bits;
        var base = desc.stat_desc.extra_base;
        var max_length = desc.stat_desc.max_length;
        var h2;
        var n2, m;
        var bits;
        var xbits;
        var f2;
        var overflow = 0;
        for (bits = 0; bits <= MAX_BITS; bits++) {
          s2.bl_count[bits] = 0;
        }
        tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
        for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE; h2++) {
          n2 = s2.heap[h2];
          bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }
          tree[n2 * 2 + 1] = bits;
          if (n2 > max_code) {
            continue;
          }
          s2.bl_count[bits]++;
          xbits = 0;
          if (n2 >= base) {
            xbits = extra[n2 - base];
          }
          f2 = tree[n2 * 2];
          s2.opt_len += f2 * (bits + xbits);
          if (has_stree) {
            s2.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
          }
        }
        if (overflow === 0) {
          return;
        }
        do {
          bits = max_length - 1;
          while (s2.bl_count[bits] === 0) {
            bits--;
          }
          s2.bl_count[bits]--;
          s2.bl_count[bits + 1] += 2;
          s2.bl_count[max_length]--;
          overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n2 = s2.bl_count[bits];
          while (n2 !== 0) {
            m = s2.heap[--h2];
            if (m > max_code) {
              continue;
            }
            if (tree[m * 2 + 1] !== bits) {
              s2.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
              tree[m * 2 + 1] = bits;
            }
            n2--;
          }
        }
      }
      function gen_codes(tree, max_code, bl_count) {
        var next_code = new Array(MAX_BITS + 1);
        var code = 0;
        var bits;
        var n2;
        for (bits = 1; bits <= MAX_BITS; bits++) {
          next_code[bits] = code = code + bl_count[bits - 1] << 1;
        }
        for (n2 = 0; n2 <= max_code; n2++) {
          var len = tree[n2 * 2 + 1];
          if (len === 0) {
            continue;
          }
          tree[n2 * 2] = bi_reverse(next_code[len]++, len);
        }
      }
      function tr_static_init() {
        var n2;
        var bits;
        var length;
        var code;
        var dist;
        var bl_count = new Array(MAX_BITS + 1);
        length = 0;
        for (code = 0; code < LENGTH_CODES - 1; code++) {
          base_length[code] = length;
          for (n2 = 0; n2 < 1 << extra_lbits[code]; n2++) {
            _length_code[length++] = code;
          }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;
          for (n2 = 0; n2 < 1 << extra_dbits[code]; n2++) {
            _dist_code[dist++] = code;
          }
        }
        dist >>= 7;
        for (; code < D_CODES; code++) {
          base_dist[code] = dist << 7;
          for (n2 = 0; n2 < 1 << extra_dbits[code] - 7; n2++) {
            _dist_code[256 + dist++] = code;
          }
        }
        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0;
        }
        n2 = 0;
        while (n2 <= 143) {
          static_ltree[n2 * 2 + 1] = 8;
          n2++;
          bl_count[8]++;
        }
        while (n2 <= 255) {
          static_ltree[n2 * 2 + 1] = 9;
          n2++;
          bl_count[9]++;
        }
        while (n2 <= 279) {
          static_ltree[n2 * 2 + 1] = 7;
          n2++;
          bl_count[7]++;
        }
        while (n2 <= 287) {
          static_ltree[n2 * 2 + 1] = 8;
          n2++;
          bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES + 1, bl_count);
        for (n2 = 0; n2 < D_CODES; n2++) {
          static_dtree[n2 * 2 + 1] = 5;
          static_dtree[n2 * 2] = bi_reverse(n2, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
      }
      function init_block(s2) {
        var n2;
        for (n2 = 0; n2 < L_CODES; n2++) {
          s2.dyn_ltree[n2 * 2] = 0;
        }
        for (n2 = 0; n2 < D_CODES; n2++) {
          s2.dyn_dtree[n2 * 2] = 0;
        }
        for (n2 = 0; n2 < BL_CODES; n2++) {
          s2.bl_tree[n2 * 2] = 0;
        }
        s2.dyn_ltree[END_BLOCK * 2] = 1;
        s2.opt_len = s2.static_len = 0;
        s2.last_lit = s2.matches = 0;
      }
      function bi_windup(s2) {
        if (s2.bi_valid > 8) {
          put_short(s2, s2.bi_buf);
        } else if (s2.bi_valid > 0) {
          s2.pending_buf[s2.pending++] = s2.bi_buf;
        }
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      }
      function copy_block(s2, buf, len, header) {
        bi_windup(s2);
        if (header) {
          put_short(s2, len);
          put_short(s2, ~len);
        }
        utils.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
        s2.pending += len;
      }
      function smaller(tree, n2, m, depth) {
        var _n2 = n2 * 2;
        var _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m];
      }
      function pqdownheap(s2, tree, k) {
        var v2 = s2.heap[k];
        var j = k << 1;
        while (j <= s2.heap_len) {
          if (j < s2.heap_len && smaller(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
            j++;
          }
          if (smaller(tree, v2, s2.heap[j], s2.depth)) {
            break;
          }
          s2.heap[k] = s2.heap[j];
          k = j;
          j <<= 1;
        }
        s2.heap[k] = v2;
      }
      function compress_block(s2, ltree, dtree) {
        var dist;
        var lc;
        var lx = 0;
        var code;
        var extra;
        if (s2.last_lit !== 0) {
          do {
            dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
            lc = s2.pending_buf[s2.l_buf + lx];
            lx++;
            if (dist === 0) {
              send_code(s2, lc, ltree);
            } else {
              code = _length_code[lc];
              send_code(s2, code + LITERALS + 1, ltree);
              extra = extra_lbits[code];
              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s2, lc, extra);
              }
              dist--;
              code = d_code(dist);
              send_code(s2, code, dtree);
              extra = extra_dbits[code];
              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s2, dist, extra);
              }
            }
          } while (lx < s2.last_lit);
        }
        send_code(s2, END_BLOCK, ltree);
      }
      function build_tree(s2, desc) {
        var tree = desc.dyn_tree;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems = desc.stat_desc.elems;
        var n2, m;
        var max_code = -1;
        var node;
        s2.heap_len = 0;
        s2.heap_max = HEAP_SIZE;
        for (n2 = 0; n2 < elems; n2++) {
          if (tree[n2 * 2] !== 0) {
            s2.heap[++s2.heap_len] = max_code = n2;
            s2.depth[n2] = 0;
          } else {
            tree[n2 * 2 + 1] = 0;
          }
        }
        while (s2.heap_len < 2) {
          node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node * 2] = 1;
          s2.depth[node] = 0;
          s2.opt_len--;
          if (has_stree) {
            s2.static_len -= stree[node * 2 + 1];
          }
        }
        desc.max_code = max_code;
        for (n2 = s2.heap_len >> 1; n2 >= 1; n2--) {
          pqdownheap(s2, tree, n2);
        }
        node = elems;
        do {
          n2 = s2.heap[
            1
            /*SMALLEST*/
          ];
          s2.heap[
            1
            /*SMALLEST*/
          ] = s2.heap[s2.heap_len--];
          pqdownheap(
            s2,
            tree,
            1
            /*SMALLEST*/
          );
          m = s2.heap[
            1
            /*SMALLEST*/
          ];
          s2.heap[--s2.heap_max] = n2;
          s2.heap[--s2.heap_max] = m;
          tree[node * 2] = tree[n2 * 2] + tree[m * 2];
          s2.depth[node] = (s2.depth[n2] >= s2.depth[m] ? s2.depth[n2] : s2.depth[m]) + 1;
          tree[n2 * 2 + 1] = tree[m * 2 + 1] = node;
          s2.heap[
            1
            /*SMALLEST*/
          ] = node++;
          pqdownheap(
            s2,
            tree,
            1
            /*SMALLEST*/
          );
        } while (s2.heap_len >= 2);
        s2.heap[--s2.heap_max] = s2.heap[
          1
          /*SMALLEST*/
        ];
        gen_bitlen(s2, desc);
        gen_codes(tree, max_code, s2.bl_count);
      }
      function scan_tree(s2, tree, max_code) {
        var n2;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n2 = 0; n2 <= max_code; n2++) {
          curlen = nextlen;
          nextlen = tree[(n2 + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            s2.bl_tree[curlen * 2] += count;
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s2.bl_tree[curlen * 2]++;
            }
            s2.bl_tree[REP_3_6 * 2]++;
          } else if (count <= 10) {
            s2.bl_tree[REPZ_3_10 * 2]++;
          } else {
            s2.bl_tree[REPZ_11_138 * 2]++;
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      function send_tree(s2, tree, max_code) {
        var n2;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        for (n2 = 0; n2 <= max_code; n2++) {
          curlen = nextlen;
          nextlen = tree[(n2 + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            do {
              send_code(s2, curlen, s2.bl_tree);
            } while (--count !== 0);
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s2, curlen, s2.bl_tree);
              count--;
            }
            send_code(s2, REP_3_6, s2.bl_tree);
            send_bits(s2, count - 3, 2);
          } else if (count <= 10) {
            send_code(s2, REPZ_3_10, s2.bl_tree);
            send_bits(s2, count - 3, 3);
          } else {
            send_code(s2, REPZ_11_138, s2.bl_tree);
            send_bits(s2, count - 11, 7);
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      function build_bl_tree(s2) {
        var max_blindex;
        scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
        scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
        build_tree(s2, s2.bl_desc);
        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
          if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
          }
        }
        s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
      }
      function send_all_trees(s2, lcodes, dcodes, blcodes) {
        var rank;
        send_bits(s2, lcodes - 257, 5);
        send_bits(s2, dcodes - 1, 5);
        send_bits(s2, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
          send_bits(s2, s2.bl_tree[bl_order[rank] * 2 + 1], 3);
        }
        send_tree(s2, s2.dyn_ltree, lcodes - 1);
        send_tree(s2, s2.dyn_dtree, dcodes - 1);
      }
      function detect_data_type(s2) {
        var black_mask = 4093624447;
        var n2;
        for (n2 = 0; n2 <= 31; n2++, black_mask >>>= 1) {
          if (black_mask & 1 && s2.dyn_ltree[n2 * 2] !== 0) {
            return Z_BINARY;
          }
        }
        if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
          return Z_TEXT;
        }
        for (n2 = 32; n2 < LITERALS; n2++) {
          if (s2.dyn_ltree[n2 * 2] !== 0) {
            return Z_TEXT;
          }
        }
        return Z_BINARY;
      }
      var static_init_done = false;
      function _tr_init(s2) {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true;
        }
        s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
        s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
        s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
        init_block(s2);
      }
      function _tr_stored_block(s2, buf, stored_len, last) {
        send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        copy_block(s2, buf, stored_len, true);
      }
      function _tr_align(s2) {
        send_bits(s2, STATIC_TREES << 1, 3);
        send_code(s2, END_BLOCK, static_ltree);
        bi_flush(s2);
      }
      function _tr_flush_block(s2, buf, stored_len, last) {
        var opt_lenb, static_lenb;
        var max_blindex = 0;
        if (s2.level > 0) {
          if (s2.strm.data_type === Z_UNKNOWN) {
            s2.strm.data_type = detect_data_type(s2);
          }
          build_tree(s2, s2.l_desc);
          build_tree(s2, s2.d_desc);
          max_blindex = build_bl_tree(s2);
          opt_lenb = s2.opt_len + 3 + 7 >>> 3;
          static_lenb = s2.static_len + 3 + 7 >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          _tr_stored_block(s2, buf, stored_len, last);
        } else if (s2.strategy === Z_FIXED || static_lenb === opt_lenb) {
          send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s2, static_ltree, static_dtree);
        } else {
          send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
        }
        init_block(s2);
        if (last) {
          bi_windup(s2);
        }
      }
      function _tr_tally(s2, dist, lc) {
        s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
        s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
        s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
        s2.last_lit++;
        if (dist === 0) {
          s2.dyn_ltree[lc * 2]++;
        } else {
          s2.matches++;
          dist--;
          s2.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
          s2.dyn_dtree[d_code(dist) * 2]++;
        }
        return s2.last_lit === s2.lit_bufsize - 1;
      }
      exports._tr_init = _tr_init;
      exports._tr_stored_block = _tr_stored_block;
      exports._tr_flush_block = _tr_flush_block;
      exports._tr_tally = _tr_tally;
      exports._tr_align = _tr_align;
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js
  var require_adler32 = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js"(exports, module) {
      "use strict";
      init_shim();
      function adler32(adler, buf, len, pos) {
        var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
        while (len !== 0) {
          n2 = len > 2e3 ? 2e3 : len;
          len -= n2;
          do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
          } while (--n2);
          s1 %= 65521;
          s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
      }
      module.exports = adler32;
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js
  var require_crc32 = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js"(exports, module) {
      "use strict";
      init_shim();
      function makeTable() {
        var c, table = [];
        for (var n2 = 0; n2 < 256; n2++) {
          c = n2;
          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          }
          table[n2] = c;
        }
        return table;
      }
      var crcTable = makeTable();
      function crc32(crc, buf, len, pos) {
        var t2 = crcTable, end = pos + len;
        crc ^= -1;
        for (var i2 = pos; i2 < end; i2++) {
          crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
        }
        return crc ^ -1;
      }
      module.exports = crc32;
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js
  var require_messages = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = {
        2: "need dictionary",
        /* Z_NEED_DICT       2  */
        1: "stream end",
        /* Z_STREAM_END      1  */
        0: "",
        /* Z_OK              0  */
        "-1": "file error",
        /* Z_ERRNO         (-1) */
        "-2": "stream error",
        /* Z_STREAM_ERROR  (-2) */
        "-3": "data error",
        /* Z_DATA_ERROR    (-3) */
        "-4": "insufficient memory",
        /* Z_MEM_ERROR     (-4) */
        "-5": "buffer error",
        /* Z_BUF_ERROR     (-5) */
        "-6": "incompatible version"
        /* Z_VERSION_ERROR (-6) */
      };
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js
  var require_deflate = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js"(exports) {
      "use strict";
      init_shim();
      var utils = require_common();
      var trees = require_trees();
      var adler32 = require_adler32();
      var crc32 = require_crc32();
      var msg = require_messages();
      var Z_NO_FLUSH = 0;
      var Z_PARTIAL_FLUSH = 1;
      var Z_FULL_FLUSH = 3;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_BUF_ERROR = -5;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_FILTERED = 1;
      var Z_HUFFMAN_ONLY = 2;
      var Z_RLE = 3;
      var Z_FIXED = 4;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_UNKNOWN = 2;
      var Z_DEFLATED = 8;
      var MAX_MEM_LEVEL = 9;
      var MAX_WBITS = 15;
      var DEF_MEM_LEVEL = 8;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
      var PRESET_DICT = 32;
      var INIT_STATE = 42;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;
      var BS_NEED_MORE = 1;
      var BS_BLOCK_DONE = 2;
      var BS_FINISH_STARTED = 3;
      var BS_FINISH_DONE = 4;
      var OS_CODE = 3;
      function err2(strm, errorCode) {
        strm.msg = msg[errorCode];
        return errorCode;
      }
      function rank(f2) {
        return (f2 << 1) - (f2 > 4 ? 9 : 0);
      }
      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      function flush_pending(strm) {
        var s2 = strm.state;
        var len = s2.pending;
        if (len > strm.avail_out) {
          len = strm.avail_out;
        }
        if (len === 0) {
          return;
        }
        utils.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
        strm.next_out += len;
        s2.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s2.pending -= len;
        if (s2.pending === 0) {
          s2.pending_out = 0;
        }
      }
      function flush_block_only(s2, last) {
        trees._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
        s2.block_start = s2.strstart;
        flush_pending(s2.strm);
      }
      function put_byte(s2, b2) {
        s2.pending_buf[s2.pending++] = b2;
      }
      function putShortMSB(s2, b2) {
        s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
        s2.pending_buf[s2.pending++] = b2 & 255;
      }
      function read_buf(strm, buf, start, size) {
        var len = strm.avail_in;
        if (len > size) {
          len = size;
        }
        if (len === 0) {
          return 0;
        }
        strm.avail_in -= len;
        utils.arraySet(buf, strm.input, strm.next_in, len, start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32(strm.adler, buf, len, start);
        }
        strm.next_in += len;
        strm.total_in += len;
        return len;
      }
      function longest_match(s2, cur_match) {
        var chain_length = s2.max_chain_length;
        var scan = s2.strstart;
        var match;
        var len;
        var best_len = s2.prev_length;
        var nice_match = s2.nice_match;
        var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
        var _win = s2.window;
        var wmask = s2.w_mask;
        var prev = s2.prev;
        var strend = s2.strstart + MAX_MATCH;
        var scan_end1 = _win[scan + best_len - 1];
        var scan_end = _win[scan + best_len];
        if (s2.prev_length >= s2.good_match) {
          chain_length >>= 2;
        }
        if (nice_match > s2.lookahead) {
          nice_match = s2.lookahead;
        }
        do {
          match = cur_match;
          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue;
          }
          scan += 2;
          match++;
          do {
          } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
          len = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;
          if (len > best_len) {
            s2.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
              break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s2.lookahead) {
          return best_len;
        }
        return s2.lookahead;
      }
      function fill_window(s2) {
        var _w_size = s2.w_size;
        var p2, n2, m, more, str;
        do {
          more = s2.window_size - s2.lookahead - s2.strstart;
          if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            utils.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
            s2.match_start -= _w_size;
            s2.strstart -= _w_size;
            s2.block_start -= _w_size;
            n2 = s2.hash_size;
            p2 = n2;
            do {
              m = s2.head[--p2];
              s2.head[p2] = m >= _w_size ? m - _w_size : 0;
            } while (--n2);
            n2 = _w_size;
            p2 = n2;
            do {
              m = s2.prev[--p2];
              s2.prev[p2] = m >= _w_size ? m - _w_size : 0;
            } while (--n2);
            more += _w_size;
          }
          if (s2.strm.avail_in === 0) {
            break;
          }
          n2 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
          s2.lookahead += n2;
          if (s2.lookahead + s2.insert >= MIN_MATCH) {
            str = s2.strstart - s2.insert;
            s2.ins_h = s2.window[str];
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
            while (s2.insert) {
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
              s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = str;
              str++;
              s2.insert--;
              if (s2.lookahead + s2.insert < MIN_MATCH) {
                break;
              }
            }
          }
        } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
      }
      function deflate_stored(s2, flush) {
        var max_block_size = 65535;
        if (max_block_size > s2.pending_buf_size - 5) {
          max_block_size = s2.pending_buf_size - 5;
        }
        for (; ; ) {
          if (s2.lookahead <= 1) {
            fill_window(s2);
            if (s2.lookahead === 0 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s2.lookahead === 0) {
              break;
            }
          }
          s2.strstart += s2.lookahead;
          s2.lookahead = 0;
          var max_start = s2.block_start + max_block_size;
          if (s2.strstart === 0 || s2.strstart >= max_start) {
            s2.lookahead = s2.strstart - max_start;
            s2.strstart = max_start;
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s2.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s2, true);
          if (s2.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s2.strstart > s2.block_start) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_NEED_MORE;
      }
      function deflate_fast(s2, flush) {
        var hash_head;
        var bflush;
        for (; ; ) {
          if (s2.lookahead < MIN_LOOKAHEAD) {
            fill_window(s2);
            if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s2.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s2.lookahead >= MIN_MATCH) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          }
          if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
            s2.match_length = longest_match(s2, hash_head);
          }
          if (s2.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
            s2.lookahead -= s2.match_length;
            if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
              s2.match_length--;
              do {
                s2.strstart++;
                s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
                hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
                s2.head[s2.ins_h] = s2.strstart;
              } while (--s2.match_length !== 0);
              s2.strstart++;
            } else {
              s2.strstart += s2.match_length;
              s2.match_length = 0;
              s2.ins_h = s2.window[s2.strstart];
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
            }
          } else {
            bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
            s2.lookahead--;
            s2.strstart++;
          }
          if (bflush) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s2, true);
          if (s2.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s2.last_lit) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_slow(s2, flush) {
        var hash_head;
        var bflush;
        var max_insert;
        for (; ; ) {
          if (s2.lookahead < MIN_LOOKAHEAD) {
            fill_window(s2);
            if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s2.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s2.lookahead >= MIN_MATCH) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          }
          s2.prev_length = s2.match_length;
          s2.prev_match = s2.match_start;
          s2.match_length = MIN_MATCH - 1;
          if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
            s2.match_length = longest_match(s2, hash_head);
            if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
              s2.match_length = MIN_MATCH - 1;
            }
          }
          if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
            max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
            bflush = trees._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
            s2.lookahead -= s2.prev_length - 1;
            s2.prev_length -= 2;
            do {
              if (++s2.strstart <= max_insert) {
                s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
                hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
                s2.head[s2.ins_h] = s2.strstart;
              }
            } while (--s2.prev_length !== 0);
            s2.match_available = 0;
            s2.match_length = MIN_MATCH - 1;
            s2.strstart++;
            if (bflush) {
              flush_block_only(s2, false);
              if (s2.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          } else if (s2.match_available) {
            bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
            if (bflush) {
              flush_block_only(s2, false);
            }
            s2.strstart++;
            s2.lookahead--;
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          } else {
            s2.match_available = 1;
            s2.strstart++;
            s2.lookahead--;
          }
        }
        if (s2.match_available) {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
          s2.match_available = 0;
        }
        s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s2, true);
          if (s2.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s2.last_lit) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_rle(s2, flush) {
        var bflush;
        var prev;
        var scan, strend;
        var _win = s2.window;
        for (; ; ) {
          if (s2.lookahead <= MAX_MATCH) {
            fill_window(s2);
            if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s2.lookahead === 0) {
              break;
            }
          }
          s2.match_length = 0;
          if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
            scan = s2.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s2.strstart + MAX_MATCH;
              do {
              } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
              s2.match_length = MAX_MATCH - (strend - scan);
              if (s2.match_length > s2.lookahead) {
                s2.match_length = s2.lookahead;
              }
            }
          }
          if (s2.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
            s2.lookahead -= s2.match_length;
            s2.strstart += s2.match_length;
            s2.match_length = 0;
          } else {
            bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
            s2.lookahead--;
            s2.strstart++;
          }
          if (bflush) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s2.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s2, true);
          if (s2.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s2.last_lit) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_huff(s2, flush) {
        var bflush;
        for (; ; ) {
          if (s2.lookahead === 0) {
            fill_window(s2);
            if (s2.lookahead === 0) {
              if (flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              break;
            }
          }
          s2.match_length = 0;
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
          if (bflush) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s2.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s2, true);
          if (s2.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s2.last_lit) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
      }
      var configuration_table;
      configuration_table = [
        /*      good lazy nice chain */
        new Config(0, 0, 0, 0, deflate_stored),
        /* 0 store only */
        new Config(4, 4, 8, 4, deflate_fast),
        /* 1 max speed, no lazy matches */
        new Config(4, 5, 16, 8, deflate_fast),
        /* 2 */
        new Config(4, 6, 32, 32, deflate_fast),
        /* 3 */
        new Config(4, 4, 16, 16, deflate_slow),
        /* 4 lazy matches */
        new Config(8, 16, 32, 32, deflate_slow),
        /* 5 */
        new Config(8, 16, 128, 128, deflate_slow),
        /* 6 */
        new Config(8, 32, 128, 256, deflate_slow),
        /* 7 */
        new Config(32, 128, 258, 1024, deflate_slow),
        /* 8 */
        new Config(32, 258, 258, 4096, deflate_slow)
        /* 9 max compression */
      ];
      function lm_init(s2) {
        s2.window_size = 2 * s2.w_size;
        zero(s2.head);
        s2.max_lazy_match = configuration_table[s2.level].max_lazy;
        s2.good_match = configuration_table[s2.level].good_length;
        s2.nice_match = configuration_table[s2.level].nice_length;
        s2.max_chain_length = configuration_table[s2.level].max_chain;
        s2.strstart = 0;
        s2.block_start = 0;
        s2.lookahead = 0;
        s2.insert = 0;
        s2.match_length = s2.prev_length = MIN_MATCH - 1;
        s2.match_available = 0;
        s2.ins_h = 0;
      }
      function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
        this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
        this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new utils.Buf16(MAX_BITS + 1);
        this.heap = new utils.Buf16(2 * L_CODES + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new utils.Buf16(2 * L_CODES + 1);
        zero(this.depth);
        this.l_buf = 0;
        this.lit_bufsize = 0;
        this.last_lit = 0;
        this.d_buf = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
      }
      function deflateResetKeep(strm) {
        var s2;
        if (!strm || !strm.state) {
          return err2(strm, Z_STREAM_ERROR);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        s2 = strm.state;
        s2.pending = 0;
        s2.pending_out = 0;
        if (s2.wrap < 0) {
          s2.wrap = -s2.wrap;
        }
        s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s2.wrap === 2 ? 0 : 1;
        s2.last_flush = Z_NO_FLUSH;
        trees._tr_init(s2);
        return Z_OK;
      }
      function deflateReset(strm) {
        var ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
          lm_init(strm.state);
        }
        return ret;
      }
      function deflateSetHeader(strm, head) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        if (strm.state.wrap !== 2) {
          return Z_STREAM_ERROR;
        }
        strm.state.gzhead = head;
        return Z_OK;
      }
      function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        var wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION) {
          level = 6;
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
          return err2(strm, Z_STREAM_ERROR);
        }
        if (windowBits === 8) {
          windowBits = 9;
        }
        var s2 = new DeflateState();
        strm.state = s2;
        s2.strm = strm;
        s2.wrap = wrap;
        s2.gzhead = null;
        s2.w_bits = windowBits;
        s2.w_size = 1 << s2.w_bits;
        s2.w_mask = s2.w_size - 1;
        s2.hash_bits = memLevel + 7;
        s2.hash_size = 1 << s2.hash_bits;
        s2.hash_mask = s2.hash_size - 1;
        s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s2.window = new utils.Buf8(s2.w_size * 2);
        s2.head = new utils.Buf16(s2.hash_size);
        s2.prev = new utils.Buf16(s2.w_size);
        s2.lit_bufsize = 1 << memLevel + 6;
        s2.pending_buf_size = s2.lit_bufsize * 4;
        s2.pending_buf = new utils.Buf8(s2.pending_buf_size);
        s2.d_buf = 1 * s2.lit_bufsize;
        s2.l_buf = (1 + 2) * s2.lit_bufsize;
        s2.level = level;
        s2.strategy = strategy;
        s2.method = method;
        return deflateReset(strm);
      }
      function deflateInit(strm, level) {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
      }
      function deflate(strm, flush) {
        var old_flush, s2;
        var beg, val;
        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
          return strm ? err2(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
        }
        s2 = strm.state;
        if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH) {
          return err2(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
        }
        s2.strm = strm;
        old_flush = s2.last_flush;
        s2.last_flush = flush;
        if (s2.status === INIT_STATE) {
          if (s2.wrap === 2) {
            strm.adler = 0;
            put_byte(s2, 31);
            put_byte(s2, 139);
            put_byte(s2, 8);
            if (!s2.gzhead) {
              put_byte(s2, 0);
              put_byte(s2, 0);
              put_byte(s2, 0);
              put_byte(s2, 0);
              put_byte(s2, 0);
              put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
              put_byte(s2, OS_CODE);
              s2.status = BUSY_STATE;
            } else {
              put_byte(
                s2,
                (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
              );
              put_byte(s2, s2.gzhead.time & 255);
              put_byte(s2, s2.gzhead.time >> 8 & 255);
              put_byte(s2, s2.gzhead.time >> 16 & 255);
              put_byte(s2, s2.gzhead.time >> 24 & 255);
              put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
              put_byte(s2, s2.gzhead.os & 255);
              if (s2.gzhead.extra && s2.gzhead.extra.length) {
                put_byte(s2, s2.gzhead.extra.length & 255);
                put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
              }
              if (s2.gzhead.hcrc) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending, 0);
              }
              s2.gzindex = 0;
              s2.status = EXTRA_STATE;
            }
          } else {
            var header = Z_DEFLATED + (s2.w_bits - 8 << 4) << 8;
            var level_flags = -1;
            if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
              level_flags = 0;
            } else if (s2.level < 6) {
              level_flags = 1;
            } else if (s2.level === 6) {
              level_flags = 2;
            } else {
              level_flags = 3;
            }
            header |= level_flags << 6;
            if (s2.strstart !== 0) {
              header |= PRESET_DICT;
            }
            header += 31 - header % 31;
            s2.status = BUSY_STATE;
            putShortMSB(s2, header);
            if (s2.strstart !== 0) {
              putShortMSB(s2, strm.adler >>> 16);
              putShortMSB(s2, strm.adler & 65535);
            }
            strm.adler = 1;
          }
        }
        if (s2.status === EXTRA_STATE) {
          if (s2.gzhead.extra) {
            beg = s2.pending;
            while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
              if (s2.pending === s2.pending_buf_size) {
                if (s2.gzhead.hcrc && s2.pending > beg) {
                  strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s2.pending;
                if (s2.pending === s2.pending_buf_size) {
                  break;
                }
              }
              put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
              s2.gzindex++;
            }
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            if (s2.gzindex === s2.gzhead.extra.length) {
              s2.gzindex = 0;
              s2.status = NAME_STATE;
            }
          } else {
            s2.status = NAME_STATE;
          }
        }
        if (s2.status === NAME_STATE) {
          if (s2.gzhead.name) {
            beg = s2.pending;
            do {
              if (s2.pending === s2.pending_buf_size) {
                if (s2.gzhead.hcrc && s2.pending > beg) {
                  strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s2.pending;
                if (s2.pending === s2.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s2.gzindex < s2.gzhead.name.length) {
                val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s2, val);
            } while (val !== 0);
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            if (val === 0) {
              s2.gzindex = 0;
              s2.status = COMMENT_STATE;
            }
          } else {
            s2.status = COMMENT_STATE;
          }
        }
        if (s2.status === COMMENT_STATE) {
          if (s2.gzhead.comment) {
            beg = s2.pending;
            do {
              if (s2.pending === s2.pending_buf_size) {
                if (s2.gzhead.hcrc && s2.pending > beg) {
                  strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s2.pending;
                if (s2.pending === s2.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s2.gzindex < s2.gzhead.comment.length) {
                val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s2, val);
            } while (val !== 0);
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            if (val === 0) {
              s2.status = HCRC_STATE;
            }
          } else {
            s2.status = HCRC_STATE;
          }
        }
        if (s2.status === HCRC_STATE) {
          if (s2.gzhead.hcrc) {
            if (s2.pending + 2 > s2.pending_buf_size) {
              flush_pending(strm);
            }
            if (s2.pending + 2 <= s2.pending_buf_size) {
              put_byte(s2, strm.adler & 255);
              put_byte(s2, strm.adler >> 8 & 255);
              strm.adler = 0;
              s2.status = BUSY_STATE;
            }
          } else {
            s2.status = BUSY_STATE;
          }
        }
        if (s2.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK;
          }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
          return err2(strm, Z_BUF_ERROR);
        }
        if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
          return err2(strm, Z_BUF_ERROR);
        }
        if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
          var bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s2.status = FINISH_STATE;
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s2.last_flush = -1;
            }
            return Z_OK;
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              trees._tr_align(s2);
            } else if (flush !== Z_BLOCK) {
              trees._tr_stored_block(s2, 0, 0, false);
              if (flush === Z_FULL_FLUSH) {
                zero(s2.head);
                if (s2.lookahead === 0) {
                  s2.strstart = 0;
                  s2.block_start = 0;
                  s2.insert = 0;
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s2.last_flush = -1;
              return Z_OK;
            }
          }
        }
        if (flush !== Z_FINISH) {
          return Z_OK;
        }
        if (s2.wrap <= 0) {
          return Z_STREAM_END;
        }
        if (s2.wrap === 2) {
          put_byte(s2, strm.adler & 255);
          put_byte(s2, strm.adler >> 8 & 255);
          put_byte(s2, strm.adler >> 16 & 255);
          put_byte(s2, strm.adler >> 24 & 255);
          put_byte(s2, strm.total_in & 255);
          put_byte(s2, strm.total_in >> 8 & 255);
          put_byte(s2, strm.total_in >> 16 & 255);
          put_byte(s2, strm.total_in >> 24 & 255);
        } else {
          putShortMSB(s2, strm.adler >>> 16);
          putShortMSB(s2, strm.adler & 65535);
        }
        flush_pending(strm);
        if (s2.wrap > 0) {
          s2.wrap = -s2.wrap;
        }
        return s2.pending !== 0 ? Z_OK : Z_STREAM_END;
      }
      function deflateEnd(strm) {
        var status;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        status = strm.state.status;
        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
          return err2(strm, Z_STREAM_ERROR);
        }
        strm.state = null;
        return status === BUSY_STATE ? err2(strm, Z_DATA_ERROR) : Z_OK;
      }
      function deflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var s2;
        var str, n2;
        var wrap;
        var avail;
        var next;
        var input;
        var tmpDict;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        s2 = strm.state;
        wrap = s2.wrap;
        if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
          return Z_STREAM_ERROR;
        }
        if (wrap === 1) {
          strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
        }
        s2.wrap = 0;
        if (dictLength >= s2.w_size) {
          if (wrap === 0) {
            zero(s2.head);
            s2.strstart = 0;
            s2.block_start = 0;
            s2.insert = 0;
          }
          tmpDict = new utils.Buf8(s2.w_size);
          utils.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
          dictionary = tmpDict;
          dictLength = s2.w_size;
        }
        avail = strm.avail_in;
        next = strm.next_in;
        input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s2);
        while (s2.lookahead >= MIN_MATCH) {
          str = s2.strstart;
          n2 = s2.lookahead - (MIN_MATCH - 1);
          do {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
          } while (--n2);
          s2.strstart = str;
          s2.lookahead = MIN_MATCH - 1;
          fill_window(s2);
        }
        s2.strstart += s2.lookahead;
        s2.block_start = s2.strstart;
        s2.insert = s2.lookahead;
        s2.lookahead = 0;
        s2.match_length = s2.prev_length = MIN_MATCH - 1;
        s2.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s2.wrap = wrap;
        return Z_OK;
      }
      exports.deflateInit = deflateInit;
      exports.deflateInit2 = deflateInit2;
      exports.deflateReset = deflateReset;
      exports.deflateResetKeep = deflateResetKeep;
      exports.deflateSetHeader = deflateSetHeader;
      exports.deflate = deflate;
      exports.deflateEnd = deflateEnd;
      exports.deflateSetDictionary = deflateSetDictionary;
      exports.deflateInfo = "pako deflate (from Nodeca project)";
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/strings.js
  var require_strings = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/strings.js"(exports) {
      "use strict";
      init_shim();
      var utils = require_common();
      var STR_APPLY_OK = true;
      var STR_APPLY_UIA_OK = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (__) {
        STR_APPLY_OK = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (__) {
        STR_APPLY_UIA_OK = false;
      }
      var _utf8len = new utils.Buf8(256);
      for (q = 0; q < 256; q++) {
        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
      }
      var q;
      _utf8len[254] = _utf8len[254] = 1;
      exports.string2buf = function(str) {
        var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
        }
        buf = new utils.Buf8(buf_len);
        for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          if (c < 128) {
            buf[i2++] = c;
          } else if (c < 2048) {
            buf[i2++] = 192 | c >>> 6;
            buf[i2++] = 128 | c & 63;
          } else if (c < 65536) {
            buf[i2++] = 224 | c >>> 12;
            buf[i2++] = 128 | c >>> 6 & 63;
            buf[i2++] = 128 | c & 63;
          } else {
            buf[i2++] = 240 | c >>> 18;
            buf[i2++] = 128 | c >>> 12 & 63;
            buf[i2++] = 128 | c >>> 6 & 63;
            buf[i2++] = 128 | c & 63;
          }
        }
        return buf;
      };
      function buf2binstring(buf, len) {
        if (len < 65534) {
          if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
            return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
          }
        }
        var result = "";
        for (var i2 = 0; i2 < len; i2++) {
          result += String.fromCharCode(buf[i2]);
        }
        return result;
      }
      exports.buf2binstring = function(buf) {
        return buf2binstring(buf, buf.length);
      };
      exports.binstring2buf = function(str) {
        var buf = new utils.Buf8(str.length);
        for (var i2 = 0, len = buf.length; i2 < len; i2++) {
          buf[i2] = str.charCodeAt(i2);
        }
        return buf;
      };
      exports.buf2string = function(buf, max) {
        var i2, out2, c, c_len;
        var len = max || buf.length;
        var utf16buf = new Array(len * 2);
        for (out2 = 0, i2 = 0; i2 < len; ) {
          c = buf[i2++];
          if (c < 128) {
            utf16buf[out2++] = c;
            continue;
          }
          c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out2++] = 65533;
            i2 += c_len - 1;
            continue;
          }
          c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i2 < len) {
            c = c << 6 | buf[i2++] & 63;
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out2++] = 65533;
            continue;
          }
          if (c < 65536) {
            utf16buf[out2++] = c;
          } else {
            c -= 65536;
            utf16buf[out2++] = 55296 | c >> 10 & 1023;
            utf16buf[out2++] = 56320 | c & 1023;
          }
        }
        return buf2binstring(utf16buf, out2);
      };
      exports.utf8border = function(buf, max) {
        var pos;
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length;
        }
        pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--;
        }
        if (pos < 0) {
          return max;
        }
        if (pos === 0) {
          return max;
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max;
      };
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js
  var require_zstream = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js"(exports, module) {
      "use strict";
      init_shim();
      function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
      }
      module.exports = ZStream;
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/deflate.js
  var require_deflate2 = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/deflate.js"(exports) {
      "use strict";
      init_shim();
      var zlib_deflate = require_deflate();
      var utils = require_common();
      var strings = require_strings();
      var msg = require_messages();
      var ZStream = require_zstream();
      var toString = Object.prototype.toString;
      var Z_NO_FLUSH = 0;
      var Z_FINISH = 4;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_SYNC_FLUSH = 2;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_DEFLATED = 8;
      function Deflate(options) {
        if (!(this instanceof Deflate)) return new Deflate(options);
        this.options = utils.assign({
          level: Z_DEFAULT_COMPRESSION,
          method: Z_DEFLATED,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: Z_DEFAULT_STRATEGY,
          to: ""
        }, options || {});
        var opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
          opt.windowBits = -opt.windowBits;
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
          opt.windowBits += 16;
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        var status = zlib_deflate.deflateInit2(
          this.strm,
          opt.level,
          opt.method,
          opt.windowBits,
          opt.memLevel,
          opt.strategy
        );
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        if (opt.header) {
          zlib_deflate.deflateSetHeader(this.strm, opt.header);
        }
        if (opt.dictionary) {
          var dict;
          if (typeof opt.dictionary === "string") {
            dict = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            dict = new Uint8Array(opt.dictionary);
          } else {
            dict = opt.dictionary;
          }
          status = zlib_deflate.deflateSetDictionary(this.strm, dict);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          this._dict_set = true;
        }
      }
      Deflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var status, _mode;
        if (this.ended) {
          return false;
        }
        _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.string2buf(data);
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_deflate.deflate(strm, _mode);
          if (status !== Z_STREAM_END && status !== Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false;
          }
          if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
        if (_mode === Z_FINISH) {
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (_mode === Z_SYNC_FLUSH) {
          this.onEnd(Z_OK);
          strm.avail_out = 0;
          return true;
        }
        return true;
      };
      Deflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Deflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function deflate(input, options) {
        var deflator = new Deflate(options);
        deflator.push(input, true);
        if (deflator.err) {
          throw deflator.msg || msg[deflator.err];
        }
        return deflator.result;
      }
      function deflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return deflate(input, options);
      }
      function gzip(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate(input, options);
      }
      exports.Deflate = Deflate;
      exports.deflate = deflate;
      exports.deflateRaw = deflateRaw;
      exports.gzip = gzip;
    }
  });

  // node_modules/.pnpm/ttf2woff@3.0.0/node_modules/ttf2woff/index.js
  var require_ttf2woff = __commonJS({
    "node_modules/.pnpm/ttf2woff@3.0.0/node_modules/ttf2woff/index.js"(exports, module) {
      "use strict";
      init_shim();
      var deflate = require_deflate2().deflate;
      function ulong(t2) {
        t2 &= 4294967295;
        if (t2 < 0) {
          t2 += 4294967296;
        }
        return t2;
      }
      function longAlign(n2) {
        return n2 + 3 & ~3;
      }
      function calc_checksum(buf) {
        var sum = 0;
        var nlongs = buf.length / 4;
        for (var i2 = 0; i2 < nlongs; ++i2) {
          var t2 = buf.readUint32BE(i2 * 4);
          sum = ulong(sum + t2);
        }
        return sum;
      }
      var WOFF_OFFSET = {
        MAGIC: 0,
        FLAVOR: 4,
        SIZE: 8,
        NUM_TABLES: 12,
        RESERVED: 14,
        SFNT_SIZE: 16,
        VERSION_MAJ: 20,
        VERSION_MIN: 22,
        META_OFFSET: 24,
        META_LENGTH: 28,
        META_ORIG_LENGTH: 32,
        PRIV_OFFSET: 36,
        PRIV_LENGTH: 40
      };
      var WOFF_ENTRY_OFFSET = {
        TAG: 0,
        OFFSET: 4,
        COMPR_LENGTH: 8,
        LENGTH: 12,
        CHECKSUM: 16
      };
      var SFNT_OFFSET = {
        TAG: 0,
        CHECKSUM: 4,
        OFFSET: 8,
        LENGTH: 12
      };
      var SFNT_ENTRY_OFFSET = {
        FLAVOR: 0,
        VERSION_MAJ: 4,
        VERSION_MIN: 6,
        CHECKSUM_ADJUSTMENT: 8
      };
      var MAGIC = {
        WOFF: 2001684038,
        CHECKSUM_ADJUSTMENT: 2981146554
      };
      var SIZEOF = {
        WOFF_HEADER: 44,
        WOFF_ENTRY: 20,
        SFNT_HEADER: 12,
        SFNT_TABLE_ENTRY: 16
      };
      function woffAppendMetadata(src, metadata) {
        var zdata = deflate(metadata);
        src.writeUint32BE(src.length + zdata.length, WOFF_OFFSET.SIZE);
        src.writeUint32BE(src.length, WOFF_OFFSET.META_OFFSET);
        src.writeUint32BE(zdata.length, WOFF_OFFSET.META_LENGTH);
        src.writeUint32BE(metadata.length, WOFF_OFFSET.META_ORIG_LENGTH);
        return import_buffer.Buffer.concat([src, zdata]);
      }
      function ttf2woff3(arr, options) {
        arr = import_buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.length);
        options = options || {};
        var version2 = {
          maj: 0,
          min: 1
        };
        var numTables = arr.readUint16BE(4);
        var flavor = 65536;
        var woffHeader = import_buffer.Buffer.alloc(SIZEOF.WOFF_HEADER);
        woffHeader.writeUint32BE(MAGIC.WOFF, WOFF_OFFSET.MAGIC);
        woffHeader.writeUint16BE(numTables, WOFF_OFFSET.NUM_TABLES);
        woffHeader.writeUint16BE(0, WOFF_OFFSET.RESERVED);
        woffHeader.writeUint32BE(0, WOFF_OFFSET.SFNT_SIZE);
        woffHeader.writeUint32BE(0, WOFF_OFFSET.META_OFFSET);
        woffHeader.writeUint32BE(0, WOFF_OFFSET.META_LENGTH);
        woffHeader.writeUint32BE(0, WOFF_OFFSET.META_ORIG_LENGTH);
        woffHeader.writeUint32BE(0, WOFF_OFFSET.PRIV_OFFSET);
        woffHeader.writeUint32BE(0, WOFF_OFFSET.PRIV_LENGTH);
        var entries = [];
        var i2, tableEntry;
        for (i2 = 0; i2 < numTables; ++i2) {
          var data = arr.subarray(SIZEOF.SFNT_HEADER + i2 * SIZEOF.SFNT_TABLE_ENTRY);
          tableEntry = {
            Tag: data.subarray(SFNT_OFFSET.TAG, SFNT_OFFSET.TAG + 4),
            checkSum: data.readUint32BE(SFNT_OFFSET.CHECKSUM),
            Offset: data.readUint32BE(SFNT_OFFSET.OFFSET),
            Length: data.readUint32BE(SFNT_OFFSET.LENGTH)
          };
          entries.push(tableEntry);
        }
        entries = entries.sort(function(a2, b3) {
          var aStr = String.fromCharCode.apply(null, a2.Tag);
          var bStr = String.fromCharCode.apply(null, b3.Tag);
          return aStr === bStr ? 0 : aStr < bStr ? -1 : 1;
        });
        var offset = SIZEOF.WOFF_HEADER + numTables * SIZEOF.WOFF_ENTRY;
        var woffSize = offset;
        var sfntSize = SIZEOF.SFNT_HEADER + numTables * SIZEOF.SFNT_TABLE_ENTRY;
        var tableBuf = import_buffer.Buffer.alloc(numTables * SIZEOF.WOFF_ENTRY);
        for (i2 = 0; i2 < numTables; ++i2) {
          tableEntry = entries[i2];
          if (String.fromCharCode.apply(null, tableEntry.Tag) !== "head") {
            var algntable = arr.subarray(tableEntry.Offset, tableEntry.Offset + longAlign(tableEntry.Length));
            if (calc_checksum(algntable) !== tableEntry.checkSum) {
              throw "Checksum error in " + String.fromCharCode.apply(null, tableEntry.Tag);
            }
          }
          tableBuf.writeUint32BE(tableEntry.Tag.readUint32BE(0), i2 * SIZEOF.WOFF_ENTRY + WOFF_ENTRY_OFFSET.TAG);
          tableBuf.writeUint32BE(tableEntry.Length, i2 * SIZEOF.WOFF_ENTRY + WOFF_ENTRY_OFFSET.LENGTH);
          tableBuf.writeUint32BE(tableEntry.checkSum, i2 * SIZEOF.WOFF_ENTRY + WOFF_ENTRY_OFFSET.CHECKSUM);
          sfntSize += longAlign(tableEntry.Length);
        }
        var sfntOffset = SIZEOF.SFNT_HEADER + entries.length * SIZEOF.SFNT_TABLE_ENTRY;
        var csum = calc_checksum(arr.subarray(0, SIZEOF.SFNT_HEADER));
        for (i2 = 0; i2 < entries.length; ++i2) {
          tableEntry = entries[i2];
          var b2 = import_buffer.Buffer.alloc(SIZEOF.SFNT_TABLE_ENTRY);
          b2.writeUint32BE(tableEntry.Tag.readUint32BE(0), SFNT_OFFSET.TAG);
          b2.writeUint32BE(tableEntry.checkSum, SFNT_OFFSET.CHECKSUM);
          b2.writeUint32BE(sfntOffset, SFNT_OFFSET.OFFSET);
          b2.writeUint32BE(tableEntry.Length, SFNT_OFFSET.LENGTH);
          sfntOffset += longAlign(tableEntry.Length);
          csum += calc_checksum(b2);
          csum += tableEntry.checkSum;
        }
        var checksumAdjustment = ulong(MAGIC.CHECKSUM_ADJUSTMENT - csum);
        var len, woffDataChains = [];
        for (i2 = 0; i2 < entries.length; ++i2) {
          tableEntry = entries[i2];
          var sfntData = arr.subarray(tableEntry.Offset, tableEntry.Offset + tableEntry.Length);
          if (String.fromCharCode.apply(null, tableEntry.Tag) === "head") {
            version2.maj = sfntData.readUint16BE(SFNT_ENTRY_OFFSET.VERSION_MAJ);
            version2.min = sfntData.readUint16BE(SFNT_ENTRY_OFFSET.VERSION_MIN);
            flavor = sfntData.readUint32BE(SFNT_ENTRY_OFFSET.FLAVOR);
            sfntData.writeUint32BE(checksumAdjustment, SFNT_ENTRY_OFFSET.CHECKSUM_ADJUSTMENT);
          }
          var res = deflate(sfntData);
          var compLength;
          compLength = Math.min(res.length, sfntData.length);
          len = longAlign(compLength);
          var woffData = import_buffer.Buffer.alloc(len, 0);
          if (res.length >= sfntData.length) {
            woffData.set(sfntData);
          } else {
            woffData.set(res);
          }
          tableBuf.writeUint32BE(offset, i2 * SIZEOF.WOFF_ENTRY + WOFF_ENTRY_OFFSET.OFFSET);
          offset += woffData.length;
          woffSize += woffData.length;
          tableBuf.writeUint32BE(compLength, i2 * SIZEOF.WOFF_ENTRY + WOFF_ENTRY_OFFSET.COMPR_LENGTH);
          woffDataChains.push(woffData);
        }
        woffHeader.writeUint32BE(woffSize, WOFF_OFFSET.SIZE);
        woffHeader.writeUint32BE(sfntSize, WOFF_OFFSET.SFNT_SIZE);
        woffHeader.writeUint16BE(version2.maj, WOFF_OFFSET.VERSION_MAJ);
        woffHeader.writeUint16BE(version2.min, WOFF_OFFSET.VERSION_MIN);
        woffHeader.writeUint32BE(flavor, WOFF_OFFSET.FLAVOR);
        var out2 = import_buffer.Buffer.alloc(woffSize);
        var pos = 0;
        out2.set(woffHeader, pos);
        pos += woffHeader.length;
        out2.set(tableBuf, pos);
        pos += tableBuf.length;
        for (i2 = 0; i2 < woffDataChains.length; i2++) {
          out2.set(woffDataChains[i2], pos);
          pos += woffDataChains[i2].length;
        }
        if (options.metadata) {
          out2 = woffAppendMetadata(out2, options.metadata);
        }
        return new Uint8Array(out2.buffer, out2.byteOffset, out2.length);
      }
      module.exports = ttf2woff3;
    }
  });

  // dist/ttf2woff2.wasm-D9pC94Jv.mjs
  var ttf2woff2_wasm_D9pC94Jv_exports = {};
  __export(ttf2woff2_wasm_D9pC94Jv_exports, {
    wasmUrl: () => wasmUrl
  });
  var wasmUrl;
  var init_ttf2woff2_wasm_D9pC94Jv = __esm({
    "dist/ttf2woff2.wasm-D9pC94Jv.mjs"() {
      init_shim();
      wasmUrl = "data:application/wasm;base64,AGFzbQEAAAABqwEWYAJ/fwBgAX8Bf2ACf38Bf2ADf39/AGADf39/AX9gBH9/f38AYAV/f39/fwBgAX8AYAAAYAZ/f39/f38AYAt/f39/f39/f39/fwF/YAR/f39/AX9gBX9/f39/AX9gAAF/YAF/AXxgB39/f39/f38AYA5/f39/f3x/f39/f39/fwF/YAN/fn8BfmAHf39/f39/fwF/YAh/f39/f39/fwBgAXwBfGAEf39+fgACjAQSA2VudhlfZW1iaW5kX3JlZ2lzdGVyX2Z1bmN0aW9uAA8DZW52C19fY3hhX3Rocm93AAMDZW52FV9lbWJpbmRfcmVnaXN0ZXJfdm9pZAAAA2VudhVfZW1iaW5kX3JlZ2lzdGVyX2Jvb2wABQNlbnYYX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyAAYDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfZmxvYXQAAwNlbnYbX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nAAADZW52HF9lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmcAAwNlbnYWX2VtYmluZF9yZWdpc3Rlcl9lbXZhbAAHA2VudhxfZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3AAMDZW52DV9fYXNzZXJ0X2ZhaWwABQNlbnYVX2Vtc2NyaXB0ZW5fbWVtY3B5X2pzAAMWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQhmZF9jbG9zZQABFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfd3JpdGUACwNlbnYWZW1zY3JpcHRlbl9yZXNpemVfaGVhcAABA2VudglfYWJvcnRfanMACANlbnYXX2VtYmluZF9yZWdpc3Rlcl9iaWdpbnQADxZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxB2ZkX3NlZWsADAPBAb8BCAEIDQQACAELAwQABwgIBwIACwAAAAAAAQELBAEBAAAAAQADAQMCAAoMCgoKCgoKEBAIAgAAAAAABgAOBQIGAwAADgYGDgUGAwsJBQUFCQAFBQcSAgcHDAUABQIJBQADBhMAAAAEBAcBBAQEBwMBBAMUBAEBAQQRAQwDAQMGAQIBAQcCBQIABQYDAwIFAwgBBAgBAQECAQEAAQADAAAACAADAgMDAQQEBAIDBQUFAwYGCQkBAQEBAQcB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AyEMDAELQQAhByAIIQQgDkEDcSILBEADQCADQQFrIgMgBEEBayIELQAAOgAAIAdBAWoiByALRw0ACwsgCiAIa0F8TQRAA0AgA0EBayAEQQFrLQAAOgAAIANBAmsgBEECay0AADoAACADQQNrIARBA2stAAA6AAAgA0EEayIDIARBBGsiBC0AADoAACAEIApHDQALCyAFKAKMARogBSgChAEhCgsgBSAZNgKMASAFIAY2AogBIAUgDDYChAEgCkUNACAKEJQBCyANQQh2IQcgBSAGNgKIAQJAIAUoAowBIgQgBksEQCAGIAc6AAAgBkEBaiEIDAELIAYgBSgChAEiC2siCkEBaiIDQQBIDQtB/////wcgBCALayIIQQF0IgwgAyADIAxJGyAIQf////8DTxsiCAR/IAgQpAEFQQALIgwgCmoiAyAHOgAAIAggDGohDiADQQFqIQgCQCAGIAtGBEAgAyEMDAELQQAhByAGIQQgCkEDcSIKBEADQCADQQFrIgMgBEEBayIELQAAOgAAIAdBAWoiByAKRw0ACwsgCyAGa0F8TQRAA0AgA0EBayAEQQFrLQAAOgAAIANBAmsgBEECay0AADoAACADQQNrIARBA2stAAA6AAAgA0EEayIDIARBBGsiBC0AADoAACAEIAtHDQALCyAFKAKMARogBSgChAEhCwsgBSAONgKMASAFIAg2AogBIAUgDDYChAEgC0UNACALEJQBCyAFIAg2AogBIAUoAowBIgQgCEsEQCAIIA06AAAgCEEBaiEKDAELIAggBSgChAEiC2siDEEBaiIDQQBIDQogDEH/////ByAEIAtrIgdBAXQiCiADIAMgCkkbIAdB/////wNPGyIHBH8gBxCkAQVBAAsiBmoiAyANOgAAIAYgB2ohDiADQQFqIQoCQCAIIAtGBEAgAyEGDAELQQAhByAIIQQgDEEDcSINBEADQCADQQFrIgMgBEEBayIELQAAOgAAIAdBAWoiByANRw0ACwsgCyAIa0F8TQRAA0AgA0EBayAEQQFrLQAAOgAAIANBAmsgBEECay0AADoAACADQQNrIARBA2stAAA6AAAgA0EEayIDIARBBGsiBC0AADoAACAEIAtHDQALCyAFKAKMARogBSgChAEhCwsgBSAONgKMASAFIAo2AogBIAUgBjYChAEgC0UNACALEJQBCyAF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AgggACAJNgIEIAAgBTYCACAEBEAgBBCUAQsPCxAfAAtpAQR/IAAoAgAiAwRAIAAoAgQiAiADIgFHBEADQCACQQxrIgEoAgAiBARAIAJBCGsgBDYCACACQQRrKAIAGiAEEJQBCyADIAEiAkcNAAsgACgCACEBCyAAIAM2AgQgACgCCBogARCUAQsLCABBigkQIQALKQEBf0EEELcBEKYBIgBB0IMUNgIAIABB5IMUNgIAIABB1IQUQQkQAQALIABBCBC3ASAAEKcBIgBBmIUUNgIAIABBuIUUQQoQAQALWAEEfwJAIAAoAgwiAkUNACAAQQxqIgQhAANAIAAgAiACKAIQIAFJIgUbIQAgAiAFQQJ0aigCACICDQALIAAgBEYNACAAQRRqQQAgACgCECABTRshAwsgAwu4AwEJfyMAQRBrIggkACAAQQA2AgggAEIANwIAIAEoAggiBiABQQxqIglHBEACQAJAA0ACQCAGKAIUIgJBgIGChHhxRQRAIAACfyADIARJBEAgAyACNgIAIANBBGoMAQsgAyAFa0ECdSIKQQFqIgFBgICAgARPDQICQEH/////AyAEIAVrIgdBAXUiBCABIAEgBEkbIAdB/P///wdPGyIERQRAQQAhBwwBCyAEQYCAgIAETw0FIARBAnQQpAEhByAGKAIUIQILIAcgCkECdGoiASACNgIAIAcgBEECdGohBCABQQRqIQIgAyAFRwRAA0AgAUEEayIBIANBBGsiAygCADYCACADIAVHDQALCyAAIAQ2AgggACACNgIEIAAgATYCACAFBEAgBRCUAQsgASEFIAILIgM2AgQLAkAgBigCBCICBEADQCACIgEoAgAiAg0ADAILAAsDQCAGKAIIIgEoAgAgBkchAiABIQYgAg0ACwsgASEGIAEgCUcNAQwDCwsQHwALECAACyAAKAIAIQULIAUgA0EfIAMgBWtBAnUiAAR/IABnBUEgC2tBAXRBARCWASAIQRBqJAALnwkBDn8jAEEQayIKJAACQCAAKAIIIgRBAmoiCCAAKAIEIgVLDQAgAyAAKAIAIARqLwAAEIYBIgY7AQQgACAINgIIIARBCGoiBCAFSw0AIAggBUEGa0sNACAAIAQ2AgggCiAKQQhqIg02AgQgCkIANwIIAkACQCAGRQ0AIANBDGohDgNAIAAoAggiBEEEaiIHIAAo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IAUgCkcEQCACQSBqIAVBAnRqIgQgBCgCAEEBajYCACADQQFrIQMLAkAgA0ECTARAIAJBIGogBUECdGoiBCAEKAIAIANqNgIADAELIANBAmshBCACKAJgIQMDQCADQQFqIQMgBEEDSyEHIARBAnYhBCAHDQALIAIgAzYCYAsgBSEKCyABIAZKDQELCyAIQQF0QRJqCyEEIAIgCTYCICACQRBqIgNBADsBACACQgA3AwggAkIANwMAIAJBIGpBEkEHIAIQbCACLQABIQcgAigCJCEFIAItAAAhASACKAIgIQAgAi0AAiEGIAIoAighCCACLQADIQogAigCLCELIAItAAQhCSACKAIwIQwgAi0ABSENIAIoAjQhDiACLQAGIQ8gAigCOCEQIAItAAchESACKAI8IRIgAi0ACCETIAIoAkAhFCACLQAJIRUgAigCRCEWIAItAAohFyACKAJIIRggAi0ACyEZIAIoAkwhGiACLQAMIRsgAigCUCEcIAItAA0hHSACKAJUIR4gAi0ADiEfIAIoAlghICACLQAPISEgAigCXCEiIAMtAAAhAyACKAJgISMgAi0AESEkIAIoAmQhJSACQfAAaiQAIAAgAWwgBGogBSAHbGogBiAIbGogCiALbGogCSAMbGogDSAObGogDyAQbGogESASbGogEyAUbGogFSAWbGogFyAYbGogGSAabGogGyAcbGogHSAebGogHyAgbGogISAibGogIyADQQJqQf8BcWxqICUgJEEDakH/AXFsaguZCgIGfwN8IwBBkAhrIgkkAAJAAkACQCACIANGDQAgASADIAIgAiADSBsiB0ECdGooAgAhBQJ8IAEgAyACIAIgA0obIghBAnRqKAIAIgNB/wFMBEAgA0ECdEHg6AtqKgIAuwwBCyADuBCDAQshCyADIAVqIQIgA7cgC6ICfCAFQf8BTARAIAVBAnRB4OgLaioCALsMAQsgBbgQgwELIAW3oqAgArcCfCACQf8BTARAIAJBAnRB4OgLaioCALsMAQsgArgQgwELoqFEAAAAAAAA4D+iIAAgCEGQCGxqIgMrA4gIIg2hIAAgB0GQCGxqIgIrA4gIIguhIQwCQCADKAKACEUNACANIQsgAigCgAgiAUUNACAEKAIAIgUgBCgCBEYEfEQun4eirkJ9VAUgBSsDGCILRAAAAAAAAAAAIAtE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AmogASACai0AADoAACACDQALDAILIAJBA00NAANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIAJBBGsiAkEDSw0ACwsgAkUNAANAIAMgAS0AADoAACADQQFqIQMgAUEBaiEBIAJBAWsiAg0ACwsgAAvyAgICfwF+AkAgAkUNACAAIAE6AAAgACACaiIDQQFrIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0EDayABOgAAIANBAmsgAToAACACQQdJDQAgACABOgADIANBBGsgAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkEEayABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBCGsgATYCACACQQxrIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQRBrIAE2AgAgAkEUayABNgIAIAJBGGsgATYCACACQRxrIAE2AgAgBCADQQRxQRhyIgRrIgJBIEkNACABrUKBgICAEH4hBSADIARqIQEDQCABIAU3AxggASAFNwMQIAEgBTcDCCABIAU3AwAgAUEgaiEBIAJBIGsiAkEfSw0ACwsgAAsCAAvAAgEFfyMAQRBrIgUkACAFIAI2AgwjAEHQAWsiAyQAIAMgAjYCzAEgA0GgAWpBAEEoEH0aIAMgAygCzAE2AsgBAkBBACABIANByAFqIANB0ABqIANBoAFqEIsBQQBIDQAgACgCTEEASCEGIAAgACgCACIHQV9xNgIAAn8CQAJAIAAoAjBFBEAgAEHQADYCMCAAQQA2AhwgAEIANwMQIAAoAiwhBCAAIAM2AiwMAQsgACgCEA0BC0F/IAAQgAENARoLIAAgASADQcgBaiADQdAAaiADQaABahCLAQshAiAHQSBxIQEgBAR/IABBAEEAIAAoAiQRBAAaIABBADYCMCAAIAQ2AiwgAEEANgIcIAAoAhQaIABCADcDEEEABSACCxogACAAKAIAIAFyNgIAIAYNAAsgA0HQAWokACAFQRBqJAALWQEBfyAAIAAoAkgiAUEBayABcjYCSCAAKAIAIgFBCHEEQCAAIAFBIHI2AgBBfw8LIABCADcCBCAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQQQAL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AkEKSQ0ACyABC64EAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAFBCWsOEgABAgUDBAYHCAkKCwwNDg8QERILIAIgAigCACIBQQRqNgIAIAAgASgCADYCAA8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASsDADkDAA8LAAsLbQEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABIAIgA2siA0GAAiADQYACSSICGxB9GiACRQRAA0AgACAFQYACEIwBIANBgAJrIgNB/wFLDQALCyAAIAUgAxCMAQsgBUGAAmokAAsWACAARQRAQQAPC0GQiRQgADYCAEF/C6ICACAARQRAQQAPCwJ/AkAgAAR/IAFB/wBNDQECQEHkiBQoAgAoAgBFBEAgAUGAf3FBgL8DRg0DQZCJFEEZNgIADAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMBAsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMMBAsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQMBAtBkIkUQRk2AgALQX8FQQELDAELIAAgAToAAEEBCwtSAQJ/QaCHFCgCACIBIABBB2pBeHEiAmohAAJAIAJBACAAIAFNG0UEQCAAPwBBEHRNDQEgABAODQELQZCJFEEwNgIAQX8PC0GghxQgADYCACABC+UoAQt/IwBBEGsiCiQAAkACQAJAAkACQAJAAkACQAJAAkAgAEH0AU0EQEGUiRQoAgAiBkEQIABBC2pB+ANxIABBC0kbIgRBA3YiAXYiAEEDcQRAAkAgAEF/c0EBcSABaiIEQQN0IgFBvIkUaiIAIAFBxIkUaigCACIBKAIIIgNGBEBBlIkUIAZBfiAEd3E2AgAMAQsgAyAANgIMIAAgAzYCCAsgAUEIaiEAIAEgBEEDdCIEQQNyNgIEIAEgBGoiASABKAIEQQFyNgIEDAsLIARBnIkUKAIAIgdNDQEgAARAAkAgACABdEECIAF0IgBBACAAa3JxaCIBQQN0IgBBvIkUaiIDIABBxIkUaigCACIAKAIIIgJGBEBBlIkUIAZBfiABd3EiBjYCAAwBCyACIAM2AgwgAyACNgIICyAAIARBA3I2AgQgACAEaiICIAFBA3QiASAEayIEQQFyNgIEIAAgAWogBDYCACAHBEAgB0F4cUG8iRRqIQNBqIkUKAIAIQECfyAGQQEgB0EDdnQiBXFFBEBBlIkUIAUgBnI2AgAgAwwBCyADKAIICyEFIAMgATYCCCAFIAE2AgwgASADNgIMIAEgBTYCCAsgAEEIaiEAQaiJFCACNgIAQZyJFCAENgIADAsLQZiJFCgCACILRQ0BIAtoQQJ0QcSLFGooAgAiAigCBEF4cSAEayEBIAIhAwNAAkAgAygCECIARQRAIAMoAhQiAEUNAQsgACgCBEF4cSAEayIDIAEgASADSyIDGyEBIAAgAiADGyECIAAhAwwBCwsgAigCGCEJIAIgAigCDCIARwRAIAIoAggiAyAANgIMIAAgAzYCCAwKCyACKAIUIgMEfyACQRRqBSACKAIQIgNFDQMgAkEQagshBQNAIAUhCCADIgBBFGohBSAAKAIUIgMNACAAQRBqIQUgACgCECIDDQALIAhBADYCAAwJC0F/IQQgAEG/f0sNACAAQQtqIgFBeHEhBEGYiRQoAgAiCUUNAEEfIQcgAEH0//8HTQRAIARBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBwtBACAEayEBAkACQAJAIAdBAnRBxIsUaigCACIDRQRAQQAhAAwBC0EAIQAgBEEZIAdBAXZrQQAgB0EfRxt0IQIDQAJAIAMoAgRBeHEgBGsiBiABTw0AIAMhBSAGIgENAEEAIQEgBSEADAMLIAAgAygCFCIGIAYgAyACQR12QQRxaigCECIIRhsgACAGGyEAIAJBAXQhAiAIIgMNAAsLIAAgBXJFBEBBACEFQQIgB3QiAEEAIABrciAJcSIARQ0DIABoQQJ0QcSLFGooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIARrIgYgAUkhAiAGIAEgAhshASAAIAUgAhshBSAAKAIQIgMEfyADBSAAKAIUCyIADQALCyAFRQ0AIAFBnIkUKAIAIARrTw0AIAUoAhghCCAFIAUoAgwiAEcEQCAFKAIIIgMgADYCDCAAIAM2AggMCAsgBSgCFCIDBH8gBUEUagUgBSgCECIDRQ0DIAVBEGoLIQIDQCACIQYgAyIAQRRqIQIgACgCFCIDDQAgAEEQaiECIAAoAhAiAw0ACyAGQQA2AgAMBwsgBEGciRQoAgAiAE0EQEGoiRQoAgAhAQJAIAAgBGsiA0EQTwRAIAEgBGoiAiADQQFyNgIEIAAgAWogAzYCACABIARBA3I2AgQMAQsgASAAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIEQQAhAkEAIQMLQZyJFCADNgIAQaiJFCACNgIAIAFBCGohAAwJCyAEQaCJFCgCACICSQRAQaCJFCACIARrIgE2AgBBrIkUQayJFCgCACIAIARqIgM2AgAgAyABQQFyNgIEIAAgBEEDcjYCBCAAQQhqIQAMCQtBACEAIARBL2oiBwJ/QeyMFCgCAARAQfSMFCgCAAwBC0H4jBRCfzcCAEHwjBRCgKCAgICABDcCAEHsjBQgCkEMakFwcUHYqtWqBXM2AgBBgI0UQQA2AgBB0IwUQQA2AgBBgCALIgFqIgZBACABayIIcSIFIARNDQhBzIwUKAIAIgEEQEHEjBQoAgAiAyAFaiIJIANNDQkgASAJSQ0JCwJAQdCMFC0AAEEEcUUEQAJAAkACQAJAQayJFCgCACIBBEBB1IwUIQADQCABIAAoAgAiA08EQCADIAAoAgRqIAFLDQMLIAAoAggiAA0ACwtBABCSASICQX9GDQMgBSEGQfCMFCgCACIAQQFrIgEgAnEEQCAFIAJrIAEgAmpBACAAa3FqIQYLIAQgBk8NA0HMjBQoAgAiAARAQcSMFCgCACIBIAZqIgMgAU0NBCAAIANJDQQLIAYQkgEiACACRw0BDAULIAYgAmsgCHEiBhCSASICIAAoAgAgACgCBGpGDQEgAiEACyAAQX9GDQEgBEEwaiAGTQRAIAAhAgwEC0H0jBQoAgAiASAHIAZrakEAIAFrcSIBEJIBQX9GDQEgASAGaiEGIAAhAgwDCyACQX9HDQILQdCMFEHQjBQoAgBBBHI2AgALIAUQkgEhAkEAEJIBIQAgAkF/Rg0FIABBf0YNBSAAIAJNDQUgACACayIGIARBKGpNDQULQcSMFEHEjBQoAgAgBmoiADYCAEHIjBQoAgAgAEkEQEHIjBQgADYCAAsCQEGsiRQoAgAiAQRAQdSMFCEAA0AgAiAAKAIAIgMgACgCBCIFakYNAiAAKAIIIgANAAsMBAtBpIkUKAIAIgBBACAAIAJNG0UEQEGkiRQgAjYCAAtBACEAQdiMFCAGNgIAQdSMFCACNgIAQbSJFEF/NgIAQbiJFEHsjBQoAgA2AgBB4IwUQQA2AgADQCAAQQN0IgFBxIkUaiABQbyJFGoiAzYCACABQciJFGogAzYCACAAQQFqIgBBIEcNAAtBoIkUIAZBKGsiAEF4IAJrQQdxIgFrIgM2AgBBrIkUIAEgAmoiATYCACABIANBAXI2AgQgACACakEoNgIEQbCJFEH8jBQoAgA2AgAMBAsgASACTw0CIAEgA0kNAiAAKAIMQQhxDQIgACAFIAZqNgIEQayJFCABQXggAWtBB3EiAGoiAzYCAEGgiRRBoIkUKAIAIAZqIgIgAGsiADYCACADIABBAXI2AgQgASACakEoNgIEQbCJFEH8jBQoAgA2AgAMAwtBACEADAYLQQAhAAwEC0GkiRQoAgAgAksEQEGkiRQgAjYCAAsgAiAGaiEDQdSMFCEAAkADQCADIAAoAgAiBUcEQCAAKAIIIgANAQwCCwsgAC0ADEEIcUUNAwtB1IwUIQADQAJAIAEgACgCACIDTwRAIAMgACgCBGoiAyABSw0BCyAAKAIIIQAMAQsLQaCJFCAGQShrIgBBeCACa0EHcSIFayIINgIAQayJFCACIAVqIgU2AgAgBSAIQQFyNgIEIAAgAmpBKDYCBEGwiRRB/IwUKAIANgIAIAEgA0EnIANrQQdxakEvayIAIAAgAUEQakkbIgVBGzYCBCAFQdyMFCkCADcCECAFQdSMFCkCADcCCEHcjBQgBUEIajYCAEHYjBQgBjYCAEHUjBQgAjYCAEHgjBRBADYCACAFQRhqIQADQCAAQQc2AgQgAEEIaiECIABBBGohACACIANJDQALIAEgBUYNACAFIAUoAgRBfnE2AgQgASAFIAFrIgJBAXI2AgQgBSACNgIAAn8gAkH/AU0EQCACQXhxQbyJFGohAAJ/QZSJFCgCACIDQQEgAkEDdnQiAnFFBEBBlIkUIAIgA3I2AgAgAAwBCyAAKAIICyEDIAAgATYCCCADIAE2AgxBDCECQQgMAQtBHyEAIAJB////B00EQCACQSYgAkEIdmciAGt2QQFxIABBAXRrQT5qIQALIAEgADYCHCABQgA3AhAgAEECdEHEixRqIQMCQAJAQZiJFCgCACIFQQEgAHQiBnFFBEBBmIkUIAUgBnI2AgAgAyABNgIAIAEgAzYCGAwBCyACQRkgAEEBdmtBACAAQR9HG3QhACADKAIAIQUDQCAFIgMoAgRBeHEgAkYNAiAAQR12IQUgAEEBdCEAIAMgBUEEcWpBEGoiBigCACIFDQALIAYgATYCACABIAM2AhgLQQghAiABIQMgASEAQQwMAQsgAygCCCIAIAE2AgwgAyABNgIIIAEgADYCCEEAIQBBGCECQQwLIAFqIAM2AgAgASACaiAANgIAC0GgiRQoAgAiACAETQ0AQaCJFCAAIARrIgE2AgBBrIkUQayJFCgCACIAIARqIgM2AgAgAyABQQFyNgIEIAAgBEEDcjYCBCAAQQhqIQAMBAtBkIkUQTA2AgBBACEADAMLIAAgAjYCACAAIAAoAgQgBmo2AgQgAkF4IAJrQQdxaiIJIARBA3I2AgQgBUF4IAVrQQdxaiIGIAQgCWoiAWshAgJAQayJFCgCACAGRgRAQayJFCABNgIAQaCJFEGgiRQoAgAgAmoiBDYCACABIARBAXI2AgQMAQtBqIkUKAIAIAZGBEBBqIkUIAE2AgBBnIkUQZyJFCgCACACaiIENgIAIAEgBEEBcjYCBCABIARqIAQ2AgAMAQsgBigCBCIFQQNxQQFGBEAgBUF4cSEHIAYoAgwhBAJAIAVB/wFNBEAgBigCCCIAIARGBEBBlIkUQZSJFCgCAEF+IAVBA3Z3cTYCAAwCCyAAIAQ2AgwgBCAANgIIDAELIAYoAhghCAJAIAQgBkcEQCAGKAIIIgUgBDYCDCAEIAU2AggMAQsCQCAGKAIUIgUEfyAGQRRqBSAGKAIQIgVFDQEgBkEQagshAANAIAAhAyAFIgRBFGohACAEKAIUIgUNACAEQRBqIQAgBCgCECIFDQALIANBADYCAAwBC0EAIQQLIAhFDQACQCAGKAIcIgBBAnRBxIsUaiIFKAIAIAZGBEAgBSAENgIAIAQNAUGYiRRBmIkUKAIAQX4gAHdxNgIADAILIAhBEEEUIAgoAhAgBkYbaiAENgIAIARFDQELIAQgCDYCGCAGKAIQIgUEQCAEIAU2AhAgBSAENgIYCyAGKAIUIgVFDQAgBCAFNgIUIAUgBDYCGAsgBiAHaiIGKAIEIQUgAiAHaiECCyAGIAVBfnE2AgQgASACQQFyNgIEIAEgAmogAjYCACACQf8BTQRAIAJBeHFBvIkUaiEEAn9BlIkUKAIAIgVBASACQQN2dCICcUUEQEGUiRQgAiAFcjYCACAEDAELIAQoAggLIQIgBCABNgIIIAIgATYCDCABIAQ2AgwgASACNgIIDAELQR8hBCACQf///wdNBEAgAkEmIAJBCHZnIgRrdkEBcSAEQQF0a0E+aiEECyABIAQ2AhwgAUIANwIQIARBAnRBxIsUaiEFAkACQEGYiRQoAgAiAEEBIAR0IgZxRQRAQZiJFCAAIAZyNgIAIAUgATYCACABIAU2AhgMAQsgAkEZIARBAXZrQQAgBEEfRxt0IQQgBSgCACEAA0AgACIFKAIEQXhxIAJGDQIgBEEddiEAIARBAXQhBCAFIABBBHFqQRBqIgYoAgAiAA0ACyAGIAE2AgAgASAFNgIYCyABIAE2AgwgASABNgIIDAELIAUoAggiBCABNgIMIAUgATYCCCABQQA2AhggASAFNgIMIAEgBDYCCAsgCUEIaiEADAILAkAgCEUNAAJAIAUoAhwiAkECdEHEixRqIgMoAgAgBUYEQCADIAA2AgAgAA0BQZiJFCAJQX4gAndxIgk2AgAMAgsgCEEQQRQgCCgCECAFRhtqIAA2AgAgAEUNAQsgACAINgIYIAUoAhAiAwRAIAAgAzYCECADIAA2AhgLIAUoAhQiA0UNACAAIAM2AhQgAyAANgIYCwJAIAFBD00EQCAFIAEgBGoiAEEDcjYCBCAAIAVqIgAgACgCBEEBcjYCBAwBCyAFIARBA3I2AgQgBCAFaiICIAFBAXI2AgQgASACaiABNgIAIAFB/wFNBEAgAUF4cUG8iRRqIQACf0GUiRQoAgAiBEEBIAFBA3Z0IgFxRQRAQZSJFCABIARyNgIAIAAMAQsgACgCCAshASAAIAI2AgggASACNgIMIAIgADYCDCACIAE2AggMAQtBHyEAIAFB////B00EQCABQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qIQALIAIgADYCHCACQgA3AhAgAEECdEHEixRqIQQCQAJAIAlBASAAdCIDcUUEQEGYiRQgAyAJcjYCACAEIAI2AgAgAiAENgIYDAELIAFBGSAAQQF2a0EAIABBH0cbdCEAIAQoAgAhAwNAIAMiBCgCBEF4cSABRg0CIABBHXYhAyAAQQF0IQAgBCADQQRxakEQaiIGKAIAIgMNAAsgBiACNgIAIAIgBDYCGAsgAiACNgIMIAIgAjYCCAwBCyAEKAIIIgAgAjYCDCAEIAI2AgggAkEANgIYIAIgBDYCDCACIAA2AggLIAVBCGohAAwBCwJAIAlFDQACQCACKAIcIgVBAnRBxIsUaiIDKAIAIAJGBEAgAyAANgIAIAANAUGYiRQgC0F+IAV3cTYCAAwCCyAJQRBBFCAJKAIQIAJGG2ogADYCACAARQ0BCyAAIAk2AhggAigCECIDBEAgACADNgIQIAMgADYCGAsgAigCFCIDRQ0AIAAgAzYCFCADIAA2AhgLAkAgAUEPTQRAIAIgASAEaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDAELIAIgBEEDcjYCBCACIARqIgQgAUEBcjYCBCABIARqIAE2AgAgBwRAIAdBeHFBvIkUaiEDQaiJFCgCACEAAn9BASAHQQN2dCIFIAZxRQRAQZSJFCAFIAZyNgIAIAMMAQsgAygCCAshBSADIAA2AgggBSAANgIMIAAgAzYCDCAAIAU2AggLQaiJFCAENgIAQZyJFCABNgIACyACQQhqIQALIApBEGokACAAC/ALAQd/AkAgAEUNACAAQQhrIgMgAEEEaygCACIBQXhxIgBqIQQCQCABQQFxDQAgAUECcUUNASADIAMoAgAiAmsiA0GkiRQoAgBJDQEgACACaiEAAkACQAJAQaiJFCgCACADRwRAIAMoAgwhASACQf8BTQRAIAEgAygCCCIFRw0CQZSJFEGUiRQoAgBBfiACQQN2d3E2AgAMBQsgAygCGCEGIAEgA0cEQCADKAIIIgIgATYCDCABIAI2AggMBAsgAygCFCICBH8gA0EUagUgAygCECICRQ0DIANBEGoLIQUDQCAFIQcgAiIBQRRqIQUgASgCFCICDQAgAUEQaiEFIAEoAhAiAg0ACyAHQQA2AgAMAwsgBCgCBCIBQQNxQQNHDQNBnIkUIAA2AgAgBCABQX5xNgIEIAMgAEEBcjYCBCAEIAA2AgAPCyAFIAE2AgwgASAFNgIIDAILQQAhAQsgBkUNAAJAIAMoAhwiBUECdEHEixRqIgIoAgAgA0YEQCACIAE2AgAgAQ0BQZiJFEGYiRQoAgBBfiAFd3E2AgAMAgsgBkEQQRQgBigCECADRhtqIAE2AgAgAUUNAQsgASAGNgIYIAMoAhAiAgRAIAEgAjYCECACIAE2AhgLIAMoAhQiAkUNACABIAI2AhQgAiABNgIYCyADIARPDQAgBCgCBCICQQFxRQ0AAkACQAJAAkAgAkECcUUEQEGsiRQoAgAgBEYEQEGsiRQgAzYCAEGgiRRBoIkUKAIAIABqIgA2AgAgAyAAQQFyNgIEIANBqIkUKAIARw0GQZyJFEEANgIAQaiJFEEANgIADwtBqIkUKAIAIARGBEBBqIkUIAM2AgBBnIkUQZyJFCgCACAAaiIANgIAIAMgAEEBcjYCBCAAIANqIAA2AgAPCyACQXhxIABqIQAgBCgCDCEBIAJB/wFNBEAgBCgCCCIFIAFGBEBBlIkUQZSJFCgCAEF+IAJBA3Z3cTYCAAwFCyAFIAE2AgwgASAFNgIIDAQLIAQoAhghBiABIARHBEAgBCgCCCICIAE2AgwgASACNgIIDAMLIAQoAhQiAgR/IARBFGoFIAQoAhAiAkUNAiAEQRBqCyEFA0AgBSEHIAIiAUEUaiEFIAEoAhQiAg0AIAFBEGohBSABKAIQIgINAAsgB0EANgIADAILIAQgAkF+cTYCBCADIABBAXI2AgQgACADaiAANgIADAMLQQAhAQsgBkUNAAJAIAQoAhwiBUECdEHEixRqIgIoAgAgBEYEQCACIAE2AgAgAQ0BQZiJFEGYiRQoAgBBfiAFd3E2AgAMAgsgBkEQQRQgBigCECAERhtqIAE2AgAgAUUNAQsgASAGNgIYIAQoAhAiAgRAIAEgAjYCECACIAE2AhgLIAQoAhQiAkUNACABIAI2AhQgAiABNgIYCyADIABBAXI2AgQgACADaiAANgIAIANBqIkUKAIARw0AQZyJFCAANgIADwsgAEH/AU0EQCAAQXhxQbyJFGohAQJ/QZSJFCgCACICQQEgAEEDdnQiAHFFBEBBlIkUIAAgAnI2AgAgAQwBCyABKAIICyEAIAEgAzYCCCAAIAM2AgwgAyABNgIMIAMgADYCCA8LQR8hASAAQf///wdNBEAgAEEmIABBCHZnIgFrdkEBcSABQQF0a0E+aiEBCyADIAE2AhwgA0IANwIQIAFBAnRBxIsUaiEEAn8CQAJ/QZiJFCgCACICQQEgAXQiBXFFBEBBmIkUIAIgBXI2AgBBGCEBIAQhBUEIDAELIABBGSABQQF2a0EAIAFBH0cbdCEBIAQoAgAhBQNAIAUiAigCBEF4cSAARg0CIAFBHXYhBSABQQF0IQEgAiAFQQRxakEQaiIEKAIAIgUNAAtBGCEBIAIhBUEICyEAIAMhAiADDAELIAIoAggiBSADNgIMQQghASACQQhqIQRBGCEAQQALIQcgBCADNgIAIAEgA2ogBTYCACADIAI2AgwgACADaiAHNgIAQbSJFEG0iRQoAgBBAWsiA0F/IAMbNgIACwtbAgF/AX4CQAJ/QQAgAEUNABogAK0gAa1+IgOnIgIgACABckGAgARJDQAaQX8gAiADQiCIpxsLIgIQkwEiAEUNACAAQQRrLQAAQQNxRQ0AIABBACACEH0aCyAAC+cRAQx/IwBBIGsiBSQAIAUgATYCFCAFIAA2AhgDQAJAAkACQAJAAkACQAJAAkACQCABIABrQQJ1IgcOBgYGAAQBAgMLIAUgAUEEayIBNgIUIAEgABCXAUUNBSAFQRhqIAVBFGoQmAEMBQsgBSABQQRrIgE2AhQgACAAQQRqIABBCGogARCZAQwECyAFIAFBBGsiATYCFCAAIABBBGogAEEIaiAAQQxqIAEQmgEMAwsgB0EXTARAIANBAXEEQCMAQRBrIgMkAAJAIAEgACICRg0AA0AgAyAAQQRqIgQ2AgggASAERg0BIAQgABCXAQRAIAMgAygCCCgCADYCBCADIAA2AgAgAygCCCEAA0ACQCAAIAMoAgAoAgA2AgAgAygCACIAIAJGDQAgAyAAQQRrIgQ2AgAgA0EEaiAEEJcBDQELCyAAIAMoAgQ2AgALIAMoAgghAAwACwALIANBEGokAAwECyMAQRBrIgIkAAJAIAAgAUYNAANAIAIgAEEEaiIDNgIIIAEgA0YNASADIAAQlwEEQCACIAIoAggoAgA2AgQgAiAANgIAIAIoAgghAANAIAAgAigCACgCADYCACACIAIoAgAiAEEEayIDNgIAIAJBBGogAxCXAQ0ACyAAIAIoAgQ2AgALIAIoAgghAAwACwALIAJBEGokAAwDCyACRQRAIAAgAUYNAyMAQRBrIgMkACADIAA2AgwgACABRgR/IAEFAkAgASAAa0ECdSIEQQJIDQAgBEECa0EBdiECA0AgAkEASA0BIAAgBCAAIAJBAnRqEJ8BIAJBAWshAgwACwALIAEgAGtBAnUhBCABIQADQAJAIAMgADYCCCADKAIMIQIgACABRg0AIAAgAhCXAQRAIANBCGogA0EMahCYASADKAIMIgAgBCAAEJ8BCyADKAIIQQRqIQAMAQsLIAEgAmtBAnUhAANAIABBAUoEQCABIQlBACEGIwBBEGsiCiQAIAogAjYCDAJAIAAiBEECSA0AIAooAgwoAgAhCCAKKAIMIQwjAEEQayILJAAgAEECa0ECbSENA0AgCyAMIAZBAnRqIg5BBGoiDzYCDCAGQQF0IgdBAXIhBgJAIAdBAmoiByAETg0AIA8gDkEIahCXAUUNACALIAsoAgxBBGo2AgwgByEGCyAMIAsoAgwoAgA2AgAgCygCDCEMIAYgDUwNAAsgC0EQaiQAIAogCUEEayIJNgIIIAwiBCAJRgRAIAQgCDYCAAwBCyAEIAooAggoAgA2AgAgCigCCCAINgIAIAooAgwiCCEJIARBBGoiBCEHIwBBEGsiBiQAAkAgBCAIa0ECdSIEQQJIDQAgBiAHQQRrIgc2AgwgBiAJIARBAmtBAXYiBEECdGoiCDYCCCAIIAcQlwFFDQAgBiAGKAIMKAIANgIEAkADQCAGKAIMIAYoAggoAgA2AgAgBiAGKAIIIgc2AgwgBEUNASAGIAkgBEEBa0EBdiIEQQJ0aiIHNgIIIAcgBkEEahCXAQ0ACyAGKAIMIQcLIAcgBigCBDYCAAsgBkEQaiQACyAKQRBqJAAgAEEBayEAIAFBBGshAQwBCwsgAygCCAsaIANBEGokAAwDCyABQQRrIQQgACAHQQF2QQJ0IgFqIQYCQCAHQYEBTwRAIAAgBiAEEJsBIAUoAhgiAEEEaiAAIAFBBGsiB2ogBSgCFCIAQQhrEJsBIAUoAhgiBEEIaiAEIAFBBGoiBmogAEEMaxCbASAFKAIYIgAgB2ogACABaiAAIAZqEJsBIAUgBSgCGCABajYCDCAFQRhqIAVBDGoQmAEMAQsgBiAAIAQQmwELIAJBAWshAiADQQFxIgcEQCAFKAIUIQEMAgsgBSgCGCIAQQRrIAAQlwEhACAFKAIUIQEgAA0BIAUoAhghByMAQRBrIgMkACADIAEiADYCCCADIAc2AgwgAyADKAIMKAIANgIEAkAgA0EEaiAAQQRrEJcBBEADQCADIAMoAgxBBGoiBDYCDCADQQRqIAQQlwFFDQAMAgsACwNAIAMgAygCDEEEaiIENgIMIAAgBE0NASADQQRqIAQQlwFFDQALCyAAIAMoAgxLBEADQCADIABBBGsiADYCCCADQQRqIAAQlwENAAsLA0AgACADKAIMIgRLBEAgA0EMaiADQQhqEJgBA0AgAyADKAIMQQRqIgA2AgwgA0EEaiAAEJcBRQ0ACwNAIAMgAygCCEEEayIANgIIIANBBGogABCXAQ0ACyADKAIIIQAMAQsLIAMgBEEEayIANgIAIAAgB0cEfyAHIAMoAgAoAgA2AgAgAygCDCEEIAMoAgAFIAALIAMoAgQ2AgAgA0EQaiQAIAUgBDYCGEEAIQMMBAsgBSABQQRrIgE2AhQgACAAQQRqIAEQnAEMAQsgBUEMaiEJIAUoAhghCCMAQSBrIgQkACAEIAEiADYCFCAEIAg2AhggBCAEKAIYKAIANgIQA0AgBCAEKAIYQQRqIgY2AhggBiAEQRBqEJcBDQALAkAgCCAEKAIYQQRrRgRAA0AgBCgCGCAATw0CIAQgAEEEayIANgIUIAAgBEEQahCXAUUNAAwCCwALA0AgBCAAQQRrIgA2AhQgACAEQRBqEJcBRQ0ACwsgBCAEKAIYIgYgAE86AA8DQCAAIAZLBEAgBEEYaiAEQRRqEJgBA0AgBCAEKAIYQQRqIgA2AhggACAEQRBqEJcBDQALA0AgBCAEKAIUQQRrIgA2AhQgACAEQRBqEJcBRQ0ACyAEKAIUIQAgBCgCGCEGDAELCyAEIAZBBGsiADYCCCAAIAhHBH8gCCAEKAIIKAIANgIAIAQoAggFIAALIAQoAhA2AgAgCSAEKAIINgIAIAkgBC0ADzoABCAEQSBqJAAgBSgCDCEAIAUtABBBAUcNASAFKAIYIAAQnQEhBCAAQQRqIgYgARCdAQRAIAQNASAFIAA2AhQgACEBDAMLIARFDQEgBSAGNgIYDAILIAVBIGokAA8LIAUoAhggACACIAcQlgEgBSAAQQRqNgIYQQAhAwsgBSgCGCEADAALAAsNACAAKAIAIAEoAgBJCyYBAX8gACgCACIAKAIAIQIgACABKAIAIgAoAgA2AgAgACACNgIACw0AIAAgASACIAMQngELqgEBAX8jAEEgayIFJAAgBSABNgIUIAUgADYCGCAFIAI2AhAgBSADNgIMIAUgBDYCCCAAIAEgAiADEJ4BAkAgBCADEJcBRQ0AIAVBDGogBUEIahCYASAFKAIMIAIQlwFFDQAgBUEQaiAFQQxqEJgBIAUoAhAgARCXAUUNACAFQRRqIAVBEGoQmAEgBSgCFCAAEJcBRQ0AIAVBGGogBUEUahCYAQsgBUEgaiQAC60BAQF/IwBBEGsiAyQAIAMgATYCBCADIAA2AgggAyACNgIAIAEgABCXASEAIAIgARCXASECAkACQCAARQRAIAJFDQIgA0EEaiADEJgBIAMoAgQgAygCCBCXAUUNAiADQQhqIANBBGoQmAEMAQsgAgRAIANBCGogAxCYAQwCCyADQQhqIANBBGoQmAEgAygCACADKAIEEJcBRQ0BIANBBGogAxCYAQsLIANBEGokAAsLACAAIAEgAhCbAQvtAgEFfyMAQSBrIgIkACACIAA2AhhBASEFAkACQAJAAkACQAJAIAEgAGtBAnUOBgUFAAECAwQLIAIgAUEEayIDNgIUIAMgABCXAUUNBCACQRhqIAJBFGoQmAEMBAsgACAAQQRqIAFBBGsQnAEMAwsgACAAQQRqIABBCGogAUEEaxCZAQwCCyAAIABBBGogAEEIaiAAQQxqIAFBBGsQmgEMAQsgACAAQQRqIABBCGoiBBCcASAAQQxqIQMDQCACIAM2AhAgASADRg0BAkAgAyAEEJcBRQ0AIAIgAkEQaigCACgCADYCDCACIAQ2AgggAigCECEDA0ACQCADIAJBCGooAgAoAgA2AgAgAigCCCIDIABGDQAgAiADQQRrIgQ2AgggAkEMaiAEEJcBDQELCyADIAIoAgw2AgAgBkEBaiIGQQhHDQAgAigCEEEEaiABRiEFDAILIAIoAhAiBEEEaiEDDAALAAsgAkEgaiQAIAULhwEBAX8jAEEgayIEJAAgBCABNgIUIAQgADYCGCAEIAI2AhAgBCADNgIMIAAgASACEJsBAkAgAyACEJcBRQ0AIARBEGogBEEMahCYASAEKAIQIAEQlwFFDQAgBEEUaiAEQRBqEJgBIAQoAhQgABCXAUUNACAEQRhqIARBFGoQmAELIARBIGokAAu6AgEGfyMAQRBrIgMkACADIAI2AgwCQCABQQJIDQAgAUECa0EBdiIIIAIgAGsiBEECdUgNACADIAAgBEEBdSIGQQFqIgRBAnRqIgU2AggCQCAGQQJqIgYgAU4NACAFIAVBBGoiBxCXAUUNACADIAc2AgggByEFIAYhBAsgBSACEJcBDQAgAyADQQxqKAIAKAIANgIEAkADQCADKAIMIANBCGooAgAoAgA2AgAgAyADKAIIIgI2AgwgBCAISg0BIAMgACAEQQF0IgRBAXIiBUECdGoiAjYCCAJAAkAgBEECaiIEIAFODQAgAiACQQRqEJcBIQYgAygCCCECIAZFDQAgAyACQQRqIgI2AggMAQsgBSEECyACIANBBGoQlwFFDQALIAMoAgwhAgsgAiADKAIENgIACyADQRBqJAALBQAQDwALtwwBB38jAEEQayIEJAAgBCAANgIMAkAgAEHTAU0EQEGA/BNBwP0TIARBDGoQogEoAgAhAAwBCyAAQXxPBEAQowEACyAEIAAgAEHSAW4iBkHSAWwiA2s2AghBwP0TQYD/EyAEQQhqEKIBQcD9E2tBAnUhBQNAIAVBAnRBwP0TaigCACADaiEAQQUhAgJAAkADQCACIgNBL0YNASAAIANBAnRBgPwTaigCACIBbiIHIAFJDQQgA0EBaiECIAAgASAHbEcNAAsgA0EvSQ0BC0HTASEDA0AgACADbiIBIANJDQMgACABIANsRg0BIAAgA0EKaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0EMaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0EQaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0ESaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0EWaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0EcaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0EeaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0EkaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0EoaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0EqaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0EuaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0E0aiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0E6aiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0E8aiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0HCAGoiAW4iAiABSQ0DIAAgASACbEYNASAAIANBxgBqIgFuIgIgAUkNAyAAIAEgAmxGDQEgACADQcgAaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0HOAGoiAW4iAiABSQ0DIAAgASACbEYNASAAIANB0gBqIgFuIgIgAUkNAyAAIAEgAmxGDQEgACADQdgAaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0HgAGoiAW4iAiABSQ0DIAAgASACbEYNASAAIANB5ABqIgFuIgIgAUkNAyAAIAEgAmxGDQEgACADQeYAaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0HqAGoiAW4iAiABSQ0DIAAgASACbEYNASAAIANB7ABqIgFuIgIgAUkNAyAAIAEgAmxGDQEgACADQfAAaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0H4AGoiAW4iAiABSQ0DIAAgASACbEYNASAAIANB/gBqIgFuIgIgAUkNAyAAIAEgAmxGDQEgACADQYIBaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0GIAWoiAW4iAiABSQ0DIAAgASACbEYNASAAIANBigFqIgFuIgIgAUkNAyAAIAEgAmxGDQEgACADQY4BaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0GUAWoiAW4iAiABSQ0DIAAgASACbEYNASAAIANBlgFqIgFuIgIgAUkNAyAAIAEgAmxGDQEgACADQZwBaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0GiAWoiAW4iAiABSQ0DIAAgASACbEYNASAAIANBpgFqIgFuIgIgAUkNAyAAIAEgAmxGDQEgACADQagBaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0GsAWoiAW4iAiABSQ0DIAAgASACbEYNASAAIANBsgFqIgFuIgIgAUkNAyAAIAEgAmxGDQEgACADQbQBaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0G6AWoiAW4iAiABSQ0DIAAgASACbEYNASAAIANBvgFqIgFuIgIgAUkNAyAAIAEgAmxGDQEgACADQcABaiIBbiICIAFJDQMgACABIAJsRg0BIAAgA0HEAWoiAW4iAiABSQ0DIAAgASACbEYNASAAIANBxgFqIgFuIgIgAUkNAyAAIAEgAmxGDQEgACADQdABaiIBbiICIAFJDQMgA0HSAWohAyAAIAEgAmxHDQALC0EAIAVBAWoiACAAQTBGIgAbIQUgACAGaiIGQdIBbCEDDAALAAsgBEEQaiQAIAALigEBA38jAEEQayIFJAAgBUEAOgAOIwBBEGsiBCQAIAEgAGtBAnUhAQNAIAEEQCAEIAA2AgwgBEEMaiIDIAMoAgAgAUEBdiIDQQJ0ajYCACABIANBf3NqIAMgBCgCDCACEJcBIgMbIQEgBCgCDEEEaiAAIAMbIQAMAQsLIARBEGokACAFQRBqJAAgAAsGABCgAQALEgAgABClASIARQRAEKMBCyAACzQBAn9BASAAIABBAU0bIQEDQAJAIAEQkwEiAg0AQYSNFCgCACIARQ0AIAARCAAMAQsLIAILDQAgAEH4gxQ2AgAgAAtMAQJ/IAAQpgEiAEHohBQ2AgAgARCKASICQQ1qEKQBIgNBADYCCCADIAI2AgQgAyACNgIAIABBBGogA0EMaiABIAJBAWoQezYCACAACwoAIAAtAAtBB3YLEgAgABCoAQRAIAAoAgAPCyAACwwAIAAgAS0AADoAAAskACAAQQtPBH8gAEEIakF4cSIAIABBAWsiACAAQQtGGwVBCgsLGQEBfyABEKQBIQIgACABNgIEIAAgAjYCAAvhAQEEfyMAQRBrIgUkACMAQSBrIgMkACMAQRBrIgQkACAEIAE2AgwgBCABIAJqNgIIIANBGGogBEEMaiAEQQhqELYBIARBEGokACADKAIYIQYgAygCHCEEIwBBEGsiAiQAIAIgBDYCDCAEIAZrIgQEQCAAIAYgBBB8GgsgAiAAIARqNgIIIANBEGogAkEMaiACQQhqELUBIAJBEGokACADIAEgAygCEBC0ATYCDCADIAAgAygCFBC0ATYCCCAFQQhqIANBDGogA0EIahC1ASADQSBqJAAgBSgCDBogBUEQaiQACwkAIAAgATYCAAsuACAAIAAoAghBgICAgHhxIAFB/////wdxcjYCCCAAIAAoAghBgICAgHhyNgIICwkAIAAgATYCBAsGABCjAQALJQAgACAALQALQYABcSABQf8AcXI6AAsgACAALQALQf8AcToACwu0AwEJfyMAQRBrIgckAAJAIAIgABCoAQR/IAAoAghB/////wdxQQFrBUEKCyIFAn8gABCoAQRAIAAoAgQMAQsgAC0AC0H/AHELIgNrTQRAIAJFDQEgABCpASIFIANqIAEgAhCtASACIANqIgIhAQJAIAAQqAEEQCAAIAEQsAEMAQsgACABELIBCyAHQQA6AA8gAiAFaiAHQQ9qEKoBDAELIwBBEGsiBCQAAkAgAiAFayADaiIIIAVBf3NB9////wdqTQRAIAAQqQEhCSAEQQRqIAVB8////wNJBH8gBCAFQQF0NgIMIAQgBSAIajYCBCMAQRBrIggkACAEQQRqIgYgBEEMaiIKEJcBIQsgCEEQaiQAIAogBiALGygCABCrAUEBagVB9////wcLEKwBIAQoAgQhBiAEKAIIGiADBEAgBiAJIAMQrQELIAIEQCADIAZqIAEgAhCtAQtBACEBIAVBCkcEQCAJEJQBCyAAIAYQrgEgACAEKAIIEK8BIAAgAiADaiABaiIDELABIARBADoADCADIAZqIARBDGoQqgEgBEEQaiQADAELELEBAAsLIAdBEGokAAsKACAAIAEgAGtqCwsAIAAgASACELYBCxYAIAAgASgCADYCACAAIAIoAgA2AgQLDwAgAEHQAGoQkwFB0ABqCwsAIAAgAUEAELkBC3QBAX8gAkUEQCAAKAIEIAEoAgRGDwsgACABRgRAQQEPCyABKAIEIgItAAAhAQJAIAAoAgQiAy0AACIARQ0AIAAgAUcNAANAIAItAAEhASADLQABIgBFDQEgAkEB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X25leHRfcHJpbWUgb3ZlcmZsb3cAdW5zaWduZWQgc2hvcnQAY29udmVydAB1bnNpZ25lZCBpbnQAZmxvYXQAdWludDY0X3QAYml0cyA8IDFVTEwgPDwgbl9iaXRzAFdyaXRlQml0cwBmcmVlUHRycwBnZXRTaXplUHRyAHZlY3RvcgB1bnNpZ25lZCBjaGFyAHN0ZDo6ZXhjZXB0aW9uAGJvb2wAYmFkX2FycmF5X25ld19sZW5ndGgAY3NyYy9lbmMvLi93cml0ZV9iaXRzLmgAdW5zaWduZWQgbG9uZwBzdGQ6OndzdHJpbmcAYmFzaWNfc3RyaW5nAHN0ZDo6c3RyaW5nAHN0ZDo6dTE2c3RyaW5nAHN0ZDo6dTMyc3RyaW5nAGRvdWJsZQBXcml0ZUJpdHNQcmVwYXJlU3RvcmFnZQBtYXA6OmF0OiAga2V5IG5vdCBmb3VuZAB2b2lkAHN0ZDo6YmFkX2FsbG9jAF0AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4AIj4AOgAocG9zICYgNykgPT0gMAAuY29tLwAuACwAKG51bGwpACgAPScAPSIAbHkgACBieSAAZXN0IAAgbm90IAAgdGhhdCAAIGF0IABvdXMgAGxlc3MgAC4gVGhpcyAAIGlzIAAgYXMgACBmb3IgAGVyIAAgdG8gACBvbiAAIGluIAAgZnJvbSAAZnVsIABhbCAAIHdpdGggAGluZyAAIG9mIABpemUgAGl2ZSAAIG9mIHRoZSAALiBUaGUgACBhbmQgAGVkIAAgYSAALiAALCAATWlzc2luZyB0YWJsZSBpbmRleCBmb3Igb2Zmc2V0IDB4JTA4eAoARmFpbGVkIHRvIGZpeCBjaGVja3N1bXMKAFBhcnNpbmcgb2YgdGhlIGlucHV0IGZvbnQgZmFpbGVkLgoARm9udCBub3JtYWxpemF0aW9uIGZhaWxlZC4KAEZvbnQgdHJhbnNmb3JtYXRpb24gZmFpbGVkLgoAQ29tcHJlc3Npb24gb2YgY29tYmluZWQgdGFibGUgZmFpbGVkLgoAQ29tcHJlc3Npb24gb2YgZXh0ZW5kZWQgbWV0YWRhdGEgZmFpbGVkLgoAUmVzdWx0IGFsbG9jYXRpb24gd2FzIHRvbyBzbWFsbCAoJXpkIHZzICV6ZCBieXRlcykuCgBNaXNtYXRjaCBiZXR3ZWVuIGNvbXB1dGVkIGFuZCBhY3R1YWwgbGVuZ3RoICglemQgdnMgJXpkKQoACgkATlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUAAABMAQUAUwoAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0loTlNfMTFjaGFyX3RyYWl0c0loRUVOU185YWxsb2NhdG9ySWhFRUVFAABMAQUAnAoAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0l3TlNfMTFjaGFyX3RyYWl0c0l3RUVOU185YWxsb2NhdG9ySXdFRUVFAABMAQUA5AoAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEc05TXzExY2hhcl90cmFpdHNJRHNFRU5TXzlhbGxvY2F0b3JJRHNFRUVFAAAATAEFACwLAABOU3QzX18yMTJiYXNpY19zdHJpbmdJRGlOU18xMWNoYXJfdHJhaXRzSURpRUVOU185YWxsb2NhdG9ySURpRUVFRQAAAEwBBQB4CwAATjEwZW1zY3JpcHRlbjN2YWxFAABMAQUAxAsAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWNFRQAATAEFAOALAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lhRUUAAEwBBQAIDAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaEVFAABMAQUAMAwAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXNFRQAATAEFAFgMAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l0RUUAAEwBBQCADAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaUVFAABMAQUAqAwAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWpFRQAATAEFANAMAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lsRUUAAEwBBQD4DAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbUVFAABMAQUAIA0AAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXhFRQAATAEFAEgNAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l5RUUAAEwBBQBwDQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAABMAQUAmA0AAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWRFRQAATAEFAMANAADoAAUAaXAAAOgABQDoAAUA6AAFAOgABQBpcGlpaQAAAJQABQDoAAUA6AAFAHZwaWkAAAAAAAAAAHBhbWNkYWVoYWVoaHh0bWhweGFtZW1hbjIvU090c29wIHR2Y21ncGZmeWxnYWNvbHBlcnAgRkZDR1JPVlREQkVDTEJFcHNhZ3htZGhucmVrSFNUTFRMQ1BYTURWYWVodnh0bXZFU0FCRkVER1NPUEdCVVNHQ1NCRUZU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EAAAACQAAABUAAAAjAAAAKwAAADQAAAA+AAAACQBAABUAQAAbgEAAIoBAACZAQAAoQEAgKkBAIC7AQAAxQEAAM8BAEDUAQDA2QEAoNwBAEHApQQLoL8HdGltZWRvd25saWZlbGVmdGJhY2tjb2RlZGF0YXNob3dvbmx5c2l0ZWNpdHlvcGVuanVzdGxpa2VmcmVld29ya3RleHR5ZWFyb3ZlcmJvZHlsb3ZlZm9ybWJvb2twbGF5bGl2ZWxpbmVoZWxwaG9tZXNpZGVtb3Jld29yZGxvbmd0aGVtdmlld2ZpbmRwYWdlZGF5c2Z1bGxoZWFkdGVybWVhY2hhcmVhZnJvbXRydWVtYXJrYWJsZXVwb25oaWdoZGF0ZWxhbmRuZXdzZXZlbm5leHRjYXNlYm90aHBvc3R1c2VkbWFkZWhhbmRoZXJld2hhdG5hbWVMaW5rYmxvZ3NpemViYXNlaGVsZG1ha2VtYWludXNlcicpICtob2xkZW5kc3dpdGhOZXdzcmVhZHdlcmVzaWdudGFrZWhhdmVnYW1lc2VlbmNhbGxwYXRod2VsbHBsdXNtZW51ZmlsbXBhcnRqb2ludGhpc2xpc3Rnb29kbmVlZHdheXN3ZXN0am9ic21pbmRhbHNvbG9nb3JpY2h1c2VzbGFzdHRlYW1hcm15Zm9vZGtpbmd3aWxsZWFzdHdhcmRiZXN0ZmlyZVBhZ2Vrbm93YXdheS5wbmdtb3ZldGhhbmxvYWRnaXZlc2VsZm5vdGVtdWNoZmVlZG1hbnlyb2NraWNvbm9uY2Vsb29raGlkZWRpZWRIb21lcnVsZWhvc3RhamF4aW5mb2NsdWJsYXdzbGVzc2hhbGZzb21lc3VjaHpvbmUxMDAlb25lc2NhcmVUaW1lcmFjZWJsdWVmb3Vyd2Vla2ZhY2Vob3BlZ2F2ZWhhcmRsb3N0d2hlbnBhcmtrZXB0cGFzc3NoaXByb29tSFRNTHBsYW5UeXBlZG9uZXNhdmVrZWVwZmxhZ2xpbmtzb2xkZml2ZXRvb2tyYXRldG93bmp1bXB0aHVzZGFya2NhcmRmaWxlZmVhcnN0YXlraWxsdGhhdGZhbGxhdXRvZXZlci5jb210YWxrc2hvcHZvdGVkZWVwbW9kZXJlc3R0dXJuYm9ybmJhbmRmZWxscm9zZXVybChza2lucm9sZWNvbWVhY3RzYWdlc21lZXRnb2xkLmpwZ2l0ZW12YXJ5ZmVsdHRoZW5zZW5kZHJvcFZpZXdjb3B5MS4wIjwvYT5zdG9wZWxzZWxpZXN0b3VycGFjay5naWZwYXN0Y3NzP2dyYXltZWFuJmd0O3JpZGVzaG90bGF0ZXNhaWRyb2FkdmFyIGZlZWxqb2hucmlja3BvcnRmYXN0J1VBLWRlYWQ8L2I+cG9vcmJpbGx0eXBlVS5TLndvb2RtdXN0MnB4O0luZm9yYW5rd2lkZXdhbnR3YWxsbGVhZFswXTtwYXVsd2F2ZXN1cmUkKCcjd2FpdG1hc3Nhcm1zZ29lc2dhaW5sYW5ncGFpZCEtLSBsb2NrdW5pdHJvb3R3YWxrZmlybXdpZmV4bWwic29uZ3Rlc3QyMHB4a2luZHJvd3N0b29sZm9udG1haWxzYWZlc3Rhcm1hcHNjb3JlcmFpbmZsb3diYWJ5c3BhbnNheXM0cHg7NnB4O2FydHNmb290cmVhbHdpa2loZWF0c3RlcHRyaXBvcmcvbGFrZXdlYWt0b2xkRm9ybWNhc3RmYW5zYmFua3ZlcnlydW5zanVseXRhc2sxcHg7Z29hbGdyZXdzbG93ZWRnZWlkPSJzZXRzNXB4Oy5qcz80MHB4aWYgKHNvb25zZWF0bm9uZXR1YmV6ZXJvc2VudHJlZWRmYWN0aW50b2dpZnRoYXJtMThweGNhbWVoaWxsYm9sZHpvb212b2lkZWFzeXJpbmdmaWxscGVha2luaXRjb3N0M3B4O2phY2t0YWdzYml0c3JvbGxlZGl0a25ld25lYXI8IS0tZ3Jvd0pTT05kdXR5TmFtZXNhbGV5b3UgbG90c3BhaW5qYXp6Y29sZGV5ZXNmaXNod3d3LnJpc2t0YWJzcHJldjEwcHhyaXNlMjVweEJsdWVkaW5nMzAwLGJhbGxmb3JkZWFybndpbGRib3guZmFpcmxhY2t2ZXJzcGFpcmp1bmV0ZWNoaWYoIXBpY2tldmlsJCgiI3dhcm1sb3JkZG9lc3B1bGwsMDAwaWRlYWRyYXdodWdlc3BvdGZ1bmRidXJuaHJlZmNlbGxrZXlzdGlja2hvdXJsb3NzZnVlbDEycHhzdWl0ZGVhbFJTUyJhZ2VkZ3JleUdFVCJlYXNlYWltc2dpcmxhaWRzOHB4O25hdnlncmlkdGlwcyM5OTl3YXJzbGFkeWNhcnMpOyB9cGhwP2hlbGx0YWxsd2hvbXpoOuUqLw0KIDEwMGhhbGwuCgpBN3B4O3B1c2hjaGF0MHB4O2NyZXcqLzwvaGFzaDc1cHhmbGF0cmFyZSAmJiB0ZWxsY2FtcG9udG9sYWlkbWlzc3NraXB0ZW50ZmluZW1hbGVnZXRzcGxvdDQwMCwNCg0KY29vbGZlZXQucGhwPGJyPmVyaWNtb3N0Z3VpZGJlbGxkZXNjaGFpcm1hdGhhdG9tL2ltZyYjODJsdWNrY2VudDAwMDt0aW55Z29uZWh0bWxzZWxsZHJ1Z0ZSRUVub2Rlbmljaz9pZD1sb3NlbnVsbHZhc3R3aW5kUlNTIHdlYXJyZWx5YmVlbnNhbWVkdWtlbmFzYWNhcGV3aXNoZ3VsZlQyMzpoaXRzc2xvdGdhdGVraWNrYmx1cnRoZXkxNXB4JycpOyk7Ij5tc2lld2luc2JpcmRzb3J0YmV0YXNlZWtUMTg6b3Jkc3RyZWVtYWxsNjBweGZhcm3igJlzYm95c1swXS4nKTsiUE9TVGJlYXJraWRzKTt9fW1hcnl0ZW5kKFVLKXF1YWR6aDrmLXNpei0tLS1wcm9wJyk7DWxpZnRUMTk6dmljZWFuZHlkZWJ0PlJTU3Bvb2xuZWNrYmxvd1QxNjpkb29yZXZhbFQxNzpsZXRzZmFpbG9yYWxwb2xsbm92YWNvbHNnZW5lIOKAlHNvZnRyb21ldGlsbHJvc3M8aDM+cG91cmZhZGVwaW5rPHRyPm1pbmkpfCEobWluZXpoOuhiYXJzaGVhcjAwKTttaWxrIC0tPmlyb25mcmVkZGlza3dlbnRzb2lscHV0cy9qcy9ob2x5VDIyOklTQk5UMjA6YWRhbXNlZXM8aDI+anNvbicsICdjb250VDIxOiBSU1Nsb29wYXNpYW1vb248L3A+c291bExJTkVmb3J0Y2FydFQxNDo8aDE+ODBweCEtLTw5cHg7VDA0Om1pa2U6NDZabmljZWluY2hZb3JrcmljZXpoOuQnKSk7cHVyZW1hZ2VwYXJhdG9uZWJvbmQ6MzdaX29mXyddKTswMDAsemg653Rhbmt5YXJkYm93bGJ1c2g6NTZaSmF2YTMwcHgKfH0KJUMzJTozNFpqZWZmRVhQSWNhc2h2aXNhZ29sZnNub3d6aDrpcXVlci5jc3NzaWNrbWVhdG1pbi5iaW5kZGVsbGhpcmVwaWNzcmVudDozNlpIVFRQLTIwMWZvdG93b2xmRU5EIHhib3g6NTRaQk9EWWRpY2s7Cn0KZXhpdDozNVp2YXJzYmVhdCd9KTtkaWV0OTk5O2FubmV9fTwvW2ldLkxhbmdrbcKyd2lyZXRveXNhZGRzc2VhbGFsZXg7Cgl9ZWNob25pbmUub3JnMDA1KXRvbnlqZXdzc2FuZGxlZ3Nyb29mMDAwKSAyMDB3aW5lZ2VhcmRvZ3Nib290Z2FyeWN1dHN0eWxldGVtcHRpb24ueG1sY29ja2dhbmckKCcuNTBweFBoLkRtaXNjYWxhbmxvYW5kZXNrbWlsZXJ5YW51bml4ZGlzYyk7fQpkdXN0Y2xpcCkuCgo3MHB4LTIwMERWRHM3XT48dGFwZWRlbW9pKyspd2FnZWV1cm9waGlsb3B0c2hvbGVGQVFzYXNpbi0yNlRsYWJzcGV0c1VSTCBidWxrY29vazt9DQpIRUFEWzBdKWFiYnJqdWFuKDE5OGxlc2h0d2luPC9pPnNvbnlndXlzZnVja3BpcGV8LQohMDAyKW5kb3dbMV07W107CkxvZyBzYWx0DQoJCWJhbmd0cmltYmF0aCl7DQowMHB4Cn0pO2tvOuxmZWVzYWQ+DXM6Ly8gW107dG9sbHBsdWcoKXsKew0KIC5qcycyMDBwZHVhbGJvYXQuSlBHKTsKfXF1b3QpOwoKJyk7Cg0KfQ0yMDE0MjAxNTIwMTYyMDE3MjAxODIwMTkyMDIwMjAyMTIwMjIyMDIzMjAyNDIwMjUyMDI2MjAyNzIwMjgyMDI5MjAzMDIwMzEyMDMyMjAzMzIwMzQyMDM1MjAzNjIwMzcyMDEzMjAxMjIwMTEyMDEwMjAwOTIwMDgyMDA3MjAwNjIwMDUyMDA0MjAwMzIwMDIyMDAxMjAwMDE5OTkxOTk4MTk5NzE5OTYxOTk1MTk5NDE5OTMxOTkyMTk5MTE5OTAxOTg5MTk4ODE5ODcxOTg2MTk4NTE5ODQxOTgzMTk4MjE5ODExOTgwMTk3OTE5NzgxOTc3MTk3NjE5NzUxOTc0MTk3MzE5NzIxOTcxMTk3MDE5NjkxOTY4MTk2NzE5NjYxOTY1MTk2NDE5NjMxOTYyMTk2MTE5NjAxOTU5MTk1ODE5NTcxOTU2MTk1NTE5NTQxOTUzMTk1MjE5NTExOTUwMTAwMDEwMjQxMzk0MDAwMDk5OTljb21vbcOhc2VzdGVlc3RhcGVyb3RvZG9oYWNlY2FkYWHDsW9iaWVuZMOtYWFzw612aWRhY2Fzb290cm9mb3Jvc29sb290cmFjdWFsZGlqb3NpZG9ncmFudGlwb3RlbWFkZWJlYWxnb3F1w6llc3RvbmFkYXRyZXNwb2NvY2FzYWJham90b2Rhc2lub2FndWFwdWVzdW5vc2FudGVkaWNlbHVpc2VsbGFtYXlvem9uYWFtb3JwaXNvb2JyYWNsaWNlbGxvZGlvc2hvcmFjYXNp0LfQsNC90LDQvtC80YDQsNGA0YPRgtCw0L3QtdC/0L7QvtGC0LjQt9C90L7QtNC+0YLQvtC20LXQvtC90LjRhdCd0LDQtdC10LHRi9C80YvQktGL0YHQvtCy0YvQstC+0J3QvtC+0LHQn9C+0LvQuNC90LjQoNCk0J3QtdCc0YvRgtGL0J7QvdC40LzQtNCw0JfQsNCU0LDQndGD0J7QsdGC0LXQmNC30LXQudC90YPQvNC80KLRi9GD0LbZgdmK2KPZhtmF2KfZhdi52YPZhNij2YjYsdiv2YrYp9mB2YnZh9mI2YTZhdmE2YPYp9mI2YTZh9io2LPYp9mE2KXZhtmH2YrYo9mK2YLYr9mH2YTYq9mF2KjZh9mE2YjZhNmK2KjZhNin2YrYqNmD2LTZitin2YXYo9mF2YbYqtio2YrZhNmG2K3YqNmH2YXZhdi02YjYtGZpcnN0dmlkZW9saWdodHdvcmxkbWVkaWF3aGl0ZWNsb3NlYmxhY2tyaWdodHNtYWxsYm9va3NwbGFjZW11c2ljZmllbGRvcmRlcnBvaW50dmFsdWVsZXZlbHRhYmxlYm9hcmRob3VzZWdyb3Vwd29ya3N5ZWFyc3N0YXRldG9kYXl3YXRlcnN0YXJ0c3R5bGVkZWF0aHBvd2VycGhvbmVuaWdodGVycm9yaW5wdXRhYm91dHRlcm1zdGl0bGV0b29sc2V2ZW50bG9jYWx0aW1lc2xhcmdld29yZHNnYW1lc3Nob3J0c3BhY2Vmb2N1c2NsZWFybW9kZWxibG9ja2d1aWRlcmFkaW9zaGFyZXdvbWVuYWdhaW5tb25leWltYWdlbmFtZXN5b3VuZ2xpbmVzbGF0ZXJjb2xvcmdyZWVuZnJvbnQmYW1wO3dhdGNoZm9yY2VwcmljZXJ1bGVzYmVnaW5hZnRlcnZpc2l0aXNzdWVhcmVhc2JlbG93aW5kZXh0b3RhbGhvdXJzbGFiZWxwcmludHByZXNzYnVpbHRsaW5rc3NwZWVkc3R1ZHl0cmFkZWZvdW5kc2Vuc2V1bmRlcnNob3duZm9ybXNyYW5nZWFkZGVkc3RpbGxtb3ZlZHRha2VuYWJvdmVmbGFzaGZpeGVkb2Z0ZW5vdGhlcnZpZXdzY2hlY2tsZWdhbHJpdmVyaXRlbXNxdWlja3NoYXBlaHVtYW5leGlzdGdvaW5nbW92aWV0aGlyZGJhc2ljcGVhY2VzdGFnZXdpZHRobG9naW5pZGVhc3dyb3RlcGFnZXN1c2Vyc2RyaXZlc3RvcmVicmVha3NvdXRodm9pY2VzaXRlc21vbnRod2hlcmVidWlsZHdoaWNoZWFydGhmb3J1bXRocmVlc3BvcnRwYXJ0eUNsaWNrbG93ZXJsaXZlc2NsYXNzbGF5ZXJlbnRyeXN0b3J5dXNhZ2Vzb3VuZGNvdXJ0eW91ciBiaXJ0aHBvcHVwdHlwZXNhcHBseUltYWdlYmVpbmd1cHBlcm5vdGVzZXZlcnlzaG93c21lYW5zZXh0cmFtYXRjaHRyYWNra25vd25lYXJseWJlZ2Fuc3VwZXJwYXBlcm5vcnRobGVhcm5naXZlbm5hbWVkZW5kZWRUZXJtc3BhcnRzR3JvdXBicmFuZHVzaW5nd29tYW5mYWxzZXJlYWR5YXVkaW90YWtlc3doaWxlLmNvbS9saXZlZGNhc2VzZGFpbHljaGlsZGdyZWF0anVkZ2V0aG9zZXVuaXRzbmV2ZXJicm9hZGNvYXN0Y292ZXJhcHBsZWZpbGVzY3ljbGVzY2VuZXBsYW5zY2xpY2t3cml0ZXF1ZWVucGllY2VlbWFpbGZyYW1lb2xkZXJwaG90b2xpbWl0Y2FjaGVjaXZpbHNjYWxlZW50ZXJ0aGVtZXRoZXJldG91Y2hib3VuZHJveWFsYXNrZWR3aG9sZXNpbmNlc3RvY2sgbmFtZWZhaXRoaGVhcnRlbXB0eW9mZmVyc2NvcGVvd25lZG1pZ2h0YWxidW10aGlua2Jsb29kYXJyYXltYWpvcnRydXN0Y2Fub251bmlvbmNvdW50dmFsaWRzdG9uZVN0eWxlTG9naW5oYXBweW9jY3VybGVmdDpmcmVzaHF1aXRlZmlsbXNncmFkZW5lZWRzdXJiYW5maWdodGJhc2lzaG92ZXJhdXRvO3JvdXRlLmh0bWxtaXhlZGZpbmFsWW91ciBzbGlkZXRvcGljYnJvd25hbG9uZWRyYXduc3BsaXRyZWFjaFJpZ2h0ZGF0ZXNtYXJjaHF1b3RlZ29vZHNMaW5rc2RvdWJ0YXN5bmN0aHVtYmFsbG93Y2hpZWZ5b3V0aG5vdmVsMTBweDtzZXJ2ZXVudGlsaGFuZHNDaGVja1NwYWNlcXVlcnlqYW1lc2VxdWFsdHdpY2UwLDAwMFN0YXJ0cGFuZWxzb25nc3JvdW5kZWlnaHRzaGlmdHdvcnRocG9zdHNsZWFkc3dlZWtzYXZvaWR0aGVzZW1pbGVzcGxhbmVzbWFydGFscGhhcGxhbnRtYXJrc3JhdGVzcGxheXNjbGFpbXNhbGVzdGV4dHNzdGFyc3dyb25nPC9oMz50aGluZy5vcmcvbXVsdGloZWFyZFBvd2Vyc3RhbmR0b2tlbnNvbGlkKHRoaXNicmluZ3NoaXBzc3RhZmZ0cmllZGNhbGxzZnVsbHlmYWN0c2FnZW50VGhpcyAvLy0tPmFkbWluZWd5cHRFdmVudDE1cHg7RW1haWx0cnVlImNyb3Nzc3BlbnRibG9nc2JveCI+bm90ZWRsZWF2ZWNoaW5hc2l6ZXNndWVzdDwvaDQ+cm9ib3RoZWF2eXRydWUsc2V2ZW5ncmFuZGNyaW1lc2lnbnNhd2FyZWRhbmNlcGhhc2U+PCEtLWVuX1VTJiMzOTsyMDBweF9uYW1lbGF0aW5lbmpveWFqYXguYXRpb25zbWl0aFUuUy4gaG9sZHNwZXRlcmluZGlhbmF2Ij5jaGFpbnNjb3JlY29tZXNkb2luZ3ByaW9yU2hhcmUxOTkwc3JvbWFubGlzdHNqYXBhbmZhbGxzdHJpYWxvd25lcmFncmVlPC9oMj5hYnVzZWFsZXJ0b3BlcmEiLS8vV2NhcmRzaGlsbHN0ZWFtc1Bob3RvdHJ1dGhjbGVhbi5waHA/c2FpbnRtZXRhbGxvdWlzbWVhbnRwcm9vZmJyaWVmcm93Ij5nZW5yZXRydWNrbG9va3NWYWx1ZUZyYW1lLm5ldC8tLT4KPHRyeSB7CnZhciBtYWtlc2Nvc3RzcGxhaW5hZHVsdHF1ZXN0dHJhaW5sYWJvcmhlbHBzY2F1c2VtYWdpY21vdG9ydGhlaXIyNTBweGxlYXN0c3RlcHNDb3VudGNvdWxkZ2xhc3NzaWRlc2Z1bmRzaG90ZWxhd2FyZG1vdXRobW92ZXNwYXJpc2dpdmVzZHV0Y2h0ZXhhc2ZydWl0bnVsbCx8fFtdO3RvcCI+CjwhLS1QT1NUIm9jZWFuPGJyLz5mbG9vcnNwZWFrZGVwdGggc2l6ZWJhbmtzY2F0Y2hjaGFydDIwcHg7YWxpZ25kZWFsc3dvdWxkNTBweDt1cmw9InBhcmtzbW91c2VNb3N0IC4uLjwvYW1vbmdicmFpbmJvZHkgbm9uZTtiYXNlZGNhcnJ5ZHJhZnRyZWZlcnBhZ2VfaG9tZS5tZXRlcmRlbGF5ZHJlYW1wcm92ZWpvaW50PC90cj5kcnVnczwhLS0gYXByaWxpZGVhbGFsbGVuZXhhY3Rmb3J0aGNvZGVzbG9naWNWaWV3IHNlZW1zYmxhbmtwb3J0cyAoMjAwc2F2ZWRfbGlua2dvYWxzZ3JhbnRncmVla2hvbWVzcmluZ3NyYXRlZDMwcHg7d2hvc2VwYXJzZSgpOyIgQmxvY2tsaW51eGpvbmVzcGl4ZWwnKTsiPik7aWYoLWxlZnRkYXZpZGhvcnNlRm9jdXNyYWlzZWJveGVzVHJhY2tlbWVudDwvZW0+YmFyIj4uc3JjPXRvd2VyYWx0PSJjYWJsZWhlbnJ5MjRweDtzZXR1cGl0YWx5c2hhcnBtaW5vcnRhc3Rld2FudHN0aGlzLnJlc2V0d2hlZWxnaXJscy9jc3MvMTAwJTtjbHVic3N0dWZmYmlibGV2b3RlcyAxMDAwa29yZWF9KTsNCmJhbmRzcXVldWU9IHt9OzgwcHg7Y2tpbmd7DQoJCWFoZWFkY2xvY2tpcmlzaGxpa2UgcmF0aW9zdGF0c0Zvcm0ieWFob28pWzBdO0Fib3V0ZmluZHM8L2gxPmRlYnVndGFza3NVUkwgPWNlbGxzfSkoKTsxMnB4O3ByaW1ldGVsbHN0dXJuczB4NjAwLmpwZyJzcGFpbmJlYWNodGF4ZXNtaWNyb2FuZ2VsLS0+PC9naWZ0c3N0ZXZlLWxpbmtib2R5Ln0pOwoJbW91bnQgKDE5OUZBUTwvcm9nZXJmcmFua0NsYXNzMjhweDtmZWVkczxoMT48c2NvdHR0ZXN0czIycHg7ZHJpbmspIHx8IGxld2lzc2hhbGwjMDM5OyBmb3IgbG92ZWR3YXN0ZTAwcHg7amE644JzaW1vbjxmb250cmVwbHltZWV0c3VudGVyY2hlYXB0aWdodEJyYW5kKSAhPSBkcmVzc2NsaXBzcm9vbXNvbmtleW1vYmlsbWFpbi5OYW1lIHBsYXRlZnVubnl0cmVlc2NvbS8iMS5qcGd3bW9kZXBhcmFtU1RBUlRsZWZ0IGlkZGVuLCAyMDEpOwp9CmZvcm0udmlydXNjaGFpcnRyYW5zd29yc3RQYWdlc2l0aW9ucGF0Y2g8IS0tCm8tY2FjZmlybXN0b3VycywwMDAgYXNpYW5pKyspe2Fkb2JlJylbMF1pZD0xMGJvdGg7bWVudSAuMi5taS5wbmcia2V2aW5jb2FjaENoaWxkYnJ1Y2UyLmpwZ1VSTCkrLmpwZ3xzdWl0ZXNsaWNlaGFycnkxMjAiIHN3ZWV0dHI+DQpuYW1lPWRpZWdvcGFnZSBzd2lzcy0tPgoKI2ZmZjsiPkxvZy5jb20idHJlYXRzaGVldCkgJiYgMTRweDtzbGVlcG50ZW50ZmlsZWRqYTrjg2lkPSJjTmFtZSJ3b3JzZXNob3RzLWJveC1kZWx0YQombHQ7YmVhcnM6NDhaPGRhdGEtcnVyYWw8L2E+IHNwZW5kYmFrZXJzaG9wcz0gIiI7cGhwIj5jdGlvbjEzcHg7YnJpYW5oZWxsb3NpemU9bz0lMkYgam9pbm1heWJlPGltZyBpbWciPiwgZmpzaW1nIiAiKVswXU1Ub3BCVHlwZSJuZXdseURhbnNrY3plY2h0cmFpbGtub3dzPC9oNT5mYXEiPnpoLWNuMTApOwotMSIpO3R5cGU9Ymx1ZXN0cnVseWRhdmlzLmpzJzs+DQo8IXN0ZWVsIHlvdSBoMj4NCmZvcm0gamVzdXMxMDAlIG1lbnUuDQoJDQp3YWxlc3Jpc2tzdW1lbnRkZGluZ2ItbGlrdGVhY2hnaWYiIHZlZ2FzZGFuc2tlZXN0aXNocWlwc3VvbWlzb2JyZWRlc2RlZW50cmV0b2Rvc3B1ZWRlYcOxb3Nlc3TDoXRpZW5laGFzdGFvdHJvc3BhcnRlZG9uZGVudWV2b2hhY2VyZm9ybWFtaXNtb21lam9ybXVuZG9hcXXDrWTDrWFzc8OzbG9heXVkYWZlY2hhdG9kYXN0YW50b21lbm9zZGF0b3NvdHJhc3NpdGlvbXVjaG9haG9yYWx1Z2FybWF5b3Jlc3Rvc2hvcmFzdGVuZXJhbnRlc2ZvdG9zZXN0YXNwYcOtc251ZXZhc2FsdWRmb3Jvc21lZGlvcXVpZW5tZXNlc3BvZGVyY2hpbGVzZXLDoXZlY2VzZGVjaXJqb3PDqWVzdGFydmVudGFncnVwb2hlY2hvZWxsb3N0ZW5nb2FtaWdvY29zYXNuaXZlbGdlbnRlbWlzbWFhaXJlc2p1bGlvdGVtYXNoYWNpYWZhdm9yanVuaW9saWJyZXB1bnRvYnVlbm9hdXRvcmFicmlsYnVlbmF0ZXh0b21hcnpvc2FiZXJsaXN0YWx1ZWdvY8OzbW9lbmVyb2p1ZWdvcGVyw7poYWJlcmVzdG95bnVuY2FtdWplcnZhbG9yZnVlcmFsaWJyb2d1c3RhaWd1YWx2b3Rvc2Nhc29zZ3XDrWFwdWVkb3NvbW9zYXZpc291c3RlZGRlYmVubm9jaGVidXNjYWZhbHRhZXVyb3NzZXJpZWRpY2hvY3Vyc29jbGF2ZWNhc2FzbGXDs25wbGF6b2xhcmdvb2JyYXN2aXN0YWFwb3lvanVudG90cmF0YXZpc3RvY3JlYXJjYW1wb2hlbW9zY2luY29jYXJnb3Bpc29zb3JkZW5oYWNlbsOhcmVhZGlzY29wZWRyb2NlcmNhcHVlZGFwYXBlbG1lbm9yw7p0aWxjbGFyb2pvcmdlY2FsbGVwb25lcnRhcmRlbmFkaWVtYXJjYXNpZ3VlZWxsYXNzaWdsb2NvY2hlbW90b3NtYWRyZWNsYXNlcmVzdG9uacOxb3F1ZWRhcGFzYXJiYW5jb2hpam9zdmlhamVwYWJsb8Opc3RldmllbmVyZWlub2RlamFyZm9uZG9jYW5hbG5vcnRlbGV0cmFjYXVzYXRvbWFybWFub3NsdW5lc2F1dG9zdmlsbGF2ZW5kb3Blc2FydGlwb3N0ZW5nYW1hcmNvbGxldmFwYWRyZXVuaWRvdmFtb3N6b25hc2FtYm9zYmFuZGFtYXJpYWFidXNvbXVjaGFzdWJpcnJpb2phdml2aXJncmFkb2NoaWNhYWxsw61qb3ZlbmRpY2hhZXN0YW50YWxlc3NhbGlyc3VlbG9wZXNvc2ZpbmVzbGxhbWFidXNjb8Opc3RhbGxlZ2FuZWdyb3BsYXphaHVtb3JwYWdhcmp1bnRhZG9ibGVpc2xhc2JvbHNhYmHDsW9oYWJsYWx1Y2hhw4FyZWFkaWNlbmp1Z2Fybm90YXN2YWxsZWFsbMOhY2FyZ2Fkb2xvcmFiYWpvZXN0w6lndXN0b21lbnRlbWFyaW9maXJtYWNvc3RvZmljaGFwbGF0YWhvZ2FyYXJ0ZXNsZXllc2FxdWVsbXVzZW9iYXNlc3BvY29zbWl0YWRjaWVsb2NoaWNvbWllZG9nYW5hcnNhbnRvZXRhcGFkZWJlc3BsYXlhcmVkZXNzaWV0ZWNvcnRlY29yZWFkdWRhc2Rlc2Vvdmllam9kZXNlYWFndWFzJnF1b3Q7ZG9tYWluY29tbW9uc3RhdHVzZXZlbnRzbWFzdGVyc3lzdGVtYWN0aW9uYmFubmVycmVtb3Zlc2Nyb2xsdXBkYXRlZ2xvYmFsbWVkaXVtZmlsdGVybnVtYmVyY2hhbmdlcmVzdWx0cHVibGljc2NyZWVuY2hvb3Nlbm9ybWFsdHJhdmVsaXNzdWVzc291cmNldGFyZ2V0c3ByaW5nbW9kdWxlbW9iaWxlc3dpdGNocGhvdG9zYm9yZGVycmVnaW9uaXRzZWxmc29jaWFsYWN0aXZlY29sdW1ucmVjb3JkZm9sbG93dGl0bGU+ZWl0aGVybGVuZ3RoZmFtaWx5ZnJpZW5kbGF5b3V0YXV0aG9yY3JlYXRlcmV2aWV3c3VtbWVyc2VydmVycGxheWVkcGxheWVyZXhwYW5kcG9saWN5Zm9ybWF0ZG91YmxlcG9pbnRzc2VyaWVzcGVyc29ubGl2aW5nZGVzaWdubW9udGhzZm9yY2VzdW5pcXVld2VpZ2h0cGVvcGxlZW5lcmd5bmF0dXJlc2VhcmNoZmlndXJlaGF2aW5nY3VzdG9tb2Zmc2V0bGV0dGVyd2luZG93c3VibWl0cmVuZGVyZ3JvdXBzdXBsb2FkaGVhbHRobWV0aG9kdmlkZW9zc2Nob29sZnV0dXJlc2hhZG93ZGViYXRldmFsdWVzT2JqZWN0b3RoZXJzcmlnaHRzbGVhZ3VlY2hyb21lc2ltcGxlbm90aWNlc2hhcmVkZW5kaW5nc2Vhc29ucmVwb3J0b25saW5lc3F1YXJlYnV0dG9uaW1hZ2VzZW5hYmxlbW92aW5nbGF0ZXN0d2ludGVyRnJhbmNlcGVyaW9kc3Ryb25ncmVwZWF0TG9uZG9uZGV0YWlsZm9ybWVkZGVtYW5kc2VjdXJlcGFzc2VkdG9nZ2xlcGxhY2VzZGV2aWNlc3RhdGljY2l0aWVzc3RyZWFteWVsbG93YXR0YWNrc3RyZWV0ZmxpZ2h0aGlkZGVuaW5mbyI+b3BlbmVkdXNlZnVsdmFsbGV5Y2F1c2VzbGVhZGVyc2VjcmV0c2Vjb25kZGFtYWdlc3BvcnRzZXhjZXB0cmF0aW5nc2lnbmVkdGhpbmdzZWZmZWN0ZmllbGRzc3RhdGVzb2ZmaWNldmlzdWFsZWRpdG9ydm9sdW1lUmVwb3J0bXVzZXVtbW92aWVzcGFyZW50YWNjZXNzbW9zdGx5bW90aGVyIiBpZD0ibWFya2V0Z3JvdW5kY2hhbmNlc3VydmV5YmVmb3Jlc3ltYm9sbW9tZW50c3BlZWNobW90aW9uaW5zaWRlbWF0dGVyQ2VudGVyb2JqZWN0ZXhpc3RzbWlkZGxlRXVyb3BlZ3Jvd3RobGVnYWN5bWFubmVyZW5vdWdoY2FyZWVyYW5zd2Vyb3JpZ2lucG9ydGFsY2xpZW50c2VsZWN0cmFuZG9tY2xvc2VkdG9waWNzY29taW5nZmF0aGVyb3B0aW9uc2ltcGx5cmFpc2VkZXNjYXBlY2hvc2VuY2h1cmNoZGVmaW5lcmVhc29uY29ybmVyb3V0cHV0bWVtb3J5aWZyYW1lcG9saWNlbW9kZWxzTnVtYmVyZHVyaW5nb2ZmZXJzc3R5bGVza2lsbGVkbGlzdGVkY2FsbGVkc2lsdmVybWFyZ2luZGVsZXRlYmV0dGVyYnJvd3NlbGltaXRzR2xvYmFsc2luZ2xld2lkZ2V0Y2VudGVyYnVkZ2V0bm93cmFwY3JlZGl0Y2xhaW1zZW5naW5lc2FmZXR5Y2hvaWNlc3Bpcml0LXN0eWxlc3ByZWFkbWFraW5nbmVlZGVkcnVzc2lhcGxlYXNlZXh0ZW50U2NyaXB0YnJva2VuYWxsb3dzY2hhcmdlZGl2aWRlZmFjdG9ybWVtYmVyLWJhc2VkdGhlb3J5Y29uZmlnYXJvdW5kd29ya2VkaGVscGVkQ2h1cmNoaW1wYWN0c2hvdWxkYWx3YXlzbG9nbyIgYm90dG9tbGlzdCI+KXt2YXIgcHJlZml4b3JhbmdlSGVhZGVyLnB1c2goY291cGxlZ2FyZGVuYnJpZGdlbGF1bmNoUmV2aWV3dGFraW5ndmlzaW9ubGl0dGxlZGF0aW5nQnV0dG9uYmVhdXR5dGhlbWVzZm9yZ290U2VhcmNoYW5jaG9yYWxtb3N0bG9hZGVkQ2hhbmdlcmV0dXJuc3RyaW5ncmVsb2FkTW9iaWxlaW5jb21lc3VwcGx5U291cmNlb3JkZXJzdmlld2VkJm5ic3A7Y291cnNlQWJvdXQgaXNsYW5kPGh0bWwgY29va2llbmFtZT0iYW1hem9ubW9kZXJuYWR2aWNlaW48L2E+OiBUaGUgZGlhbG9naG91c2VzQkVHSU4gTWV4aWNvc3RhcnRzY2VudHJlaGVpZ2h0YWRkaW5nSXNsYW5kYXNzZXRzRW1waXJlU2Nob29sZWZmb3J0ZGlyZWN0bmVhcmx5bWFudWFsU2VsZWN0LgoKT25lam9pbmVkbWVudSI+UGhpbGlwYXdhcmRzaGFuZGxlaW1wb3J0T2ZmaWNlcmVnYXJkc2tpbGxzbmF0aW9uU3BvcnRzZGVncmVld2Vla2x5IChlLmcuYmVoaW5kZG9jdG9ybG9nZ2VkdW5pdGVkPC9iPjwvYmVnaW5zcGxhbnRzYXNzaXN0YXJ0aXN0aXNzdWVkMzAwcHh8Y2FuYWRhYWdlbmN5c2NoZW1lcmVtYWluQnJhemlsc2FtcGxlbG9nbyI+YmV5b25kLXNjYWxlYWNjZXB0c2VydmVkbWFyaW5lRm9vdGVyY2FtZXJhPC9oMT4KX2Zvcm0ibGVhdmVzc3RyZXNzIiAvPg0KLmdpZiIgb25sb2FkbG9hZGVyT3hmb3Jkc2lzdGVyc3Vydml2bGlzdGVuZmVtYWxlRGVzaWduc2l6ZT0iYXBwZWFsdGV4dCI+bGV2ZWxzdGhhbmtzaGlnaGVyZm9yY2VkYW5pbWFsYW55b25lQWZyaWNhYWdyZWVkcmVjZW50UGVvcGxlPGJyIC8+d29uZGVycHJpY2VzdHVybmVkfHwge307bWFpbiI+aW5saW5lc3VuZGF5d3JhcCI+ZmFpbGVkY2Vuc3VzbWludXRlYmVhY29ucXVvdGVzMTUwcHh8ZXN0YXRlcmVtb3RlZW1haWwibGlua2VkcmlnaHQ7c2lnbmFsZm9ybWFsMS5odG1sc2lnbnVwcHJpbmNlZmxvYXQ6LnBuZyIgZm9ydW0uQWNjZXNzcGFwZXJzc291bmRzZXh0ZW5kSGVpZ2h0c2xpZGVyVVRGLTgiJmFtcDsgQmVmb3JlLiBXaXRoc3R1ZGlvb3duZXJzbWFuYWdlcHJvZml0alF1ZXJ5YW5udWFscGFyYW1zYm91Z2h0ZmFtb3VzZ29vZ2xlbG9uZ2VyaSsrKSB7aXNyYWVsc2F5aW5nZGVjaWRlaG9tZSI+aGVhZGVyZW5zdXJlYnJhbmNocGllY2VzYmxvY2s7c3RhdGVkdG9wIj48cmFjaW5ncmVzaXplLS0mZ3Q7cGFjaXR5c2V4dWFsYnVyZWF1LmpwZyIgMTAsMDAwb2J0YWludGl0bGVzYW1vdW50LCBJbmMuY29tZWR5bWVudSIgbHlyaWNzdG9kYXkuaW5kZWVkY291bnR5X2xvZ28uRmFtaWx5bG9va2VkTWFya2V0bHNlIGlmUGxheWVydHVya2V5KTt2YXIgZm9yZXN0Z2l2aW5nZXJyb3JzRG9tYWlufWVsc2V7aW5zZXJ0QmxvZzwvZm9vdGVybG9naW4uZmFzdGVyYWdlbnRzPGJvZHkgMTBweCAwcHJhZ21hZnJpZGF5anVuaW9yZG9sbGFycGxhY2VkY292ZXJzcGx1Z2luNSwwMDAgcGFnZSI+Ym9zdG9uLnRlc3QoYXZhdGFydGVzdGVkX2NvdW50Zm9ydW1zc2NoZW1haW5kZXgsZmlsbGVkc2hhcmVzcmVhZGVyYWxlcnQoYXBwZWFyU3VibWl0bGluZSI+Ym9keSI+CiogVGhlVGhvdWdoc2VlaW5namVyc2V5TmV3czwvdmVyaWZ5ZXhwZXJ0aW5qdXJ5d2lkdGg9Q29va2llU1RBUlQgYWNyb3NzX2ltYWdldGhyZWFkbmF0aXZlcG9ja2V0Ym94Ij4KU3lzdGVtIERhdmlkY2FuY2VydGFibGVzcHJvdmVkQXByaWwgcmVhbGx5ZHJpdmVyaXRlbSI+bW9yZSI+Ym9hcmRzY29sb3JzY2FtcHVzZmlyc3QgfHwgW107bWVkaWEuZ3VpdGFyZmluaXNod2lkdGg6c2hvd2VkT3RoZXIgLnBocCIgYXNzdW1lbGF5ZXJzd2lsc29uc3RvcmVzcmVsaWVmc3dlZGVuQ3VzdG9tZWFzaWx5IHlvdXIgU3RyaW5nCgpXaGlsdGF5bG9yY2xlYXI6cmVzb3J0ZnJlbmNodGhvdWdoIikgKyAiPGJvZHk+YnV5aW5nYnJhbmRzTWVtYmVybmFtZSI+b3BwaW5nc2VjdG9yNXB4OyI+dnNwYWNlcG9zdGVybWFqb3IgY29mZmVlbWFydGlubWF0dXJlaGFwcGVuPC9uYXY+a2Fuc2FzbGluayI+SW1hZ2VzPWZhbHNld2hpbGUgaHNwYWNlMCZhbXA7IAoKSW4gIHBvd2VyUG9sc2tpLWNvbG9yam9yZGFuQm90dG9tU3RhcnQgLWNvdW50Mi5odG1sbmV3cyI+MDEuanBnT25saW5lLXJpZ2h0bWlsbGVyc2VuaW9ySVNCTiAwMCwwMDAgZ3VpZGVzdmFsdWUpZWN0aW9ucmVwYWlyLnhtbCIgIHJpZ2h0cy5odG1sLWJsb2NrcmVnRXhwOmhvdmVyd2l0aGludmlyZ2lucGhvbmVzPC90cj4NdXNpbmcgCgl2YXIgPicpOwoJPC90ZD4KPC90cj4KYmFoYXNhYnJhc2lsZ2FsZWdvbWFneWFycG9sc2tpc3Jwc2tp2LHYr9mI5Lit5paH566A5L2T57mB6auU5L+h5oGv5Lit5Zu95oiR5Lus5LiA5Liq5YWs5Y+4566h55CG6K665Z2b5Y+v5Lul5pyN5Yqh5pe26Ze05Liq5Lq65Lqn5ZOB6Ieq5bex5LyB5Lia5p+l55yL5bel5L2c6IGU57O75rKh5pyJ572R56uZ5omA5pyJ6K+E6K665Lit5b+D5paH56ug55So5oi36aaW6aG15L2c6ICF5oqA5pyv6Zeu6aKY55u45YWz5LiL6L295pCc57Si5L2/55So6L2v5Lu25Zyo57q/5Li76aKY6LWE5paZ6KeG6aKR5Zue5aSN5rOo5YaM572R57uc5pS26JeP5YaF5a655o6o6I2Q5biC5Zy65raI5oGv56m66Ze05Y+R5biD5LuA5LmI5aW95Y+L55Sf5rS75Zu+54mH5Y+R5bGV5aaC5p6c5omL5py65paw6Ze75pyA5paw5pa55byP5YyX5Lqs5o+Q5L6b5YWz5LqO5pu05aSa6L+Z5Liq57O757uf55+l6YGT5ri45oiP5bm/5ZGK5YW25LuW5Y+R6KGo5a6J5YWo56ys5LiA5Lya5ZGY6L+b6KGM54K55Ye754mI5p2D55S15a2Q5LiW55WM6K6+6K6h5YWN6LS55pWZ6IKy5Yqg5YWl5rS75Yqo5LuW5Lus5ZWG5ZOB5Y2a5a6i546w5Zyo5LiK5rW35aaC5L2V5bey57uP55WZ6KiA6K+m57uG56S+5Yy655m75b2V5pys56uZ6ZyA6KaB5Lu35qC85pSv5oyB5Zu96ZmF6ZO+5o6l5Zu95a625bu66K6+5pyL5Y+L6ZiF6K+75rOV5b6L5L2N572u57uP5rWO6YCJ5oup6L+Z5qC35b2T5YmN5YiG57G75o6S6KGM5Zug5Li65Lqk5piT5pyA5ZCO6Z+z5LmQ5LiN6IO96YCa6L+H6KGM5Lia56eR5oqA5Y+v6IO96K6+5aSH5ZCI5L2c5aSn5a6256S+5Lya56CU56m25LiT5Lia5YWo6YOo6aG555uu6L+Z6YeM6L+Y5piv5byA5aeL5oOF5Ya155S16ISR5paH5Lu25ZOB54mM5biu5Yqp5paH5YyW6LWE5rqQ5aSn5a2m5a2m5Lmg5Zyw5Z2A5rWP6KeI5oqV6LWE5bel56iL6KaB5rGC5oCO5LmI5pe25YCZ5Yqf6IO95Li76KaB55uu5YmN6LWE6K6v5Z+O5biC5pa55rOV55S15b2x5oub6IGY5aOw5piO5Lu75L2V5YGl5bq35pWw5o2u576O5Zu95rG96L2m5LuL57uN5L2G5piv5Lqk5rWB55Sf5Lqn5omA5Lul55S16K+d5pi+56S65LiA5Lqb5Y2V5L2N5Lq65ZGY5YiG5p6Q5Zyw5Zu+5peF5ri45bel5YW35a2m55Sf57O75YiX572R5Y+L5biW5a2Q5a+G56CB6aKR6YGT5o6n5Yi25Zyw5Yy65Z+65pys5YWo5Zu9572R5LiK6YeN6KaB56ys5LqM5Zac5qyi6L+b5YWl5Y+L5oOF6L+Z5Lqb6ICD6K+V5Y+R546w5Z+56K6t5Lul5LiK5pS/5bqc5oiQ5Li6546v5aKD6aaZ5riv5ZCM5pe25aix5LmQ5Y+R6YCB5LiA5a6a5byA5Y+R5L2c5ZOB5qCH5YeG5qyi6L+O6Kej5Yaz5Zyw5pa55LiA5LiL5Lul5Y+K6LSj5Lu75oiW6ICF5a6i5oi35Luj6KGo56ev5YiG5aWz5Lq65pWw56CB6ZSA5ZSu5Ye6546w56a757q/5bqU55So5YiX6KGo5LiN5ZCM57yW6L6R57uf6K6h5p+l6K+i5LiN6KaB5pyJ5YWz5py65p6E5b6I5aSa5pKt5pS+57uE57uH5pS/562W55u05o6l6IO95Yqb5p2l5rqQ5pmC6ZaT55yL5Yiw54Ot6Zeo5YWz6ZSu5LiT5Yy66Z2e5bi46Iux6K+t55m+5bqm5biM5pyb576O5aWz5q+U6L6D55+l6K+G6KeE5a6a5bu66K6u6YOo6Zeo5oSP6KeB57K+5b2p5pel5pys5o+Q6auY5Y+R6KiA5pa56Z2i5Z+66YeR5aSE55CG5p2D6ZmQ5b2x54mH6ZO26KGM6L+Y5pyJ5YiG5Lqr54mp5ZOB57uP6JCl5re75Yqg5LiT5a626L+Z56eN6K+d6aKY6LW35p2l5Lia5Yqh5YWs5ZGK6K6w5b2V566A5LuL6LSo6YeP55S35Lq65b2x5ZON5byV55So5oql5ZGK6YOo5YiG5b+r6YCf5ZKo6K+i5pe25bCa5rOo5oSP55Sz6K+35a2m5qCh5bqU6K+l5Y6G5Y+y5Y+q5piv6L+U5Zue6LSt5Lmw5ZCN56ew5Li65LqG5oiQ5Yqf6K+05piO5L6b5bqU5a2p5a2Q5LiT6aKY56iL5bqP5LiA6Iis5pyD5ZOh5Y+q5pyJ5YW25a6D5L+d5oqk6ICM5LiU5LuK5aSp56qX5Y+j5Yqo5oCB54q25oCB54m55Yir6K6k5Li65b+F6aG75pu05paw5bCP6K+05oiR5YCR5L2c5Li65aqS5L2T5YyF5ous6YKj5LmI5LiA5qC35Zu95YaF5piv5ZCm5qC55o2u55S16KeG5a2m6Zmi5YW35pyJ6L+H56iL55Sx5LqO5Lq65omN5Ye65p2l5LiN6L+H5q2j5Zyo5piO5pif5pWF5LqL5YWz57O75qCH6aKY5ZWG5Yqh6L6T5YWl5LiA55u05Z+656GA5pWZ5a2m5LqG6Kej5bu6562R57uT5p6c5YWo55CD6YCa55+l6K6h5YiS5a+55LqO6Im65pyv55u45YaM5Y+R55Sf55yf55qE5bu656uL562J57qn57G75Z6L57uP6aqM5a6e546w5Yi25L2c5p2l6Ieq5qCH562+5Lul5LiL5Y6f5Yib5peg5rOV5YW25Lit5YCL5Lq65LiA5YiH5oyH5Y2X5YWz6Zet6ZuG5Zui56ys5LiJ5YWz5rOo5Zug5q2k54Wn54mH5rex5Zyz5ZWG5Lia5bm/5bee5pel5pyf6auY57qn5pyA6L+R57u85ZCI6KGo56S65LiT6L6R6KGM5Li65Lqk6YCa6K+E5Lu36KeJ5b6X57K+5Y2O5a625bqt5a6M5oiQ5oSf6KeJ5a6J6KOF5b6X5Yiw6YKu5Lu25Yi25bqm6aOf5ZOB6Jm954S26L2s6L295oql5Lu36K6w6ICF5pa55qGI6KGM5pS/5Lq65rCR55So5ZOB5Lic6KW/5o+Q5Ye66YWS5bqX54S25ZCO5LuY5qy+54Ot54K55Lul5YmN5a6M5YWo5Y+R5biW6K6+572u6aKG5a+85bel5Lia5Yy76Zmi55yL55yL57uP5YW45Y6f5Zug5bmz5Y+w5ZCE56eN5aKe5Yqg5p2Q5paZ5paw5aKe5LmL5ZCO6IGM5Lia5pWI5p6c5LuK5bm06K665paH5oiR5Zu95ZGK6K+J54mI5Li75L+u5pS55Y+C5LiO5omT5Y2w5b+r5LmQ5py65qKw6KeC54K55a2Y5Zyo57K+56We6I635b6X5Yip55So57un57ut5L2g5Lus6L+Z5LmI5qih5byP6K+t6KiA6IO95aSf6ZuF6JmO5pON5L2c6aOO5qC85LiA6LW356eR5a2m5L2T6IKy55+t5L+h5p2h5Lu25rK755aX6L+Q5Yqo5Lqn5Lia5Lya6K6u5a+86Iiq5YWI55Sf6IGU55uf5Y+v5piv5ZWP6aGM57uT5p6E5L2c55So6LCD5p+l6LOH5paZ6Ieq5Yqo6LSf6LSj5Yac5Lia6K6/6Zeu5a6e5pa95o6l5Y+X6K6o6K666YKj5Liq5Y+N6aaI5Yqg5by65aWz5oCn6IyD5Zu05pyN5YuZ5LyR6Zey5LuK5pel5a6i5pyN6KeA55yL5Y+C5Yqg55qE6K+d5LiA54K55L+d6K+B5Zu+5Lmm5pyJ5pWI5rWL6K+V56e75Yqo5omN6IO95Yaz5a6a6IKh56Wo5LiN5pat6ZyA5rGC5LiN5b6X5Yqe5rOV5LmL6Ze06YeH55So6JCl6ZSA5oqV6K+J55uu5qCH54ix5oOF5pGE5b2x5pyJ5Lqb6KSH6KO95paH5a2m5py65Lya5pWw5a2X6KOF5L+u6LSt54mp5Yac5p2R5YWo6Z2i57K+5ZOB5YW25a6e5LqL5oOF5rC05bmz5o+Q56S65LiK5biC6LCi6LCi5pmu6YCa5pWZ5biI5LiK5Lyg57G75Yir5q2M5puy5oul5pyJ5Yib5paw6YWN5Lu25Y+q6KaB5pe25Luj6LOH6KiK6L6+5Yiw5Lq655Sf6K6i6ZiF6ICB5biI5bGV56S65b+D55CG6LS05a2Q57ay56uZ5Li76aGM6Ieq54S257qn5Yir566A5Y2V5pS56Z2p6YKj5Lqb5p2l6K+05omT5byA5Luj56CB5Yig6Zmk6K+B5Yi46IqC55uu6YeN54K55qyh5pW45aSa5bCR6KeE5YiS6LWE6YeR5om+5Yiw5Lul5ZCO5aSn5YWo5Li76aG15pyA5L2z5Zue562U5aSp5LiL5L+d6Zqc546w5Luj5qOA5p+l5oqV56Wo5bCP5pe25rKS5pyJ5q2j5bi455Sa6Iez5Luj55CG55uu5b2V5YWs5byA5aSN5Yi26YeR6J6N5bm456aP54mI5pys5b2i5oiQ5YeG5aSH6KGM5oOF5Zue5Yiw5oCd5oOz5oCO5qC35Y2P6K6u6K6k6K+B5pyA5aW95Lqn55Sf5oyJ54Wn5pyN6KOF5bm/5Lic5Yqo5ryr6YeH6LSt5paw5omL57uE5Zu+6Z2i5p2/5Y+C6ICD5pS/5rK75a655piT5aSp5Zyw5Yqq5Yqb5Lq65Lus5Y2H57qn6YCf5bqm5Lq654mp6LCD5pW05rWB6KGM6YCg5oiQ5paH5a2X6Z+p5Zu96LS45piT5byA5bGV55u46Zec6KGo546w5b2x6KeG5aaC5q2k576O5a655aSn5bCP5oql6YGT5p2h5qy+5b+D5oOF6K645aSa5rOV6KeE5a625bGF5Lmm5bqX6L+e5o6l56uL5Y2z5Li+5oql5oqA5ben5aWl6L+Q55m75YWl5Lul5p2l55CG6K665LqL5Lu26Ieq55Sx5Lit5Y2O5Yqe5YWs5aaI5aaI55yf5q2j5LiN6ZSZ5YWo5paH5ZCI5ZCM5Lu35YC85Yir5Lq655uR552j5YW35L2T5LiW57qq5Zui6Zif5Yib5Lia5om/5ouF5aKe6ZW/5pyJ5Lq65L+d5oyB5ZWG5a6257u05L+u5Y+w5rm+5bem5Y+z6IKh5Lu9562U5qGI5a6e6ZmF55S15L+h57uP55CG55Sf5ZG95a6j5Lyg5Lu75Yqh5q2j5byP54m56Imy5LiL5p2l5Y2P5Lya5Y+q6IO95b2T54S26YeN5paw5YWn5a655oyH5a+86L+Q6KGM5pel5b+X6LOj5a626LaF6L+H5Zyf5Zyw5rWZ5rGf5pSv5LuY5o6o5Ye656uZ6ZW/5p2t5bee5omn6KGM5Yi26YCg5LmL5LiA5o6o5bm/546w5Zy65o+P6L+w5Y+Y5YyW5Lyg57uf5q2M5omL5L+d6Zmp6K++56iL5Yy755aX57uP6L+H6L+H5Y675LmL5YmN5pS25YWl5bm05bqm5p2C5b+X576O5Li95pyA6auY55m76ZmG5pyq5p2l5Yqg5bel5YWN6LSj5pWZ56iL54mI5Z2X6Lqr5L2T6YeN5bqG5Ye65ZSu5oiQ5pys5b2i5byP5Zyf6LGG5Ye65YO55Lic5pa56YKu566x5Y2X5Lqs5rGC6IGM5Y+W5b6X6IGM5L2N55u45L+h6aG16Z2i5YiG6ZKf572R6aG156Gu5a6a5Zu+5L6L572R5Z2A56ev5p6B6ZSZ6K+v55uu55qE5a6d6LSd5py65YWz6aOO6Zmp5o6I5p2D55eF5q+S5a6g54mp6Zmk5LqG6KmV6KuW55a+55eF5Y+K5pe25rGC6LSt56uZ54K55YS/56ul5q+P5aSp5Lit5aSu6K6k6K+G5q+P5Liq5aSp5rSl5a2X5L2T5Y+w54Gj57u05oqk5pys6aG15Liq5oCn5a6Y5pa55bi46KeB55u45py65oiY55Wl5bqU5b2T5b6L5biI5pa55L6/5qCh5Zut6IKh5biC5oi/5bGL5qCP55uu5ZGY5bel5a+86Ie056qB54S26YGT5YW35pys572R57uT5ZCI5qGj5qGI5Yqz5Yqo5Y+m5aSW576O5YWD5byV6LW35pS55Y+Y56ys5Zub5Lya6K6h6Kqq5piO6ZqQ56eB5a6d5a6d6KeE6IyD5raI6LS55YWx5ZCM5b+Y6K6w5L2T57O75bim5p2l5ZCN5a2X55m86KGo5byA5pS+5Yqg55uf5Y+X5Yiw5LqM5omL5aSn6YeP5oiQ5Lq65pWw6YeP5YWx5Lqr5Yy65Z+f5aWz5a2p5Y6f5YiZ5omA5Zyo57uT5p2f6YCa5L+h6LaF57qn6YWN572u5b2T5pe25LyY56eA5oCn5oSf5oi/5Lqn6YGK5oiy5Ye65Y+j5o+Q5Lqk5bCx5Lia5L+d5YGl56iL5bqm5Y+C5pWw5LqL5Lia5pW05Liq5bGx5Lic5oOF5oSf54m55q6K5YiG6aGe5pCc5bCL5bGe5LqO6Zeo5oi36LSi5Yqh5aOw6Z+z5Y+K5YW26LSi57uP5Z2a5oyB5bmy6YOo5oiQ56uL5Yip55uK6ICD6JmR5oiQ6YO95YyF6KOF55So5oi25q+U6LWb5paH5piO5oub5ZWG5a6M5pW055yf5piv55y8552b5LyZ5Ly05aiB5pyb6aKG5Z+f5Y2r55Sf5LyY5oOg6KuW5aOH5YWs5YWx6Imv5aW95YWF5YiG56ym5ZCI6ZmE5Lu254m554K55LiN5Y+v6Iux5paH6LWE5Lqn5qC55pys5piO5pi+5a+G56K85YWs5LyX5rCR5peP5pu05Yqg5Lqr5Y+X5ZCM5a2m5ZCv5Yqo6YCC5ZCI5Y6f5p2l6Zeu562U5pys5paH576O6aOf57u/6Imy56iz5a6a57uI5LqO55Sf54mp5L6b5rGC5pCc54uQ5Yqb6YeP5Lil6YeN5rC46L+c5YaZ55yf5pyJ6ZmQ56ue5LqJ5a+56LGh6LS555So5LiN5aW957ud5a+55Y2B5YiG5L+D6L+b54K56K+E5b2x6Z+z5LyY5Yq/5LiN5bCR5qyj6LWP5bm25LiU5pyJ54K55pa55ZCR5YWo5paw5L+h55So6K6+5pa95b2i6LGh6LWE5qC856qB56C06ZqP552A6YeN5aSn5LqO5piv5q+V5Lia5pm66IO95YyW5bel5a6M576O5ZWG5Z+O57uf5LiA5Ye654mI5omT6YCg55Si5ZOB5qaC5Ya155So5LqO5L+d55WZ5Zug57Sg5Lit5ZyL5a2Y5YKo6LS05Zu+5pyA5oSb6ZW/5pyf5Y+j5Lu355CG6LSi5Z+65Zyw5a6J5o6S5q2m5rGJ6YeM6Z2i5Yib5bu65aSp56m66aaW5YWI5a6M5ZaE6amx5Yqo5LiL6Z2i5LiN5YaN6K+a5L+h5oSP5LmJ6Ziz5YWJ6Iux5Zu95ryC5Lqu5Yab5LqL546p5a62576k5LyX5Yac5rCR5Y2z5Y+v5ZCN56ix5a625YW35Yqo55S75oOz5Yiw5rOo5piO5bCP5a2m5oCn6IO96ICD56CU56Gs5Lu26KeC55yL5riF5qWa5pCe56yR6aaW6aCB6buE6YeR6YCC55So5rGf6IuP55yf5a6e5Li7566h6Zi25q616Ki75YaK57+76K+R5p2D5Yip5YGa5aW95Ly85LmO6YCa6K6v5pa95bel54uA5oWL5Lmf6K64546v5L+d5Z+55YW75qaC5b+15aSn5Z6L5py656Wo55CG6Kej5Yy/5ZCNY3VhbmRvZW52aWFybWFkcmlkYnVzY2FyaW5pY2lvdGllbXBvcG9ycXVlY3VlbnRhZXN0YWRvcHVlZGVuanVlZ29zY29udHJhZXN0w6Fubm9tYnJldGllbmVucGVyZmlsbWFuZXJhYW1pZ29zY2l1ZGFkY2VudHJvYXVucXVlcHVlZGVzZGVudHJvcHJpbWVycHJlY2lvc2Vnw7puYnVlbm9zdm9sdmVycHVudG9zc2VtYW5haGFiw61hYWdvc3RvbnVldm9zdW5pZG9zY2FybG9zZXF1aXBvbmnDsW9zbXVjaG9zYWxndW5hY29ycmVvaW1hZ2VucGFydGlyYXJyaWJhbWFyw61haG9tYnJlZW1wbGVvdmVyZGFkY2FtYmlvbXVjaGFzZnVlcm9ucGFzYWRvbMOtbmVhcGFyZWNlbnVldmFzY3Vyc29zZXN0YWJhcXVpZXJvbGlicm9zY3VhbnRvYWNjZXNvbWlndWVsdmFyaW9zY3VhdHJvdGllbmVzZ3J1cG9zc2Vyw6FuZXVyb3BhbWVkaW9zZnJlbnRlYWNlcmNhZGVtw6Fzb2ZlcnRhY29jaGVzbW9kZWxvaXRhbGlhbGV0cmFzYWxnw7puY29tcHJhY3VhbGVzZXhpc3RlY3VlcnBvc2llbmRvcHJlbnNhbGxlZ2FydmlhamVzZGluZXJvbXVyY2lhcG9kcsOhcHVlc3RvZGlhcmlvcHVlYmxvcXVpZXJlbWFudWVscHJvcGlvY3Jpc2lzY2llcnRvc2VndXJvbXVlcnRlZnVlbnRlY2VycmFyZ3JhbmRlZWZlY3RvcGFydGVzbWVkaWRhcHJvcGlhb2ZyZWNldGllcnJhZS1tYWlsdmFyaWFzZm9ybWFzZnV0dXJvb2JqZXRvc2VndWlycmllc2dvbm9ybWFzbWlzbW9zw7puaWNvY2FtaW5vc2l0aW9zcmF6w7NuZGViaWRvcHJ1ZWJhdG9sZWRvdGVuw61hamVzw7pzZXNwZXJvY29jaW5hb3JpZ2VudGllbmRhY2llbnRvY8OhZGl6aGFibGFyc2Vyw61hbGF0aW5hZnVlcnphZXN0aWxvZ3VlcnJhZW50cmFyw6l4aXRvbMOzcGV6YWdlbmRhdsOtZGVvZXZpdGFycGFnaW5hbWV0cm9zamF2aWVycGFkcmVzZsOhY2lsY2FiZXphw6FyZWFzc2FsaWRhZW52w61vamFww7NuYWJ1c29zYmllbmVzdGV4dG9zbGxldmFycHVlZGFuZnVlcnRlY29tw7puY2xhc2VzaHVtYW5vdGVuaWRvYmlsYmFvdW5pZGFkZXN0w6FzZWRpdGFyY3JlYWRv0LTQu9GP0YfRgtC+0LrQsNC60LjQu9C40Y3RgtC+0LLRgdC10LXQs9C+0L/RgNC40YLQsNC60LXRidC10YPQttC10JrQsNC60LHQtdC30LHRi9C70L7QvdC40JLRgdC10L/QvtC00K3RgtC+0YLQvtC80YfQtdC80L3QtdGC0LvQtdGC0YDQsNC30L7QvdCw0LPQtNC10LzQvdC10JTQu9GP0J/RgNC40L3QsNGB0L3QuNGF0YLQtdC80LrRgtC+0LPQvtC00LLQvtGC0YLQsNC80KHQqNCQ0LzQsNGP0KfRgtC+0LLQsNGB0LLQsNC80LXQvNGD0KLQsNC60LTQstCw0L3QsNC80Y3RgtC40Y3RgtGD0JLQsNC80YLQtdGF0L/RgNC+0YLRg9GC0L3QsNC00LTQvdGP0JLQvtGC0YLRgNC40L3QtdC50JLQsNGB0L3QuNC80YHQsNC80YLQvtGC0YDRg9Cx0J7QvdC40LzQuNGA0L3QtdC10J7QntCe0LvQuNGG0Y3RgtCw0J7QvdCw0L3QtdC80LTQvtC80LzQvtC50LTQstC10L7QvdC+0YHRg9C04KSV4KWH4KS54KWI4KSV4KWA4KS44KWH4KSV4KS+4KSV4KWL4KSU4KSw4KSq4KSw4KSo4KWH4KSP4KSV4KSV4KS/4KSt4KWA4KSH4KS44KSV4KSw4KSk4KWL4KS54KWL4KSG4KSq4KS54KWA4KSv4KS54KSv4KS+4KSk4KSV4KSl4KS+amFncmFu4KSG4KSc4KSc4KWL4KSF4KSs4KSm4KWL4KSX4KSI4KSc4KS+4KSX4KSP4KS54KSu4KSH4KSo4KS14KS54KSv4KWH4KSl4KWH4KSl4KWA4KSY4KSw4KSc4KSs4KSm4KWA4KSV4KSI4KSc4KWA4KS14KWH4KSo4KSI4KSo4KSP4KS54KSw4KSJ4KS44KSu4KWH4KSV4KSu4KS14KWL4KSy4KWH4KS44KSs4KSu4KSI4KSm4KWH4KST4KSw4KSG4KSu4KSs4KS44KSt4KSw4KSs4KSo4KSa4KSy4KSu4KSo4KSG4KSX4KS44KWA4KSy4KWA2LnZhNmJ2KXZhNmJ2YfYsNin2KLYrtix2LnYr9iv2KfZhNmJ2YfYsNmH2LXZiNix2LrZitix2YPYp9mG2YjZhNin2KjZitmG2LnYsdi22LDZhNmD2YfZhtin2YrZiNmF2YLYp9mE2LnZhNmK2KfZhtin2YTZg9mG2K3YqtmJ2YLYqNmE2YjYrdip2KfYrtix2YHZgti32LnYqNiv2LHZg9mG2KXYsNin2YPZhdin2KfYrdiv2KXZhNin2YHZitmH2KjYudi22YPZitmB2KjYrdir2YjZhdmG2YjZh9mI2KPZhtin2KzYr9in2YTZh9in2LPZhNmF2LnZhtiv2YTZitiz2LnYqNix2LXZhNmJ2YXZhtiw2KjZh9in2KPZhtmH2YXYq9mE2YPZhtiq2KfZhNin2K3Zitir2YXYtdix2LTYsdit2K3ZiNmE2YjZgdmK2KfYsNin2YTZg9mE2YXYsdip2KfZhtiq2KfZhNmB2KPYqNmI2K7Yp9i12KPZhtiq2KfZhtmH2KfZhNmK2LnYttmI2YjZgtiv2KfYqNmG2K7Zitix2KjZhtiq2YTZg9mF2LTYp9ih2YjZh9mK2KfYqNmI2YLYtdi12YjZhdin2LHZgtmF2KPYrdiv2YbYrdmG2LnYr9mF2LHYo9mK2KfYrdip2YPYqtio2K/ZiNmG2YrYrNio2YXZhtmH2KrYrdiq2KzZh9ip2LPZhtip2YrYqtmF2YPYsdip2LrYstip2YbZgdiz2KjZitiq2YTZhNmH2YTZhtin2KrZhNmD2YLZhNio2YTZhdin2LnZhtmH2KPZiNmE2LTZitih2YbZiNix2KPZhdin2YHZitmD2KjZg9mE2LDYp9iq2LHYqtio2KjYo9mG2YfZhdiz2KfZhtmD2KjZiti52YHZgtiv2K3Ys9mG2YTZh9mF2LTYudix2KPZh9mE2LTZh9ix2YLYt9ix2LfZhNiocHJvZmlsZXNlcnZpY2VkZWZhdWx0aGltc2VsZmRldGFpbHNjb250ZW50c3VwcG9ydHN0YXJ0ZWRtZXNzYWdlc3VjY2Vzc2Zhc2hpb248dGl0bGU+Y291bnRyeWFjY291bnRjcmVhdGVkc3Rvcmllc3Jlc3VsdHNydW5uaW5ncHJvY2Vzc3dyaXRpbmdvYmplY3RzdmlzaWJsZXdlbGNvbWVhcnRpY2xldW5rbm93bm5ldHdvcmtjb21wYW55ZHluYW1pY2Jyb3dzZXJwcml2YWN5cHJvYmxlbVNlcnZpY2VyZXNwZWN0ZGlzcGxheXJlcXVlc3RyZXNlcnZld2Vic2l0ZWhpc3RvcnlmcmllbmRzb3B0aW9uc3dvcmtpbmd2ZXJzaW9ubWlsbGlvbmNoYW5uZWx3aW5kb3cuYWRkcmVzc3Zpc2l0ZWR3ZWF0aGVyY29ycmVjdHByb2R1Y3RlZGlyZWN0Zm9yd2FyZHlvdSBjYW5yZW1vdmVkc3ViamVjdGNvbnRyb2xhcmNoaXZlY3VycmVudHJlYWRpbmdsaWJyYXJ5bGltaXRlZG1hbmFnZXJmdXJ0aGVyc3VtbWFyeW1hY2hpbmVtaW51dGVzcHJpdmF0ZWNvbnRleHRwcm9ncmFtc29jaWV0eW51bWJlcnN3cml0dGVuZW5hYmxlZHRyaWdnZXJzb3VyY2VzbG9hZGluZ2VsZW1lbnRwYXJ0bmVyZmluYWxseXBlcmZlY3RtZWFuaW5nc3lzdGVtc2tlZXBpbmdjdWx0dXJlJnF1b3Q7LGpvdXJuYWxwcm9qZWN0c3VyZmFjZXMmcXVvdDtleHBpcmVzcmV2aWV3c2JhbGFuY2VFbmdsaXNoQ29udGVudHRocm91Z2hQbGVhc2Ugb3BpbmlvbmNvbnRhY3RhdmVyYWdlcHJpbWFyeXZpbGxhZ2VTcGFuaXNoZ2FsbGVyeWRlY2xpbmVtZWV0aW5nbWlzc2lvbnBvcHVsYXJxdWFsaXR5bWVhc3VyZWdlbmVyYWxzcGVjaWVzc2Vzc2lvbnNlY3Rpb253cml0ZXJzY291bnRlcmluaXRpYWxyZXBvcnRzZmlndXJlc21lbWJlcnNob2xkaW5nZGlzcHV0ZWVhcmxpZXJleHByZXNzZGlnaXRhbHBpY3R1cmVBbm90aGVybWFycmllZHRyYWZmaWNsZWFkaW5nY2hhbmdlZGNlbnRyYWx2aWN0b3J5aW1hZ2VzL3JlYXNvbnNzdHVkaWVzZmVhdHVyZWxpc3RpbmdtdXN0IGJlc2Nob29sc1ZlcnNpb251c3VhbGx5ZXBpc29kZXBsYXlpbmdncm93aW5nb2J2aW91c292ZXJsYXlwcmVzZW50YWN0aW9uczwvdWw+DQp3cmFwcGVyYWxyZWFkeWNlcnRhaW5yZWFsaXR5c3RvcmFnZWFub3RoZXJkZXNrdG9wb2ZmZXJlZHBhdHRlcm51bnVzdWFsRGlnaXRhbGNhcGl0YWxXZWJzaXRlZmFpbHVyZWNvbm5lY3RyZWR1Y2VkQW5kcm9pZGRlY2FkZXNyZWd1bGFyICZhbXA7IGFuaW1hbHNyZWxlYXNlQXV0b21hdGdldHRpbmdtZXRob2Rzbm90aGluZ1BvcHVsYXJjYXB0aW9ubGV0dGVyc2NhcHR1cmVzY2llbmNlbGljZW5zZWNoYW5nZXNFbmdsYW5kPTEmYW1wO0hpc3RvcnkgPSBuZXcgQ2VudHJhbHVwZGF0ZWRTcGVjaWFsTmV0d29ya3JlcXVpcmVjb21tZW50d2FybmluZ0NvbGxlZ2V0b29sYmFycmVtYWluc2JlY2F1c2VlbGVjdGVkRGV1dHNjaGZpbmFuY2V3b3JrZXJzcXVpY2tseWJldHdlZW5leGFjdGx5c2V0dGluZ2Rpc2Vhc2VTb2NpZXR5d2VhcG9uc2V4aGliaXQmbHQ7IS0tQ29udHJvbGNsYXNzZXNjb3ZlcmVkb3V0bGluZWF0dGFja3NkZXZpY2VzKHdpbmRvd3B1cnBvc2V0aXRsZT0iTW9iaWxlIGtpbGxpbmdzaG93aW5nSXRhbGlhbmRyb3BwZWRoZWF2aWx5ZWZmZWN0cy0xJ10pOwpjb25maXJtQ3VycmVudGFkdmFuY2VzaGFyaW5nb3BlbmluZ2RyYXdpbmdiaWxsaW9ub3JkZXJlZEdlcm1hbnlyZWxhdGVkPC9mb3JtPmluY2x1ZGV3aGV0aGVyZGVmaW5lZFNjaWVuY2VjYXRhbG9nQXJ0aWNsZWJ1dHRvbnNsYXJnZXN0dW5pZm9ybWpvdXJuZXlzaWRlYmFyQ2hpY2Fnb2hvbGlkYXlHZW5lcmFscGFzc2FnZSwmcXVvdDthbmltYXRlZmVlbGluZ2Fycml2ZWRwYXNzaW5nbmF0dXJhbHJvdWdobHkuCgpUaGUgYnV0IG5vdGRlbnNpdHlCcml0YWluQ2hpbmVzZWxhY2sgb2Z0cmlidXRlSXJlbGFuZCIgZGF0YS1mYWN0b3JzcmVjZWl2ZXRoYXQgaXNMaWJyYXJ5aHVzYmFuZGluIGZhY3RhZmZhaXJzQ2hhcmxlc3JhZGljYWxicm91Z2h0ZmluZGluZ2xhbmRpbmc6bGFuZz0icmV0dXJuIGxlYWRlcnNwbGFubmVkcHJlbWl1bXBhY2thZ2VBbWVyaWNhRWRpdGlvbl0mcXVvdDtNZXNzYWdlbmVlZCB0b3ZhbHVlPSJjb21wbGV4bG9va2luZ3N0YXRpb25iZWxpZXZlc21hbGxlci1tb2JpbGVyZWNvcmRzd2FudCB0b2tpbmQgb2ZGaXJlZm94eW91IGFyZXNpbWlsYXJzdHVkaWVkbWF4aW11bWhlYWRpbmdyYXBpZGx5Y2xpbWF0ZWtpbmdkb21lbWVyZ2VkYW1vdW50c2ZvdW5kZWRwaW9uZWVyZm9ybXVsYWR5bmFzdHlob3cgdG8gU3VwcG9ydHJldmVudWVlY29ub215UmVzdWx0c2Jyb3RoZXJzb2xkaWVybGFyZ2VseWNhbGxpbmcuJnF1b3Q7QWNjb3VudEVkd2FyZCBzZWdtZW50Um9iZXJ0IGVmZm9ydHNQYWNpZmljbGVhcm5lZHVwIHdpdGhoZWlnaHQ6d2UgaGF2ZUFuZ2VsZXNuYXRpb25zX3NlYXJjaGFwcGxpZWRhY3F1aXJlbWFzc2l2ZWdyYW50ZWQ6IGZhbHNldHJlYXRlZGJpZ2dlc3RiZW5lZml0ZHJpdmluZ1N0dWRpZXNtaW5pbXVtcGVyaGFwc21vcm5pbmdzZWxsaW5naXMgdXNlZHJldmVyc2V2YXJpYW50IHJvbGU9Im1pc3NpbmdhY2hpZXZlcHJvbW90ZXN0dWRlbnRzb21lb25lZXh0cmVtZXJlc3RvcmVib3R0b206ZXZvbHZlZGFsbCB0aGVzaXRlbWFwZW5nbGlzaHdheSB0byAgQXVndXN0c3ltYm9sc0NvbXBhbnltYXR0ZXJzbXVzaWNhbGFnYWluc3RzZXJ2aW5nfSkoKTsNCnBheW1lbnR0cm91YmxlY29uY2VwdGNvbXBhcmVwYXJlbnRzcGxheWVyc3JlZ2lvbnNtb25pdG9yICcnVGhlIHdpbm5pbmdleHBsb3JlYWRhcHRlZEdhbGxlcnlwcm9kdWNlYWJpbGl0eWVuaGFuY2VjYXJlZXJzKS4gVGhlIGNvbGxlY3RTZWFyY2ggYW5jaWVudGV4aXN0ZWRmb290ZXIgaGFuZGxlcnByaW50ZWRjb25zb2xlRWFzdGVybmV4cG9ydHN3aW5kb3dzQ2hhbm5lbGlsbGVnYWxuZXV0cmFsc3VnZ2VzdF9oZWFkZXJzaWduaW5nLmh0bWwiPnNldHRsZWR3ZXN0ZXJuY2F1c2luZy13ZWJraXRjbGFpbWVkSnVzdGljZWNoYXB0ZXJ2aWN0aW1zVGhvbWFzIG1vemlsbGFwcm9taXNlcGFydGllc2VkaXRpb25vdXRzaWRlOmZhbHNlLGh1bmRyZWRPbHltcGljX2J1dHRvbmF1dGhvcnNyZWFjaGVkY2hyb25pY2RlbWFuZHNzZWNvbmRzcHJvdGVjdGFkb3B0ZWRwcmVwYXJlbmVpdGhlcmdyZWF0bHlncmVhdGVyb3ZlcmFsbGltcHJvdmVjb21tYW5kc3BlY2lhbHNlYXJjaC53b3JzaGlwZnVuZGluZ3Rob3VnaHRoaWdoZXN0aW5zdGVhZHV0aWxpdHlxdWFydGVyQ3VsdHVyZXRlc3RpbmdjbGVhcmx5ZXhwb3NlZEJyb3dzZXJsaWJlcmFsfSBjYXRjaFByb2plY3RleGFtcGxlaGlkZSgpO0Zsb3JpZGFhbnN3ZXJzYWxsb3dlZEVtcGVyb3JkZWZlbnNlc2VyaW91c2ZyZWVkb21TZXZlcmFsLWJ1dHRvbkZ1cnRoZXJvdXQgb2YgIT0gbnVsbHRyYWluZWREZW5tYXJrdm9pZCgwKS9hbGwuanNwcmV2ZW50UmVxdWVzdFN0ZXBoZW4KCldoZW4gb2JzZXJ2ZTwvaDI+DQpNb2Rlcm4gcHJvdmlkZSIgYWx0PSJib3JkZXJzLgoKRm9yIAoKTWFueSBhcnRpc3RzcG93ZXJlZHBlcmZvcm1maWN0aW9udHlwZSBvZm1lZGljYWx0aWNrZXRzb3Bwb3NlZENvdW5jaWx3aXRuZXNzanVzdGljZUdlb3JnZSBCZWxnaXVtLi4uPC9hPnR3aXR0ZXJub3RhYmx5d2FpdGluZ3dhcmZhcmUgT3RoZXIgcmFua2luZ3BocmFzZXNtZW50aW9uc3Vydml2ZXNjaG9sYXI8L3A+DQogQ291bnRyeWlnbm9yZWRsb3NzIG9manVzdCBhc0dlb3JnaWFzdHJhbmdlPGhlYWQ+PHN0b3BwZWQxJ10pOw0KaXNsYW5kc25vdGFibGVib3JkZXI6bGlzdCBvZmNhcnJpZWQxMDAsMDAwPC9oMz4KIHNldmVyYWxiZWNvbWVzc2VsZWN0IHdlZGRpbmcwMC5odG1sbW9uYXJjaG9mZiB0aGV0ZWFjaGVyaGlnaGx5IGJpb2xvZ3lsaWZlIG9mb3IgZXZlbnJpc2Ugb2YmcmFxdW87cGx1c29uZWh1bnRpbmcodGhvdWdoRG91Z2xhc2pvaW5pbmdjaXJjbGVzRm9yIHRoZUFuY2llbnRWaWV0bmFtdmVoaWNsZXN1Y2ggYXNjcnlzdGFsdmFsdWUgPVdpbmRvd3NlbmpveWVkYSBzbWFsbGFzc3VtZWQ8YSBpZD0iZm9yZWlnbiBBbGwgcmlob3cgdGhlRGlzcGxheXJldGlyZWRob3dldmVyaGlkZGVuO2JhdHRsZXNzZWVraW5nY2FiaW5ldHdhcyBub3Rsb29rIGF0Y29uZHVjdGdldCB0aGVKYW51YXJ5aGFwcGVuc3R1cm5pbmdhOmhvdmVyT25saW5lIEZyZW5jaCBsYWNraW5ndHlwaWNhbGV4dHJhY3RlbmVtaWVzZXZlbiBpZmdlbmVyYXRkZWNpZGVkYXJlIG5vdC9zZWFyY2hiZWxpZWZzLWltYWdlOmxvY2F0ZWRzdGF0aWMubG9naW4iPmNvbnZlcnR2aW9sZW50ZW50ZXJlZGZpcnN0Ij5jaXJjdWl0RmlubGFuZGNoZW1pc3RzaGUgd2FzMTBweDsiPmFzIHN1Y2hkaXZpZGVkPC9zcGFuPndpbGwgYmVsaW5lIG9mYSBncmVhdG15c3RlcnkvaW5kZXguZmFsbGluZ2R1ZSB0byByYWlsd2F5Y29sbGVnZW1vbnN0ZXJkZXNjZW50aXQgd2l0aG51Y2xlYXJKZXdpc2ggcHJvdGVzdEJyaXRpc2hmbG93ZXJzcHJlZGljdHJlZm9ybXNidXR0b24gd2hvIHdhc2xlY3R1cmVpbnN0YW50c3VpY2lkZWdlbmVyaWNwZXJpb2RzbWFya2V0c1NvY2lhbCBmaXNoaW5nY29tYmluZWdyYXBoaWN3aW5uZXJzPGJyIC8+PGJ5IHRoZSBOYXR1cmFsUHJpdmFjeWNvb2tpZXNvdXRjb21lcmVzb2x2ZVN3ZWRpc2hicmllZmx5UGVyc2lhbnNvIG11Y2hDZW50dXJ5ZGVwaWN0c2NvbHVtbnNob3VzaW5nc2NyaXB0c25leHQgdG9iZWFyaW5nbWFwcGluZ3JldmlzZWRqUXVlcnkoLXdpZHRoOnRpdGxlIj50b29sdGlwU2VjdGlvbmRlc2lnbnNUdXJraXNoeW91bmdlci5tYXRjaCh9KSgpOwoKYnVybmluZ29wZXJhdGVkZWdyZWVzc291cmNlPVJpY2hhcmRjbG9zZWx5cGxhc3RpY2VudHJpZXM8L3RyPg0KY29sb3I6I3VsIGlkPSJwb3NzZXNzcm9sbGluZ3BoeXNpY3NmYWlsaW5nZXhlY3V0ZWNvbnRlc3RsaW5rIHRvRGVmYXVsdDxiciAvPgo6IHRydWUsY2hhcnRlcnRvdXJpc21jbGFzc2ljcHJvY2VlZGV4cGxhaW48L2gxPg0Kb25saW5lLj94bWwgdmVoZWxwaW5nZGlhbW9uZHVzZSB0aGVhaXJsaW5lZW5kIC0tPikuYXR0cihyZWFkZXJzaG9zdGluZyNmZmZmZmZyZWFsaXplVmluY2VudHNpZ25hbHMgc3JjPSIvUHJvZHVjdGRlc3BpdGVkaXZlcnNldGVsbGluZ1B1YmxpYyBoZWxkIGluSm9zZXBoIHRoZWF0cmVhZmZlY3RzPHN0eWxlPmEgbGFyZ2Vkb2Vzbid0bGF0ZXIsIEVsZW1lbnRmYXZpY29uY3JlYXRvckh1bmdhcnlBaXJwb3J0c2VlIHRoZXNvIHRoYXRNaWNoYWVsU3lzdGVtc1Byb2dyYW1zLCBhbmQgIHdpZHRoPWUmcXVvdDt0cmFkaW5nbGVmdCI+CnBlcnNvbnNHb2xkZW4gQWZmYWlyc2dyYW1tYXJmb3JtaW5nZGVzdHJveWlkZWEgb2ZjYXNlIG9mb2xkZXN0IHRoaXMgaXMuc3JjID0gY2FydG9vbnJlZ2lzdHJDb21tb25zTXVzbGltc1doYXQgaXNpbiBtYW55bWFya2luZ3JldmVhbHNJbmRlZWQsZXF1YWxseS9zaG93X2FvdXRkb29yZXNjYXBlKEF1c3RyaWFnZW5ldGljc3lzdGVtLEluIHRoZSBzaXR0aW5nSGUgYWxzb0lzbGFuZHNBY2FkZW15CgkJPCEtLURhbmllbCBiaW5kaW5nYmxvY2siPmltcG9zZWR1dGlsaXplQWJyYWhhbShleGNlcHR7d2lkdGg6cHV0dGluZykuaHRtbCh8fCBbXTsKREFUQVsgKmtpdGNoZW5tb3VudGVkYWN0dWFsIGRpYWxlY3RtYWlubHkgX2JsYW5rJ2luc3RhbGxleHBlcnRzaWYodHlwZUl0IGFsc28mY29weTsgIj5UZXJtc2Jvcm4gaW5PcHRpb25zZWFzdGVybnRhbGtpbmdjb25jZXJuZ2FpbmVkIG9uZ29pbmdqdXN0aWZ5Y3JpdGljc2ZhY3RvcnlpdHMgb3duYXNzYXVsdGludml0ZWRsYXN0aW5naGlzIG93bmhyZWY9Ii8iIHJlbD0iZGV2ZWxvcGNvbmNlcnRkaWFncmFtZG9sbGFyc2NsdXN0ZXJwaHA/aWQ9YWxjb2hvbCk7fSkoKTt1c2luZyBhPjxzcGFuPnZlc3NlbHNyZXZpdmFsQWRkcmVzc2FtYXRldXJhbmRyb2lkYWxsZWdlZGlsbG5lc3N3YWxraW5nY2VudGVyc3F1YWxpZnltYXRjaGVzdW5pZmllZGV4dGluY3REZWZlbnNlZGllZCBpbgoJPCEtLSBjdXN0b21zbGlua2luZ0xpdHRsZSBCb29rIG9mZXZlbmluZ21pbi5qcz9hcmUgdGhla29udGFrdHRvZGF5J3MuaHRtbCIgdGFyZ2V0PXdlYXJpbmdBbGwgUmlnOwp9KSgpO3JhaXNpbmcgQWxzbywgY3J1Y2lhbGFib3V0Ij5kZWNsYXJlLS0+CjxzY2ZpcmVmb3hhcyBtdWNoYXBwbGllc2luZGV4LCBzLCBidXQgdHlwZSA9IAoNCjwhLS10b3dhcmRzUmVjb3Jkc1ByaXZhdGVGb3JlaWduUHJlbWllcmNob2ljZXNWaXJ0dWFscmV0dXJuc0NvbW1lbnRQb3dlcmVkaW5saW5lO3BvdmVydHljaGFtYmVyTGl2aW5nIHZvbHVtZXNBbnRob255bG9naW4iIFJlbGF0ZWRFY29ub215cmVhY2hlc2N1dHRpbmdncmF2aXR5bGlmZSBpbkNoYXB0ZXItc2hhZG93Tm90YWJsZTwvdGQ+DQogcmV0dXJuc3RhZGl1bXdpZGdldHN2YXJ5aW5ndHJhdmVsc2hlbGQgYnl3aG8gYXJld29yayBpbmZhY3VsdHlhbmd1bGFyd2hvIGhhZGFpcnBvcnR0b3duIG9mCgpTb21lICdjbGljaydjaGFyZ2Vza2V5d29yZGl0IHdpbGxjaXR5IG9mKHRoaXMpO0FuZHJldyB1bmlxdWUgY2hlY2tlZG9yIG1vcmUzMDBweDsgcmV0dXJuO3JzaW9uPSJwbHVnaW5zd2l0aGluIGhlcnNlbGZTdGF0aW9uRmVkZXJhbHZlbnR1cmVwdWJsaXNoc2VudCB0b3RlbnNpb25hY3RyZXNzY29tZSB0b2ZpbmdlcnNEdWtlIG9mcGVvcGxlLGV4cGxvaXR3aGF0IGlzaGFybW9ueWEgbWFqb3IiOiJodHRwaW4gaGlzIG1lbnUiPgptb250aGx5b2ZmaWNlcmNvdW5jaWxnYWluaW5nZXZlbiBpblN1bW1hcnlkYXRlIG9mbG95YWx0eWZpdG5lc3NhbmQgd2FzZW1wZXJvcnN1cHJlbWVTZWNvbmQgaGVhcmluZ1J1c3NpYW5sb25nZXN0QWxiZXJ0YWxhdGVyYWxzZXQgb2Ygc21hbGwiPi5hcHBlbmRkbyB3aXRoZmVkZXJhbGJhbmsgb2ZiZW5lYXRoRGVzcGl0ZUNhcGl0YWxncm91bmRzKSwgYW5kIHBlcmNlbnRpdCBmcm9tY2xvc2luZ2NvbnRhaW5JbnN0ZWFkZmlmdGVlbmFzIHdlbGwueWFob28ucmVzcG9uZGZpZ2h0ZXJvYnNjdXJlcmVmbGVjdG9yZ2FuaWM9IE1hdGguZWRpdGluZ29ubGluZSBwYWRkaW5nYSB3aG9sZW9uZXJyb3J5ZWFyIG9mZW5kIG9mIGJhcnJpZXJ3aGVuIGl0aGVhZGVyIGhvbWUgb2ZyZXN1bWVkcmVuYW1lZHN0cm9uZz5oZWF0aW5ncmV0YWluc2Nsb3VkZnJ3YXkgb2YgTWFyY2ggMWtub3dpbmdpbiBwYXJ0QmV0d2Vlbmxlc3NvbnNjbG9zZXN0dmlydHVhbGxpbmtzIj5jcm9zc2VkRU5EIC0tPmZhbW91cyBhd2FyZGVkTGljZW5zZUhlYWx0aCBmYWlybHkgd2VhbHRoeW1pbmltYWxBZnJpY2FuY29tcGV0ZWxhYmVsIj5zaW5naW5nZmFybWVyc0JyYXNpbClkaXNjdXNzcmVwbGFjZUdyZWdvcnlmb250IGNvcHVyc3VlZGFwcGVhcnNtYWtlIHVwcm91bmRlZGJvdGggb2ZibG9ja2Vkc2F3IHRoZW9mZmljZXNjb2xvdXJzaWYoZG9jdXdoZW4gaGVlbmZvcmNlcHVzaChmdUF1Z3VzdCBVVEYtOCI+RmFudGFzeWluIG1vc3Rpbmp1cmVkVXN1YWxseWZhcm1pbmdjbG9zdXJlb2JqZWN0IGRlZmVuY2V1c2Ugb2YgTWVkaWNhbDxib2R5PgpldmlkZW50YmUgdXNlZGtleUNvZGVzaXh0ZWVuSXNsYW1pYyMwMDAwMDBlbnRpcmUgd2lkZWx5IGFjdGl2ZSAodHlwZW9mb25lIGNhbmNvbG9yID1zcGVha2VyZXh0ZW5kc1BoeXNpY3N0ZXJyYWluPHRib2R5PmZ1bmVyYWx2aWV3aW5nbWlkZGxlIGNyaWNrZXRwcm9waGV0c2hpZnRlZGRvY3RvcnNSdXNzZWxsIHRhcmdldGNvbXBhY3RhbGdlYnJhc29jaWFsLWJ1bGsgb2ZtYW4gYW5kPC90ZD4KIGhlIGxlZnQpLnZhbCgpZmFsc2UpO2xvZ2ljYWxiYW5raW5naG9tZSB0b25hbWluZyBBcml6b25hY3JlZGl0cyk7Cn0pOwpmb3VuZGVyaW4gdHVybkNvbGxpbnNiZWZvcmUgQnV0IHRoZWNoYXJnZWRUaXRsZSI+Q2FwdGFpbnNwZWxsZWRnb2RkZXNzVGFnIC0tPkFkZGluZzpidXQgd2FzUmVjZW50IHBhdGllbnRiYWNrIGluPWZhbHNlJkxpbmNvbG53ZSBrbm93Q291bnRlckp1ZGFpc21zY3JpcHQgYWx0ZXJlZCddKTsKICBoYXMgdGhldW5jbGVhckV2ZW50Jyxib3RoIGlubm90IGFsbAoKPCEtLSBwbGFjaW5naGFyZCB0byBjZW50ZXJzb3J0IG9mY2xpZW50c3N0cmVldHNCZXJuYXJkYXNzZXJ0c3RlbmQgdG9mYW50YXN5ZG93biBpbmhhcmJvdXJGcmVlZG9tamV3ZWxyeS9hYm91dC4uc2VhcmNobGVnZW5kc2lzIG1hZGVtb2Rlcm4gb25seSBvbm9ubHkgdG9pbWFnZSIgbGluZWFyIHBhaW50ZXJhbmQgbm90cmFyZWx5IGFjcm9ueW1kZWxpdmVyc2hvcnRlcjAwJmFtcDthcyBtYW55d2lkdGg9Ii8qIDwhW0N0aXRsZSA9b2YgdGhlIGxvd2VzdCBwaWNrZWQgZXNjYXBlZHVzZXMgb2ZwZW9wbGVzIFB1YmxpY01hdHRoZXd0YWN0aWNzZGFtYWdlZHdheSBmb3JsYXdzIG9mZWFzeSB0byB3aW5kb3dzdHJvbmcgIHNpbXBsZX1jYXRjaChzZXZlbnRoaW5mb2JveHdlbnQgdG9wYWludGVkY2l0aXplbkkgZG9uJ3RyZXRyZWF0LiBTb21lIHd3LiIpOwpib21iaW5nbWFpbHRvOm1hZGUgaW4uIE1hbnkgY2Fycmllc3x8e307d2l3b3JrIG9mc3lub255bWRlZmVhdHNmYXZvcmVkb3B0aWNhbHBhZ2VUcmF1bmxlc3Mgc2VuZGluZ2xlZnQiPjxjb21TY29yQWxsIHRoZWpRdWVyeS50b3VyaXN0Q2xhc3NpY2ZhbHNlIiBXaWxoZWxtc3VidXJic2dlbnVpbmViaXNob3BzLnNwbGl0KGdsb2JhbCBmb2xsb3dzYm9keSBvZm5vbWluYWxDb250YWN0c2VjdWxhcmxlZnQgdG9jaGllZmx5LWhpZGRlbi1iYW5uZXI8L2xpPgoKLiBXaGVuIGluIGJvdGhkaXNtaXNzRXhwbG9yZWFsd2F5cyB2aWEgdGhlc3Bhw7FvbHdlbGZhcmVydWxpbmcgYXJyYW5nZWNhcHRhaW5oaXMgc29ucnVsZSBvZmhlIHRvb2tpdHNlbGYsPTAmYW1wOyhjYWxsZWRzYW1wbGVzdG8gbWFrZWNvbS9wYWdNYXJ0aW4gS2VubmVkeWFjY2VwdHNmdWxsIG9maGFuZGxlZEJlc2lkZXMvLy0tPjwvYWJsZSB0b3RhcmdldHNlc3NlbmNlaGltIHRvIGl0cyBieSBjb21tb24ubWluZXJhbHRvIHRha2V3YXlzIHRvcy5vcmcvbGFkdmlzZWRwZW5hbHR5c2ltcGxlOmlmIHRoZXlMZXR0ZXJzYSBzaG9ydEhlcmJlcnRzdHJpa2VzIGdyb3Vwcy5sZW5ndGhmbGlnaHRzb3ZlcmxhcHNsb3dseSBsZXNzZXIgc29jaWFsIDwvcD4KCQlpdCBpbnRvcmFua2VkIHJhdGUgb2Z1bD4NCiAgYXR0ZW1wdHBhaXIgb2ZtYWtlIGl0S29udGFrdEFudG9uaW9oYXZpbmcgcmF0aW5ncyBhY3RpdmVzdHJlYW1zdHJhcHBlZCIpLmNzcyhob3N0aWxlbGVhZCB0b2xpdHRsZSBncm91cHMsUGljdHVyZS0tPg0KDQogcm93cz0iIG9iamVjdGludmVyc2U8Zm9vdGVyQ3VzdG9tVj48XC9zY3Jzb2x2aW5nQ2hhbWJlcnNsYXZlcnl3b3VuZGVkd2hlcmVhcyE9ICd1bmRmb3IgYWxscGFydGx5IC1yaWdodDpBcmFiaWFuYmFja2VkIGNlbnR1cnl1bml0IG9mbW9iaWxlLUV1cm9wZSxpcyBob21lcmlzayBvZmRlc2lyZWRDbGludG9uY29zdCBvZmFnZSBvZiBiZWNvbWUgbm9uZSBvZnAmcXVvdDtNaWRkbGUgZWFkJylbMENyaXRpY3NzdHVkaW9zPiZjb3B5O2dyb3VwIj5hc3NlbWJsbWFraW5nIHByZXNzZWR3aWRnZXQucHM6IiA/IHJlYnVpbHRieSBzb21lRm9ybWVyIGVkaXRvcnNkZWxheWVkQ2Fub25pY2hhZCB0aGVwdXNoaW5nY2xhc3M9ImJ1dCBhcmVwYXJ0aWFsQmFieWxvbmJvdHRvbSBjYXJyaWVyQ29tbWFuZGl0cyB1c2VBcyB3aXRoY291cnNlc2EgdGhpcmRkZW5vdGVzYWxzbyBpbkhvdXN0b24yMHB4OyI+YWNjdXNlZGRvdWJsZSBnb2FsIG9mRmFtb3VzICkuYmluZChwcmllc3RzIE9ubGluZWluIEp1bHlzdCArICJnY29uc3VsdGRlY2ltYWxoZWxwZnVscmV2aXZlZGlzIHZlcnlyJysnaXB0bG9zaW5nIGZlbWFsZXNpcyBhbHNvc3RyaW5nc2RheXMgb2ZhcnJpdmFsZnV0dXJlIDxvYmplY3Rmb3JjaW5nU3RyaW5nKCIgLz4KCQloZXJlIGlzZW5jb2RlZC4gIFRoZSBiYWxsb29uZG9uZSBieS9jb21tb25iZ2NvbG9ybGF3IG9mIEluZGlhbmFhdm9pZGVkYnV0IHRoZTJweCAzcHhqcXVlcnkuYWZ0ZXIgYXBvbGljeS5tZW4gYW5kZm9vdGVyLT0gdHJ1ZTtmb3IgdXNlc2NyZWVuLkluZGlhbiBpbWFnZSA9ZmFtaWx5LGh0dHA6Ly8gJm5ic3A7ZHJpdmVyc2V0ZXJuYWxzYW1lIGFzbm90aWNlZHZpZXdlcnN9KSgpOwogaXMgbW9yZXNlYXNvbnNmb3JtZXIgdGhlIG5ld2lzIGp1c3Rjb25zZW50IFNlYXJjaHdhcyB0aGV3aHkgdGhlc2hpcHBlZGJyPjxicj53aWR0aDogaGVpZ2h0PW1hZGUgb2ZjdWlzaW5laXMgdGhhdGEgdmVyeSBBZG1pcmFsIGZpeGVkO25vcm1hbCBNaXNzaW9uUHJlc3MsIG9udGFyaW9jaGFyc2V0dHJ5IHRvIGludmFkZWQ9InRydWUic3BhY2luZ2lzIG1vc3RhIG1vcmUgdG90YWxseWZhbGwgb2Z9KTsNCiAgaW1tZW5zZXRpbWUgaW5zZXQgb3V0c2F0aXNmeXRvIGZpbmRkb3duIHRvbG90IG9mIFBsYXllcnNpbiBKdW5lcXVhbnR1bW5vdCB0aGV0aW1lIHRvZGlzdGFudEZpbm5pc2hzcmMgPSAoc2luZ2xlIGhlbHAgb2ZHZXJtYW4gbGF3IGFuZGxhYmVsZWRmb3Jlc3RzY29va2luZ3NwYWNlIj5oZWFkZXItd2VsbCBhc1N0YW5sZXlicmlkZ2VzL2dsb2JhbENyb2F0aWEgQWJvdXQgWzBdOwogIGl0LCBhbmRncm91cGVkYmVpbmcgYSl7dGhyb3doZSBtYWRlbGlnaHRlcmV0aGljYWxGRkZGRkYiYm90dG9tImxpa2UgYSBlbXBsb3lzbGl2ZSBpbmFzIHNlZW5wcmludGVybW9zdCBvZnViLWxpbmtyZWplY3RzYW5kIHVzZWltYWdlIj5zdWNjZWVkZmVlZGluZ051Y2xlYXJpbmZvcm1hdG8gaGVscFdvbWVuJ3NOZWl0aGVyTWV4aWNhbnByb3RlaW48dGFibGUgYnkgbWFueWhlYWx0aHlsYXdzdWl0ZGV2aXNlZC5wdXNoKHtzZWxsZXJzc2ltcGx5IFRocm91Z2guY29va2llIEltYWdlKG9sZGVyIj51cy5qcyI+IFNpbmNlIHVuaXZlcnNsYXJnZXIgb3BlbiB0byEtLSBlbmRsaWVzIGluJ10pOw0KICBtYXJrZXR3aG8gaXMgKCJET01Db21hbmFnZWRvbmUgZm9ydHlwZW9mIEtpbmdkb21wcm9maXRzcHJvcG9zZXRvIHNob3djZW50ZXI7bWFkZSBpdGRyZXNzZWR3ZXJlIGlubWl4dHVyZXByZWNpc2VhcmlzaW5nc3JjID0gJ21ha2UgYSBzZWN1cmVkQmFwdGlzdHZvdGluZyAKCQl2YXIgTWFyY2ggMmdyZXcgdXBDbGltYXRlLnJlbW92ZXNraWxsZWR3YXkgdGhlPC9oZWFkPmZhY2Ugb2ZhY3RpbmcgcmlnaHQiPnRvIHdvcmtyZWR1Y2VzaGFzIGhhZGVyZWN0ZWRzaG93KCk7YWN0aW9uPWJvb2sgb2ZhbiBhcmVhPT0gImh0dDxoZWFkZXIKPGh0bWw+Y29uZm9ybWZhY2luZyBjb29raWUucmVseSBvbmhvc3RlZCAuY3VzdG9taGUgd2VudGJ1dCBmb3JzcHJlYWQgRmFtaWx5IGEgbWVhbnNvdXQgdGhlZm9ydW1zLmZvb3RhZ2UiPk1vYmlsQ2xlbWVudHMiIGlkPSJhcyBoaWdoaW50ZW5zZS0tPjwhLS1mZW1hbGUgaXMgc2VlbmltcGxpZWRzZXQgdGhlYSBzdGF0ZWFuZCBoaXNmYXN0ZXN0YmVzaWRlc2J1dHRvbl9ib3VuZGVkIj48aW1nIEluZm9ib3hldmVudHMsYSB5b3VuZ2FuZCBhcmVOYXRpdmUgY2hlYXBlclRpbWVvdXRhbmQgaGFzZW5naW5lc3dvbiB0aGUobW9zdGx5cmlnaHQ6IGZpbmQgYSAtYm90dG9tUHJpbmNlIGFyZWEgb2Ztb3JlIG9mc2VhcmNoX25hdHVyZSxsZWdhbGx5cGVyaW9kLGxhbmQgb2ZvciB3aXRoaW5kdWNlZHByb3ZpbmdtaXNzaWxlbG9jYWxseUFnYWluc3R0aGUgd2F5ayZxdW90O3B4OyI+DQpwdXNoZWQgYWJhbmRvbm51bWVyYWxDZXJ0YWluSW4gdGhpc21vcmUgaW5vciBzb21lbmFtZSBpc2FuZCwgaW5jcm93bmVkSVNCTiAwLWNyZWF0ZXNPY3RvYmVybWF5IG5vdGNlbnRlciBsYXRlIGluRGVmZW5jZWVuYWN0ZWR3aXNoIHRvYnJvYWRseWNvb2xpbmdvbmxvYWQ9aXQuIFRoZXJlY292ZXJNZW1iZXJzaGVpZ2h0IGFzc3VtZXM8aHRtbD4KcGVvcGxlLmluIG9uZSA9d2luZG93Zm9vdGVyX2EgZ29vZCByZWtsYW1hb3RoZXJzLHRvIHRoaXNfY29va2llcGFuZWwiPkxvbmRvbixkZWZpbmVzY3J1c2hlZGJhcHRpc21jb2FzdGFsc3RhdHVzIHRpdGxlIiBtb3ZlIHRvbG9zdCBpbmJldHRlciBpbXBsaWVzcml2YWxyeXNlcnZlcnMgU3lzdGVtUGVyaGFwc2VzIGFuZCBjb250ZW5kZmxvd2luZ2xhc3RlZCByaXNlIGluR2VuZXNpc3ZpZXcgb2ZyaXNpbmcgc2VlbSB0b2J1dCBpbiBiYWNraW5naGUgd2lsbGdpdmVuIGFnaXZpbmcgY2l0aWVzLmZsb3cgb2YgTGF0ZXIgYWxsIGJ1dEhpZ2h3YXlvbmx5IGJ5c2lnbiBvZmhlIGRvZXNkaWZmZXJzYmF0dGVyeSZhbXA7bGFzaW5nbGVzdGhyZWF0c2ludGVnZXJ0YWtlIG9ucmVmdXNlZGNhbGxlZCA9VVMmYW1wU2VlIHRoZW5hdGl2ZXNieSB0aGlzc3lzdGVtLmhlYWQgb2Y6aG92ZXIsbGVzYmlhbnN1cm5hbWVhbmQgYWxsY29tbW9uL2hlYWRlcl9fcGFyYW1zSGFydmFyZC9waXhlbC5yZW1vdmFsc28gbG9uZ3JvbGUgb2Zqb2ludGx5c2t5c2NyYVVuaWNvZGViciAvPg0KQXRsYW50YW51Y2xldXNDb3VudHkscHVyZWx5IGNvdW50Ij5lYXNpbHkgYnVpbGQgYW9uY2xpY2thIGdpdmVucG9pbnRlcmgmcXVvdDtldmVudHMgZWxzZSB7CmRpdGlvbnNub3cgdGhlLCB3aXRoIG1hbiB3aG9vcmcvV2Vib25lIGFuZGNhdmFscnlIZSBkaWVkc2VhdHRsZTAwLDAwMCB7d2luZG93aGF2ZSB0b2lmKHdpbmRhbmQgaXRzc29sZWx5IG0mcXVvdDtyZW5ld2VkRGV0cm9pdGFtb25nc3RlaXRoZXIgdGhlbSBpblNlbmF0b3JVczwvYT48S2luZyBvZkZyYW5jaXMtcHJvZHVjaGUgdXNlZGFydCBhbmRoaW0gYW5kdXNlZCBieXNjb3JpbmdhdCBob21ldG8gaGF2ZXJlbGF0ZXNpYmlsaXR5ZmFjdGlvbkJ1ZmZhbG9saW5rIj48d2hhdCBoZWZyZWUgdG9DaXR5IG9mY29tZSBpbnNlY3RvcnNjb3VudGVkb25lIGRheW5lcnZvdXNzcXVhcmUgfTtpZihnb2luIHdoYXRpbWciIGFsaXMgb25seXNlYXJjaC90dWVzZGF5bG9vc2VseVNvbG9tb25zZXh1YWwgLSA8YSBocm1lZGl1bSJETyBOT1QgRnJhbmNlLHdpdGggYSB3YXIgYW5kc2Vjb25kIHRha2UgYSA+DQoNCg0KbWFya2V0LmhpZ2h3YXlkb25lIGluY3Rpdml0eSJsYXN0Ij5vYmxpZ2VkcmlzZSB0byJ1bmRlZmltYWRlIHRvIEVhcmx5IHByYWlzZWRpbiBpdHMgZm9yIGhpc2F0aGxldGVKdXBpdGVyWWFob28hIHRlcm1lZCBzbyBtYW55cmVhbGx5IHMuIFRoZSBhIHdvbWFuP3ZhbHVlPWRpcmVjdCByaWdodCIgYmljeWNsZWFjaW5nPSJkYXkgYW5kc3RhdGluZ1JhdGhlcixoaWdoZXIgT2ZmaWNlIGFyZSBub3d0aW1lcywgd2hlbiBhIHBheSBmb3JvbiB0aGlzLWxpbmsiPjtib3JkZXJhcm91bmQgYW5udWFsIHRoZSBOZXdwdXQgdGhlLmNvbSIgdGFraW4gdG9hIGJyaWVmKGluIHRoZWdyb3Vwcy47IHdpZHRoZW56eW1lc3NpbXBsZSBpbiBsYXRle3JldHVybnRoZXJhcHlhIHBvaW50YmFubmluZ2lua3MiPgooKTsiIHJlYSBwbGFjZVx1MDAzQ2FhYm91dCBhdHI+DQoJCWNjb3VudCBnaXZlcyBhPFNDUklQVFJhaWx3YXl0aGVtZXMvdG9vbGJveEJ5SWQoInhodW1hbnMsd2F0Y2hlc2luIHNvbWUgaWYgKHdpY29taW5nIGZvcm1hdHMgVW5kZXIgYnV0IGhhc2hhbmRlZCBtYWRlIGJ5dGhhbiBpbmZlYXIgb2ZkZW5vdGVkL2lmcmFtZWxlZnQgaW52b2x0YWdlaW4gZWFjaGEmcXVvdDtiYXNlIG9mSW4gbWFueXVuZGVyZ29yZWdpbWVzYWN0aW9uIDwvcD4NCjx1c3RvbVZhOyZndDs8L2ltcG9ydHNvciB0aGF0bW9zdGx5ICZhbXA7cmUgc2l6ZT0iPC9hPjwvaGEgY2xhc3NwYXNzaXZlSG9zdCA9IFdoZXRoZXJmZXJ0aWxlVmFyaW91cz1bXTsoZnVjYW1lcmFzLz48L3RkPmFjdHMgYXNJbiBzb21lPg0KDQo8IW9yZ2FuaXMgPGJyIC8+QmVpamluZ2NhdGFsw6BkZXV0c2NoZXVyb3BldWV1c2thcmFnYWVpbGdlc3ZlbnNrYWVzcGHDsWFtZW5zYWpldXN1YXJpb3RyYWJham9tw6l4aWNvcMOhZ2luYXNpZW1wcmVzaXN0ZW1hb2N0dWJyZWR1cmFudGVhw7FhZGlyZW1wcmVzYW1vbWVudG9udWVzdHJvcHJpbWVyYXRyYXbDqXNncmFjaWFzbnVlc3RyYXByb2Nlc29lc3RhZG9zY2FsaWRhZHBlcnNvbmFuw7ptZXJvYWN1ZXJkb23DunNpY2FtaWVtYnJvb2ZlcnRhc2FsZ3Vub3NwYcOtc2VzZWplbXBsb2RlcmVjaG9hZGVtw6FzcHJpdmFkb2FncmVnYXJlbmxhY2VzcG9zaWJsZWhvdGVsZXNzZXZpbGxhcHJpbWVyb8O6bHRpbW9ldmVudG9zYXJjaGl2b2N1bHR1cmFtdWplcmVzZW50cmFkYWFudW5jaW9lbWJhcmdvbWVyY2Fkb2dyYW5kZXNlc3R1ZGlvbWVqb3Jlc2ZlYnJlcm9kaXNlw7FvdHVyaXNtb2PDs2RpZ29wb3J0YWRhZXNwYWNpb2ZhbWlsaWFhbnRvbmlvcGVybWl0ZWd1YXJkYXJhbGd1bmFzcHJlY2lvc2FsZ3VpZW5zZW50aWRvdmlzaXRhc3TDrXR1bG9jb25vY2Vyc2VndW5kb2NvbnNlam9mcmFuY2lhbWludXRvc3NlZ3VuZGF0ZW5lbW9zZWZlY3Rvc23DoWxhZ2FzZXNpw7NucmV2aXN0YWdyYW5hZGFjb21wcmFyaW5ncmVzb2dhcmPDrWFhY2Npw7NuZWN1YWRvcnF1aWVuZXNpbmNsdXNvZGViZXLDoW1hdGVyaWFob21icmVzbXVlc3RyYXBvZHLDrWFtYcOxYW5hw7psdGltYWVzdGFtb3NvZmljaWFsdGFtYmllbm5pbmfDum5zYWx1ZG9zcG9kZW1vc21lam9yYXJwb3NpdGlvbmJ1c2luZXNzaG9tZXBhZ2VzZWN1cml0eWxhbmd1YWdlc3RhbmRhcmRjYW1wYWlnbmZlYXR1cmVzY2F0ZWdvcnlleHRlcm5hbGNoaWxkcmVucmVzZXJ2ZWRyZXNlYXJjaGV4Y2hhbmdlZmF2b3JpdGV0ZW1wbGF0ZW1pbGl0YXJ5aW5kdXN0cnlzZXJ2aWNlc21hdGVyaWFscHJvZHVjdHN6LWluZGV4OmNvbW1lbnRzc29mdHdhcmVjb21wbGV0ZWNhbGVuZGFycGxhdGZvcm1hcnRpY2xlc3JlcXVpcmVkbW92ZW1lbnRxdWVzdGlvbmJ1aWxkaW5ncG9saXRpY3Nwb3NzaWJsZXJlbGlnaW9ucGh5c2ljYWxmZWVkYmFja3JlZ2lzdGVycGljdHVyZXNkaXNhYmxlZHByb3RvY29sYXVkaWVuY2VzZXR0aW5nc2FjdGl2aXR5ZWxlbWVudHNsZWFybmluZ2FueXRoaW5nYWJzdHJhY3Rwcm9ncmVzc292ZXJ2aWV3bWFnYXppbmVlY29ub21pY3RyYWluaW5ncHJlc3N1cmV2YXJpb3VzIDxzdHJvbmc+cHJvcGVydHlzaG9wcGluZ3RvZ2V0aGVyYWR2YW5jZWRiZWhhdmlvcmRvd25sb2FkZmVhdHVyZWRmb290YmFsbHNlbGVjdGVkTGFuZ3VhZ2VkaXN0YW5jZXJlbWVtYmVydHJhY2tpbmdwYXNzd29yZG1vZGlmaWVkc3R1ZGVudHNkaXJlY3RseWZpZ2h0aW5nbm9ydGhlcm5kYXRhYmFzZWZlc3RpdmFsYnJlYWtpbmdsb2NhdGlvbmludGVybmV0ZHJvcGRvd25wcmFjdGljZWV2aWRlbmNlZnVuY3Rpb25tYXJyaWFnZXJlc3BvbnNlcHJvYmxlbXNuZWdhdGl2ZXByb2dyYW1zYW5hbHlzaXNyZWxlYXNlZGJhbm5lciI+cHVyY2hhc2Vwb2xpY2llc3JlZ2lvbmFsY3JlYXRpdmVhcmd1bWVudGJvb2ttYXJrcmVmZXJyZXJjaGVtaWNhbGRpdmlzaW9uY2FsbGJhY2tzZXBhcmF0ZXByb2plY3RzY29uZmxpY3RoYXJkd2FyZWludGVyZXN0ZGVsaXZlcnltb3VudGFpbm9idGFpbmVkPSBmYWxzZTtmb3IodmFyIGFjY2VwdGVkY2FwYWNpdHljb21wdXRlcmlkZW50aXR5YWlyY3JhZnRlbXBsb3llZHByb3Bvc2VkZG9tZXN0aWNpbmNsdWRlc3Byb3ZpZGVkaG9zcGl0YWx2ZXJ0aWNhbGNvbGxhcHNlYXBwcm9hY2hwYXJ0bmVyc2xvZ28iPjxhZGF1Z2h0ZXJhdXRob3IiIGN1bHR1cmFsZmFtaWxpZXMvaW1hZ2VzL2Fzc2VtYmx5cG93ZXJmdWx0ZWFjaGluZ2ZpbmlzaGVkZGlzdHJpY3Rjcml0aWNhbGNnaS1iaW4vcHVycG9zZXNyZXF1aXJlc2VsZWN0aW9uYmVjb21pbmdwcm92aWRlc2FjYWRlbWljZXhlcmNpc2VhY3R1YWxseW1lZGljaW5lY29uc3RhbnRhY2NpZGVudE1hZ2F6aW5lZG9jdW1lbnRzdGFydGluZ2JvdHRvbSI+b2JzZXJ2ZWQ6ICZxdW90O2V4dGVuZGVkcHJldmlvdXNTb2Z0d2FyZWN1c3RvbWVyZGVjaXNpb25zdHJlbmd0aGRldGFpbGVkc2xpZ2h0bHlwbGFubmluZ3RleHRhcmVhY3VycmVuY3lldmVyeW9uZXN0cmFpZ2h0dHJhbnNmZXJwb3NpdGl2ZXByb2R1Y2VkaGVyaXRhZ2VzaGlwcGluZ2Fic29sdXRlcmVjZWl2ZWRyZWxldmFudGJ1dHRvbiIgdmlvbGVuY2Vhbnl3aGVyZWJlbmVmaXRzbGF1bmNoZWRyZWNlbnRseWFsbGlhbmNlZm9sbG93ZWRtdWx0aXBsZWJ1bGxldGluaW5jbHVkZWRvY2N1cnJlZGludGVybmFsJCh0aGlzKS5yZXB1YmxpYz48dHI+PHRkY29uZ3Jlc3NyZWNvcmRlZHVsdGltYXRlc29sdXRpb248dWwgaWQ9ImRpc2NvdmVySG9tZTwvYT53ZWJzaXRlc25ldHdvcmtzYWx0aG91Z2hlbnRpcmVseW1lbW9yaWFsbWVzc2FnZXNjb250aW51ZWFjdGl2ZSI+c29tZXdoYXR2aWN0b3JpYVdlc3Rlcm4gIHRpdGxlPSJMb2NhdGlvbmNvbnRyYWN0dmlzaXRvcnNEb3dubG9hZHdpdGhvdXQgcmlnaHQiPgptZWFzdXJlc3dpZHRoID0gdmFyaWFibGVpbnZvbHZlZHZpcmdpbmlhbm9ybWFsbHloYXBwZW5lZGFjY291bnRzc3RhbmRpbmduYXRpb25hbFJlZ2lzdGVycHJlcGFyZWRjb250cm9sc2FjY3VyYXRlYmlydGhkYXlzdHJhdGVneW9mZmljaWFsZ3JhcGhpY3NjcmltaW5hbHBvc3NpYmx5Y29uc3VtZXJQZXJzb25hbHNwZWFraW5ndmFsaWRhdGVhY2hpZXZlZC5qcGciIC8+bWFjaGluZXM8L2gyPgogIGtleXdvcmRzZnJpZW5kbHlicm90aGVyc2NvbWJpbmVkb3JpZ2luYWxjb21wb3NlZGV4cGVjdGVkYWRlcXVhdGVwYWtpc3RhbmZvbGxvdyIgdmFsdWFibGU8L2xhYmVsPnJlbGF0aXZlYnJpbmdpbmdpbmNyZWFzZWdvdmVybm9ycGx1Z2lucy9MaXN0IG9mIEhlYWRlciI+IiBuYW1lPSIgKCZxdW90O2dyYWR1YXRlPC9oZWFkPgpjb21tZXJjZW1hbGF5c2lhZGlyZWN0b3JtYWludGFpbjtoZWlnaHQ6c2NoZWR1bGVjaGFuZ2luZ2JhY2sgdG8gY2F0aG9saWNwYXR0ZXJuc2NvbG9yOiAjZ3JlYXRlc3RzdXBwbGllc3JlbGlhYmxlPC91bD4KCQk8c2VsZWN0IGNpdGl6ZW5zY2xvdGhpbmd3YXRjaGluZzxsaSBpZD0ic3BlY2lmaWNjYXJyeWluZ3NlbnRlbmNlPGNlbnRlcj5jb250cmFzdHRoaW5raW5nY2F0Y2goZSlzb3V0aGVybk1pY2hhZWwgbWVyY2hhbnRjYXJvdXNlbHBhZGRpbmc6aW50ZXJpb3Iuc3BsaXQoImxpemF0aW9uT2N0b2JlciApe3JldHVybmltcHJvdmVkLS0mZ3Q7Cgpjb3ZlcmFnZWNoYWlybWFuLnBuZyIgLz5zdWJqZWN0c1JpY2hhcmQgd2hhdGV2ZXJwcm9iYWJseXJlY292ZXJ5YmFzZWJhbGxqdWRnbWVudGNvbm5lY3QuLmNzcyIgLz4gd2Vic2l0ZXJlcG9ydGVkZGVmYXVsdCIvPjwvYT4NCmVsZWN0cmljc2NvdGxhbmRjcmVhdGlvbnF1YW50aXR5LiBJU0JOIDBkaWQgbm90IGluc3RhbmNlLXNlYXJjaC0iIGxhbmc9InNwZWFrZXJzQ29tcHV0ZXJjb250YWluc2FyY2hpdmVzbWluaXN0ZXJyZWFjdGlvbmRpc2NvdW50SXRhbGlhbm9jcml0ZXJpYXN0cm9uZ2x5OiAnaHR0cDonc2NyaXB0J2NvdmVyaW5nb2ZmZXJpbmdhcHBlYXJlZEJyaXRpc2ggaWRlbnRpZnlGYWNlYm9va251bWVyb3VzdmVoaWNsZXNjb25jZXJuc0FtZXJpY2FuaGFuZGxpbmdkaXYgaWQ9IldpbGxpYW0gcHJvdmlkZXJfY29udGVudGFjY3VyYWN5c2VjdGlvbiBhbmRlcnNvbmZsZXhpYmxlQ2F0ZWdvcnlsYXdyZW5jZTxzY3JpcHQ+bGF5b3V0PSJhcHByb3ZlZCBtYXhpbXVtaGVhZGVyIj48L3RhYmxlPlNlcnZpY2VzaGFtaWx0b25jdXJyZW50IGNhbmFkaWFuY2hhbm5lbHMvdGhlbWVzLy9hcnRpY2xlb3B0aW9uYWxwb3J0dWdhbHZhbHVlPSIiaW50ZXJ2YWx3aXJlbGVzc2VudGl0bGVkYWdlbmNpZXNTZWFyY2giIG1lYXN1cmVkdGhvdXNhbmRzcGVuZGluZyZoZWxsaXA7bmV3IERhdGUiIHNpemU9InBhZ2VOYW1lbWlkZGxlIiAiIC8+PC9hPmhpZGRlbiI+c2VxdWVuY2VwZXJzb25hbG92ZXJmbG93b3BpbmlvbnNpbGxpbm9pc2xpbmtzIj4KCTx0aXRsZT52ZXJzaW9uc3NhdHVyZGF5dGVybWluYWxpdGVtcHJvcGVuZ2luZWVyc2VjdGlvbnNkZXNpZ25lcnByb3Bvc2FsPSJmYWxzZSJFc3Bhw7FvbHJlbGVhc2Vzc3VibWl0IiBlciZxdW90O2FkZGl0aW9uc3ltcHRvbXNvcmllbnRlZHJlc291cmNlcmlnaHQiPjxwbGVhc3VyZXN0YXRpb25zaGlzdG9yeS5sZWF2aW5nICBib3JkZXI9Y29udGVudHNjZW50ZXIiPi4KClNvbWUgZGlyZWN0ZWRzdWl0YWJsZWJ1bGdhcmlhLnNob3coKTtkZXNpZ25lZEdlbmVyYWwgY29uY2VwdHNFeGFtcGxlc3dpbGxpYW1zT3JpZ2luYWwiPjxzcGFuPnNlYXJjaCI+b3BlcmF0b3JyZXF1ZXN0c2EgJnF1b3Q7YWxsb3dpbmdEb2N1bWVudHJldmlzaW9uLiAKClRoZSB5b3Vyc2VsZkNvbnRhY3QgbWljaGlnYW5FbmdsaXNoIGNvbHVtYmlhcHJpb3JpdHlwcmludGluZ2RyaW5raW5nZmFjaWxpdHlyZXR1cm5lZENvbnRlbnQgb2ZmaWNlcnNSdXNzaWFuIGdlbmVyYXRlLTg4NTktMSJpbmRpY2F0ZWZhbWlsaWFyIHF1YWxpdHltYXJnaW46MCBjb250ZW50dmlld3BvcnRjb250YWN0cy10aXRsZSI+cG9ydGFibGUubGVuZ3RoIGVsaWdpYmxlaW52b2x2ZXNhdGxhbnRpY29ubG9hZD0iZGVmYXVsdC5zdXBwbGllZHBheW1lbnRzZ2xvc3NhcnkKCkFmdGVyIGd1aWRhbmNlPC90ZD48dGRlbmNvZGluZ21pZGRsZSI+Y2FtZSB0byBkaXNwbGF5c3Njb3R0aXNoam9uYXRoYW5tYWpvcml0eXdpZGdldHMuY2xpbmljYWx0aGFpbGFuZHRlYWNoZXJzPGhlYWQ+CglhZmZlY3RlZHN1cHBvcnRzcG9pbnRlcjt0b1N0cmluZzwvc21hbGw+b2tsYWhvbWF3aWxsIGJlIGludmVzdG9yMCIgYWx0PSJob2xpZGF5c1Jlc291cmNlbGljZW5zZWQgKHdoaWNoIC4gQWZ0ZXIgY29uc2lkZXJ2aXNpdGluZ2V4cGxvcmVycHJpbWFyeSBzZWFyY2giIGFuZHJvaWQicXVpY2tseSBtZWV0aW5nc2VzdGltYXRlO3JldHVybiA7Y29sb3I6IyBoZWlnaHQ9YXBwcm92YWwsICZxdW90OyBjaGVja2VkLm1pbi5qcyJtYWduZXRpYz48L2E+PC9oZm9yZWNhc3QuIFdoaWxlIHRodXJzZGF5ZHZlcnRpc2UmZWFjdXRlO2hhc0NsYXNzZXZhbHVhdGVvcmRlcmluZ2V4aXN0aW5ncGF0aWVudHMgT25saW5lIGNvbG9yYWRvT3B0aW9ucyJjYW1wYmVsbDwhLS0gZW5kPC9zcGFuPjw8YnIgLz4NCl9wb3B1cHN8c2NpZW5jZXMsJnF1b3Q7IHF1YWxpdHkgV2luZG93cyBhc3NpZ25lZGhlaWdodDogPGIgY2xhc3NsZSZxdW90OyB2YWx1ZT0iIENvbXBhbnlleGFtcGxlczxpZnJhbWUgYmVsaWV2ZXNwcmVzZW50c21hcnNoYWxscGFydCBvZiBwcm9wZXJseSkuCgpUaGUgdGF4b25vbXltdWNoIG9mIDwvc3Bhbj4KIiBkYXRhLXNydHVndcOqc3Njcm9sbFRvIHByb2plY3Q8aGVhZD4NCmF0dG9ybmV5ZW1waGFzaXNzcG9uc29yc2ZhbmN5Ym94d29ybGQncyB3aWxkbGlmZWNoZWNrZWQ9c2Vzc2lvbnNwcm9ncmFtbXB4O2ZvbnQtIFByb2plY3Rqb3VybmFsc2JlbGlldmVkdmFjYXRpb250aG9tcHNvbmxpZ2h0aW5nYW5kIHRoZSBzcGVjaWFsIGJvcmRlcj0wY2hlY2tpbmc8L3Rib2R5PjxidXR0b24gQ29tcGxldGVjbGVhcmZpeAo8aGVhZD4KYXJ0aWNsZSA8c2VjdGlvbmZpbmRpbmdzcm9sZSBpbiBwb3B1bGFyICBPY3RvYmVyd2Vic2l0ZSBleHBvc3VyZXVzZWQgdG8gIGNoYW5nZXNvcGVyYXRlZGNsaWNraW5nZW50ZXJpbmdjb21tYW5kc2luZm9ybWVkIG51bWJlcnMgIDwvZGl2PmNyZWF0aW5nb25TdWJtaXRtYXJ5bGFuZGNvbGxlZ2VzYW5hbHl0aWNsaXN0aW5nc2NvbnRhY3QubG9nZ2VkSW5hZHZpc29yeXNpYmxpbmdzY29udGVudCJzJnF1b3Q7KXMuIFRoaXMgcGFja2FnZXNjaGVja2JveHN1Z2dlc3RzcHJlZ25hbnR0b21vcnJvd3NwYWNpbmc9aWNvbi5wbmdqYXBhbmVzZWNvZGViYXNlYnV0dG9uIj5nYW1ibGluZ3N1Y2ggYXMgLCB3aGlsZSA8L3NwYW4+IG1pc3NvdXJpc3BvcnRpbmd0b3A6MXB4IC48L3NwYW4+dGVuc2lvbnN3aWR0aD0iMmxhenlsb2Fkbm92ZW1iZXJ1c2VkIGluIGhlaWdodD0iY3JpcHQiPgombmJzcDs8Lzx0cj48dGQgaGVpZ2h0OjIvcHJvZHVjdGNvdW50cnkgaW5jbHVkZSBmb290ZXIiICZsdDshLS0gdGl0bGUiPjwvanF1ZXJ5LjwvZm9ybT4KKOeugOS9kyko57mB6auUKWhydmF0c2tpaXRhbGlhbm9yb23Dom7Eg3TDvHJrw6dl2KfYsdiv2Yh0YW1iacOpbm5vdGljaWFzbWVuc2FqZXNwZXJzb25hc2RlcmVjaG9zbmFjaW9uYWxzZXJ2aWNpb2NvbnRhY3RvdXN1YXJpb3Nwcm9ncmFtYWdvYmllcm5vZW1wcmVzYXNhbnVuY2lvc3ZhbGVuY2lhY29sb21iaWFkZXNwdcOpc2RlcG9ydGVzcHJveWVjdG9wcm9kdWN0b3DDumJsaWNvbm9zb3Ryb3NoaXN0b3JpYXByZXNlbnRlbWlsbG9uZXNtZWRpYW50ZXByZWd1bnRhYW50ZXJpb3JyZWN1cnNvc3Byb2JsZW1hc2FudGlhZ29udWVzdHJvc29waW5pw7NuaW1wcmltaXJtaWVudHJhc2Ftw6lyaWNhdmVuZGVkb3Jzb2NpZWRhZHJlc3BlY3RvcmVhbGl6YXJyZWdpc3Ryb3BhbGFicmFzaW50ZXLDqXNlbnRvbmNlc2VzcGVjaWFsbWllbWJyb3NyZWFsaWRhZGPDs3Jkb2JhemFyYWdvemFww6FnaW5hc3NvY2lhbGVzYmxvcXVlYXJnZXN0acOzbmFscXVpbGVyc2lzdGVtYXNjaWVuY2lhc2NvbXBsZXRvdmVyc2nDs25jb21wbGV0YWVzdHVkaW9zcMO6YmxpY2FvYmpldGl2b2FsaWNhbnRlYnVzY2Fkb3JjYW50aWRhZGVudHJhZGFzYWNjaW9uZXNhcmNoaXZvc3N1cGVyaW9ybWF5b3LDrWFhbGVtYW5pYWZ1bmNpw7Nuw7psdGltb3NoYWNpZW5kb2FxdWVsbG9zZWRpY2nDs25mZXJuYW5kb2FtYmllbnRlZmFjZWJvb2tudWVzdHJhc2NsaWVudGVzcHJvY2Vzb3NiYXN0YW50ZXByZXNlbnRhcmVwb3J0YXJjb25ncmVzb3B1YmxpY2FyY29tZXJjaW9jb250cmF0b2rDs3ZlbmVzZGlzdHJpdG90w6ljbmljYWNvbmp1bnRvZW5lcmfDrWF0cmFiYWphcmFzdHVyaWFzcmVjaWVudGV1dGlsaXphcmJvbGV0w61uc2FsdmFkb3Jjb3JyZWN0YXRyYWJham9zcHJpbWVyb3NuZWdvY2lvc2xpYmVydGFkZGV0YWxsZXNwYW50YWxsYXByw7N4aW1vYWxtZXLDrWFhbmltYWxlc3F1acOpbmVzY29yYXrDs25zZWNjacOzbmJ1c2NhbmRvb3BjaW9uZXNleHRlcmlvcmNvbmNlcHRvdG9kYXbDrWFnYWxlcsOtYWVzY3JpYmlybWVkaWNpbmFsaWNlbmNpYWNvbnN1bHRhYXNwZWN0b3NjcsOtdGljYWTDs2xhcmVzanVzdGljaWFkZWJlcsOhbnBlcsOtb2RvbmVjZXNpdGFtYW50ZW5lcnBlcXVlw7FvcmVjaWJpZGF0cmlidW5hbHRlbmVyaWZlY2FuY2nDs25jYW5hcmlhc2Rlc2NhcmdhZGl2ZXJzb3NtYWxsb3JjYXJlcXVpZXJldMOpY25pY29kZWJlcsOtYXZpdmllbmRhZmluYW56YXNhZGVsYW50ZWZ1bmNpb25hY29uc2Vqb3NkaWbDrWNpbGNpdWRhZGVzYW50aWd1YXNhdmFuemFkYXTDqXJtaW5vdW5pZGFkZXNzw6FuY2hlemNhbXBhw7Fhc29mdG9uaWNyZXZpc3Rhc2NvbnRpZW5lc2VjdG9yZXNtb21lbnRvc2ZhY3VsdGFkY3LDqWRpdG9kaXZlcnNhc3N1cHVlc3RvZmFjdG9yZXNzZWd1bmRvc3BlcXVlw7Fh0LPQvtC00LDQtdGB0LvQuNC10YHRgtGM0LHRi9C70L7QsdGL0YLRjNGN0YLQvtC80JXRgdC70LjRgtC+0LPQvtC80LXQvdGP0LLRgdC10YXRjdGC0L7QudC00LDQttC10LHRi9C70LjQs9C+0LTRg9C00LXQvdGM0Y3RgtC+0YLQsdGL0LvQsNGB0LXQsdGP0L7QtNC40L3RgdC10LHQtdC90LDQtNC+0YHQsNC50YLRhNC+0YLQvtC90LXQs9C+0YHQstC+0LjRgdCy0L7QudC40LPRgNGL0YLQvtC20LXQstGB0LXQvNGB0LLQvtGO0LvQuNGI0YzRjdGC0LjRhdC/0L7QutCw0LTQvdC10LnQtNC+0LzQsNC80LjRgNCw0LvQuNCx0L7RgtC10LzRg9GF0L7RgtGP0LTQstGD0YXRgdC10YLQuNC70Y7QtNC40LTQtdC70L7QvNC40YDQtdGC0LXQsdGP0YHQstC+0LXQstC40LTQtdGH0LXQs9C+0Y3RgtC40LzRgdGH0LXRgtGC0LXQvNGL0YbQtdC90YvRgdGC0LDQu9Cy0LXQtNGM0YLQtdC80LXQstC+0LTRi9GC0LXQsdC10LLRi9GI0LXQvdCw0LzQuNGC0LjQv9Cw0YLQvtC80YPQv9GA0LDQstC70LjRhtCw0L7QtNC90LDQs9C+0LTRi9C30L3QsNGO0LzQvtCz0YPQtNGA0YPQs9Cy0YHQtdC50LjQtNC10YLQutC40L3QvtC+0LTQvdC+0LTQtdC70LDQtNC10LvQtdGB0YDQvtC60LjRjtC90Y/QstC10YHRjNCV0YHRgtGM0YDQsNC30LDQvdCw0YjQuNin2YTZhNmH2KfZhNiq2YrYrNmF2YrYudiu2KfYtdip2KfZhNiw2YrYudmE2YrZh9is2K/Zitiv2KfZhNii2YbYp9mE2LHYr9iq2K3Zg9mF2LXZgdit2KnZg9in2YbYqtin2YTZhNmK2YrZg9mI2YbYtNio2YPYqdmB2YrZh9in2KjZhtin2KrYrdmI2KfYodij2YPYq9ix2K7ZhNin2YTYp9mE2K3YqNiv2YTZitmE2K/YsdmI2LPYp9i22LrYt9iq2YPZiNmG2YfZhtin2YPYs9in2K3YqdmG2KfYr9mK2KfZhNi32KjYudmE2YrZg9i02YPYsdin2YrZhdmD2YbZhdmG2YfYp9i02LHZg9ip2LHYptmK2LPZhti02YrYt9mF2KfYsNin2KfZhNmB2YbYtNio2KfYqNiq2LnYqNix2LHYrdmF2KnZg9in2YHYqdmK2YLZiNmE2YXYsdmD2LLZg9mE2YXYqdij2K3Zhdiv2YLZhNio2YrZiti52YbZiti12YjYsdip2LfYsdmK2YLYtNin2LHZg9is2YjYp9mE2KPYrtix2YnZhdi52YbYp9in2KjYrdir2LnYsdmI2LbYqNi02YPZhNmF2LPYrNmE2KjZhtin2YbYrtin2YTYr9mD2KrYp9io2YPZhNmK2KnYqNiv2YjZhtij2YrYttin2YrZiNis2K/Zgdix2YrZgtmD2KrYqNiq2KPZgdi22YTZhdi32KjYrtin2YPYq9ix2KjYp9ix2YPYp9mB2LbZhNin2K3ZhNmJ2YbZgdiz2YfYo9mK2KfZhdix2K/ZiNiv2KPZhtmH2KfYr9mK2YbYp9in2YTYp9mG2YXYudix2LbYqti52YTZhdiv2KfYrtmE2YXZhdmD2YYAAAAAAAAAAAEAAQABAAEAAgACAAIAAgAEAAQABAAEAAABAgMEBQYHBwYFBAMCAQAICQoLDA0ODw8ODQwLCgkIEBESExQVFhcXFhUUExIREBgZGhscHR4fHx4dHBsaGRj/////AAAAAAAAAAD/////AQAAAAIAAAACAAAAAQAAAAEAAAADAAAA//8AAQAAAAEAAP//AAEAAAAIAAgACAAIAAAAAQACAAMABAAFAAYAB3Jlc291cmNlc2NvdW50cmllc3F1ZXN0aW9uc2VxdWlwbWVudGNvbW11bml0eWF2YWlsYWJsZWhpZ2hsaWdodERURC94aHRtbG1hcmtldGluZ2tub3dsZWRnZXNvbWV0aGluZ2NvbnRhaW5lcmRpcmVjdGlvbnN1YnNjcmliZWFkdmVydGlzZWNoYXJhY3RlciIgdmFsdWU9Ijwvc2VsZWN0PkF1c3RyYWxpYSIgY2xhc3M9InNpdHVhdGlvbmF1dGhvcml0eWZvbGxvd2luZ3ByaW1hcmlseW9wZXJhdGlvbmNoYWxsZW5nZWRldmVsb3BlZGFub255bW91c2Z1bmN0aW9uIGZ1bmN0aW9uc2NvbXBhbmllc3N0cnVjdHVyZWFncmVlbWVudCIgdGl0bGU9InBvdGVudGlhbGVkdWNhdGlvbmFyZ3VtZW50c3NlY29uZGFyeWNvcHlyaWdodGxhbmd1YWdlc2V4Y2x1c2l2ZWNvbmRpdGlvbjwvZm9ybT4NCnN0YXRlbWVudGF0dGVudGlvbkJpb2dyYXBoeX0gZWxzZSB7CnNvbHV0aW9uc3doZW4gdGhlIEFuYWx5dGljc3RlbXBsYXRlc2Rhbmdlcm91c3NhdGVsbGl0ZWRvY3VtZW50c3B1Ymxpc2hlcmltcG9ydGFudHByb3RvdHlwZWluZmx1ZW5jZSZyYXF1bzs8L2VmZmVjdGl2ZWdlbmVyYWxseXRyYW5zZm9ybWJlYXV0aWZ1bHRyYW5zcG9ydG9yZ2FuaXplZHB1Ymxpc2hlZHByb21pbmVudHVudGlsIHRoZXRodW1ibmFpbE5hdGlvbmFsIC5mb2N1cygpO292ZXIgdGhlIG1pZ3JhdGlvbmFubm91bmNlZGZvb3RlciI+CmV4Y2VwdGlvbmxlc3MgdGhhbmV4cGVuc2l2ZWZvcm1hdGlvbmZyYW1ld29ya3RlcnJpdG9yeW5kaWNhdGlvbmN1cnJlbnRseWNsYXNzTmFtZWNyaXRpY2lzbXRyYWRpdGlvbmVsc2V3aGVyZUFsZXhhbmRlcmFwcG9pbnRlZG1hdGVyaWFsc2Jyb2FkY2FzdG1lbnRpb25lZGFmZmlsaWF0ZTwvb3B0aW9uPnRyZWF0bWVudGRpZmZlcmVudC9kZWZhdWx0LlByZXNpZGVudG9uY2xpY2s9ImJpb2dyYXBoeW90aGVyd2lzZXBlcm1hbmVudEZyYW7Dp2Fpc0hvbGx5d29vZGV4cGFuc2lvbnN0YW5kYXJkczwvc3R5bGU+CnJlZHVjdGlvbkRlY2VtYmVyIHByZWZlcnJlZENhbWJyaWRnZW9wcG9uZW50c0J1c2luZXNzIGNvbmZ1c2lvbj4KPHRpdGxlPnByZXNlbnRlZGV4cGxhaW5lZGRvZXMgbm90IHdvcmxkd2lkZWludGVyZmFjZXBvc2l0aW9uc25ld3NwYXBlcjwvdGFibGU+Cm1vdW50YWluc2xpa2UgdGhlIGVzc2VudGlhbGZpbmFuY2lhbHNlbGVjdGlvbmFjdGlvbj0iL2FiYW5kb25lZEVkdWNhdGlvbnBhcnNlSW50KHN0YWJpbGl0eXVuYWJsZSB0bzwvdGl0bGU+CnJlbGF0aW9uc05vdGUgdGhhdGVmZmljaWVudHBlcmZvcm1lZHR3byB5ZWFyc1NpbmNlIHRoZXRoZXJlZm9yZXdyYXBwZXIiPmFsdGVybmF0ZWluY3JlYXNlZEJhdHRsZSBvZnBlcmNlaXZlZHRyeWluZyB0b25lY2Vzc2FyeXBvcnRyYXllZGVsZWN0aW9uc0VsaXphYmV0aDwvaWZyYW1lPmRpc2NvdmVyeWluc3VyYW5jZXMubGVuZ3RoO2xlZ2VuZGFyeUdlb2dyYXBoeWNhbmRpZGF0ZWNvcnBvcmF0ZXNvbWV0aW1lc3NlcnZpY2VzLmluaGVyaXRlZDwvc3Ryb25nPkNvbW11bml0eXJlbGlnaW91c2xvY2F0aW9uc0NvbW1pdHRlZWJ1aWxkaW5nc3RoZSB3b3JsZG5vIGxvbmdlcmJlZ2lubmluZ3JlZmVyZW5jZWNhbm5vdCBiZWZyZXF1ZW5jeXR5cGljYWxseWludG8gdGhlIHJlbGF0aXZlO3JlY29yZGluZ3ByZXNpZGVudGluaXRpYWxseXRlY2huaXF1ZXRoZSBvdGhlcml0IGNhbiBiZWV4aXN0ZW5jZXVuZGVybGluZXRoaXMgdGltZXRlbGVwaG9uZWl0ZW1zY29wZXByYWN0aWNlc2FkdmFudGFnZSk7cmV0dXJuIEZvciBvdGhlcnByb3ZpZGluZ2RlbW9jcmFjeWJvdGggdGhlIGV4dGVuc2l2ZXN1ZmZlcmluZ3N1cHBvcnRlZGNvbXB1dGVycyBmdW5jdGlvbnByYWN0aWNhbHNhaWQgdGhhdGl0IG1heSBiZUVuZ2xpc2g8L2Zyb20gdGhlIHNjaGVkdWxlZGRvd25sb2FkczwvbGFiZWw+CnN1c3BlY3RlZG1hcmdpbjogMHNwaXJpdHVhbDwvaGVhZD4KCm1pY3Jvc29mdGdyYWR1YWxseWRpc2N1c3NlZGhlIGJlY2FtZWV4ZWN1dGl2ZWpxdWVyeS5qc2hvdXNlaG9sZGNvbmZpcm1lZHB1cmNoYXNlZGxpdGVyYWxseWRlc3Ryb3llZHVwIHRvIHRoZXZhcmlhdGlvbnJlbWFpbmluZ2l0IGlzIG5vdGNlbnR1cmllc0phcGFuZXNlIGFtb25nIHRoZWNvbXBsZXRlZGFsZ29yaXRobWludGVyZXN0c3JlYmVsbGlvbnVuZGVmaW5lZGVuY291cmFnZXJlc2l6YWJsZWludm9sdmluZ3NlbnNpdGl2ZXVuaXZlcnNhbHByb3Zpc2lvbihhbHRob3VnaGZlYXR1cmluZ2NvbmR1Y3RlZCksIHdoaWNoIGNvbnRpbnVlZC1oZWFkZXIiPkZlYnJ1YXJ5IG51bWVyb3VzIG92ZXJmbG93OmNvbXBvbmVudGZyYWdtZW50c2V4Y2VsbGVudGNvbHNwYW49InRlY2huaWNhbG5lYXIgdGhlIEFkdmFuY2VkIHNvdXJjZSBvZmV4cHJlc3NlZEhvbmcgS29uZyBGYWNlYm9va211bHRpcGxlIG1lY2hhbmlzbWVsZXZhdGlvbm9mZmVuc2l2ZTwvZm9ybT4KCXNwb25zb3JlZGRvY3VtZW50Lm9yICZxdW90O3RoZXJlIGFyZXRob3NlIHdob21vdmVtZW50c3Byb2Nlc3Nlc2RpZmZpY3VsdHN1Ym1pdHRlZHJlY29tbWVuZGNvbnZpbmNlZHByb21vdGluZyIgd2lkdGg9Ii5yZXBsYWNlKGNsYXNzaWNhbGNvYWxpdGlvbmhpcyBmaXJzdGRlY2lzaW9uc2Fzc2lzdGFudGluZGljYXRlZGV2b2x1dGlvbi13cmFwcGVyImVub3VnaCB0b2Fsb25nIHRoZWRlbGl2ZXJlZC0tPg0KPCEtLUFtZXJpY2FuIHByb3RlY3RlZE5vdmVtYmVyIDwvc3R5bGU+PGZ1cm5pdHVyZUludGVybmV0ICBvbmJsdXI9InN1c3BlbmRlZHJlY2lwaWVudGJhc2VkIG9uIE1vcmVvdmVyLGFib2xpc2hlZGNvbGxlY3RlZHdlcmUgbWFkZWVtb3Rpb25hbGVtZXJnZW5jeW5hcnJhdGl2ZWFkdm9jYXRlc3B4O2JvcmRlcmNvbW1pdHRlZGRpcj0ibHRyImVtcGxveWVlc3Jlc2VhcmNoLiBzZWxlY3RlZHN1Y2Nlc3NvcmN1c3RvbWVyc2Rpc3BsYXllZFNlcHRlbWJlcmFkZENsYXNzKEZhY2Vib29rIHN1Z2dlc3RlZGFuZCBsYXRlcm9wZXJhdGluZ2VsYWJvcmF0ZVNvbWV0aW1lc0luc3RpdHV0ZWNlcnRhaW5seWluc3RhbGxlZGZvbGxvd2Vyc0plcnVzYWxlbXRoZXkgaGF2ZWNvbXB1dGluZ2dlbmVyYXRlZHByb3ZpbmNlc2d1YXJhbnRlZWFyYml0cmFyeXJlY29nbml6ZXdhbnRlZCB0b3B4O3dpZHRoOnRoZW9yeSBvZmJlaGF2aW91cldoaWxlIHRoZWVzdGltYXRlZGJlZ2FuIHRvIGl0IGJlY2FtZW1hZ25pdHVkZW11c3QgaGF2ZW1vcmUgdGhhbkRpcmVjdG9yeWV4dGVuc2lvbnNlY3JldGFyeW5hdHVyYWxseW9jY3VycmluZ3ZhcmlhYmxlc2dpdmVuIHRoZXBsYXRmb3JtLjwvbGFiZWw+PGZhaWxlZCB0b2NvbXBvdW5kc2tpbmRzIG9mIHNvY2lldGllc2Fsb25nc2lkZSAtLSZndDsKCnNvdXRod2VzdHRoZSByaWdodHJhZGlhdGlvbm1heSBoYXZlIHVuZXNjYXBlKHNwb2tlbiBpbiIgaHJlZj0iL3Byb2dyYW1tZW9ubHkgdGhlIGNvbWUgZnJvbWRpcmVjdG9yeWJ1cmllZCBpbmEgc2ltaWxhcnRoZXkgd2VyZTwvZm9udD48L05vcndlZ2lhbnNwZWNpZmllZHByb2R1Y2luZ3Bhc3NlbmdlcihuZXcgRGF0ZXRlbXBvcmFyeWZpY3Rpb25hbEFmdGVyIHRoZWVxdWF0aW9uc2Rvd25sb2FkLnJlZ3VsYXJseWRldmVsb3BlcmFib3ZlIHRoZWxpbmtlZCB0b3BoZW5vbWVuYXBlcmlvZCBvZnRvb2x0aXAiPnN1YnN0YW5jZWF1dG9tYXRpY2FzcGVjdCBvZkFtb25nIHRoZWNvbm5lY3RlZGVzdGltYXRlc0FpciBGb3JjZXN5c3RlbSBvZm9iamVjdGl2ZWltbWVkaWF0ZW1ha2luZyBpdHBhaW50aW5nc2NvbnF1ZXJlZGFyZSBzdGlsbHByb2NlZHVyZWdyb3d0aCBvZmhlYWRlZCBieUV1cm9wZWFuIGRpdmlzaW9uc21vbGVjdWxlc2ZyYW5jaGlzZWludGVudGlvbmF0dHJhY3RlZGNoaWxkaG9vZGFsc28gdXNlZGRlZGljYXRlZHNpbmdhcG9yZWRlZ3JlZSBvZmZhdGhlciBvZmNvbmZsaWN0czwvYT48L3A+CmNhbWUgZnJvbXdlcmUgdXNlZG5vdGUgdGhhdHJlY2VpdmluZ0V4ZWN1dGl2ZWV2ZW4gbW9yZWFjY2VzcyB0b2NvbW1hbmRlclBvbGl0aWNhbG11c2ljaWFuc2RlbGljaW91c3ByaXNvbmVyc2FkdmVudCBvZlVURi04IiAvPjwhW0NEQVRBWyI+Q29udGFjdFNvdXRoZXJuIGJnY29sb3I9InNlcmllcyBvZi4gSXQgd2FzIGluIEV1cm9wZXBlcm1pdHRlZHZhbGlkYXRlLmFwcGVhcmluZ29mZmljaWFsc3NlcmlvdXNseS1sYW5ndWFnZWluaXRpYXRlZGV4dGVuZGluZ2xvbmctdGVybWluZmxhdGlvbnN1Y2ggdGhhdGdldENvb2tpZW1hcmtlZCBieTwvYnV0dG9uPmltcGxlbWVudGJ1dCBpdCBpc2luY3JlYXNlc2Rvd24gdGhlIHJlcXVpcmluZ2RlcGVuZGVudC0tPgo8IS0tIGludGVydmlld1dpdGggdGhlIGNvcGllcyBvZmNvbnNlbnN1c3dhcyBidWlsdFZlbmV6dWVsYShmb3JtZXJseXRoZSBzdGF0ZXBlcnNvbm5lbHN0cmF0ZWdpY2Zhdm91ciBvZmludmVudGlvbldpa2lwZWRpYWNvbnRpbmVudHZpcnR1YWxseXdoaWNoIHdhc3ByaW5jaXBsZUNvbXBsZXRlIGlkZW50aWNhbHNob3cgdGhhdHByaW1pdGl2ZWF3YXkgZnJvbW1vbGVjdWxhcnByZWNpc2VseWRpc3NvbHZlZFVuZGVyIHRoZXZlcnNpb249Ij4mbmJzcDs8L0l0IGlzIHRoZSBUaGlzIGlzIHdpbGwgaGF2ZW9yZ2FuaXNtc3NvbWUgdGltZUZyaWVkcmljaHdhcyBmaXJzdHRoZSBvbmx5IGZhY3QgdGhhdGZvcm0gaWQ9InByZWNlZGluZ1RlY2huaWNhbHBoeXNpY2lzdG9jY3VycyBpbm5hdmlnYXRvcnNlY3Rpb24iPnNwYW4gaWQ9InNvdWdodCB0b2JlbG93IHRoZXN1cnZpdmluZ308L3N0eWxlPmhpcyBkZWF0aGFzIGluIHRoZWNhdXNlZCBieXBhcnRpYWxseWV4aXN0aW5nIHVzaW5nIHRoZXdhcyBnaXZlbmEgbGlzdCBvZmxldmVscyBvZm5vdGlvbiBvZk9mZmljaWFsIGRpc21pc3NlZHNjaWVudGlzdHJlc2VtYmxlc2R1cGxpY2F0ZWV4cGxvc2l2ZXJlY292ZXJlZGFsbCBvdGhlcmdhbGxlcmllc3twYWRkaW5nOnBlb3BsZSBvZnJlZ2lvbiBvZmFkZHJlc3Nlc2Fzc29jaWF0ZWltZyBhbHQ9ImluIG1vZGVybnNob3VsZCBiZW1ldGhvZCBvZnJlcG9ydGluZ3RpbWVzdGFtcG5lZWRlZCB0b3RoZSBHcmVhdHJlZ2FyZGluZ3NlZW1lZCB0b3ZpZXdlZCBhc2ltcGFjdCBvbmlkZWEgdGhhdHRoZSBXb3JsZGhlaWdodCBvZmV4cGFuZGluZ1RoZXNlIGFyZWN1cnJlbnQiPmNhcmVmdWxseW1haW50YWluc2NoYXJnZSBvZkNsYXNzaWNhbGFkZHJlc3NlZHByZWRpY3RlZG93bmVyc2hpcDxkaXYgaWQ9InJpZ2h0Ij4NCnJlc2lkZW5jZWxlYXZlIHRoZWNvbnRlbnQiPmFyZSBvZnRlbiAgfSkoKTsNCnByb2JhYmx5IFByb2Zlc3Nvci1idXR0b24iIHJlc3BvbmRlZHNheXMgdGhhdGhhZCB0byBiZXBsYWNlZCBpbkh1bmdhcmlhbnN0YXR1cyBvZnNlcnZlcyBhc1VuaXZlcnNhbGV4ZWN1dGlvbmFnZ3JlZ2F0ZWZvciB3aGljaGluZmVjdGlvbmFncmVlZCB0b2hvd2V2ZXIsIHBvcHVsYXIiPnBsYWNlZCBvbmNvbnN0cnVjdGVsZWN0b3JhbHN5bWJvbCBvZmluY2x1ZGluZ3JldHVybiB0b2FyY2hpdGVjdENocmlzdGlhbnByZXZpb3VzIGxpdmluZyBpbmVhc2llciB0b3Byb2Zlc3NvcgombHQ7IS0tIGVmZmVjdCBvZmFuYWx5dGljc3dhcyB0YWtlbndoZXJlIHRoZXRvb2sgb3ZlcmJlbGllZiBpbkFmcmlrYWFuc2FzIGZhciBhc3ByZXZlbnRlZHdvcmsgd2l0aGEgc3BlY2lhbDxmaWVsZHNldENocmlzdG1hc1JldHJpZXZlZAoKSW4gdGhlIGJhY2sgaW50b25vcnRoZWFzdG1hZ2F6aW5lcz48c3Ryb25nPmNvbW1pdHRlZWdvdmVybmluZ2dyb3VwcyBvZnN0b3JlZCBpbmVzdGFibGlzaGEgZ2VuZXJhbGl0cyBmaXJzdHRoZWlyIG93bnBvcHVsYXRlZGFuIG9iamVjdENhcmliYmVhbmFsbG93IHRoZWRpc3RyaWN0c3dpc2NvbnNpbmxvY2F0aW9uLjsgd2lkdGg6IGluaGFiaXRlZFNvY2lhbGlzdEphbnVhcnkgMTwvZm9vdGVyPnNpbWlsYXJseWNob2ljZSBvZnRoZSBzYW1lIHNwZWNpZmljIGJ1c2luZXNzIFRoZSBmaXJzdC5sZW5ndGg7IGRlc2lyZSB0b2RlYWwgd2l0aHNpbmNlIHRoZXVzZXJBZ2VudGNvbmNlaXZlZGluZGV4LnBocGFzICZxdW90O2VuZ2FnZSBpbnJlY2VudGx5LGZldyB5ZWFyc3dlcmUgYWxzbwo8aGVhZD4KPGVkaXRlZCBieWFyZSBrbm93bmNpdGllcyBpbmFjY2Vzc2tleWNvbmRlbW5lZGFsc28gaGF2ZXNlcnZpY2VzLGZhbWlseSBvZlNjaG9vbCBvZmNvbnZlcnRlZG5hdHVyZSBvZiBsYW5ndWFnZW1pbmlzdGVyczwvb2JqZWN0PnRoZXJlIGlzIGEgcG9wdWxhcnNlcXVlbmNlc2Fkdm9jYXRlZFRoZXkgd2VyZWFueSBvdGhlcmxvY2F0aW9uPWVudGVyIHRoZW11Y2ggbW9yZXJlZmxlY3RlZHdhcyBuYW1lZG9yaWdpbmFsIGEgdHlwaWNhbHdoZW4gdGhleWVuZ2luZWVyc2NvdWxkIG5vdHJlc2lkZW50c3dlZG5lc2RheXRoZSB0aGlyZCBwcm9kdWN0c0phbnVhcnkgMndoYXQgdGhleWEgY2VydGFpbnJlYWN0aW9uc3Byb2Nlc3NvcmFmdGVyIGhpc3RoZSBsYXN0IGNvbnRhaW5lZCI+PC9kaXY+CjwvYT48L3RkPmRlcGVuZCBvbnNlYXJjaCI+CnBpZWNlcyBvZmNvbXBldGluZ1JlZmVyZW5jZXRlbm5lc3NlZXdoaWNoIGhhcyB2ZXJzaW9uPTwvc3Bhbj4gPDwvaGVhZGVyPmdpdmVzIHRoZWhpc3RvcmlhbnZhbHVlPSIiPnBhZGRpbmc6MHZpZXcgdGhhdHRvZ2V0aGVyLHRoZSBtb3N0IHdhcyBmb3VuZHN1YnNldCBvZmF0dGFjayBvbmNoaWxkcmVuLHBvaW50cyBvZnBlcnNvbmFsIHBvc2l0aW9uOmFsbGVnZWRseUNsZXZlbGFuZHdhcyBsYXRlcmFuZCBhZnRlcmFyZSBnaXZlbndhcyBzdGlsbHNjcm9sbGluZ2Rlc2lnbiBvZm1ha2VzIHRoZW11Y2ggbGVzc0FtZXJpY2Fucy4KCkFmdGVyICwgYnV0IHRoZU11c2V1bSBvZmxvdWlzaWFuYShmcm9tIHRoZW1pbm5lc290YXBhcnRpY2xlc2EgcHJvY2Vzc0RvbWluaWNhbnZvbHVtZSBvZnJldHVybmluZ2RlZmVuc2l2ZTAwcHh8cmlnaG1hZGUgZnJvbW1vdXNlb3ZlciIgc3R5bGU9InN0YXRlcyBvZih3aGljaCBpc2NvbnRpbnVlc0ZyYW5jaXNjb2J1aWxkaW5nIHdpdGhvdXQgYXdpdGggc29tZXdobyB3b3VsZGEgZm9ybSBvZmEgcGFydCBvZmJlZm9yZSBpdGtub3duIGFzICBTZXJ2aWNlc2xvY2F0aW9uIGFuZCBvZnRlbm1lYXN1cmluZ2FuZCBpdCBpc3BhcGVyYmFja3ZhbHVlcyBvZg0KPHRpdGxlPj0gd2luZG93LmRldGVybWluZWVyJnF1b3Q7IHBsYXllZCBieWFuZCBlYXJseTwvY2VudGVyPmZyb20gdGhpc3RoZSB0aHJlZXBvd2VyIGFuZG9mICZxdW90O2lubmVySFRNTDxhIGhyZWY9Ink6aW5saW5lO0NodXJjaCBvZnRoZSBldmVudHZlcnkgaGlnaG9mZmljaWFsIC1oZWlnaHQ6IGNvbnRlbnQ9Ii9jZ2ktYmluL3RvIGNyZWF0ZWFmcmlrYWFuc2VzcGVyYW50b2ZyYW7Dp2Fpc2xhdHZpZcWhdWxpZXR1dmnFs8SMZcWhdGluYcSNZcWhdGluYeC5hOC4l+C4ouaXpeacrOiqnueugOS9k+Wtl+e5gemrlOWtl+2VnOq1reyWtOS4uuS7gOS5iOiuoeeul+acuueslOiusOacrOiojuirluWNgOacjeWKoeWZqOS6kuiBlOe9keaIv+WcsOS6p+S/seS5kOmDqOWHuueJiOekvuaOkuihjOamnOmDqOiQveagvOi/m+S4gOatpeaUr+S7mOWunemqjOivgeeggeWnlOWRmOS8muaVsOaNruW6k+a2iOi0ueiAheWKnuWFrOWupOiuqOiuuuWMuua3seWcs+W4guaSreaUvuWZqOWMl+S6rOW4guWkp+WtpueUn+i2iuadpei2iueuoeeQhuWRmOS/oeaBr+e9kXNlcnZpY2lvc2FydMOtY3Vsb2FyZ2VudGluYWJhcmNlbG9uYWN1YWxxdWllcnB1YmxpY2Fkb3Byb2R1Y3Rvc3BvbMOtdGljYXJlc3B1ZXN0YXdpa2lwZWRpYXNpZ3VpZW50ZWLDunNxdWVkYWNvbXVuaWRhZHNlZ3VyaWRhZHByaW5jaXBhbHByZWd1bnRhc2NvbnRlbmlkb3Jlc3BvbmRlcnZlbmV6dWVsYXByb2JsZW1hc2RpY2llbWJyZXJlbGFjacOzbm5vdmllbWJyZXNpbWlsYXJlc3Byb3llY3Rvc3Byb2dyYW1hc2luc3RpdHV0b2FjdGl2aWRhZGVuY3VlbnRyYWVjb25vbcOtYWltw6FnZW5lc2NvbnRhY3RhcmRlc2Nhcmdhcm5lY2VzYXJpb2F0ZW5jacOzbnRlbMOpZm9ub2NvbWlzacOzbmNhbmNpb25lc2NhcGFjaWRhZGVuY29udHJhcmFuw6FsaXNpc2Zhdm9yaXRvc3TDqXJtaW5vc3Byb3ZpbmNpYWV0aXF1ZXRhc2VsZW1lbnRvc2Z1bmNpb25lc3Jlc3VsdGFkb2NhcsOhY3RlcnByb3BpZWRhZHByaW5jaXBpb25lY2VzaWRhZG11bmljaXBhbGNyZWFjacOzbmRlc2Nhcmdhc3ByZXNlbmNpYWNvbWVyY2lhbG9waW5pb25lc2VqZXJjaWNpb2VkaXRvcmlhbHNhbGFtYW5jYWdvbnrDoWxlemRvY3VtZW50b3BlbMOtY3VsYXJlY2llbnRlc2dlbmVyYWxlc3RhcnJhZ29uYXByw6FjdGljYW5vdmVkYWRlc3Byb3B1ZXN0YXBhY2llbnRlc3TDqWNuaWNhc29iamV0aXZvc2NvbnRhY3Rvc+CkruClh+CkguCksuCkv+Ckj+CkueCliOCkguCkl+Ckr+CkvuCkuOCkvuCkpeCkj+CkteCkguCksOCkueClh+CkleCli+CkiOCkleClgeCkm+CksOCkueCkvuCkrOCkvuCkpuCkleCkueCkvuCkuOCkreClgOCkueClgeCkj+CksOCkueClgOCkruCliOCkguCkpuCkv+CkqOCkrOCkvuCkpGRpcGxvZG9jc+CkuOCkruCkr+CksOClguCkquCkqOCkvuCkruCkquCkpOCkvuCkq+Ckv+CksOCklOCkuOCkpOCkpOCksOCkueCksuCli+Ckl+CkueClgeCkhuCkrOCkvuCksOCkpuClh+CktuCkueClgeCkiOCkluClh+CksuCkr+CkpuCkv+CkleCkvuCkruCkteClh+CkrOCkpOClgOCkqOCkrOClgOCkmuCkruCljOCkpOCkuOCkvuCksuCksuClh+CkluCknOClieCkrOCkruCkpuCkpuCkpOCkpeCkvuCkqOCkueClgOCktuCkueCksOCkheCksuCkl+CkleCkreClgOCkqOCkl+CksOCkquCkvuCkuOCksOCkvuCkpOCkleCkv+Ckj+CkieCkuOClh+Ckl+Ckr+ClgOCkueClguCkgeCkhuCkl+Clh+Ckn+ClgOCkruCkluCli+CknOCkleCkvuCksOCkheCkreClgOCkl+Ckr+Clh+CkpOClgeCkruCkteCli+Ckn+CkpuClh+CkguCkheCkl+CksOCkkOCkuOClh+CkruClh+CksuCksuCkl+CkvuCkueCkvuCksuCkiuCkquCksOCkmuCkvuCksOCkkOCkuOCkvuCkpuClh+CksOCknOCkv+CkuOCkpuCkv+CksuCkrOCkguCkpuCkrOCkqOCkvuCkueClguCkguCksuCkvuCkluCknOClgOCkpOCkrOCkn+CkqOCkruCkv+CksuCkh+CkuOClh+CkhuCkqOClh+CkqOCkr+CkvuCkleClgeCksuCksuClieCkl+CkreCkvuCkl+CksOClh+CksuCknOCkl+CkueCksOCkvuCkruCksuCkl+Clh+CkquClh+CknOCkueCkvuCkpeCkh+CkuOClgOCkuOCkueClgOCkleCksuCkvuCkoOClgOCkleCkueCkvuCkgeCkpuClguCksOCkpOCkueCkpOCkuOCkvuCkpOCkr+CkvuCkpuCkhuCkr+CkvuCkquCkvuCkleCkleCljOCkqOCktuCkvuCkruCkpuClh+CkluCkr+CkueClgOCksOCkvuCkr+CkluClgeCkpuCksuCkl+ClgGNhdGVnb3JpZXNleHBlcmllbmNlPC90aXRsZT4NCkNvcHlyaWdodCBqYXZhc2NyaXB0Y29uZGl0aW9uc2V2ZXJ5dGhpbmc8cCBjbGFzcz0idGVjaG5vbG9neWJhY2tncm91bmQ8YSBjbGFzcz0ibWFuYWdlbWVudCZjb3B5OyAyMDFqYXZhU2NyaXB0Y2hhcmFjdGVyc2JyZWFkY3J1bWJ0aGVtc2VsdmVzaG9yaXpvbnRhbGdvdmVybm1lbnRDYWxpZm9ybmlhYWN0aXZpdGllc2Rpc2NvdmVyZWROYXZpZ2F0aW9udHJhbnNpdGlvbmNvbm5lY3Rpb25uYXZpZ2F0aW9uYXBwZWFyYW5jZTwvdGl0bGU+PG1jaGVja2JveCIgdGVjaG5pcXVlc3Byb3RlY3Rpb25hcHBhcmVudGx5YXMgd2VsbCBhc3VudCcsICdVQS1yZXNvbHV0aW9ub3BlcmF0aW9uc3RlbGV2aXNpb250cmFuc2xhdGVkV2FzaGluZ3Rvbm5hdmlnYXRvci4gPSB3aW5kb3cuaW1wcmVzc2lvbiZsdDticiZndDtsaXRlcmF0dXJlcG9wdWxhdGlvbmJnY29sb3I9IiNlc3BlY2lhbGx5IGNvbnRlbnQ9InByb2R1Y3Rpb25uZXdzbGV0dGVycHJvcGVydGllc2RlZmluaXRpb25sZWFkZXJzaGlwVGVjaG5vbG9neVBhcmxpYW1lbnRjb21wYXJpc29udWwgY2xhc3M9Ii5pbmRleE9mKCJjb25jbHVzaW9uZGlzY3Vzc2lvbmNvbXBvbmVudHNiaW9sb2dpY2FsUmV2b2x1dGlvbl9jb250YWluZXJ1bmRlcnN0b29kbm9zY3JpcHQ+PHBlcm1pc3Npb25lYWNoIG90aGVyYXRtb3NwaGVyZSBvbmZvY3VzPSI8Zm9ybSBpZD0icHJvY2Vzc2luZ3RoaXMudmFsdWVnZW5lcmF0aW9uQ29uZmVyZW5jZXN1YnNlcXVlbnR3ZWxsLWtub3dudmFyaWF0aW9uc3JlcHV0YXRpb25waGVub21lbm9uZGlzY2lwbGluZWxvZ28ucG5nIiAoZG9jdW1lbnQsYm91bmRhcmllc2V4cHJlc3Npb25zZXR0bGVtZW50QmFja2dyb3VuZG91dCBvZiB0aGVlbnRlcnByaXNlKCJodHRwczoiIHVuZXNjYXBlKCJwYXNzd29yZCIgZGVtb2NyYXRpYzxhIGhyZWY9Ii93cmFwcGVyIj4KbWVtYmVyc2hpcGxpbmd1aXN0aWNweDtwYWRkaW5ncGhpbG9zb3BoeWFzc2lzdGFuY2V1bml2ZXJzaXR5ZmFjaWxpdGllc3JlY29nbml6ZWRwcmVmZXJlbmNlaWYgKHR5cGVvZm1haW50YWluZWR2b2NhYnVsYXJ5aHlwb3RoZXNpcy5zdWJtaXQoKTsmYW1wO25ic3A7YW5ub3RhdGlvbmJlaGluZCB0aGVGb3VuZGF0aW9ucHVibGlzaGVyImFzc3VtcHRpb25pbnRyb2R1Y2VkY29ycnVwdGlvbnNjaWVudGlzdHNleHBsaWNpdGx5aW5zdGVhZCBvZmRpbWVuc2lvbnMgb25DbGljaz0iY29uc2lkZXJlZGRlcGFydG1lbnRvY2N1cGF0aW9uc29vbiBhZnRlcmludmVzdG1lbnRwcm9ub3VuY2VkaWRlbnRpZmllZGV4cGVyaW1lbnRNYW5hZ2VtZW50Z2VvZ3JhcGhpYyIgaGVpZ2h0PSJsaW5rIHJlbD0iLnJlcGxhY2UoL2RlcHJlc3Npb25jb25mZXJlbmNlcHVuaXNobWVudGVsaW1pbmF0ZWRyZXNpc3RhbmNlYWRhcHRhdGlvbm9wcG9zaXRpb253ZWxsIGtub3duc3VwcGxlbWVudGRldGVybWluZWRoMSBjbGFzcz0iMHB4O21hcmdpbm1lY2hhbmljYWxzdGF0aXN0aWNzY2VsZWJyYXRlZEdvdmVybm1lbnQKCkR1cmluZyB0ZGV2ZWxvcGVyc2FydGlmaWNpYWxlcXVpdmFsZW50b3JpZ2luYXRlZENvbW1pc3Npb25hdHRhY2htZW50PHNwYW4gaWQ9InRoZXJlIHdlcmVOZWRlcmxhbmRzYmV5b25kIHRoZXJlZ2lzdGVyZWRqb3VybmFsaXN0ZnJlcXVlbnRseWFsbCBvZiB0aGVsYW5nPSJlbiIgPC9zdHlsZT4NCmFic29sdXRlOyBzdXBwb3J0aW5nZXh0cmVtZWx5IG1haW5zdHJlYW08L3N0cm9uZz4gcG9wdWxhcml0eWVtcGxveW1lbnQ8L3RhYmxlPg0KIGNvbHNwYW49IjwvZm9ybT4KICBjb252ZXJzaW9uYWJvdXQgdGhlIDwvcD48L2Rpdj5pbnRlZ3JhdGVkIiBsYW5nPSJlblBvcnR1Z3Vlc2VzdWJzdGl0dXRlaW5kaXZpZHVhbGltcG9zc2libGVtdWx0aW1lZGlhYWxtb3N0IGFsbHB4IHNvbGlkICNhcGFydCBmcm9tc3ViamVjdCB0b2luIEVuZ2xpc2hjcml0aWNpemVkZXhjZXB0IGZvcmd1aWRlbGluZXNvcmlnaW5hbGx5cmVtYXJrYWJsZXRoZSBzZWNvbmRoMiBjbGFzcz0iPGEgdGl0bGU9IihpbmNsdWRpbmdwYXJhbWV0ZXJzcHJvaGliaXRlZD0gImh0dHA6Ly9kaWN0aW9uYXJ5cGVyY2VwdGlvbnJldm9sdXRpb25mb3VuZGF0aW9ucHg7aGVpZ2h0OnN1Y2Nlc3NmdWxzdXBwb3J0ZXJzbWlsbGVubml1bWhpcyBmYXRoZXJ0aGUgJnF1b3Q7bm8tcmVwZWF0O2NvbW1lcmNpYWxpbmR1c3RyaWFsZW5jb3VyYWdlZGFtb3VudCBvZiB1bm9mZmljaWFsZWZmaWNpZW5jeVJlZmVyZW5jZXNjb29yZGluYXRlZGlzY2xhaW1lcmV4cGVkaXRpb25kZXZlbG9waW5nY2FsY3VsYXRlZHNpbXBsaWZpZWRsZWdpdGltYXRlc3Vic3RyaW5nKDAiIGNsYXNzPSJjb21wbGV0ZWx5aWxsdXN0cmF0ZWZpdmUgeWVhcnNpbnN0cnVtZW50UHVibGlzaGluZzEiIGNsYXNzPSJwc3ljaG9sb2d5Y29uZmlkZW5jZW51bWJlciBvZiBhYnNlbmNlIG9mZm9jdXNlZCBvbmpvaW5lZCB0aGVzdHJ1Y3R1cmVzcHJldmlvdXNseT48L2lmcmFtZT5vbmNlIGFnYWluYnV0IHJhdGhlcmltbWlncmFudHNvZiBjb3Vyc2UsYSBncm91cCBvZkxpdGVyYXR1cmVVbmxpa2UgdGhlPC9hPiZuYnNwOwpmdW5jdGlvbiBpdCB3YXMgdGhlQ29udmVudGlvbmF1dG9tb2JpbGVQcm90ZXN0YW50YWdncmVzc2l2ZWFmdGVyIHRoZSBTaW1pbGFybHksIiAvPjwvZGl2PmNvbGxlY3Rpb24NCmZ1bmN0aW9udmlzaWJpbGl0eXRoZSB1c2Ugb2Z2b2x1bnRlZXJzYXR0cmFjdGlvbnVuZGVyIHRoZSB0aHJlYXRlbmVkKjwhW0NEQVRBW2ltcG9ydGFuY2VpbiBnZW5lcmFsdGhlIGxhdHRlcjwvZm9ybT4KPC8uaW5kZXhPZignaSA9IDA7IGkgPGRpZmZlcmVuY2VkZXZvdGVkIHRvdHJhZGl0aW9uc3NlYXJjaCBmb3J1bHRpbWF0ZWx5dG91cm5hbWVudGF0dHJpYnV0ZXNzby1jYWxsZWQgfQo8L3N0eWxlPmV2YWx1YXRpb25lbXBoYXNpemVkYWNjZXNzaWJsZTwvc2VjdGlvbj5zdWNjZXNzaW9uYWxvbmcgd2l0aE1lYW53aGlsZSxpbmR1c3RyaWVzPC9hPjxiciAvPmhhcyBiZWNvbWVhc3BlY3RzIG9mVGVsZXZpc2lvbnN1ZmZpY2llbnRiYXNrZXRiYWxsYm90aCBzaWRlc2NvbnRpbnVpbmdhbiBhcnRpY2xlPGltZyBhbHQ9ImFkdmVudHVyZXNoaXMgbW90aGVybWFuY2hlc3RlcnByaW5jaXBsZXNwYXJ0aWN1bGFyY29tbWVudGFyeWVmZmVjdHMgb2ZkZWNpZGVkIHRvIj48c3Ryb25nPnB1Ymxpc2hlcnNKb3VybmFsIG9mZGlmZmljdWx0eWZhY2lsaXRhdGVhY2NlcHRhYmxlc3R5bGUuY3NzIglmdW5jdGlvbiBpbm5vdmF0aW9uPkNvcHlyaWdodHNpdHVhdGlvbnN3b3VsZCBoYXZlYnVzaW5lc3Nlc0RpY3Rpb25hcnlzdGF0ZW1lbnRzb2Z0ZW4gdXNlZHBlcnNpc3RlbnRpbiBKYW51YXJ5Y29tcHJpc2luZzwvdGl0bGU+CglkaXBsb21hdGljY29udGFpbmluZ3BlcmZvcm1pbmdleHRlbnNpb25zbWF5IG5vdCBiZWNvbmNlcHQgb2Ygb25jbGljaz0iSXQgaXMgYWxzb2ZpbmFuY2lhbCBtYWtpbmcgdGhlTHV4ZW1ib3VyZ2FkZGl0aW9uYWxhcmUgY2FsbGVkZW5nYWdlZCBpbiJzY3JpcHQiKTtidXQgaXQgd2FzZWxlY3Ryb25pY29uc3VibWl0PSIKPCEtLSBFbmQgZWxlY3RyaWNhbG9mZmljaWFsbHlzdWdnZXN0aW9udG9wIG9mIHRoZXVubGlrZSB0aGVBdXN0cmFsaWFuT3JpZ2luYWxseXJlZmVyZW5jZXMKPC9oZWFkPg0KcmVjb2duaXNlZGluaXRpYWxpemVsaW1pdGVkIHRvQWxleGFuZHJpYXJldGlyZW1lbnRBZHZlbnR1cmVzZm91ciB5ZWFycwoKJmx0OyEtLSBpbmNyZWFzaW5nZGVjb3JhdGlvbmgzIGNsYXNzPSJvcmlnaW5zIG9mb2JsaWdhdGlvbnJlZ3VsYXRpb25jbGFzc2lmaWVkKGZ1bmN0aW9uKGFkdmFudGFnZXNiZWluZyB0aGUgaGlzdG9yaWFuczxiYXNlIGhyZWZyZXBlYXRlZGx5d2lsbGluZyB0b2NvbXBhcmFibGVkZXNpZ25hdGVkbm9taW5hdGlvbmZ1bmN0aW9uYWxpbnNpZGUgdGhlcmV2ZWxhdGlvbmVuZCBvZiB0aGVzIGZvciB0aGUgYXV0aG9yaXplZHJlZnVzZWQgdG90YWtlIHBsYWNlYXV0b25vbW91c2NvbXByb21pc2Vwb2xpdGljYWwgcmVzdGF1cmFudHR3byBvZiB0aGVGZWJydWFyeSAycXVhbGl0eSBvZnN3Zm9iamVjdC51bmRlcnN0YW5kbmVhcmx5IGFsbHdyaXR0ZW4gYnlpbnRlcnZpZXdzIiB3aWR0aD0iMXdpdGhkcmF3YWxmbG9hdDpsZWZ0aXMgdXN1YWxseWNhbmRpZGF0ZXNuZXdzcGFwZXJzbXlzdGVyaW91c0RlcGFydG1lbnRiZXN0IGtub3ducGFybGlhbWVudHN1cHByZXNzZWRjb252ZW5pZW50cmVtZW1iZXJlZGRpZmZlcmVudCBzeXN0ZW1hdGljaGFzIGxlZCB0b3Byb3BhZ2FuZGFjb250cm9sbGVkaW5mbHVlbmNlc2NlcmVtb25pYWxwcm9jbGFpbWVkUHJvdGVjdGlvbmxpIGNsYXNzPSJTY2llbnRpZmljY2xhc3M9Im5vLXRyYWRlbWFya3Ntb3JlIHRoYW4gd2lkZXNwcmVhZExpYmVyYXRpb250b29rIHBsYWNlZGF5IG9mIHRoZWFzIGxvbmcgYXNpbXByaXNvbmVkQWRkaXRpb25hbAo8aGVhZD4KPG1MYWJvcmF0b3J5Tm92ZW1iZXIgMmV4Y2VwdGlvbnNJbmR1c3RyaWFsdmFyaWV0eSBvZmZsb2F0OiBsZWZEdXJpbmcgdGhlYXNzZXNzbWVudGhhdmUgYmVlbiBkZWFscyB3aXRoU3RhdGlzdGljc29jY3VycmVuY2UvdWw+PC9kaXY+Y2xlYXJmaXgiPnRoZSBwdWJsaWNtYW55IHllYXJzd2hpY2ggd2VyZW92ZXIgdGltZSxzeW5vbnltb3VzY29udGVudCI+CnByZXN1bWFibHloaXMgZmFtaWx5dXNlckFnZW50LnVuZXhwZWN0ZWRpbmNsdWRpbmcgY2hhbGxlbmdlZGEgbWlub3JpdHl1bmRlZmluZWQiYmVsb25ncyB0b3Rha2VuIGZyb21pbiBPY3RvYmVycG9zaXRpb246IHNhaWQgdG8gYmVyZWxpZ2lvdXMgRmVkZXJhdGlvbiByb3dzcGFuPSJvbmx5IGEgZmV3bWVhbnQgdGhhdGxlZCB0byB0aGUtLT4NCjxkaXYgPGZpZWxkc2V0PkFyY2hiaXNob3AgY2xhc3M9Im5vYmVpbmcgdXNlZGFwcHJvYWNoZXNwcml2aWxlZ2Vzbm9zY3JpcHQ+CnJlc3VsdHMgaW5tYXkgYmUgdGhlRWFzdGVyIGVnZ21lY2hhbmlzbXNyZWFzb25hYmxlUG9wdWxhdGlvbkNvbGxlY3Rpb25zZWxlY3RlZCI+bm9zY3JpcHQ+DS9pbmRleC5waHBhcnJpdmFsIG9mLWpzc2RrJykpO21hbmFnZWQgdG9pbmNvbXBsZXRlY2FzdWFsdGllc2NvbXBsZXRpb25DaHJpc3RpYW5zU2VwdGVtYmVyIGFyaXRobWV0aWNwcm9jZWR1cmVzbWlnaHQgaGF2ZVByb2R1Y3Rpb25pdCBhcHBlYXJzUGhpbG9zb3BoeWZyaWVuZHNoaXBsZWFkaW5nIHRvZ2l2aW5nIHRoZXRvd2FyZCB0aGVndWFyYW50ZWVkZG9jdW1lbnRlZGNvbG9yOiMwMDB2aWRlbyBnYW1lY29tbWlzc2lvbnJlZmxlY3RpbmdjaGFuZ2UgdGhlYXNzb2NpYXRlZHNhbnMtc2VyaWZvbmtleXByZXNzOyBwYWRkaW5nOkhlIHdhcyB0aGV1bmRlcmx5aW5ndHlwaWNhbGx5ICwgYW5kIHRoZSBzcmNFbGVtZW50c3VjY2Vzc2l2ZXNpbmNlIHRoZSBzaG91bGQgYmUgbmV0d29ya2luZ2FjY291bnRpbmd1c2Ugb2YgdGhlbG93ZXIgdGhhbnNob3dzIHRoYXQ8L3NwYW4+CgkJY29tcGxhaW50c2NvbnRpbnVvdXNxdWFudGl0aWVzYXN0cm9ub21lcmhlIGRpZCBub3RkdWUgdG8gaXRzYXBwbGllZCB0b2FuIGF2ZXJhZ2VlZmZvcnRzIHRvdGhlIGZ1dHVyZWF0dGVtcHQgdG9UaGVyZWZvcmUsY2FwYWJpbGl0eVJlcHVibGljYW53YXMgZm9ybWVkRWxlY3Ryb25pY2tpbG9tZXRlcnNjaGFsbGVuZ2VzcHVibGlzaGluZ3RoZSBmb3JtZXJpbmRpZ2Vub3VzZGlyZWN0aW9uc3N1YnNpZGlhcnljb25zcGlyYWN5ZGV0YWlscyBvZmFuZCBpbiB0aGVhZmZvcmRhYmxlc3Vic3RhbmNlc3JlYXNvbiBmb3Jjb252ZW50aW9uaXRlbXR5cGU9ImFic29sdXRlbHlzdXBwb3NlZGx5cmVtYWluZWQgYWF0dHJhY3RpdmV0cmF2ZWxsaW5nc2VwYXJhdGVseWZvY3VzZXMgb25lbGVtZW50YXJ5YXBwbGljYWJsZWZvdW5kIHRoYXRzdHlsZXNoZWV0bWFudXNjcmlwdHN0YW5kcyBmb3Igbm8tcmVwZWF0KHNvbWV0aW1lc0NvbW1lcmNpYWxpbiBBbWVyaWNhdW5kZXJ0YWtlbnF1YXJ0ZXIgb2ZhbiBleGFtcGxlcGVyc29uYWxseWluZGV4LnBocD88L2J1dHRvbj4KcGVyY2VudGFnZWJlc3Qta25vd25jcmVhdGluZyBhIiBkaXI9Imx0ckxpZXV0ZW5hbnQKPGRpdiBpZD0idGhleSB3b3VsZGFiaWxpdHkgb2ZtYWRlIHVwIG9mbm90ZWQgdGhhdGNsZWFyIHRoYXRhcmd1ZSB0aGF0dG8gYW5vdGhlcmNoaWxkcmVuJ3NwdXJwb3NlIG9mZm9ybXVsYXRlZGJhc2VkIHVwb250aGUgcmVnaW9uc3ViamVjdCBvZnBhc3NlbmdlcnNwb3NzZXNzaW9uLgoKSW4gdGhlIEJlZm9yZSB0aGVhZnRlcndhcmRzY3VycmVudGx5IGFjcm9zcyB0aGVzY2llbnRpZmljY29tbXVuaXR5LmNhcGl0YWxpc21pbiBHZXJtYW55cmlnaHQtd2luZ3RoZSBzeXN0ZW1Tb2NpZXR5IG9mcG9saXRpY2lhbmRpcmVjdGlvbjp3ZW50IG9uIHRvcmVtb3ZhbCBvZiBOZXcgWW9yayBhcGFydG1lbnRzaW5kaWNhdGlvbmR1cmluZyB0aGV1bmxlc3MgdGhlaGlzdG9yaWNhbGhhZCBiZWVuIGFkZWZpbml0aXZlaW5ncmVkaWVudGF0dGVuZGFuY2VDZW50ZXIgZm9ycHJvbWluZW5jZXJlYWR5U3RhdGVzdHJhdGVnaWVzYnV0IGluIHRoZWFzIHBhcnQgb2Zjb25zdGl0dXRlY2xhaW0gdGhhdGxhYm9yYXRvcnljb21wYXRpYmxlZmFpbHVyZSBvZiwgc3VjaCBhcyBiZWdhbiB3aXRodXNpbmcgdGhlIHRvIHByb3ZpZGVmZWF0dXJlIG9mZnJvbSB3aGljaC8iIGNsYXNzPSJnZW9sb2dpY2Fsc2V2ZXJhbCBvZmRlbGliZXJhdGVpbXBvcnRhbnQgaG9sZHMgdGhhdGluZyZxdW90OyB2YWxpZ249dG9wdGhlIEdlcm1hbm91dHNpZGUgb2ZuZWdvdGlhdGVkaGlzIGNhcmVlcnNlcGFyYXRpb25pZD0ic2VhcmNod2FzIGNhbGxlZHRoZSBmb3VydGhyZWNyZWF0aW9ub3RoZXIgdGhhbnByZXZlbnRpb253aGlsZSB0aGUgZWR1Y2F0aW9uLGNvbm5lY3RpbmdhY2N1cmF0ZWx5d2VyZSBidWlsdHdhcyBraWxsZWRhZ3JlZW1lbnRzbXVjaCBtb3JlIER1ZSB0byB0aGV3aWR0aDogMTAwc29tZSBvdGhlcktpbmdkb20gb2Z0aGUgZW50aXJlZmFtb3VzIGZvcnRvIGNvbm5lY3RvYmplY3RpdmVzdGhlIEZyZW5jaHBlb3BsZSBhbmRmZWF0dXJlZCI+aXMgc2FpZCB0b3N0cnVjdHVyYWxyZWZlcmVuZHVtbW9zdCBvZnRlbmEgc2VwYXJhdGUtPgo8ZGl2IGlkIE9mZmljaWFsIHdvcmxkd2lkZS5hcmlhLWxhYmVsdGhlIHBsYW5ldGFuZCBpdCB3YXNkIiB2YWx1ZT0ibG9va2luZyBhdGJlbmVmaWNpYWxhcmUgaW4gdGhlbW9uaXRvcmluZ3JlcG9ydGVkbHl0aGUgbW9kZXJud29ya2luZyBvbmFsbG93ZWQgdG93aGVyZSB0aGUgaW5ub3ZhdGl2ZTwvYT48L2Rpdj5zb3VuZHRyYWNrc2VhcmNoRm9ybXRlbmQgdG8gYmVpbnB1dCBpZD0ib3BlbmluZyBvZnJlc3RyaWN0ZWRhZG9wdGVkIGJ5YWRkcmVzc2luZ3RoZW9sb2dpYW5tZXRob2RzIG9mdmFyaWFudCBvZkNocmlzdGlhbiB2ZXJ5IGxhcmdlYXV0b21vdGl2ZWJ5IGZhciB0aGVyYW5nZSBmcm9tcHVyc3VpdCBvZmZvbGxvdyB0aGVicm91Z2h0IHRvaW4gRW5nbGFuZGFncmVlIHRoYXRhY2N1c2VkIG9mY29tZXMgZnJvbXByZXZlbnRpbmdkaXYgc3R5bGU9aGlzIG9yIGhlcnRyZW1lbmRvdXNmcmVlZG9tIG9mY29uY2VybmluZzAgMWVtIDFlbTtCYXNrZXRiYWxsL3N0eWxlLmNzc2FuIGVhcmxpZXJldmVuIGFmdGVyLyIgdGl0bGU9Ii5jb20vaW5kZXh0YWtpbmcgdGhlcGl0dHNidXJnaGNvbnRlbnQiPg08c2NyaXB0PihmdHVybmVkIG91dGhhdmluZyB0aGU8L3NwYW4+DQogb2NjYXNpb25hbGJlY2F1c2UgaXRzdGFydGVkIHRvcGh5c2ljYWxseT48L2Rpdj4KICBjcmVhdGVkIGJ5Q3VycmVudGx5LCBiZ2NvbG9yPSJ0YWJpbmRleD0iZGlzYXN0cm91c0FuYWx5dGljcyBhbHNvIGhhcyBhPjxkaXYgaWQ9Ijwvc3R5bGU+CjxjYWxsZWQgZm9yc2luZ2VyIGFuZC5zcmMgPSAiLy92aW9sYXRpb25zdGhpcyBwb2ludGNvbnN0YW50bHlpcyBsb2NhdGVkcmVjb3JkaW5nc2QgZnJvbSB0aGVuZWRlcmxhbmRzcG9ydHVndcOqc9ei15HXqNeZ16rZgdin2LHYs9uMZGVzYXJyb2xsb2NvbWVudGFyaW9lZHVjYWNpw7Nuc2VwdGllbWJyZXJlZ2lzdHJhZG9kaXJlY2Npw7NudWJpY2FjacOzbnB1YmxpY2lkYWRyZXNwdWVzdGFzcmVzdWx0YWRvc2ltcG9ydGFudGVyZXNlcnZhZG9zYXJ0w61jdWxvc2RpZmVyZW50ZXNzaWd1aWVudGVzcmVww7pibGljYXNpdHVhY2nDs25taW5pc3RlcmlvcHJpdmFjaWRhZGRpcmVjdG9yaW9mb3JtYWNpw7NucG9ibGFjacOzbnByZXNpZGVudGVjb250ZW5pZG9zYWNjZXNvcmlvc3RlY2hub3JhdGlwZXJzb25hbGVzY2F0ZWdvcsOtYWVzcGVjaWFsZXNkaXNwb25pYmxlYWN0dWFsaWRhZHJlZmVyZW5jaWF2YWxsYWRvbGlkYmlibGlvdGVjYXJlbGFjaW9uZXNjYWxlbmRhcmlvcG9sw610aWNhc2FudGVyaW9yZXNkb2N1bWVudG9zbmF0dXJhbGV6YW1hdGVyaWFsZXNkaWZlcmVuY2lhZWNvbsOzbWljYXRyYW5zcG9ydGVyb2Ryw61ndWV6cGFydGljaXBhcmVuY3VlbnRyYW5kaXNjdXNpw7NuZXN0cnVjdHVyYWZ1bmRhY2nDs25mcmVjdWVudGVzcGVybWFuZW50ZXRvdGFsbWVudGXQvNC+0LbQvdC+0LHRg9C00LXRgtC80L7QttC10YLQstGA0LXQvNGP0YLQsNC60LbQtdGH0YLQvtCx0YvQsdC+0LvQtdC10L7Rh9C10L3RjNGN0YLQvtCz0L7QutC+0LPQtNCw0L/QvtGB0LvQtdCy0YHQtdCz0L7RgdCw0LnRgtC10YfQtdGA0LXQt9C80L7Qs9GD0YLRgdCw0LnRgtCw0LbQuNC30L3QuNC80LXQttC00YPQsdGD0LTRg9GC0J/QvtC40YHQutC30LTQtdGB0YzQstC40LTQtdC+0YHQstGP0LfQuNC90YPQttC90L7RgdCy0L7QtdC50LvRjtC00LXQudC/0L7RgNC90L7QvNC90L7Qs9C+0LTQtdGC0LXQudGB0LLQvtC40YXQv9GA0LDQstCw0YLQsNC60L7QudC80LXRgdGC0L7QuNC80LXQtdGC0LbQuNC30L3RjNC+0LTQvdC+0LnQu9GD0YfRiNC10L/QtdGA0LXQtNGH0LDRgdGC0LjRh9Cw0YHRgtGM0YDQsNCx0L7RgtC90L7QstGL0YXQv9GA0LDQstC+0YHQvtCx0L7QudC/0L7RgtC+0LzQvNC10L3QtdC10YfQuNGB0LvQtdC90L7QstGL0LXRg9GB0LvRg9Cz0L7QutC+0LvQvtC90LDQt9Cw0LTRgtCw0LrQvtC10YLQvtCz0LTQsNC/0L7Rh9GC0LjQn9C+0YHQu9C10YLQsNC60LjQtdC90L7QstGL0LnRgdGC0L7QuNGC0YLQsNC60LjRhdGB0YDQsNC30YPQodCw0L3QutGC0YTQvtGA0YPQvNCa0L7Qs9C00LDQutC90LjQs9C40YHQu9C+0LLQsNC90LDRiNC10LnQvdCw0LnRgtC40YHQstC+0LjQvNGB0LLRj9C30YzQu9GO0LHQvtC50YfQsNGB0YLQvtGB0YDQtdC00LjQmtGA0L7QvNC10KTQvtGA0YPQvNGA0YvQvdC60LXRgdGC0LDQu9C40L/QvtC40YHQutGC0YvRgdGP0YfQvNC10YHRj9GG0YbQtdC90YLRgNGC0YDRg9C00LDRgdCw0LzRi9GF0YDRi9C90LrQsNCd0L7QstGL0LnRh9Cw0YHQvtCy0LzQtdGB0YLQsNGE0LjQu9GM0LzQvNCw0YDRgtCw0YHRgtGA0LDQvdC80LXRgdGC0LXRgtC10LrRgdGC0L3QsNGI0LjRhdC80LjQvdGD0YLQuNC80LXQvdC40LjQvNC10Y7RgtC90L7QvNC10YDQs9C+0YDQvtC00YHQsNC80L7QvNGN0YLQvtC80YPQutC+0L3RhtC10YHQstC+0LXQvNC60LDQutC+0LnQkNGA0YXQuNCy2YXZhtiq2K/Zidil2LHYs9in2YTYsdiz2KfZhNip2KfZhNi52KfZhdmD2KrYqNmH2KfYqNix2KfZhdis2KfZhNmK2YjZhdin2YTYtdmI2LHYrNiv2YrYr9ip2KfZhNi52LbZiNil2LbYp9mB2KnYp9mE2YLYs9mF2KfZhNi52KfYqNiq2K3ZhdmK2YTZhdmE2YHYp9iq2YXZhNiq2YLZidiq2LnYr9mK2YTYp9mE2LTYudix2KPYrtio2KfYsdiq2LfZiNmK2LHYudmE2YrZg9mF2KXYsdmB2KfZgti32YTYqNin2KrYp9mE2YTYutip2KrYsdiq2YrYqNin2YTZhtin2LPYp9mE2LTZitiu2YXZhtiq2K/Zitin2YTYudix2KjYp9mE2YLYtdi12KfZgdmE2KfZhdi52YTZitmH2KfYqtit2K/Zitir2KfZhNmE2YfZhdin2YTYudmF2YTZhdmD2KrYqNip2YrZhdmD2YbZg9in2YTYt9mB2YTZgdmK2K/ZitmI2KXYr9in2LHYqdiq2KfYsdmK2K7Yp9mE2LXYrdip2KrYs9is2YrZhNin2YTZiNmC2KrYudmG2K/Zhdin2YXYr9mK2YbYqdiq2LXZhdmK2YXYo9ix2LTZitmB2KfZhNiw2YrZhti52LHYqNmK2KnYqNmI2KfYqNip2KPZhNi52KfYqNin2YTYs9mB2LHZhdi02KfZg9mE2KrYudin2YTZidin2YTYo9mI2YTYp9mE2LPZhtip2KzYp9mF2LnYqdin2YTYtdit2YHYp9mE2K/ZitmG2YPZhNmF2KfYqtin2YTYrtin2LXYp9mE2YXZhNmB2KPYudi22KfYodmD2KrYp9io2KnYp9mE2K7Zitix2LHYs9in2KbZhNin2YTZgtmE2KjYp9mE2KPYr9io2YXZgtin2LfYudmF2LHYp9iz2YTZhdmG2LfZgtip2KfZhNmD2KrYqNin2YTYsdis2YTYp9i02KrYsdmD2KfZhNmC2K/ZhdmK2LnYt9mK2YNzQnlUYWdOYW1lKC5qcGciIGFsdD0iMXB4IHNvbGlkICMuZ2lmIiBhbHQ9InRyYW5zcGFyZW50aW5mb3JtYXRpb25hcHBsaWNhdGlvbiIgb25jbGljaz0iZXN0YWJsaXNoZWRhZHZlcnRpc2luZy5wbmciIGFsdD0iZW52aXJvbm1lbnRwZXJmb3JtYW5jZWFwcHJvcHJpYXRlJmFtcDttZGFzaDtpbW1lZGlhdGVseTwvc3Ryb25nPjwvcmF0aGVyIHRoYW50ZW1wZXJhdHVyZWRldmVsb3BtZW50Y29tcGV0aXRpb25wbGFjZWhvbGRlcnZpc2liaWxpdHk6Y29weXJpZ2h0Ij4wIiBoZWlnaHQ9ImV2ZW4gdGhvdWdocmVwbGFjZW1lbnRkZXN0aW5hdGlvbkNvcnBvcmF0aW9uPHVsIGNsYXNzPSJBc3NvY2lhdGlvbmluZGl2aWR1YWxzcGVyc3BlY3RpdmVzZXRUaW1lb3V0KHVybChodHRwOi8vbWF0aGVtYXRpY3NtYXJnaW4tdG9wOmV2ZW50dWFsbHkgZGVzY3JpcHRpb24pIG5vLXJlcGVhdGNvbGxlY3Rpb25zLkpQR3x0aHVtYnxwYXJ0aWNpcGF0ZS9oZWFkPjxib2R5ZmxvYXQ6bGVmdDs8bGkgY2xhc3M9Imh1bmRyZWRzIG9mCgpIb3dldmVyLCBjb21wb3NpdGlvbmNsZWFyOmJvdGg7Y29vcGVyYXRpb253aXRoaW4gdGhlIGxhYmVsIGZvcj0iYm9yZGVyLXRvcDpOZXcgWmVhbGFuZHJlY29tbWVuZGVkcGhvdG9ncmFwaHlpbnRlcmVzdGluZyZsdDtzdXAmZ3Q7Y29udHJvdmVyc3lOZXRoZXJsYW5kc2FsdGVybmF0aXZlbWF4bGVuZ3RoPSJzd2l0emVybGFuZERldmVsb3BtZW50ZXNzZW50aWFsbHkKCkFsdGhvdWdoIDwvdGV4dGFyZWE+dGh1bmRlcmJpcmRyZXByZXNlbnRlZCZhbXA7bmRhc2g7c3BlY3VsYXRpb25jb21tdW5pdGllc2xlZ2lzbGF0aW9uZWxlY3Ryb25pY3MKCTxkaXYgaWQ9ImlsbHVzdHJhdGVkZW5naW5lZXJpbmd0ZXJyaXRvcmllc2F1dGhvcml0aWVzZGlzdHJpYnV0ZWQ2IiBoZWlnaHQ9InNhbnMtc2VyaWY7Y2FwYWJsZSBvZiBkaXNhcHBlYXJlZGludGVyYWN0aXZlbG9va2luZyBmb3JpdCB3b3VsZCBiZUFmZ2hhbmlzdGFud2FzIGNyZWF0ZWRNYXRoLmZsb29yKHN1cnJvdW5kaW5nY2FuIGFsc28gYmVvYnNlcnZhdGlvbm1haW50ZW5hbmNlZW5jb3VudGVyZWQ8aDIgY2xhc3M9Im1vcmUgcmVjZW50aXQgaGFzIGJlZW5pbnZhc2lvbiBvZikuZ2V0VGltZSgpZnVuZGFtZW50YWxEZXNwaXRlIHRoZSI+PGRpdiBpZD0iaW5zcGlyYXRpb25leGFtaW5hdGlvbnByZXBhcmF0aW9uZXhwbGFuYXRpb248aW5wdXQgaWQ9IjwvYT48L3NwYW4+dmVyc2lvbnMgb2ZpbnN0cnVtZW50c2JlZm9yZSB0aGUgID0gJ2h0dHA6Ly9EZXNjcmlwdGlvbnJlbGF0aXZlbHkgLnN1YnN0cmluZyhlYWNoIG9mIHRoZWV4cGVyaW1lbnRzaW5mbHVlbnRpYWxpbnRlZ3JhdGlvbm1hbnkgcGVvcGxlZHVlIHRvIHRoZSBjb21iaW5hdGlvbmRvIG5vdCBoYXZlTWlkZGxlIEVhc3Q8bm9zY3JpcHQ+PGNvcHlyaWdodCIgcGVyaGFwcyB0aGVpbnN0aXR1dGlvbmluIERlY2VtYmVyYXJyYW5nZW1lbnRtb3N0IGZhbW91c3BlcnNvbmFsaXR5Y3JlYXRpb24gb2ZsaW1pdGF0aW9uc2V4Y2x1c2l2ZWx5c292ZXJlaWdudHktY29udGVudCI+Cjx0ZCBjbGFzcz0idW5kZXJncm91bmRwYXJhbGxlbCB0b2RvY3RyaW5lIG9mb2NjdXBpZWQgYnl0ZXJtaW5vbG9neVJlbmFpc3NhbmNlYSBudW1iZXIgb2ZzdXBwb3J0IGZvcmV4cGxvcmF0aW9ucmVjb2duaXRpb25wcmVkZWNlc3NvcjxpbWcgc3JjPSIvPGgxIGNsYXNzPSJwdWJsaWNhdGlvbm1heSBhbHNvIGJlc3BlY2lhbGl6ZWQ8L2ZpZWxkc2V0PnByb2dyZXNzaXZlbWlsbGlvbnMgb2ZzdGF0ZXMgdGhhdGVuZm9yY2VtZW50YXJvdW5kIHRoZSBvbmUgYW5vdGhlci5wYXJlbnROb2RlYWdyaWN1bHR1cmVBbHRlcm5hdGl2ZXJlc2VhcmNoZXJzdG93YXJkcyB0aGVNb3N0IG9mIHRoZW1hbnkgb3RoZXIgKGVzcGVjaWFsbHk8dGQgd2lkdGg9Ijt3aWR0aDoxMDAlaW5kZXBlbmRlbnQ8aDMgY2xhc3M9IiBvbmNoYW5nZT0iKS5hZGRDbGFzcyhpbnRlcmFjdGlvbk9uZSBvZiB0aGUgZGF1Z2h0ZXIgb2ZhY2Nlc3Nvcmllc2JyYW5jaGVzIG9mDQo8ZGl2IGlkPSJ0aGUgbGFyZ2VzdGRlY2xhcmF0aW9ucmVndWxhdGlvbnNJbmZvcm1hdGlvbnRyYW5zbGF0aW9uZG9jdW1lbnRhcnlpbiBvcmRlciB0byI+CjxoZWFkPgo8IiBoZWlnaHQ9IjFhY3Jvc3MgdGhlIG9yaWVudGF0aW9uKTs8L3NjcmlwdD5pbXBsZW1lbnRlZGNhbiBiZSBzZWVudGhlcmUgd2FzIGFkZW1vbnN0cmF0ZWNvbnRhaW5lciI+Y29ubmVjdGlvbnN0aGUgQnJpdGlzaHdhcyB3cml0dGVuIWltcG9ydGFudDtweDsgbWFyZ2luLWZvbGxvd2VkIGJ5YWJpbGl0eSB0byBjb21wbGljYXRlZGR1cmluZyB0aGUgaW1taWdyYXRpb25hbHNvIGNhbGxlZDxoNCBjbGFzcz0iZGlzdGluY3Rpb25yZXBsYWNlZCBieWdvdmVybm1lbnRzbG9jYXRpb24gb2ZpbiBOb3ZlbWJlcndoZXRoZXIgdGhlPC9wPgo8L2Rpdj5hY3F1aXNpdGlvbmNhbGxlZCB0aGUgcGVyc2VjdXRpb25kZXNpZ25hdGlvbntmb250LXNpemU6YXBwZWFyZWQgaW5pbnZlc3RpZ2F0ZWV4cGVyaWVuY2VkbW9zdCBsaWtlbHl3aWRlbHkgdXNlZGRpc2N1c3Npb25zcHJlc2VuY2Ugb2YgKGRvY3VtZW50LmV4dGVuc2l2ZWx5SXQgaGFzIGJlZW5pdCBkb2VzIG5vdGNvbnRyYXJ5IHRvaW5oYWJpdGFudHNpbXByb3ZlbWVudHNjaG9sYXJzaGlwY29uc3VtcHRpb25pbnN0cnVjdGlvbmZvciBleGFtcGxlb25lIG9yIG1vcmVweDsgcGFkZGluZ3RoZSBjdXJyZW50YSBzZXJpZXMgb2ZhcmUgdXN1YWxseXJvbGUgaW4gdGhlcHJldmlvdXNseSBkZXJpdmF0aXZlc2V2aWRlbmNlIG9mZXhwZXJpZW5jZXNjb2xvcnNjaGVtZXN0YXRlZCB0aGF0Y2VydGlmaWNhdGU8L2E+PC9kaXY+CiBzZWxlY3RlZD0iaGlnaCBzY2hvb2xyZXNwb25zZSB0b2NvbWZvcnRhYmxlYWRvcHRpb24gb2Z0aHJlZSB5ZWFyc3RoZSBjb3VudHJ5aW4gRmVicnVhcnlzbyB0aGF0IHRoZXBlb3BsZSB3aG8gcHJvdmlkZWQgYnk8cGFyYW0gbmFtZWFmZmVjdGVkIGJ5aW4gdGVybXMgb2ZhcHBvaW50bWVudElTTy04ODU5LTEid2FzIGJvcm4gaW5oaXN0b3JpY2FsIHJlZ2FyZGVkIGFzbWVhc3VyZW1lbnRpcyBiYXNlZCBvbiBhbmQgb3RoZXIgOiBmdW5jdGlvbihzaWduaWZpY2FudGNlbGVicmF0aW9udHJhbnNtaXR0ZWQvanMvanF1ZXJ5LmlzIGtub3duIGFzdGhlb3JldGljYWwgdGFiaW5kZXg9Iml0IGNvdWxkIGJlPG5vc2NyaXB0PgpoYXZpbmcgYmVlbg0KPGhlYWQ+DQo8ICZxdW90O1RoZSBjb21waWxhdGlvbmhlIGhhZCBiZWVucHJvZHVjZWQgYnlwaGlsb3NvcGhlcmNvbnN0cnVjdGVkaW50ZW5kZWQgdG9hbW9uZyBvdGhlcmNvbXBhcmVkIHRvdG8gc2F5IHRoYXRFbmdpbmVlcmluZ2EgZGlmZmVyZW50cmVmZXJyZWQgdG9kaWZmZXJlbmNlc2JlbGllZiB0aGF0cGhvdG9ncmFwaHNpZGVudGlmeWluZ0hpc3Rvcnkgb2YgUmVwdWJsaWMgb2ZuZWNlc3NhcmlseXByb2JhYmlsaXR5dGVjaG5pY2FsbHlsZWF2aW5nIHRoZXNwZWN0YWN1bGFyZnJhY3Rpb24gb2ZlbGVjdHJpY2l0eWhlYWQgb2YgdGhlcmVzdGF1cmFudHNwYXJ0bmVyc2hpcGVtcGhhc2lzIG9ubW9zdCByZWNlbnRzaGFyZSB3aXRoIHNheWluZyB0aGF0ZmlsbGVkIHdpdGhkZXNpZ25lZCB0b2l0IGlzIG9mdGVuIj48L2lmcmFtZT5hcyBmb2xsb3dzOm1lcmdlZCB3aXRodGhyb3VnaCB0aGVjb21tZXJjaWFsIHBvaW50ZWQgb3V0b3Bwb3J0dW5pdHl2aWV3IG9mIHRoZXJlcXVpcmVtZW50ZGl2aXNpb24gb2Zwcm9ncmFtbWluZ2hlIHJlY2VpdmVkc2V0SW50ZXJ2YWwiPjwvc3Bhbj48L2luIE5ldyBZb3JrYWRkaXRpb25hbCBjb21wcmVzc2lvbgoKPGRpdiBpZD0iaW5jb3Jwb3JhdGU7PC9zY3JpcHQ+PGF0dGFjaEV2ZW50YmVjYW1lIHRoZSAiIHRhcmdldD0iX2NhcnJpZWQgb3V0U29tZSBvZiB0aGVzY2llbmNlIGFuZHRoZSB0aW1lIG9mQ29udGFpbmVyIj5tYWludGFpbmluZ0NocmlzdG9waGVyTXVjaCBvZiB0aGV3cml0aW5ncyBvZiIgaGVpZ2h0PSIyc2l6ZSBvZiB0aGV2ZXJzaW9uIG9mIG1peHR1cmUgb2YgYmV0d2VlbiB0aGVFeGFtcGxlcyBvZmVkdWNhdGlvbmFsY29tcGV0aXRpdmUgb25zdWJtaXQ9ImRpcmVjdG9yIG9mZGlzdGluY3RpdmUvRFREIFhIVE1MIHJlbGF0aW5nIHRvdGVuZGVuY3kgdG9wcm92aW5jZSBvZndoaWNoIHdvdWxkZGVzcGl0ZSB0aGVzY2llbnRpZmljIGxlZ2lzbGF0dXJlLmlubmVySFRNTCBhbGxlZ2F0aW9uc0FncmljdWx0dXJld2FzIHVzZWQgaW5hcHByb2FjaCB0b2ludGVsbGlnZW50eWVhcnMgbGF0ZXIsc2Fucy1zZXJpZmRldGVybWluaW5nUGVyZm9ybWFuY2VhcHBlYXJhbmNlcywgd2hpY2ggaXMgZm91bmRhdGlvbnNhYmJyZXZpYXRlZGhpZ2hlciB0aGFucyBmcm9tIHRoZSBpbmRpdmlkdWFsIGNvbXBvc2VkIG9mc3VwcG9zZWQgdG9jbGFpbXMgdGhhdGF0dHJpYnV0aW9uZm9udC1zaXplOjFlbGVtZW50cyBvZkhpc3RvcmljYWwgaGlzIGJyb3RoZXJhdCB0aGUgdGltZWFubml2ZXJzYXJ5Z292ZXJuZWQgYnlyZWxhdGVkIHRvIHVsdGltYXRlbHkgaW5ub3ZhdGlvbnNpdCBpcyBzdGlsbGNhbiBvbmx5IGJlZGVmaW5pdGlvbnN0b0dNVFN0cmluZ0EgbnVtYmVyIG9maW1nIGNsYXNzPSJFdmVudHVhbGx5LHdhcyBjaGFuZ2Vkb2NjdXJyZWQgaW5uZWlnaGJvcmluZ2Rpc3Rpbmd1aXNod2hlbiBoZSB3YXNpbnRyb2R1Y2luZ3RlcnJlc3RyaWFsTWFueSBvZiB0aGVhcmd1ZXMgdGhhdGFuIEFtZXJpY2FuY29ucXVlc3Qgb2Z3aWRlc3ByZWFkIHdlcmUga2lsbGVkc2NyZWVuIGFuZCBJbiBvcmRlciB0b2V4cGVjdGVkIHRvZGVzY2VuZGFudHNhcmUgbG9jYXRlZGxlZ2lzbGF0aXZlZ2VuZXJhdGlvbnMgYmFja2dyb3VuZG1vc3QgcGVvcGxleWVhcnMgYWZ0ZXJ0aGVyZSBpcyBub3RoZSBoaWdoZXN0ZnJlcXVlbnRseSB0aGV5IGRvIG5vdGFyZ3VlZCB0aGF0c2hvd2VkIHRoYXRwcmVkb21pbmFudHRoZW9sb2dpY2FsYnkgdGhlIHRpbWVjb25zaWRlcmluZ3Nob3J0LWxpdmVkPC9zcGFuPjwvYT5jYW4gYmUgdXNlZHZlcnkgbGl0dGxlb25lIG9mIHRoZSBoYWQgYWxyZWFkeWludGVycHJldGVkY29tbXVuaWNhdGVmZWF0dXJlcyBvZmdvdmVybm1lbnQsPC9ub3NjcmlwdD5lbnRlcmVkIHRoZSIgaGVpZ2h0PSIzSW5kZXBlbmRlbnRwb3B1bGF0aW9uc2xhcmdlLXNjYWxlLiBBbHRob3VnaCB1c2VkIGluIHRoZWRlc3RydWN0aW9ucG9zc2liaWxpdHlzdGFydGluZyBpbnR3byBvciBtb3JlZXhwcmVzc2lvbnNzdWJvcmRpbmF0ZWxhcmdlciB0aGFuaGlzdG9yeSBhbmQ8L29wdGlvbj4NCkNvbnRpbmVudGFsZWxpbWluYXRpbmd3aWxsIG5vdCBiZXByYWN0aWNlIG9maW4gZnJvbnQgb2ZzaXRlIG9mIHRoZWVuc3VyZSB0aGF0dG8gY3JlYXRlIGFtaXNzaXNzaXBwaXBvdGVudGlhbGx5b3V0c3RhbmRpbmdiZXR0ZXIgdGhhbndoYXQgaXMgbm93c2l0dWF0ZWQgaW5tZXRhIG5hbWU9IlRyYWRpdGlvbmFsc3VnZ2VzdGlvbnNUcmFuc2xhdGlvbnRoZSBmb3JtIG9mYXRtb3NwaGVyaWNpZGVvbG9naWNhbGVudGVycHJpc2VzY2FsY3VsYXRpbmdlYXN0IG9mIHRoZXJlbW5hbnRzIG9mcGx1Z2luc3BhZ2UvaW5kZXgucGhwP3JlbWFpbmVkIGludHJhbnNmb3JtZWRIZSB3YXMgYWxzb3dhcyBhbHJlYWR5c3RhdGlzdGljYWxpbiBmYXZvciBvZk1pbmlzdHJ5IG9mbW92ZW1lbnQgb2Zmb3JtdWxhdGlvbmlzIHJlcXVpcmVkPGxpbmsgcmVsPSJUaGlzIGlzIHRoZSA8YSBocmVmPSIvcG9wdWxhcml6ZWRpbnZvbHZlZCBpbmFyZSB1c2VkIHRvYW5kIHNldmVyYWxtYWRlIGJ5IHRoZXNlZW1zIHRvIGJlbGlrZWx5IHRoYXRQYWxlc3Rpbmlhbm5hbWVkIGFmdGVyaXQgaGFkIGJlZW5tb3N0IGNvbW1vbnRvIHJlZmVyIHRvYnV0IHRoaXMgaXNjb25zZWN1dGl2ZXRlbXBvcmFyaWx5SW4gZ2VuZXJhbCxjb252ZW50aW9uc3Rha2VzIHBsYWNlc3ViZGl2aXNpb250ZXJyaXRvcmlhbG9wZXJhdGlvbmFscGVybWFuZW50bHl3YXMgbGFyZ2VseW91dGJyZWFrIG9maW4gdGhlIHBhc3Rmb2xsb3dpbmcgYSB4bWxuczpvZz0iPjxhIGNsYXNzPSJjbGFzcz0idGV4dENvbnZlcnNpb24gbWF5IGJlIHVzZWRtYW51ZmFjdHVyZWFmdGVyIGJlaW5nY2xlYXJmaXgiPgpxdWVzdGlvbiBvZndhcyBlbGVjdGVkdG8gYmVjb21lIGFiZWNhdXNlIG9mIHNvbWUgcGVvcGxlaW5zcGlyZWQgYnlzdWNjZXNzZnVsIGEgdGltZSB3aGVubW9yZSBjb21tb25hbW9uZ3N0IHRoZWFuIG9mZmljaWFsd2lkdGg6MTAwJTt0ZWNobm9sb2d5LHdhcyBhZG9wdGVkdG8ga2VlcCB0aGVzZXR0bGVtZW50c2xpdmUgYmlydGhzaW5kZXguaHRtbCJDb25uZWN0aWN1dGFzc2lnbmVkIHRvJmFtcDt0aW1lczthY2NvdW50IGZvcmFsaWduPXJpZ2h0dGhlIGNvbXBhbnlhbHdheXMgYmVlbnJldHVybmVkIHRvaW52b2x2ZW1lbnRCZWNhdXNlIHRoZXRoaXMgcGVyaW9kIiBuYW1lPSJxIiBjb25maW5lZCB0b2EgcmVzdWx0IG9mdmFsdWU9IiIgLz5pcyBhY3R1YWxseUVudmlyb25tZW50DQo8L2hlYWQ+DQpDb252ZXJzZWx5LD4KPGRpdiBpZD0iMCIgd2lkdGg9IjFpcyBwcm9iYWJseWhhdmUgYmVjb21lY29udHJvbGxpbmd0aGUgcHJvYmxlbWNpdGl6ZW5zIG9mcG9saXRpY2lhbnNyZWFjaGVkIHRoZWFzIGVhcmx5IGFzOm5vbmU7IG92ZXI8dGFibGUgY2VsbHZhbGlkaXR5IG9mZGlyZWN0bHkgdG9vbm1vdXNlZG93bndoZXJlIGl0IGlzd2hlbiBpdCB3YXNtZW1iZXJzIG9mIHJlbGF0aW9uIHRvYWNjb21tb2RhdGVhbG9uZyB3aXRoIEluIHRoZSBsYXRldGhlIEVuZ2xpc2hkZWxpY2lvdXMiPnRoaXMgaXMgbm90dGhlIHByZXNlbnRpZiB0aGV5IGFyZWFuZCBmaW5hbGx5YSBtYXR0ZXIgb2YNCgk8L2Rpdj4NCg0KPC9zY3JpcHQ+ZmFzdGVyIHRoYW5tYWpvcml0eSBvZmFmdGVyIHdoaWNoY29tcGFyYXRpdmV0byBtYWludGFpbmltcHJvdmUgdGhlYXdhcmRlZCB0aGVlciIgY2xhc3M9ImZyYW1lYm9yZGVycmVzdG9yYXRpb25pbiB0aGUgc2FtZWFuYWx5c2lzIG9mdGhlaXIgZmlyc3REdXJpbmcgdGhlIGNvbnRpbmVudGFsc2VxdWVuY2Ugb2ZmdW5jdGlvbigpe2ZvbnQtc2l6ZTogd29yayBvbiB0aGU8L3NjcmlwdD4KPGJlZ2lucyB3aXRoamF2YXNjcmlwdDpjb25zdGl0dWVudHdhcyBmb3VuZGVkZXF1aWxpYnJpdW1hc3N1bWUgdGhhdGlzIGdpdmVuIGJ5bmVlZHMgdG8gYmVjb29yZGluYXRlc3RoZSB2YXJpb3VzYXJlIHBhcnQgb2Zvbmx5IGluIHRoZXNlY3Rpb25zIG9maXMgYSBjb21tb250aGVvcmllcyBvZmRpc2NvdmVyaWVzYXNzb2NpYXRpb25lZGdlIG9mIHRoZXN0cmVuZ3RoIG9mcG9zaXRpb24gaW5wcmVzZW50LWRheXVuaXZlcnNhbGx5dG8gZm9ybSB0aGVidXQgaW5zdGVhZGNvcnBvcmF0aW9uYXR0YWNoZWQgdG9pcyBjb21tb25seXJlYXNvbnMgZm9yICZxdW90O3RoZSBjYW4gYmUgbWFkZXdhcyBhYmxlIHRvd2hpY2ggbWVhbnNidXQgZGlkIG5vdG9uTW91c2VPdmVyYXMgcG9zc2libGVvcGVyYXRlZCBieWNvbWluZyBmcm9tdGhlIHByaW1hcnlhZGRpdGlvbiBvZmZvciBzZXZlcmFsdHJhbnNmZXJyZWRhIHBlcmlvZCBvZmFyZSBhYmxlIHRvaG93ZXZlciwgaXRzaG91bGQgaGF2ZW11Y2ggbGFyZ2VyCgk8L3NjcmlwdD5hZG9wdGVkIHRoZXByb3BlcnR5IG9mZGlyZWN0ZWQgYnllZmZlY3RpdmVseXdhcyBicm91Z2h0Y2hpbGRyZW4gb2ZQcm9ncmFtbWluZ2xvbmdlciB0aGFubWFudXNjcmlwdHN3YXIgYWdhaW5zdGJ5IG1lYW5zIG9mYW5kIG1vc3Qgb2ZzaW1pbGFyIHRvIHByb3ByaWV0YXJ5b3JpZ2luYXRpbmdwcmVzdGlnaW91c2dyYW1tYXRpY2FsZXhwZXJpZW5jZS50byBtYWtlIHRoZUl0IHdhcyBhbHNvaXMgZm91bmQgaW5jb21wZXRpdG9yc2luIHRoZSBVLlMucmVwbGFjZSB0aGVicm91Z2h0IHRoZWNhbGN1bGF0aW9uZmFsbCBvZiB0aGV0aGUgZ2VuZXJhbHByYWN0aWNhbGx5aW4gaG9ub3Igb2ZyZWxlYXNlZCBpbnJlc2lkZW50aWFsYW5kIHNvbWUgb2ZraW5nIG9mIHRoZXJlYWN0aW9uIHRvMXN0IEVhcmwgb2ZjdWx0dXJlIGFuZHByaW5jaXBhbGx5PC90aXRsZT4KICB0aGV5IGNhbiBiZWJhY2sgdG8gdGhlc29tZSBvZiBoaXNleHBvc3VyZSB0b2FyZSBzaW1pbGFyZm9ybSBvZiB0aGVhZGRGYXZvcml0ZWNpdGl6ZW5zaGlwcGFydCBpbiB0aGVwZW9wbGUgd2l0aGluIHByYWN0aWNldG8gY29udGludWUmYW1wO21pbnVzO2FwcHJvdmVkIGJ5IHRoZSBmaXJzdCBhbGxvd2VkIHRoZWFuZCBmb3IgdGhlZnVuY3Rpb25pbmdwbGF5aW5nIHRoZXNvbHV0aW9uIHRvaGVpZ2h0PSIwIiBpbiBoaXMgYm9va21vcmUgdGhhbiBhZm9sbG93cyB0aGVjcmVhdGVkIHRoZXByZXNlbmNlIGluJm5ic3A7PC90ZD5uYXRpb25hbGlzdHRoZSBpZGVhIG9mYSBjaGFyYWN0ZXJ3ZXJlIGZvcmNlZCBjbGFzcz0iYnRuZGF5cyBvZiB0aGVmZWF0dXJlZCBpbnNob3dpbmcgdGhlaW50ZXJlc3QgaW5pbiBwbGFjZSBvZnR1cm4gb2YgdGhldGhlIGhlYWQgb2ZMb3JkIG9mIHRoZXBvbGl0aWNhbGx5aGFzIGl0cyBvd25FZHVjYXRpb25hbGFwcHJvdmFsIG9mc29tZSBvZiB0aGVlYWNoIG90aGVyLGJlaGF2aW9yIG9mYW5kIGJlY2F1c2VhbmQgYW5vdGhlcmFwcGVhcmVkIG9ucmVjb3JkZWQgaW5ibGFjayZxdW90O21heSBpbmNsdWRldGhlIHdvcmxkJ3NjYW4gbGVhZCB0b3JlZmVycyB0byBhYm9yZGVyPSIwIiBnb3Zlcm5tZW50IHdpbm5pbmcgdGhlcmVzdWx0ZWQgaW4gd2hpbGUgdGhlIFdhc2hpbmd0b24sdGhlIHN1YmplY3RjaXR5IGluIHRoZT48L2Rpdj4NCgkJcmVmbGVjdCB0aGV0byBjb21wbGV0ZWJlY2FtZSBtb3JlcmFkaW9hY3RpdmVyZWplY3RlZCBieXdpdGhvdXQgYW55aGlzIGZhdGhlcix3aGljaCBjb3VsZGNvcHkgb2YgdGhldG8gaW5kaWNhdGVhIHBvbGl0aWNhbGFjY291bnRzIG9mY29uc3RpdHV0ZXN3b3JrZWQgd2l0aGVyPC9hPjwvbGk+b2YgaGlzIGxpZmVhY2NvbXBhbmllZGNsaWVudFdpZHRocHJldmVudCB0aGVMZWdpc2xhdGl2ZWRpZmZlcmVudGx5dG9nZXRoZXIgaW5oYXMgc2V2ZXJhbGZvciBhbm90aGVydGV4dCBvZiB0aGVmb3VuZGVkIHRoZWUgd2l0aCB0aGUgaXMgdXNlZCBmb3JjaGFuZ2VkIHRoZXVzdWFsbHkgdGhlcGxhY2Ugd2hlcmV3aGVyZWFzIHRoZT4gPGEgaHJlZj0iIj48YSBocmVmPSJ0aGVtc2VsdmVzLGFsdGhvdWdoIGhldGhhdCBjYW4gYmV0cmFkaXRpb25hbHJvbGUgb2YgdGhlYXMgYSByZXN1bHRyZW1vdmVDaGlsZGRlc2lnbmVkIGJ5d2VzdCBvZiB0aGVTb21lIHBlb3BsZXByb2R1Y3Rpb24sc2lkZSBvZiB0aGVuZXdzbGV0dGVyc3VzZWQgYnkgdGhlZG93biB0byB0aGVhY2NlcHRlZCBieWxpdmUgaW4gdGhlYXR0ZW1wdHMgdG9vdXRzaWRlIHRoZWZyZXF1ZW5jaWVzSG93ZXZlciwgaW5wcm9ncmFtbWVyc2F0IGxlYXN0IGluYXBwcm94aW1hdGVhbHRob3VnaCBpdHdhcyBwYXJ0IG9mYW5kIHZhcmlvdXNHb3Zlcm5vciBvZnRoZSBhcnRpY2xldHVybmVkIGludG8+PGEgaHJlZj0iL3RoZSBlY29ub215aXMgdGhlIG1vc3Rtb3N0IHdpZGVseXdvdWxkIGxhdGVyYW5kIHBlcmhhcHNyaXNlIHRvIHRoZW9jY3VycyB3aGVudW5kZXIgd2hpY2hjb25kaXRpb25zLnRoZSB3ZXN0ZXJudGhlb3J5IHRoYXRpcyBwcm9kdWNlZHRoZSBjaXR5IG9maW4gd2hpY2ggaGVzZWVuIGluIHRoZXRoZSBjZW50cmFsYnVpbGRpbmcgb2ZtYW55IG9mIGhpc2FyZWEgb2YgdGhlaXMgdGhlIG9ubHltb3N0IG9mIHRoZW1hbnkgb2YgdGhldGhlIFdlc3Rlcm5UaGVyZSBpcyBub2V4dGVuZGVkIHRvU3RhdGlzdGljYWxjb2xzcGFuPTIgfHNob3J0IHN0b3J5cG9zc2libGUgdG90b3BvbG9naWNhbGNyaXRpY2FsIG9mcmVwb3J0ZWQgdG9hIENocmlzdGlhbmRlY2lzaW9uIHRvaXMgZXF1YWwgdG9wcm9ibGVtcyBvZlRoaXMgY2FuIGJlbWVyY2hhbmRpc2Vmb3IgbW9zdCBvZm5vIGV2aWRlbmNlZWRpdGlvbnMgb2ZlbGVtZW50cyBpbiZxdW90Oy4gVGhlY29tL2ltYWdlcy93aGljaCBtYWtlc3RoZSBwcm9jZXNzcmVtYWlucyB0aGVsaXRlcmF0dXJlLGlzIGEgbWVtYmVydGhlIHBvcHVsYXJ0aGUgYW5jaWVudHByb2JsZW1zIGludGltZSBvZiB0aGVkZWZlYXRlZCBieWJvZHkgb2YgdGhlYSBmZXcgeWVhcnNtdWNoIG9mIHRoZXRoZSB3b3JrIG9mQ2FsaWZvcm5pYSxzZXJ2ZWQgYXMgYWdvdmVybm1lbnQuY29uY2VwdHMgb2Ztb3ZlbWVudCBpbgkJPGRpdiBpZD0iaXQiIHZhbHVlPSJsYW5ndWFnZSBvZmFzIHRoZXkgYXJlcHJvZHVjZWQgaW5pcyB0aGF0IHRoZWV4cGxhaW4gdGhlZGl2PjwvZGl2PgpIb3dldmVyIHRoZWxlYWQgdG8gdGhlCTxhIGhyZWY9Ii93YXMgZ3JhbnRlZHBlb3BsZSBoYXZlY29udGludWFsbHl3YXMgc2VlbiBhc2FuZCByZWxhdGVkdGhlIHJvbGUgb2Zwcm9wb3NlZCBieW9mIHRoZSBiZXN0ZWFjaCBvdGhlci5Db25zdGFudGluZXBlb3BsZSBmcm9tZGlhbGVjdHMgb2Z0byByZXZpc2lvbndhcyByZW5hbWVkYSBzb3VyY2Ugb2Z0aGUgaW5pdGlhbGxhdW5jaGVkIGlucHJvdmlkZSB0aGV0byB0aGUgd2VzdHdoZXJlIHRoZXJlYW5kIHNpbWlsYXJiZXR3ZWVuIHR3b2lzIGFsc28gdGhlRW5nbGlzaCBhbmRjb25kaXRpb25zLHRoYXQgaXQgd2FzZW50aXRsZWQgdG90aGVtc2VsdmVzLnF1YW50aXR5IG9mcmFuc3BhcmVuY3l0aGUgc2FtZSBhc3RvIGpvaW4gdGhlY291bnRyeSBhbmR0aGlzIGlzIHRoZVRoaXMgbGVkIHRvYSBzdGF0ZW1lbnRjb250cmFzdCB0b2xhc3RJbmRleE9mdGhyb3VnaCBoaXNpcyBkZXNpZ25lZHRoZSB0ZXJtIGlzaXMgcHJvdmlkZWRwcm90ZWN0IHRoZW5nPC9hPjwvbGk+VGhlIGN1cnJlbnR0aGUgc2l0ZSBvZnN1YnN0YW50aWFsZXhwZXJpZW5jZSxpbiB0aGUgV2VzdHRoZXkgc2hvdWxkc2xvdmVuxI1pbmFjb21lbnRhcmlvc3VuaXZlcnNpZGFkY29uZGljaW9uZXNhY3RpdmlkYWRlc2V4cGVyaWVuY2lhdGVjbm9sb2fDrWFwcm9kdWNjacOzbnB1bnR1YWNpw7NuYXBsaWNhY2nDs25jb250cmFzZcOxYWNhdGVnb3LDrWFzcmVnaXN0cmFyc2Vwcm9mZXNpb25hbHRyYXRhbWllbnRvcmVnw61zdHJhdGVzZWNyZXRhcsOtYXByaW5jaXBhbGVzcHJvdGVjY2nDs25pbXBvcnRhbnRlc2ltcG9ydGFuY2lhcG9zaWJpbGlkYWRpbnRlcmVzYW50ZWNyZWNpbWllbnRvbmVjZXNpZGFkZXNzdXNjcmliaXJzZWFzb2NpYWNpw7NuZGlzcG9uaWJsZXNldmFsdWFjacOzbmVzdHVkaWFudGVzcmVzcG9uc2FibGVyZXNvbHVjacOzbmd1YWRhbGFqYXJhcmVnaXN0cmFkb3NvcG9ydHVuaWRhZGNvbWVyY2lhbGVzZm90b2dyYWbDrWFhdXRvcmlkYWRlc2luZ2VuaWVyw61hdGVsZXZpc2nDs25jb21wZXRlbmNpYW9wZXJhY2lvbmVzZXN0YWJsZWNpZG9zaW1wbGVtZW50ZWFjdHVhbG1lbnRlbmF2ZWdhY2nDs25jb25mb3JtaWRhZGxpbmUtaGVpZ2h0OmZvbnQtZmFtaWx5OiIgOiAiaHR0cDovL2FwcGxpY2F0aW9uc2xpbmsiIGhyZWY9InNwZWNpZmljYWxseS8vPCFbQ0RBVEFbCk9yZ2FuaXphdGlvbmRpc3RyaWJ1dGlvbjBweDsgaGVpZ2h0OnJlbGF0aW9uc2hpcGRldmljZS13aWR0aDxkaXYgY2xhc3M9IjxsYWJlbCBmb3I9InJlZ2lzdHJhdGlvbjwvbm9zY3JpcHQ+Ci9pbmRleC5odG1sIndpbmRvdy5vcGVuKCAhaW1wb3J0YW50O2FwcGxpY2F0aW9uL2luZGVwZW5kZW5jZS8vd3d3Lmdvb2dsZW9yZ2FuaXphdGlvbmF1dG9jb21wbGV0ZXJlcXVpcmVtZW50c2NvbnNlcnZhdGl2ZTxmb3JtIG5hbWU9ImludGVsbGVjdHVhbG1hcmdpbi1sZWZ0OjE4dGggY2VudHVyeWFuIGltcG9ydGFudGluc3RpdHV0aW9uc2FiYnJldmlhdGlvbjxpbWcgY2xhc3M9Im9yZ2FuaXNhdGlvbmNpdmlsaXphdGlvbjE5dGggY2VudHVyeWFyY2hpdGVjdHVyZWluY29ycG9yYXRlZDIwdGggY2VudHVyeS1jb250YWluZXIiPm1vc3Qgbm90YWJseS8+PC9hPjwvZGl2Pm5vdGlmaWNhdGlvbid1bmRlZmluZWQnKUZ1cnRoZXJtb3JlLGJlbGlldmUgdGhhdGlubmVySFRNTCA9IHByaW9yIHRvIHRoZWRyYW1hdGljYWxseXJlZmVycmluZyB0b25lZ290aWF0aW9uc2hlYWRxdWFydGVyc1NvdXRoIEFmcmljYXVuc3VjY2Vzc2Z1bFBlbm5zeWx2YW5pYUFzIGEgcmVzdWx0LDxodG1sIGxhbmc9IiZsdDsvc3VwJmd0O2RlYWxpbmcgd2l0aHBoaWxhZGVscGhpYWhpc3RvcmljYWxseSk7PC9zY3JpcHQ+CnBhZGRpbmctdG9wOmV4cGVyaW1lbnRhbGdldEF0dHJpYnV0ZWluc3RydWN0aW9uc3RlY2hub2xvZ2llc3BhcnQgb2YgdGhlID1mdW5jdGlvbigpe3N1YnNjcmlwdGlvbmwuZHRkIj4NCjxodGdlb2dyYXBoaWNhbENvbnN0aXR1dGlvbicsIGZ1bmN0aW9uKHN1cHBvcnRlZCBieWFncmljdWx0dXJhbGNvbnN0cnVjdGlvbnB1YmxpY2F0aW9uc2ZvbnQtc2l6ZTogMWEgdmFyaWV0eSBvZjxkaXYgc3R5bGU9IkVuY3ljbG9wZWRpYWlmcmFtZSBzcmM9ImRlbW9uc3RyYXRlZGFjY29tcGxpc2hlZHVuaXZlcnNpdGllc0RlbW9ncmFwaGljcyk7PC9zY3JpcHQ+PGRlZGljYXRlZCB0b2tub3dsZWRnZSBvZnNhdGlzZmFjdGlvbnBhcnRpY3VsYXJseTwvZGl2PjwvZGl2PkVuZ2xpc2ggKFVTKWFwcGVuZENoaWxkKHRyYW5zbWlzc2lvbnMuIEhvd2V2ZXIsIGludGVsbGlnZW5jZSIgdGFiaW5kZXg9ImZsb2F0OnJpZ2h0O0NvbW1vbndlYWx0aHJhbmdpbmcgZnJvbWluIHdoaWNoIHRoZWF0IGxlYXN0IG9uZXJlcHJvZHVjdGlvbmVuY3ljbG9wZWRpYTtmb250LXNpemU6MWp1cmlzZGljdGlvbmF0IHRoYXQgdGltZSI+PGEgY2xhc3M9IkluIGFkZGl0aW9uLGRlc2NyaXB0aW9uK2NvbnZlcnNhdGlvbmNvbnRhY3Qgd2l0aGlzIGdlbmVyYWxseXIiIGNvbnRlbnQ9InJlcHJlc2VudGluZyZsdDttYXRoJmd0O3ByZXNlbnRhdGlvbm9jY2FzaW9uYWxseTxpbWcgd2lkdGg9Im5hdmlnYXRpb24iPmNvbXBlbnNhdGlvbmNoYW1waW9uc2hpcG1lZGlhPSJhbGwiIHZpb2xhdGlvbiBvZnJlZmVyZW5jZSB0b3JldHVybiB0cnVlO1N0cmljdC8vRU4iIHRyYW5zYWN0aW9uc2ludGVydmVudGlvbnZlcmlmaWNhdGlvbkluZm9ybWF0aW9uIGRpZmZpY3VsdGllc0NoYW1waW9uc2hpcGNhcGFiaWxpdGllczwhW2VuZGlmXS0tPn0KPC9zY3JpcHQ+CkNocmlzdGlhbml0eWZvciBleGFtcGxlLFByb2Zlc3Npb25hbHJlc3RyaWN0aW9uc3N1Z2dlc3QgdGhhdHdhcyByZWxlYXNlZChzdWNoIGFzIHRoZXJlbW92ZUNsYXNzKHVuZW1wbG95bWVudHRoZSBBbWVyaWNhbnN0cnVjdHVyZSBvZi9pbmRleC5odG1sIHB1Ymxpc2hlZCBpbnNwYW4gY2xhc3M9IiI+PGEgaHJlZj0iL2ludHJvZHVjdGlvbmJlbG9uZ2luZyB0b2NsYWltZWQgdGhhdGNvbnNlcXVlbmNlczxtZXRhIG5hbWU9Ikd1aWRlIHRvIHRoZW92ZXJ3aGVsbWluZ2FnYWluc3QgdGhlIGNvbmNlbnRyYXRlZCwKLm5vbnRvdWNoIG9ic2VydmF0aW9uczwvYT4KPC9kaXY+CmYgKGRvY3VtZW50LmJvcmRlcjogMXB4IHtmb250LXNpemU6MXRyZWF0bWVudCBvZjAiIGhlaWdodD0iMW1vZGlmaWNhdGlvbkluZGVwZW5kZW5jZWRpdmlkZWQgaW50b2dyZWF0ZXIgdGhhbmFjaGlldmVtZW50c2VzdGFibGlzaGluZ0phdmFTY3JpcHQiIG5ldmVydGhlbGVzc3NpZ25pZmljYW5jZUJyb2FkY2FzdGluZz4mbmJzcDs8L3RkPmNvbnRhaW5lciI+CnN1Y2ggYXMgdGhlIGluZmx1ZW5jZSBvZmEgcGFydGljdWxhcnNyYz0naHR0cDovL25hdmlnYXRpb24iIGhhbGYgb2YgdGhlIHN1YnN0YW50aWFsICZuYnNwOzwvZGl2PmFkdmFudGFnZSBvZmRpc2NvdmVyeSBvZmZ1bmRhbWVudGFsIG1ldHJvcG9saXRhbnRoZSBvcHBvc2l0ZSIgeG1sOmxhbmc9ImRlbGliZXJhdGVseWFsaWduPWNlbnRlcmV2b2x1dGlvbiBvZnByZXNlcnZhdGlvbmltcHJvdmVtZW50c2JlZ2lubmluZyBpbkplc3VzIENocmlzdFB1YmxpY2F0aW9uc2Rpc2FncmVlbWVudHRleHQtYWxpZ246ciwgZnVuY3Rpb24oKXNpbWlsYXJpdGllc2JvZHk+PC9odG1sPmlzIGN1cnJlbnRseWFscGhhYmV0aWNhbGlzIHNvbWV0aW1lc3R5cGU9ImltYWdlL21hbnkgb2YgdGhlIGZsb3c6aGlkZGVuO2F2YWlsYWJsZSBpbmRlc2NyaWJlIHRoZWV4aXN0ZW5jZSBvZmFsbCBvdmVyIHRoZXRoZSBJbnRlcm5ldAk8dWwgY2xhc3M9Imluc3RhbGxhdGlvbm5laWdoYm9yaG9vZGFybWVkIGZvcmNlc3JlZHVjaW5nIHRoZWNvbnRpbnVlcyB0b05vbmV0aGVsZXNzLHRlbXBlcmF0dXJlcwoJCTxhIGhyZWY9ImNsb3NlIHRvIHRoZWV4YW1wbGVzIG9mIGlzIGFib3V0IHRoZShzZWUgYmVsb3cpLiIgaWQ9InNlYXJjaHByb2Zlc3Npb25hbGlzIGF2YWlsYWJsZXRoZSBvZmZpY2lhbAkJPC9zY3JpcHQ+CgoJCTxkaXYgaWQ9ImFjY2VsZXJhdGlvbnRocm91Z2ggdGhlIEhhbGwgb2YgRmFtZWRlc2NyaXB0aW9uc3RyYW5zbGF0aW9uc2ludGVyZmVyZW5jZSB0eXBlPSd0ZXh0L3JlY2VudCB5ZWFyc2luIHRoZSB3b3JsZHZlcnkgcG9wdWxhcntiYWNrZ3JvdW5kOnRyYWRpdGlvbmFsIHNvbWUgb2YgdGhlIGNvbm5lY3RlZCB0b2V4cGxvaXRhdGlvbmVtZXJnZW5jZSBvZmNvbnN0aXR1dGlvbkEgSGlzdG9yeSBvZnNpZ25pZmljYW50IG1hbnVmYWN0dXJlZGV4cGVjdGF0aW9ucz48bm9zY3JpcHQ+PGNhbiBiZSBmb3VuZGJlY2F1c2UgdGhlIGhhcyBub3QgYmVlbm5laWdoYm91cmluZ3dpdGhvdXQgdGhlIGFkZGVkIHRvIHRoZQk8bGkgY2xhc3M9Imluc3RydW1lbnRhbFNvdmlldCBVbmlvbmFja25vd2xlZGdlZHdoaWNoIGNhbiBiZW5hbWUgZm9yIHRoZWF0dGVudGlvbiB0b2F0dGVtcHRzIHRvIGRldmVsb3BtZW50c0luIGZhY3QsIHRoZTxsaSBjbGFzcz0iYWltcGxpY2F0aW9uc3N1aXRhYmxlIGZvcm11Y2ggb2YgdGhlIGNvbG9uaXphdGlvbnByZXNpZGVudGlhbGNhbmNlbEJ1YmJsZSBJbmZvcm1hdGlvbm1vc3Qgb2YgdGhlIGlzIGRlc2NyaWJlZHJlc3Qgb2YgdGhlIG1vcmUgb3IgbGVzc2luIFNlcHRlbWJlckludGVsbGlnZW5jZXNyYz0iaHR0cDovL3B4OyBoZWlnaHQ6IGF2YWlsYWJsZSB0b21hbnVmYWN0dXJlcmh1bWFuIHJpZ2h0c2xpbmsgaHJlZj0iL2F2YWlsYWJpbGl0eXByb3BvcnRpb25hbG91dHNpZGUgdGhlIGFzdHJvbm9taWNhbGh1bWFuIGJlaW5nc25hbWUgb2YgdGhlIGFyZSBmb3VuZCBpbmFyZSBiYXNlZCBvbnNtYWxsZXIgdGhhbmEgcGVyc29uIHdob2V4cGFuc2lvbiBvZmFyZ3VpbmcgdGhhdG5vdyBrbm93biBhc0luIHRoZSBlYXJseWludGVybWVkaWF0ZWRlcml2ZWQgZnJvbVNjYW5kaW5hdmlhbjwvYT48L2Rpdj4NCmNvbnNpZGVyIHRoZWFuIGVzdGltYXRlZHRoZSBOYXRpb25hbDxkaXYgaWQ9InBhZ3Jlc3VsdGluZyBpbmNvbW1pc3Npb25lZGFuYWxvZ291cyB0b2FyZSByZXF1aXJlZC91bD4KPC9kaXY+CndhcyBiYXNlZCBvbmFuZCBiZWNhbWUgYSZuYnNwOyZuYnNwO3QiIHZhbHVlPSIiIHdhcyBjYXB0dXJlZG5vIG1vcmUgdGhhbnJlc3BlY3RpdmVseWNvbnRpbnVlIHRvID4NCjxoZWFkPg0KPHdlcmUgY3JlYXRlZG1vcmUgZ2VuZXJhbGluZm9ybWF0aW9uIHVzZWQgZm9yIHRoZWluZGVwZW5kZW50IHRoZSBJbXBlcmlhbGNvbXBvbmVudCBvZnRvIHRoZSBub3J0aGluY2x1ZGUgdGhlIENvbnN0cnVjdGlvbnNpZGUgb2YgdGhlIHdvdWxkIG5vdCBiZWZvciBpbnN0YW5jZWludmVudGlvbiBvZm1vcmUgY29tcGxleGNvbGxlY3RpdmVseWJhY2tncm91bmQ6IHRleHQtYWxpZ246IGl0cyBvcmlnaW5hbGludG8gYWNjb3VudHRoaXMgcHJvY2Vzc2FuIGV4dGVuc2l2ZWhvd2V2ZXIsIHRoZXRoZXkgYXJlIG5vdHJlamVjdGVkIHRoZWNyaXRpY2lzbSBvZmR1cmluZyB3aGljaHByb2JhYmx5IHRoZXRoaXMgYXJ0aWNsZShmdW5jdGlvbigpe0l0IHNob3VsZCBiZWFuIGFncmVlbWVudGFjY2lkZW50YWxseWRpZmZlcnMgZnJvbUFyY2hpdGVjdHVyZWJldHRlciBrbm93bmFycmFuZ2VtZW50c2luZmx1ZW5jZSBvbmF0dGVuZGVkIHRoZWlkZW50aWNhbCB0b3NvdXRoIG9mIHRoZXBhc3MgdGhyb3VnaHhtbCIgdGl0bGU9IndlaWdodDpib2xkO2NyZWF0aW5nIHRoZWRpc3BsYXk6bm9uZXJlcGxhY2VkIHRoZTxpbWcgc3JjPSIvaWh0dHBzOi8vd3d3LldvcmxkIFdhciBJSXRlc3RpbW9uaWFsc2ZvdW5kIGluIHRoZXJlcXVpcmVkIHRvIGFuZCB0aGF0IHRoZWJldHdlZW4gdGhlIHdhcyBkZXNpZ25lZGNvbnNpc3RzIG9mIGNvbnNpZGVyYWJseXB1Ymxpc2hlZCBieXRoZSBsYW5ndWFnZUNvbnNlcnZhdGlvbmNvbnNpc3RlZCBvZnJlZmVyIHRvIHRoZWJhY2sgdG8gdGhlIGNzcyIgbWVkaWE9IlBlb3BsZSBmcm9tIGF2YWlsYWJsZSBvbnByb3ZlZCB0byBiZXN1Z2dlc3Rpb25zIndhcyBrbm93biBhc3ZhcmlldGllcyBvZmxpa2VseSB0byBiZWNvbXByaXNlZCBvZnN1cHBvcnQgdGhlIGhhbmRzIG9mIHRoZWNvdXBsZWQgd2l0aGNvbm5lY3QgYW5kIGJvcmRlcjpub25lO3BlcmZvcm1hbmNlc2JlZm9yZSBiZWluZ2xhdGVyIGJlY2FtZWNhbGN1bGF0aW9uc29mdGVuIGNhbGxlZHJlc2lkZW50cyBvZm1lYW5pbmcgdGhhdD48bGkgY2xhc3M9ImV2aWRlbmNlIGZvcmV4cGxhbmF0aW9uc2Vudmlyb25tZW50cyI+PC9hPjwvZGl2PndoaWNoIGFsbG93c0ludHJvZHVjdGlvbmRldmVsb3BlZCBieWEgd2lkZSByYW5nZW9uIGJlaGFsZiBvZnZhbGlnbj0idG9wInByaW5jaXBsZSBvZmF0IHRoZSB0aW1lLDwvbm9zY3JpcHQ+DXNhaWQgdG8gaGF2ZWluIHRoZSBmaXJzdHdoaWxlIG90aGVyc2h5cG90aGV0aWNhbHBoaWxvc29waGVyc3Bvd2VyIG9mIHRoZWNvbnRhaW5lZCBpbnBlcmZvcm1lZCBieWluYWJpbGl0eSB0b3dlcmUgd3JpdHRlbnNwYW4gc3R5bGU9ImlucHV0IG5hbWU9InRoZSBxdWVzdGlvbmludGVuZGVkIGZvcnJlamVjdGlvbiBvZmltcGxpZXMgdGhhdGludmVudGVkIHRoZXRoZSBzdGFuZGFyZHdhcyBwcm9iYWJseWxpbmsgYmV0d2VlbnByb2Zlc3NvciBvZmludGVyYWN0aW9uc2NoYW5naW5nIHRoZUluZGlhbiBPY2VhbiBjbGFzcz0ibGFzdHdvcmtpbmcgd2l0aCdodHRwOi8vd3d3LnllYXJzIGJlZm9yZVRoaXMgd2FzIHRoZXJlY3JlYXRpb25hbGVudGVyaW5nIHRoZW1lYXN1cmVtZW50c2FuIGV4dHJlbWVseXZhbHVlIG9mIHRoZXN0YXJ0IG9mIHRoZQo8L3NjcmlwdD4KCmFuIGVmZm9ydCB0b2luY3JlYXNlIHRoZXRvIHRoZSBzb3V0aHNwYWNpbmc9IjAiPnN1ZmZpY2llbnRseXRoZSBFdXJvcGVhbmNvbnZlcnRlZCB0b2NsZWFyVGltZW91dGRpZCBub3QgaGF2ZWNvbnNlcXVlbnRseWZvciB0aGUgbmV4dGV4dGVuc2lvbiBvZmVjb25vbWljIGFuZGFsdGhvdWdoIHRoZWFyZSBwcm9kdWNlZGFuZCB3aXRoIHRoZWluc3VmZmljaWVudGdpdmVuIGJ5IHRoZXN0YXRpbmcgdGhhdGV4cGVuZGl0dXJlczwvc3Bhbj48L2E+CnRob3VnaHQgdGhhdG9uIHRoZSBiYXNpc2NlbGxwYWRkaW5nPWltYWdlIG9mIHRoZXJldHVybmluZyB0b2luZm9ybWF0aW9uLHNlcGFyYXRlZCBieWFzc2Fzc2luYXRlZHMiIGNvbnRlbnQ9ImF1dGhvcml0eSBvZm5vcnRod2VzdGVybjwvZGl2Pgo8ZGl2ICI+PC9kaXY+DQogIGNvbnN1bHRhdGlvbmNvbW11bml0eSBvZnRoZSBuYXRpb25hbGl0IHNob3VsZCBiZXBhcnRpY2lwYW50cyBhbGlnbj0ibGVmdHRoZSBncmVhdGVzdHNlbGVjdGlvbiBvZnN1cGVybmF0dXJhbGRlcGVuZGVudCBvbmlzIG1lbnRpb25lZGFsbG93aW5nIHRoZXdhcyBpbnZlbnRlZGFjY29tcGFueWluZ2hpcyBwZXJzb25hbGF2YWlsYWJsZSBhdHN0dWR5IG9mIHRoZW9uIHRoZSBvdGhlcmV4ZWN1dGlvbiBvZkh1bWFuIFJpZ2h0c3Rlcm1zIG9mIHRoZWFzc29jaWF0aW9uc3Jlc2VhcmNoIGFuZHN1Y2NlZWRlZCBieWRlZmVhdGVkIHRoZWFuZCBmcm9tIHRoZWJ1dCB0aGV5IGFyZWNvbW1hbmRlciBvZnN0YXRlIG9mIHRoZXllYXJzIG9mIGFnZXRoZSBzdHVkeSBvZjx1bCBjbGFzcz0ic3BsYWNlIGluIHRoZXdoZXJlIGhlIHdhczxsaSBjbGFzcz0iZnRoZXJlIGFyZSBub3doaWNoIGJlY2FtZWhlIHB1Ymxpc2hlZGV4cHJlc3NlZCBpbnRvIHdoaWNoIHRoZWNvbW1pc3Npb25lcmZvbnQtd2VpZ2h0OnRlcnJpdG9yeSBvZmV4dGVuc2lvbnMiPlJvbWFuIEVtcGlyZWVxdWFsIHRvIHRoZUluIGNvbnRyYXN0LGhvd2V2ZXIsIGFuZGlzIHR5cGljYWxseWFuZCBoaXMgd2lmZShhbHNvIGNhbGxlZD48dWwgY2xhc3M9ImVmZmVjdGl2ZWx5IGV2b2x2ZWQgaW50b3NlZW0gdG8gaGF2ZXdoaWNoIGlzIHRoZXRoZXJlIHdhcyBub2FuIGV4Y2VsbGVudGFsbCBvZiB0aGVzZWRlc2NyaWJlZCBieUluIHByYWN0aWNlLGJyb2FkY2FzdGluZ2NoYXJnZWQgd2l0aHJlZmxlY3RlZCBpbnN1YmplY3RlZCB0b21pbGl0YXJ5IGFuZHRvIHRoZSBwb2ludGVjb25vbWljYWxseXNldFRhcmdldGluZ2FyZSBhY3R1YWxseXZpY3Rvcnkgb3ZlcigpOzwvc2NyaXB0PmNvbnRpbnVvdXNseXJlcXVpcmVkIGZvcmV2b2x1dGlvbmFyeWFuIGVmZmVjdGl2ZW5vcnRoIG9mIHRoZSwgd2hpY2ggd2FzIGZyb250IG9mIHRoZW9yIG90aGVyd2lzZXNvbWUgZm9ybSBvZmhhZCBub3QgYmVlbmdlbmVyYXRlZCBieWluZm9ybWF0aW9uLnBlcm1pdHRlZCB0b2luY2x1ZGVzIHRoZWRldmVsb3BtZW50LGVudGVyZWQgaW50b3RoZSBwcmV2aW91c2NvbnNpc3RlbnRseWFyZSBrbm93biBhc3RoZSBmaWVsZCBvZnRoaXMgdHlwZSBvZmdpdmVuIHRvIHRoZXRoZSB0aXRsZSBvZmNvbnRhaW5zIHRoZWluc3RhbmNlcyBvZmluIHRoZSBub3J0aGR1ZSB0byB0aGVpcmFyZSBkZXNpZ25lZGNvcnBvcmF0aW9uc3dhcyB0aGF0IHRoZW9uZSBvZiB0aGVzZW1vcmUgcG9wdWxhcnN1Y2NlZWRlZCBpbnN1cHBvcnQgZnJvbWluIGRpZmZlcmVudGRvbWluYXRlZCBieWRlc2lnbmVkIGZvcm93bmVyc2hpcCBvZmFuZCBwb3NzaWJseXN0YW5kYXJkaXplZHJlc3BvbnNlVGV4dHdhcyBpbnRlbmRlZHJlY2VpdmVkIHRoZWFzc3VtZWQgdGhhdGFyZWFzIG9mIHRoZXByaW1hcmlseSBpbnRoZSBiYXNpcyBvZmluIHRoZSBzZW5zZWFjY291bnRzIGZvcmRlc3Ryb3llZCBieWF0IGxlYXN0IHR3b3dhcyBkZWNsYXJlZGNvdWxkIG5vdCBiZVNlY3JldGFyeSBvZmFwcGVhciB0byBiZW1hcmdpbi10b3A6MS9eXHMrfFxzKyQvZ2Upe3Rocm93IGV9O3RoZSBzdGFydCBvZnR3byBzZXBhcmF0ZWxhbmd1YWdlIGFuZHdobyBoYWQgYmVlbm9wZXJhdGlvbiBvZmRlYXRoIG9mIHRoZXJlYWwgbnVtYmVycwk8bGluayByZWw9InByb3ZpZGVkIHRoZXRoZSBzdG9yeSBvZmNvbXBldGl0aW9uc2VuZ2xpc2ggKFVLKWVuZ2xpc2ggKFVTKdCc0L7QvdCz0L7Qu9Ch0YDQv9GB0LrQuNGB0YDQv9GB0LrQuNGB0YDQv9GB0LrQvtmE2LnYsdio2YrYqeato+mrlOS4reaWh+eugOS9k+S4reaWh+e5geS9k+S4reaWh+aciemZkOWFrOWPuOS6uuawkeaUv+W6nOmYv+mHjOW3tOW3tOekvuS8muS4u+S5ieaTjeS9nOezu+e7n+aUv+etluazleinhGluZm9ybWFjacOzbmhlcnJhbWllbnRhc2VsZWN0csOzbmljb2Rlc2NyaXBjacOzbmNsYXNpZmljYWRvc2Nvbm9jaW1pZW50b3B1YmxpY2FjacOzbnJlbGFjaW9uYWRhc2luZm9ybcOhdGljYXJlbGFjaW9uYWRvc2RlcGFydGFtZW50b3RyYWJhamFkb3Jlc2RpcmVjdGFtZW50ZWF5dW50YW1pZW50b21lcmNhZG9MaWJyZWNvbnTDoWN0ZW5vc2hhYml0YWNpb25lc2N1bXBsaW1pZW50b3Jlc3RhdXJhbnRlc2Rpc3Bvc2ljacOzbmNvbnNlY3VlbmNpYWVsZWN0csOzbmljYWFwbGljYWNpb25lc2Rlc2NvbmVjdGFkb2luc3RhbGFjacOzbnJlYWxpemFjacOzbnV0aWxpemFjacOzbmVuY2ljbG9wZWRpYWVuZmVybWVkYWRlc2luc3RydW1lbnRvc2V4cGVyaWVuY2lhc2luc3RpdHVjacOzbnBhcnRpY3VsYXJlc3N1YmNhdGVnb3JpYdGC0L7Qu9GM0LrQvtCg0L7RgdGB0LjQuNGA0LDQsdC+0YLRi9Cx0L7Qu9GM0YjQtdC/0YDQvtGB0YLQvtC80L7QttC10YLQtdC00YDRg9Cz0LjRhdGB0LvRg9GH0LDQtdGB0LXQudGH0LDRgdCy0YHQtdCz0LTQsNCg0L7RgdGB0LjRj9Cc0L7RgdC60LLQtdC00YDRg9Cz0LjQtdCz0L7RgNC+0LTQsNCy0L7Qv9GA0L7RgdC00LDQvdC90YvRhdC00L7Qu9C20L3Ri9C40LzQtdC90L3QvtCc0L7RgdC60LLRi9GA0YPQsdC70LXQudCc0L7RgdC60LLQsNGB0YLRgNCw0L3Ri9C90LjRh9C10LPQvtGA0LDQsdC+0YLQtdC00L7Qu9C20LXQvdGD0YHQu9GD0LPQuNGC0LXQv9C10YDRjNCe0LTQvdCw0LrQvtC/0L7RgtC+0LzRg9GA0LDQsdC+0YLRg9Cw0L/RgNC10LvRj9Cy0L7QvtCx0YnQtdC+0LTQvdC+0LPQvtGB0LLQvtC10LPQvtGB0YLQsNGC0YzQuNC00YDRg9Cz0L7QudGE0L7RgNGD0LzQtdGF0L7RgNC+0YjQvtC/0YDQvtGC0LjQstGB0YHRi9C70LrQsNC60LDQttC00YvQudCy0LvQsNGB0YLQuNCz0YDRg9C/0L/Ri9Cy0LzQtdGB0YLQtdGA0LDQsdC+0YLQsNGB0LrQsNC30LDQu9C/0LXRgNCy0YvQudC00LXQu9Cw0YLRjNC00LXQvdGM0LPQuNC/0LXRgNC40L7QtNCx0LjQt9C90LXRgdC+0YHQvdC+0LLQtdC80L7QvNC10L3RgtC60YPQv9C40YLRjNC00L7Qu9C20L3QsNGA0LDQvNC60LDRhdC90LDRh9Cw0LvQvtCg0LDQsdC+0YLQsNCi0L7Qu9GM0LrQvtGB0L7QstGB0LXQvNCy0YLQvtGA0L7QudC90LDRh9Cw0LvQsNGB0L/QuNGB0L7QutGB0LvRg9C20LHRi9GB0LjRgdGC0LXQvNC/0LXRh9Cw0YLQuNC90L7QstC+0LPQvtC/0L7QvNC+0YnQuNGB0LDQudGC0L7QstC/0L7Rh9C10LzRg9C/0L7QvNC+0YnRjNC00L7Qu9C20L3QvtGB0YHRi9C70LrQuNCx0YvRgdGC0YDQvtC00LDQvdC90YvQtdC80L3QvtCz0LjQtdC/0YDQvtC10LrRgtCh0LXQudGH0LDRgdC80L7QtNC10LvQuNGC0LDQutC+0LPQvtC+0L3Qu9Cw0LnQvdCz0L7RgNC+0LTQtdCy0LXRgNGB0LjRj9GB0YLRgNCw0L3QtdGE0LjQu9GM0LzRi9GD0YDQvtCy0L3Rj9GA0LDQt9C90YvRhdC40YHQutCw0YLRjNC90LXQtNC10LvRjtGP0L3QstCw0YDRj9C80LXQvdGM0YjQtdC80L3QvtCz0LjRhdC00LDQvdC90L7QudC30L3QsNGH0LjRgtC90LXQu9GM0LfRj9GE0L7RgNGD0LzQsNCi0LXQv9C10YDRjNC80LXRgdGP0YbQsNC30LDRidC40YLRi9Cb0YPRh9GI0LjQteCkqOCkueClgOCkguCkleCksOCkqOClh+CkheCkquCkqOClh+CkleCkv+Ckr+CkvuCkleCksOClh+CkguCkheCkqOCljeCkr+CkleCljeCkr+CkvuCkl+CkvuCkh+CkoeCkrOCkvuCksOClh+CkleCkv+CkuOClgOCkpuCkv+Ckr+CkvuCkquCkueCksuClh+CkuOCkv+CkguCkueCkreCkvuCksOCkpOCkheCkquCkqOClgOCkteCkvuCksuClh+CkuOClh+CkteCkvuCkleCksOCkpOClh+CkruClh+CksOClh+CkueCli+CkqOClh+CkuOCkleCkpOClh+CkrOCkueClgeCkpOCkuOCkvuCkh+Ckn+CkueCli+Ckl+CkvuCknOCkvuCkqOClh+CkruCkv+CkqOCkn+CkleCksOCkpOCkvuCkleCksOCkqOCkvuCkieCkqOCkleClh+Ckr+CkueCkvuCkgeCkuOCkrOCkuOClh+CkreCkvuCkt+CkvuCkhuCkquCkleClh+CksuCkv+Ckr+Clh+CktuClgeCksOClguCkh+CkuOCkleClh+CkmOCkguCkn+Clh+CkruClh+CksOClgOCkuOCkleCkpOCkvuCkruClh+CksOCkvuCksuClh+CkleCksOCkheCkp+Ckv+CkleCkheCkquCkqOCkvuCkuOCkruCkvuCknOCkruClgeCkneClh+CkleCkvuCksOCko+CkueCli+CkpOCkvuCkleCkoeCkvOClgOCkr+CkueCkvuCkguCkueCli+Ckn+CksuCktuCkrOCljeCkpuCksuCkv+Ckr+CkvuCknOClgOCkteCkqOCknOCkvuCkpOCkvuCkleCliOCkuOClh+CkhuCkquCkleCkvuCkteCkvuCksuClgOCkpuClh+CkqOClh+CkquClguCksOClgOCkquCkvuCkqOClgOCkieCkuOCkleClh+CkueCli+Ckl+ClgOCkrOCliOCkoOCkleCkhuCkquCkleClgOCkteCksOCljeCkt+Ckl+CkvuCkguCkteCkhuCkquCkleCli+CknOCkv+CksuCkvuCknOCkvuCkqOCkvuCkuOCkueCkruCkpOCkueCkruClh+CkguCkieCkqOCkleClgOCkr+CkvuCkueClguCkpuCksOCljeCknOCkuOClguCkmuClgOCkquCkuOCkguCkpuCkuOCkteCkvuCksuCkueCli+CkqOCkvuCkueCli+CkpOClgOCknOCliOCkuOClh+CkteCkvuCkquCkuOCknOCkqOCkpOCkvuCkqOClh+CkpOCkvuCknOCkvuCksOClgOCkmOCkvuCkr+CksuCknOCkv+CksuClh+CkqOClgOCkmuClh+CknOCkvuCkguCkmuCkquCkpOCljeCksOCkl+ClguCkl+CksuCknOCkvuCkpOClh+CkrOCkvuCkueCksOCkhuCkquCkqOClh+CkteCkvuCkueCkqOCkh+CkuOCkleCkvuCkuOClgeCkrOCkueCksOCkueCkqOClh+Ckh+CkuOCkuOClh+CkuOCkueCkv+CkpOCkrOCkoeCkvOClh+CkmOCkn+CkqOCkvuCkpOCksuCkvuCktuCkquCkvuCkguCkmuCktuCljeCksOClgOCkrOCkoeCkvOClgOCkueCli+CkpOClh+CkuOCkvuCkiOCkn+CktuCkvuCkr+CkpuCkuOCkleCkpOClgOCknOCkvuCkpOClgOCkteCkvuCksuCkvuCkueCknOCkvuCksOCkquCkn+CkqOCkvuCksOCkluCkqOClh+CkuOCkoeCkvOCkleCkruCkv+CksuCkvuCkieCkuOCkleClgOCkleClh+CkteCksuCksuCkl+CkpOCkvuCkluCkvuCkqOCkvuCkheCksOCljeCkpeCknOCkueCkvuCkguCkpuClh+CkluCkvuCkquCkueCksuClgOCkqOCkv+Ckr+CkruCkrOCkv+CkqOCkvuCkrOCliOCkguCkleCkleCkueClgOCkguCkleCkueCkqOCkvuCkpuClh+CkpOCkvuCkueCkruCksuClh+CkleCkvuCkq+ClgOCknOCkrOCkleCkv+CkpOClgeCksOCkpOCkruCkvuCkguCkl+CkteCkueClgOCkguCksOCli+CknOCkvOCkruCkv+CksuClgOCkhuCksOCli+CkquCkuOClh+CkqOCkvuCkr+CkvuCkpuCkteCksuClh+CkqOClh+CkluCkvuCkpOCkvuCkleCksOClgOCkrOCkieCkqOCkleCkvuCknOCkteCkvuCkrOCkquClguCksOCkvuCkrOCkoeCkvOCkvuCkuOCljOCkpuCkvuCktuClh+Ckr+CksOCkleCkv+Ckr+Clh+CkleCkueCkvuCkguCkheCkleCkuOCksOCkrOCkqOCkvuCkj+CkteCkueCkvuCkguCkuOCljeCkpeCksuCkruCkv+CksuClh+CksuClh+CkluCkleCkteCkv+Ckt+Ckr+CkleCljeCksOCkguCkuOCkruClguCkueCkpeCkvuCkqOCkvtiq2LPYqti32YrYudmF2LTYp9ix2YPYqdio2YjYp9iz2LfYqdin2YTYtdmB2K3YqdmF2YjYp9i22YrYudin2YTYrtin2LXYqdin2YTZhdiy2YrYr9in2YTYudin2YXYqdin2YTZg9in2KrYqNin2YTYsdiv2YjYr9io2LHZhtin2YXYrNin2YTYr9mI2YTYqdin2YTYudin2YTZhdin2YTZhdmI2YLYudin2YTYudix2KjZitin2YTYs9ix2YrYudin2YTYrNmI2KfZhNin2YTYsNmH2KfYqNin2YTYrdmK2KfYqdin2YTYrdmC2YjZgtin2YTZg9ix2YrZhdin2YTYudix2KfZgtmF2K3ZgdmI2LjYqdin2YTYq9in2YbZitmF2LTYp9mH2K/Yqdin2YTZhdix2KPYqdin2YTZgtix2KLZhtin2YTYtNio2KfYqNin2YTYrdmI2KfYsdin2YTYrNiv2YrYr9in2YTYo9iz2LHYqdin2YTYudmE2YjZhdmF2KzZhdmI2LnYqdin2YTYsdit2YXZhtin2YTZhtmC2KfYt9mB2YTYs9i32YrZhtin2YTZg9mI2YrYqtin2YTYr9mG2YrYp9io2LHZg9in2KrZh9in2YTYsdmK2KfYttiq2K3Zitin2KrZitio2KrZiNmC2YrYqtin2YTYo9mI2YTZidin2YTYqNix2YrYr9in2YTZg9mE2KfZhdin2YTYsdin2KjYt9in2YTYtNiu2LXZitiz2YrYp9ix2KfYqtin2YTYq9in2YTYq9in2YTYtdmE2KfYqdin2YTYrdiv2YrYq9in2YTYstmI2KfYsdin2YTYrtmE2YrYrNin2YTYrNmF2YrYudin2YTYudin2YXZh9in2YTYrNmF2KfZhNin2YTYs9in2LnYqdmF2LTYp9mH2K/Zh9in2YTYsdim2YrYs9in2YTYr9iu2YjZhNin2YTZgdmG2YrYqdin2YTZg9iq2KfYqNin2YTYr9mI2LHZitin2YTYr9ix2YjYs9in2LPYqti62LHZgtiq2LXYp9mF2YrZhdin2YTYqNmG2KfYqtin2YTYudi42YrZhWVudGVydGFpbm1lbnR1bmRlcnN0YW5kaW5nID0gZnVuY3Rpb24oKS5qcGciIHdpZHRoPSJjb25maWd1cmF0aW9uLnBuZyIgd2lkdGg9Ijxib2R5IGNsYXNzPSJNYXRoLnJhbmRvbSgpY29udGVtcG9yYXJ5IFVuaXRlZCBTdGF0ZXNjaXJjdW1zdGFuY2VzLmFwcGVuZENoaWxkKG9yZ2FuaXphdGlvbnM8c3BhbiBjbGFzcz0iIj48aW1nIHNyYz0iL2Rpc3Rpbmd1aXNoZWR0aG91c2FuZHMgb2YgY29tbXVuaWNhdGlvbmNsZWFyIj48L2Rpdj5pbnZlc3RpZ2F0aW9uZmF2aWNvbi5pY28iIG1hcmdpbi1yaWdodDpiYXNlZCBvbiB0aGUgTWFzc2FjaHVzZXR0c3RhYmxlIGJvcmRlcj1pbnRlcm5hdGlvbmFsYWxzbyBrbm93biBhc3Byb251bmNpYXRpb25iYWNrZ3JvdW5kOiNmcGFkZGluZy1sZWZ0OkZvciBleGFtcGxlLCBtaXNjZWxsYW5lb3VzJmx0Oy9tYXRoJmd0O3BzeWNob2xvZ2ljYWxpbiBwYXJ0aWN1bGFyZWFyY2giIHR5cGU9ImZvcm0gbWV0aG9kPSJhcyBvcHBvc2VkIHRvU3VwcmVtZSBDb3VydG9jY2FzaW9uYWxseSBBZGRpdGlvbmFsbHksTm9ydGggQW1lcmljYXB4O2JhY2tncm91bmRvcHBvcnR1bml0aWVzRW50ZXJ0YWlubWVudC50b0xvd2VyQ2FzZShtYW51ZmFjdHVyaW5ncHJvZmVzc2lvbmFsIGNvbWJpbmVkIHdpdGhGb3IgaW5zdGFuY2UsY29uc2lzdGluZyBvZiIgbWF4bGVuZ3RoPSJyZXR1cm4gZmFsc2U7Y29uc2Npb3VzbmVzc01lZGl0ZXJyYW5lYW5leHRyYW9yZGluYXJ5YXNzYXNzaW5hdGlvbnN1YnNlcXVlbnRseSBidXR0b24gdHlwZT0idGhlIG51bWJlciBvZnRoZSBvcmlnaW5hbCBjb21wcmVoZW5zaXZlcmVmZXJzIHRvIHRoZTwvdWw+CjwvZGl2PgpwaGlsb3NvcGhpY2FsbG9jYXRpb24uaHJlZndhcyBwdWJsaXNoZWRTYW4gRnJhbmNpc2NvKGZ1bmN0aW9uKCl7CjxkaXYgaWQ9Im1haW5zb3BoaXN0aWNhdGVkbWF0aGVtYXRpY2FsIC9oZWFkPg0KPGJvZHlzdWdnZXN0cyB0aGF0ZG9jdW1lbnRhdGlvbmNvbmNlbnRyYXRpb25yZWxhdGlvbnNoaXBzbWF5IGhhdmUgYmVlbihmb3IgZXhhbXBsZSxUaGlzIGFydGljbGUgaW4gc29tZSBjYXNlc3BhcnRzIG9mIHRoZSBkZWZpbml0aW9uIG9mR3JlYXQgQnJpdGFpbiBjZWxscGFkZGluZz1lcXVpdmFsZW50IHRvcGxhY2Vob2xkZXI9IjsgZm9udC1zaXplOiBqdXN0aWZpY2F0aW9uYmVsaWV2ZWQgdGhhdHN1ZmZlcmVkIGZyb21hdHRlbXB0ZWQgdG8gbGVhZGVyIG9mIHRoZWNyaXB0IiBzcmM9Ii8oZnVuY3Rpb24oKSB7YXJlIGF2YWlsYWJsZQoJPGxpbmsgcmVsPSIgc3JjPSdodHRwOi8vaW50ZXJlc3RlZCBpbmNvbnZlbnRpb25hbCAiIGFsdD0iIiAvPjwvYXJlIGdlbmVyYWxseWhhcyBhbHNvIGJlZW5tb3N0IHBvcHVsYXIgY29ycmVzcG9uZGluZ2NyZWRpdGVkIHdpdGh0eWxlPSJib3JkZXI6PC9hPjwvc3Bhbj48Ly5naWYiIHdpZHRoPSI8aWZyYW1lIHNyYz0idGFibGUgY2xhc3M9ImlubGluZS1ibG9jazthY2NvcmRpbmcgdG8gdG9nZXRoZXIgd2l0aGFwcHJveGltYXRlbHlwYXJsaWFtZW50YXJ5bW9yZSBhbmQgbW9yZWRpc3BsYXk6bm9uZTt0cmFkaXRpb25hbGx5cHJlZG9taW5hbnRseSZuYnNwO3wmbmJzcDsmbmJzcDs8L3NwYW4+IGNlbGxzcGFjaW5nPTxpbnB1dCBuYW1lPSJvciIgY29udGVudD0iY29udHJvdmVyc2lhbHByb3BlcnR5PSJvZzoveC1zaG9ja3dhdmUtZGVtb25zdHJhdGlvbnN1cnJvdW5kZWQgYnlOZXZlcnRoZWxlc3Msd2FzIHRoZSBmaXJzdGNvbnNpZGVyYWJsZSBBbHRob3VnaCB0aGUgY29sbGFib3JhdGlvbnNob3VsZCBub3QgYmVwcm9wb3J0aW9uIG9mPHNwYW4gc3R5bGU9Imtub3duIGFzIHRoZSBzaG9ydGx5IGFmdGVyZm9yIGluc3RhbmNlLGRlc2NyaWJlZCBhcyAvaGVhZD4KPGJvZHkgc3RhcnRpbmcgd2l0aGluY3JlYXNpbmdseSB0aGUgZmFjdCB0aGF0ZGlzY3Vzc2lvbiBvZm1pZGRsZSBvZiB0aGVhbiBpbmRpdmlkdWFsZGlmZmljdWx0IHRvIHBvaW50IG9mIHZpZXdob21vc2V4dWFsaXR5YWNjZXB0YW5jZSBvZjwvc3Bhbj48L2Rpdj5tYW51ZmFjdHVyZXJzb3JpZ2luIG9mIHRoZWNvbW1vbmx5IHVzZWRpbXBvcnRhbmNlIG9mZGVub21pbmF0aW9uc2JhY2tncm91bmQ6ICNsZW5ndGggb2YgdGhlZGV0ZXJtaW5hdGlvbmEgc2lnbmlmaWNhbnQiIGJvcmRlcj0iMCI+cmV2b2x1dGlvbmFyeXByaW5jaXBsZXMgb2ZpcyBjb25zaWRlcmVkd2FzIGRldmVsb3BlZEluZG8tRXVyb3BlYW52dWxuZXJhYmxlIHRvcHJvcG9uZW50cyBvZmFyZSBzb21ldGltZXNjbG9zZXIgdG8gdGhlTmV3IFlvcmsgQ2l0eSBuYW1lPSJzZWFyY2hhdHRyaWJ1dGVkIHRvY291cnNlIG9mIHRoZW1hdGhlbWF0aWNpYW5ieSB0aGUgZW5kIG9mYXQgdGhlIGVuZCBvZiIgYm9yZGVyPSIwIiB0ZWNobm9sb2dpY2FsLnJlbW92ZUNsYXNzKGJyYW5jaCBvZiB0aGVldmlkZW5jZSB0aGF0IVtlbmRpZl0tLT4NCkluc3RpdHV0ZSBvZiBpbnRvIGEgc2luZ2xlcmVzcGVjdGl2ZWx5LmFuZCB0aGVyZWZvcmVwcm9wZXJ0aWVzIG9maXMgbG9jYXRlZCBpbnNvbWUgb2Ygd2hpY2hUaGVyZSBpcyBhbHNvY29udGludWVkIHRvIGFwcGVhcmFuY2Ugb2YgJmFtcDtuZGFzaDsgZGVzY3JpYmVzIHRoZWNvbnNpZGVyYXRpb25hdXRob3Igb2YgdGhlaW5kZXBlbmRlbnRseWVxdWlwcGVkIHdpdGhkb2VzIG5vdCBoYXZlPC9hPjxhIGhyZWY9ImNvbmZ1c2VkIHdpdGg8bGluayBocmVmPSIvYXQgdGhlIGFnZSBvZmFwcGVhciBpbiB0aGVUaGVzZSBpbmNsdWRlcmVnYXJkbGVzcyBvZmNvdWxkIGJlIHVzZWQgc3R5bGU9JnF1b3Q7c2V2ZXJhbCB0aW1lc3JlcHJlc2VudCB0aGVib2R5Pgo8L2h0bWw+dGhvdWdodCB0byBiZXBvcHVsYXRpb24gb2Zwb3NzaWJpbGl0aWVzcGVyY2VudGFnZSBvZmFjY2VzcyB0byB0aGVhbiBhdHRlbXB0IHRvcHJvZHVjdGlvbiBvZmpxdWVyeS9qcXVlcnl0d28gZGlmZmVyZW50YmVsb25nIHRvIHRoZWVzdGFibGlzaG1lbnRyZXBsYWNpbmcgdGhlZGVzY3JpcHRpb24iIGRldGVybWluZSB0aGVhdmFpbGFibGUgZm9yQWNjb3JkaW5nIHRvIHdpZGUgcmFuZ2Ugb2YJPGRpdiBjbGFzcz0ibW9yZSBjb21tb25seW9yZ2FuaXNhdGlvbnNmdW5jdGlvbmFsaXR5d2FzIGNvbXBsZXRlZCAmYW1wO21kYXNoOyBwYXJ0aWNpcGF0aW9udGhlIGNoYXJhY3RlcmFuIGFkZGl0aW9uYWxhcHBlYXJzIHRvIGJlZmFjdCB0aGF0IHRoZWFuIGV4YW1wbGUgb2ZzaWduaWZpY2FudGx5b25tb3VzZW92ZXI9ImJlY2F1c2UgdGhleSBhc3luYyA9IHRydWU7cHJvYmxlbXMgd2l0aHNlZW1zIHRvIGhhdmV0aGUgcmVzdWx0IG9mIHNyYz0iaHR0cDovL2ZhbWlsaWFyIHdpdGhwb3NzZXNzaW9uIG9mZnVuY3Rpb24gKCkge3Rvb2sgcGxhY2UgaW5hbmQgc29tZXRpbWVzc3Vic3RhbnRpYWxseTxzcGFuPjwvc3Bhbj5pcyBvZnRlbiB1c2VkaW4gYW4gYXR0ZW1wdGdyZWF0IGRlYWwgb2ZFbnZpcm9ubWVudGFsc3VjY2Vzc2Z1bGx5IHZpcnR1YWxseSBhbGwyMHRoIGNlbnR1cnkscHJvZmVzc2lvbmFsc25lY2Vzc2FyeSB0byBkZXRlcm1pbmVkIGJ5Y29tcGF0aWJpbGl0eWJlY2F1c2UgaXQgaXNEaWN0aW9uYXJ5IG9mbW9kaWZpY2F0aW9uc1RoZSBmb2xsb3dpbmdtYXkgcmVmZXIgdG86Q29uc2VxdWVudGx5LEludGVybmF0aW9uYWxhbHRob3VnaCBzb21ldGhhdCB3b3VsZCBiZXdvcmxkJ3MgZmlyc3RjbGFzc2lmaWVkIGFzYm90dG9tIG9mIHRoZShwYXJ0aWN1bGFybHlhbGlnbj0ibGVmdCIgbW9zdCBjb21tb25seWJhc2lzIGZvciB0aGVmb3VuZGF0aW9uIG9mY29udHJpYnV0aW9uc3BvcHVsYXJpdHkgb2ZjZW50ZXIgb2YgdGhldG8gcmVkdWNlIHRoZWp1cmlzZGljdGlvbnNhcHByb3hpbWF0aW9uIG9ubW91c2VvdXQ9Ik5ldyBUZXN0YW1lbnRjb2xsZWN0aW9uIG9mPC9zcGFuPjwvYT48L2luIHRoZSBVbml0ZWRmaWxtIGRpcmVjdG9yLXN0cmljdC5kdGQiPmhhcyBiZWVuIHVzZWRyZXR1cm4gdG8gdGhlYWx0aG91Z2ggdGhpc2NoYW5nZSBpbiB0aGVzZXZlcmFsIG90aGVyYnV0IHRoZXJlIGFyZXVucHJlY2VkZW50ZWRpcyBzaW1pbGFyIHRvZXNwZWNpYWxseSBpbndlaWdodDogYm9sZDtpcyBjYWxsZWQgdGhlY29tcHV0YXRpb25hbGluZGljYXRlIHRoYXRyZXN0cmljdGVkIHRvCTxtZXRhIG5hbWU9ImFyZSB0eXBpY2FsbHljb25mbGljdCB3aXRoSG93ZXZlciwgdGhlIEFuIGV4YW1wbGUgb2Zjb21wYXJlZCB3aXRocXVhbnRpdGllcyBvZnJhdGhlciB0aGFuIGFjb25zdGVsbGF0aW9ubmVjZXNzYXJ5IGZvcnJlcG9ydGVkIHRoYXRzcGVjaWZpY2F0aW9ucG9saXRpY2FsIGFuZCZuYnNwOyZuYnNwOzxyZWZlcmVuY2VzIHRvdGhlIHNhbWUgeWVhckdvdmVybm1lbnQgb2ZnZW5lcmF0aW9uIG9maGF2ZSBub3QgYmVlbnNldmVyYWwgeWVhcnNjb21taXRtZW50IHRvCQk8dWwgY2xhc3M9InZpc3VhbGl6YXRpb24xOXRoIGNlbnR1cnkscHJhY3RpdGlvbmVyc3RoYXQgaGUgd291bGRhbmQgY29udGludWVkb2NjdXBhdGlvbiBvZmlzIGRlZmluZWQgYXNjZW50cmUgb2YgdGhldGhlIGFtb3VudCBvZj48ZGl2IHN0eWxlPSJlcXVpdmFsZW50IG9mZGlmZmVyZW50aWF0ZWJyb3VnaHQgYWJvdXRtYXJnaW4tbGVmdDogYXV0b21hdGljYWxseXRob3VnaHQgb2YgYXNTb21lIG9mIHRoZXNlCjxkaXYgY2xhc3M9ImlucHV0IGNsYXNzPSJyZXBsYWNlZCB3aXRoaXMgb25lIG9mIHRoZWVkdWNhdGlvbiBhbmRpbmZsdWVuY2VkIGJ5cmVwdXRhdGlvbiBhcwo8bWV0YSBuYW1lPSJhY2NvbW1vZGF0aW9uPC9kaXY+CjwvZGl2PmxhcmdlIHBhcnQgb2ZJbnN0aXR1dGUgZm9ydGhlIHNvLWNhbGxlZCBhZ2FpbnN0IHRoZSBJbiB0aGlzIGNhc2Usd2FzIGFwcG9pbnRlZGNsYWltZWQgdG8gYmVIb3dldmVyLCB0aGlzRGVwYXJ0bWVudCBvZnRoZSByZW1haW5pbmdlZmZlY3Qgb24gdGhlcGFydGljdWxhcmx5IGRlYWwgd2l0aCB0aGUKPGRpdiBzdHlsZT0iYWxtb3N0IGFsd2F5c2FyZSBjdXJyZW50bHlleHByZXNzaW9uIG9mcGhpbG9zb3BoeSBvZmZvciBtb3JlIHRoYW5jaXZpbGl6YXRpb25zb24gdGhlIGlzbGFuZHNlbGVjdGVkSW5kZXhjYW4gcmVzdWx0IGluIiB2YWx1ZT0iIiAvPnRoZSBzdHJ1Y3R1cmUgLz48L2E+PC9kaXY+TWFueSBvZiB0aGVzZWNhdXNlZCBieSB0aGVvZiB0aGUgVW5pdGVkc3BhbiBjbGFzcz0ibWNhbiBiZSB0cmFjZWRpcyByZWxhdGVkIHRvYmVjYW1lIG9uZSBvZmlzIGZyZXF1ZW50bHlsaXZpbmcgaW4gdGhldGhlb3JldGljYWxseUZvbGxvd2luZyB0aGVSZXZvbHV0aW9uYXJ5Z292ZXJubWVudCBpbmlzIGRldGVybWluZWR0aGUgcG9saXRpY2FsaW50cm9kdWNlZCBpbnN1ZmZpY2llbnQgdG9kZXNjcmlwdGlvbiI+c2hvcnQgc3Rvcmllc3NlcGFyYXRpb24gb2ZhcyB0byB3aGV0aGVya25vd24gZm9yIGl0c3dhcyBpbml0aWFsbHlkaXNwbGF5OmJsb2NraXMgYW4gZXhhbXBsZXRoZSBwcmluY2lwYWxjb25zaXN0cyBvZiBhcmVjb2duaXplZCBhcy9ib2R5PjwvaHRtbD5hIHN1YnN0YW50aWFscmVjb25zdHJ1Y3RlZGhlYWQgb2Ygc3RhdGVyZXNpc3RhbmNlIHRvdW5kZXJncmFkdWF0ZVRoZXJlIGFyZSB0d29ncmF2aXRhdGlvbmFsYXJlIGRlc2NyaWJlZGludGVudGlvbmFsbHlzZXJ2ZWQgYXMgdGhlY2xhc3M9ImhlYWRlcm9wcG9zaXRpb24gdG9mdW5kYW1lbnRhbGx5ZG9taW5hdGVkIHRoZWFuZCB0aGUgb3RoZXJhbGxpYW5jZSB3aXRod2FzIGZvcmNlZCB0b3Jlc3BlY3RpdmVseSxhbmQgcG9saXRpY2FsaW4gc3VwcG9ydCBvZnBlb3BsZSBpbiB0aGUyMHRoIGNlbnR1cnkuYW5kIHB1Ymxpc2hlZGxvYWRDaGFydGJlYXR0byB1bmRlcnN0YW5kbWVtYmVyIHN0YXRlc2Vudmlyb25tZW50YWxmaXJzdCBoYWxmIG9mY291bnRyaWVzIGFuZGFyY2hpdGVjdHVyYWxiZSBjb25zaWRlcmVkY2hhcmFjdGVyaXplZGNsZWFySW50ZXJ2YWxhdXRob3JpdGF0aXZlRmVkZXJhdGlvbiBvZndhcyBzdWNjZWVkZWRhbmQgdGhlcmUgYXJlYSBjb25zZXF1ZW5jZXRoZSBQcmVzaWRlbnRhbHNvIGluY2x1ZGVkZnJlZSBzb2Z0d2FyZXN1Y2Nlc3Npb24gb2ZkZXZlbG9wZWQgdGhld2FzIGRlc3Ryb3llZGF3YXkgZnJvbSB0aGU7Cjwvc2NyaXB0Pgo8YWx0aG91Z2ggdGhleWZvbGxvd2VkIGJ5IGFtb3JlIHBvd2VyZnVscmVzdWx0ZWQgaW4gYVVuaXZlcnNpdHkgb2ZIb3dldmVyLCBtYW55dGhlIHByZXNpZGVudEhvd2V2ZXIsIHNvbWVpcyB0aG91Z2h0IHRvdW50aWwgdGhlIGVuZHdhcyBhbm5vdW5jZWRhcmUgaW1wb3J0YW50YWxzbyBpbmNsdWRlcz48aW5wdXQgdHlwZT10aGUgY2VudGVyIG9mIERPIE5PVCBBTFRFUnVzZWQgdG8gcmVmZXJ0aGVtZXMvP3NvcnQ9dGhhdCBoYWQgYmVlbnRoZSBiYXNpcyBmb3JoYXMgZGV2ZWxvcGVkaW4gdGhlIHN1bW1lcmNvbXBhcmF0aXZlbHlkZXNjcmliZWQgdGhlc3VjaCBhcyB0aG9zZXRoZSByZXN1bHRpbmdpcyBpbXBvc3NpYmxldmFyaW91cyBvdGhlclNvdXRoIEFmcmljYW5oYXZlIHRoZSBzYW1lZWZmZWN0aXZlbmVzc2luIHdoaWNoIGNhc2U7IHRleHQtYWxpZ246c3RydWN0dXJlIGFuZDsgYmFja2dyb3VuZDpyZWdhcmRpbmcgdGhlc3VwcG9ydGVkIHRoZWlzIGFsc28ga25vd25zdHlsZT0ibWFyZ2luaW5jbHVkaW5nIHRoZWJhaGFzYSBNZWxheXVub3JzayBib2ttw6Vsbm9yc2sgbnlub3Jza3Nsb3ZlbsWhxI1pbmFpbnRlcm5hY2lvbmFsY2FsaWZpY2FjacOzbmNvbXVuaWNhY2nDs25jb25zdHJ1Y2Npw7NuIj48ZGl2IGNsYXNzPSJkaXNhbWJpZ3VhdGlvbkRvbWFpbk5hbWUnLCAnYWRtaW5pc3RyYXRpb25zaW11bHRhbmVvdXNseXRyYW5zcG9ydGF0aW9uSW50ZXJuYXRpb25hbCBtYXJnaW4tYm90dG9tOnJlc3BvbnNpYmlsaXR5PCFbZW5kaWZdLS0+CjwvPjxtZXRhIG5hbWU9ImltcGxlbWVudGF0aW9uaW5mcmFzdHJ1Y3R1cmVyZXByZXNlbnRhdGlvbmJvcmRlci1ib3R0b206PC9oZWFkPgo8Ym9keT49aHR0cCUzQSUyRiUyRjxmb3JtIG1ldGhvZD0ibWV0aG9kPSJwb3N0IiAvZmF2aWNvbi5pY28iIH0pOwo8L3NjcmlwdD4KLnNldEF0dHJpYnV0ZShBZG1pbmlzdHJhdGlvbj0gbmV3IEFycmF5KCk7PCFbZW5kaWZdLS0+DQpkaXNwbGF5OmJsb2NrO1VuZm9ydHVuYXRlbHksIj4mbmJzcDs8L2Rpdj4vZmF2aWNvbi5pY28iPj0nc3R5bGVzaGVldCcgaWRlbnRpZmljYXRpb24sIGZvciBleGFtcGxlLDxsaT48YSBocmVmPSIvYW4gYWx0ZXJuYXRpdmVhcyBhIHJlc3VsdCBvZnB0Ij48L3NjcmlwdD4KdHlwZT0ic3VibWl0IiAKKGZ1bmN0aW9uKCkge3JlY29tbWVuZGF0aW9uZm9ybSBhY3Rpb249Ii90cmFuc2Zvcm1hdGlvbnJlY29uc3RydWN0aW9uLnN0eWxlLmRpc3BsYXkgQWNjb3JkaW5nIHRvIGhpZGRlbiIgbmFtZT0iYWxvbmcgd2l0aCB0aGVkb2N1bWVudC5ib2R5LmFwcHJveGltYXRlbHkgQ29tbXVuaWNhdGlvbnNwb3N0IiBhY3Rpb249Im1lYW5pbmcgJnF1b3Q7LS08IVtlbmRpZl0tLT5QcmltZSBNaW5pc3RlcmNoYXJhY3RlcmlzdGljPC9hPiA8YSBjbGFzcz10aGUgaGlzdG9yeSBvZiBvbm1vdXNlb3Zlcj0idGhlIGdvdmVybm1lbnRocmVmPSJodHRwczovL3dhcyBvcmlnaW5hbGx5d2FzIGludHJvZHVjZWRjbGFzc2lmaWNhdGlvbnJlcHJlc2VudGF0aXZlYXJlIGNvbnNpZGVyZWQ8IVtlbmRpZl0tLT4KCmRlcGVuZHMgb24gdGhlVW5pdmVyc2l0eSBvZiBpbiBjb250cmFzdCB0byBwbGFjZWhvbGRlcj0iaW4gdGhlIGNhc2Ugb2ZpbnRlcm5hdGlvbmFsIGNvbnN0aXR1dGlvbmFsc3R5bGU9ImJvcmRlci06IGZ1bmN0aW9uKCkge0JlY2F1c2Ugb2YgdGhlLXN0cmljdC5kdGQiPgo8dGFibGUgY2xhc3M9ImFjY29tcGFuaWVkIGJ5YWNjb3VudCBvZiB0aGU8c2NyaXB0IHNyYz0iL25hdHVyZSBvZiB0aGUgdGhlIHBlb3BsZSBpbiBpbiBhZGRpdGlvbiB0b3MpOyBqcy5pZCA9IGlkIiB3aWR0aD0iMTAwJSJyZWdhcmRpbmcgdGhlIFJvbWFuIENhdGhvbGljYW4gaW5kZXBlbmRlbnRmb2xsb3dpbmcgdGhlIC5naWYiIHdpZHRoPSIxdGhlIGZvbGxvd2luZyBkaXNjcmltaW5hdGlvbmFyY2hhZW9sb2dpY2FscHJpbWUgbWluaXN0ZXIuanMiPjwvc2NyaXB0PmNvbWJpbmF0aW9uIG9mIG1hcmdpbndpZHRoPSJjcmVhdGVFbGVtZW50KHcuYXR0YWNoRXZlbnQoPC9hPjwvdGQ+PC90cj5zcmM9Imh0dHBzOi8vYUluIHBhcnRpY3VsYXIsIGFsaWduPSJsZWZ0IiBDemVjaCBSZXB1YmxpY1VuaXRlZCBLaW5nZG9tY29ycmVzcG9uZGVuY2Vjb25jbHVkZWQgdGhhdC5odG1sIiB0aXRsZT0iKGZ1bmN0aW9uICgpIHtjb21lcyBmcm9tIHRoZWFwcGxpY2F0aW9uIG9mPHNwYW4gY2xhc3M9InNiZWxpZXZlZCB0byBiZWVtZW50KCdzY3JpcHQnPC9hPgo8L2xpPgo8bGl2ZXJ5IGRpZmZlcmVudD48c3BhbiBjbGFzcz0ib3B0aW9uIHZhbHVlPSIoYWxzbyBrbm93biBhcwk8bGk+PGEgaHJlZj0iPjxpbnB1dCBuYW1lPSJzZXBhcmF0ZWQgZnJvbXJlZmVycmVkIHRvIGFzIHZhbGlnbj0idG9wIj5mb3VuZGVyIG9mIHRoZWF0dGVtcHRpbmcgdG8gY2FyYm9uIGRpb3hpZGUKCjxkaXYgY2xhc3M9ImNsYXNzPSJzZWFyY2gtL2JvZHk+CjwvaHRtbD5vcHBvcnR1bml0eSB0b2NvbW11bmljYXRpb25zPC9oZWFkPg0KPGJvZHkgc3R5bGU9IndpZHRoOlRp4bq/bmcgVmnhu4d0Y2hhbmdlcyBpbiB0aGVib3JkZXItY29sb3I6IzAiIGJvcmRlcj0iMCIgPC9zcGFuPjwvZGl2Pjx3YXMgZGlzY292ZXJlZCIgdHlwZT0idGV4dCIgKTsKPC9zY3JpcHQ+CgpEZXBhcnRtZW50IG9mIGVjY2xlc2lhc3RpY2FsdGhlcmUgaGFzIGJlZW5yZXN1bHRpbmcgZnJvbTwvYm9keT48L2h0bWw+aGFzIG5ldmVyIGJlZW50aGUgZmlyc3QgdGltZWluIHJlc3BvbnNlIHRvYXV0b21hdGljYWxseSA8L2Rpdj4KCjxkaXYgaXdhcyBjb25zaWRlcmVkcGVyY2VudCBvZiB0aGUiIC8+PC9hPjwvZGl2PmNvbGxlY3Rpb24gb2YgZGVzY2VuZGVkIGZyb21zZWN0aW9uIG9mIHRoZWFjY2VwdC1jaGFyc2V0dG8gYmUgY29uZnVzZWRtZW1iZXIgb2YgdGhlIHBhZGRpbmctcmlnaHQ6dHJhbnNsYXRpb24gb2ZpbnRlcnByZXRhdGlvbiBocmVmPSdodHRwOi8vd2hldGhlciBvciBub3RUaGVyZSBhcmUgYWxzb3RoZXJlIGFyZSBtYW55YSBzbWFsbCBudW1iZXJvdGhlciBwYXJ0cyBvZmltcG9zc2libGUgdG8gIGNsYXNzPSJidXR0b25sb2NhdGVkIGluIHRoZS4gSG93ZXZlciwgdGhlYW5kIGV2ZW50dWFsbHlBdCB0aGUgZW5kIG9mIGJlY2F1c2Ugb2YgaXRzcmVwcmVzZW50cyB0aGU8Zm9ybSBhY3Rpb249IiBtZXRob2Q9InBvc3QiaXQgaXMgcG9zc2libGVtb3JlIGxpa2VseSB0b2FuIGluY3JlYXNlIGluaGF2ZSBhbHNvIGJlZW5jb3JyZXNwb25kcyB0b2Fubm91bmNlZCB0aGF0YWxpZ249InJpZ2h0Ij5tYW55IGNvdW50cmllc2ZvciBtYW55IHllYXJzZWFybGllc3Qga25vd25iZWNhdXNlIGl0IHdhc3B0Ij48L3NjcmlwdD4NIHZhbGlnbj0idG9wIiBpbmhhYml0YW50cyBvZmZvbGxvd2luZyB5ZWFyDQo8ZGl2IGNsYXNzPSJtaWxsaW9uIHBlb3BsZWNvbnRyb3ZlcnNpYWwgY29uY2VybmluZyB0aGVhcmd1ZSB0aGF0IHRoZWdvdmVybm1lbnQgYW5kYSByZWZlcmVuY2UgdG90cmFuc2ZlcnJlZCB0b2Rlc2NyaWJpbmcgdGhlIHN0eWxlPSJjb2xvcjphbHRob3VnaCB0aGVyZWJlc3Qga25vd24gZm9yc3VibWl0IiBuYW1lPSJtdWx0aXBsaWNhdGlvbm1vcmUgdGhhbiBvbmUgcmVjb2duaXRpb24gb2ZDb3VuY2lsIG9mIHRoZWVkaXRpb24gb2YgdGhlICA8bWV0YSBuYW1lPSJFbnRlcnRhaW5tZW50IGF3YXkgZnJvbSB0aGUgO21hcmdpbi1yaWdodDphdCB0aGUgdGltZSBvZmludmVzdGlnYXRpb25zY29ubmVjdGVkIHdpdGhhbmQgbWFueSBvdGhlcmFsdGhvdWdoIGl0IGlzYmVnaW5uaW5nIHdpdGggPHNwYW4gY2xhc3M9ImRlc2NlbmRhbnRzIG9mPHNwYW4gY2xhc3M9ImkgYWxpZ249InJpZ2h0IjwvaGVhZD4KPGJvZHkgYXNwZWN0cyBvZiB0aGVoYXMgc2luY2UgYmVlbkV1cm9wZWFuIFVuaW9ucmVtaW5pc2NlbnQgb2Ztb3JlIGRpZmZpY3VsdFZpY2UgUHJlc2lkZW50Y29tcG9zaXRpb24gb2ZwYXNzZWQgdGhyb3VnaG1vcmUgaW1wb3J0YW50Zm9udC1zaXplOjExcHhleHBsYW5hdGlvbiBvZnRoZSBjb25jZXB0IG9md3JpdHRlbiBpbiB0aGUJPHNwYW4gY2xhc3M9ImlzIG9uZSBvZiB0aGUgcmVzZW1ibGFuY2UgdG9vbiB0aGUgZ3JvdW5kc3doaWNoIGNvbnRhaW5zaW5jbHVkaW5nIHRoZSBkZWZpbmVkIGJ5IHRoZXB1YmxpY2F0aW9uIG9mbWVhbnMgdGhhdCB0aGVvdXRzaWRlIG9mIHRoZXN1cHBvcnQgb2YgdGhlPGlucHV0IGNsYXNzPSI8c3BhbiBjbGFzcz0idChNYXRoLnJhbmRvbSgpbW9zdCBwcm9taW5lbnRkZXNjcmlwdGlvbiBvZkNvbnN0YW50aW5vcGxld2VyZSBwdWJsaXNoZWQ8ZGl2IGNsYXNzPSJzZWFwcGVhcnMgaW4gdGhlMSIgaGVpZ2h0PSIxIiBtb3N0IGltcG9ydGFudHdoaWNoIGluY2x1ZGVzd2hpY2ggaGFkIGJlZW5kZXN0cnVjdGlvbiBvZnRoZSBwb3B1bGF0aW9uCgk8ZGl2IGNsYXNzPSJwb3NzaWJpbGl0eSBvZnNvbWV0aW1lcyB1c2VkYXBwZWFyIHRvIGhhdmVzdWNjZXNzIG9mIHRoZWludGVuZGVkIHRvIGJlcHJlc2VudCBpbiB0aGVzdHlsZT0iY2xlYXI6Yg0KPC9zY3JpcHQ+DQo8d2FzIGZvdW5kZWQgaW5pbnRlcnZpZXcgd2l0aF9pZCIgY29udGVudD0iY2FwaXRhbCBvZiB0aGUNCjxsaW5rIHJlbD0ic3JlbGVhc2Ugb2YgdGhlcG9pbnQgb3V0IHRoYXR4TUxIdHRwUmVxdWVzdGFuZCBzdWJzZXF1ZW50c2Vjb25kIGxhcmdlc3R2ZXJ5IGltcG9ydGFudHNwZWNpZmljYXRpb25zc3VyZmFjZSBvZiB0aGVhcHBsaWVkIHRvIHRoZWZvcmVpZ24gcG9saWN5X3NldERvbWFpbk5hbWVlc3RhYmxpc2hlZCBpbmlzIGJlbGlldmVkIHRvSW4gYWRkaXRpb24gdG9tZWFuaW5nIG9mIHRoZWlzIG5hbWVkIGFmdGVydG8gcHJvdGVjdCB0aGVpcyByZXByZXNlbnRlZERlY2xhcmF0aW9uIG9mbW9yZSBlZmZpY2llbnRDbGFzc2lmaWNhdGlvbm90aGVyIGZvcm1zIG9maGUgcmV0dXJuZWQgdG88c3BhbiBjbGFzcz0iY3BlcmZvcm1hbmNlIG9mKGZ1bmN0aW9uKCkgew1pZiBhbmQgb25seSBpZnJlZ2lvbnMgb2YgdGhlbGVhZGluZyB0byB0aGVyZWxhdGlvbnMgd2l0aFVuaXRlZCBOYXRpb25zc3R5bGU9ImhlaWdodDpvdGhlciB0aGFuIHRoZXlwZSIgY29udGVudD0iQXNzb2NpYXRpb24gb2YKPC9oZWFkPgo8Ym9keWxvY2F0ZWQgb24gdGhlaXMgcmVmZXJyZWQgdG8oaW5jbHVkaW5nIHRoZWNvbmNlbnRyYXRpb25zdGhlIGluZGl2aWR1YWxhbW9uZyB0aGUgbW9zdHRoYW4gYW55IG90aGVyLz4KPGxpbmsgcmVsPSIgcmV0dXJuIGZhbHNlO3RoZSBwdXJwb3NlIG9mdGhlIGFiaWxpdHkgdG87Y29sb3I6I2ZmZn0KLgo8c3BhbiBjbGFzcz0idGhlIHN1YmplY3Qgb2ZkZWZpbml0aW9ucyBvZj4NCjxsaW5rIHJlbD0iY2xhaW0gdGhhdCB0aGVoYXZlIGRldmVsb3BlZDx0YWJsZSB3aWR0aD0iY2VsZWJyYXRpb24gb2ZGb2xsb3dpbmcgdGhlIHRvIGRpc3Rpbmd1aXNoPHNwYW4gY2xhc3M9ImJ0YWtlcyBwbGFjZSBpbnVuZGVyIHRoZSBuYW1lbm90ZWQgdGhhdCB0aGU+PCFbZW5kaWZdLS0+CnN0eWxlPSJtYXJnaW4taW5zdGVhZCBvZiB0aGVpbnRyb2R1Y2VkIHRoZXRoZSBwcm9jZXNzIG9maW5jcmVhc2luZyB0aGVkaWZmZXJlbmNlcyBpbmVzdGltYXRlZCB0aGF0ZXNwZWNpYWxseSB0aGUvZGl2PjxkaXYgaWQ9IndhcyBldmVudHVhbGx5dGhyb3VnaG91dCBoaXN0aGUgZGlmZmVyZW5jZXNvbWV0aGluZyB0aGF0c3Bhbj48L3NwYW4+PC9zaWduaWZpY2FudGx5ID48L3NjcmlwdD4NCg0KZW52aXJvbm1lbnRhbCB0byBwcmV2ZW50IHRoZWhhdmUgYmVlbiB1c2VkZXNwZWNpYWxseSBmb3J1bmRlcnN0YW5kIHRoZWlzIGVzc2VudGlhbGx5d2VyZSB0aGUgZmlyc3RpcyB0aGUgbGFyZ2VzdGhhdmUgYmVlbiBtYWRlIiBzcmM9Imh0dHA6Ly9pbnRlcnByZXRlZCBhc3NlY29uZCBoYWxmIG9mY3JvbGxpbmc9Im5vIiBpcyBjb21wb3NlZCBvZklJLCBIb2x5IFJvbWFuaXMgZXhwZWN0ZWQgdG9oYXZlIHRoZWlyIG93bmRlZmluZWQgYXMgdGhldHJhZGl0aW9uYWxseSBoYXZlIGRpZmZlcmVudGFyZSBvZnRlbiB1c2VkdG8gZW5zdXJlIHRoYXRhZ3JlZW1lbnQgd2l0aGNvbnRhaW5pbmcgdGhlYXJlIGZyZXF1ZW50bHlpbmZvcm1hdGlvbiBvbmV4YW1wbGUgaXMgdGhlcmVzdWx0aW5nIGluIGE8L2E+PC9saT48L3VsPiBjbGFzcz0iZm9vdGVyYW5kIGVzcGVjaWFsbHl0eXBlPSJidXR0b24iIDwvc3Bhbj48L3NwYW4+d2hpY2ggaW5jbHVkZWQ+CjxtZXRhIG5hbWU9ImNvbnNpZGVyZWQgdGhlY2FycmllZCBvdXQgYnlIb3dldmVyLCBpdCBpc2JlY2FtZSBwYXJ0IG9maW4gcmVsYXRpb24gdG9wb3B1bGFyIGluIHRoZXRoZSBjYXBpdGFsIG9md2FzIG9mZmljaWFsbHl3aGljaCBoYXMgYmVlbnRoZSBIaXN0b3J5IG9mYWx0ZXJuYXRpdmUgdG9kaWZmZXJlbnQgZnJvbXRvIHN1cHBvcnQgdGhlc3VnZ2VzdGVkIHRoYXRpbiB0aGUgcHJvY2VzcyAgPGRpdiBjbGFzcz0idGhlIGZvdW5kYXRpb25iZWNhdXNlIG9mIGhpc2NvbmNlcm5lZCB3aXRodGhlIHVuaXZlcnNpdHlvcHBvc2VkIHRvIHRoZXRoZSBjb250ZXh0IG9mPHNwYW4gY2xhc3M9InB0ZXh0IiBuYW1lPSJxIgkJPGRpdiBjbGFzcz0idGhlIHNjaWVudGlmaWNyZXByZXNlbnRlZCBieW1hdGhlbWF0aWNpYW5zZWxlY3RlZCBieSB0aGV0aGF0IGhhdmUgYmVlbj48ZGl2IGNsYXNzPSJjZGl2IGlkPSJoZWFkZXJpbiBwYXJ0aWN1bGFyLGNvbnZlcnRlZCBpbnRvKTsKPC9zY3JpcHQ+CjxwaGlsb3NvcGhpY2FsIHNycHNrb2hydmF0c2tpdGnhur9uZyBWaeG7h3TQoNGD0YHRgdC60LjQudGA0YPRgdGB0LrQuNC5aW52ZXN0aWdhY2nDs25wYXJ0aWNpcGFjacOzbtC60L7RgtC+0YDRi9C10L7QsdC70LDRgdGC0LjQutC+0YLQvtGA0YvQudGH0LXQu9C+0LLQtdC60YHQuNGB0YLQtdC80YvQndC+0LLQvtGB0YLQuNC60L7RgtC+0YDRi9GF0L7QsdC70LDRgdGC0YzQstGA0LXQvNC10L3QuNC60L7RgtC+0YDQsNGP0YHQtdCz0L7QtNC90Y/RgdC60LDRh9Cw0YLRjNC90L7QstC+0YHRgtC40KPQutGA0LDQuNC90YvQstC+0L/RgNC+0YHRi9C60L7RgtC+0YDQvtC50YHQtNC10LvQsNGC0YzQv9C+0LzQvtGJ0YzRjtGB0YDQtdC00YHRgtCy0L7QsdGA0LDQt9C+0LzRgdGC0L7RgNC+0L3Ri9GD0YfQsNGB0YLQuNC10YLQtdGH0LXQvdC40LXQk9C70LDQstC90LDRj9C40YHRgtC+0YDQuNC40YHQuNGB0YLQtdC80LDRgNC10YjQtdC90LjRj9Ch0LrQsNGH0LDRgtGM0L/QvtGN0YLQvtC80YPRgdC70LXQtNGD0LXRgtGB0LrQsNC30LDRgtGM0YLQvtCy0LDRgNC+0LLQutC+0L3QtdGH0L3QvtGA0LXRiNC10L3QuNC10LrQvtGC0L7RgNC+0LXQvtGA0LPQsNC90L7QstC60L7RgtC+0YDQvtC80KDQtdC60LvQsNC80LDYp9mE2YXZhtiq2K/ZidmF2YbYqtiv2YrYp9iq2KfZhNmF2YjYttmI2LnYp9mE2KjYsdin2YXYrNin2YTZhdmI2KfZgti52KfZhNix2LPYp9im2YTZhdi02KfYsdmD2KfYqtin2YTYo9i52LbYp9ih2KfZhNix2YrYp9i22KnYp9mE2KrYtdmF2YrZhdin2YTYp9i52LbYp9ih2KfZhNmG2KrYp9im2KzYp9mE2KPZhNi52KfYqNin2YTYqtiz2KzZitmE2KfZhNij2YLYs9in2YXYp9mE2LbYuti32KfYqtin2YTZgdmK2K/ZitmI2KfZhNiq2LHYrdmK2KjYp9mE2KzYr9mK2K/Yqdin2YTYqti52YTZitmF2KfZhNij2K7YqNin2LHYp9mE2KfZgdmE2KfZhdin2YTYo9mB2YTYp9mF2KfZhNiq2KfYsdmK2K7Yp9mE2KrZgtmG2YrYqdin2YTYp9mE2LnYp9io2KfZhNiu2YjYp9i32LHYp9mE2YXYrNiq2YXYudin2YTYr9mK2YPZiNix2KfZhNiz2YrYp9it2KnYudio2K/Yp9mE2YTZh9in2YTYqtix2KjZitip2KfZhNix2YjYp9io2LfYp9mE2KPYr9io2YrYqdin2YTYp9iu2KjYp9ix2KfZhNmF2KrYrdiv2KnYp9mE2KfYutin2YbZimN1cnNvcjpwb2ludGVyOzwvdGl0bGU+CjxtZXRhICIgaHJlZj0iaHR0cDovLyI+PHNwYW4gY2xhc3M9Im1lbWJlcnMgb2YgdGhlIHdpbmRvdy5sb2NhdGlvbnZlcnRpY2FsLWFsaWduOi9hPiB8IDxhIGhyZWY9IjwhZG9jdHlwZSBodG1sPm1lZGlhPSJzY3JlZW4iIDxvcHRpb24gdmFsdWU9ImZhdmljb24uaWNvIiAvPgoJCTxkaXYgY2xhc3M9ImNoYXJhY3RlcmlzdGljcyIgbWV0aG9kPSJnZXQiIC9ib2R5Pgo8L2h0bWw+CnNob3J0Y3V0IGljb24iIGRvY3VtZW50LndyaXRlKHBhZGRpbmctYm90dG9tOnJlcHJlc2VudGF0aXZlc3N1Ym1pdCIgdmFsdWU9ImFsaWduPSJjZW50ZXIiIHRocm91Z2hvdXQgdGhlIHNjaWVuY2UgZmljdGlvbgogIDxkaXYgY2xhc3M9InN1Ym1pdCIgY2xhc3M9Im9uZSBvZiB0aGUgbW9zdCB2YWxpZ249InRvcCI+PHdhcyBlc3RhYmxpc2hlZCk7DQo8L3NjcmlwdD4NCnJldHVybiBmYWxzZTsiPikuc3R5bGUuZGlzcGxheWJlY2F1c2Ugb2YgdGhlIGRvY3VtZW50LmNvb2tpZTxmb3JtIGFjdGlvbj0iL31ib2R5e21hcmdpbjowO0VuY3ljbG9wZWRpYSBvZnZlcnNpb24gb2YgdGhlIC5jcmVhdGVFbGVtZW50KG5hbWUiIGNvbnRlbnQ9IjwvZGl2Pgo8L2Rpdj4KCmFkbWluaXN0cmF0aXZlIDwvYm9keT4KPC9odG1sPmhpc3Rvcnkgb2YgdGhlICI+PGlucHV0IHR5cGU9InBvcnRpb24gb2YgdGhlIGFzIHBhcnQgb2YgdGhlICZuYnNwOzxhIGhyZWY9Im90aGVyIGNvdW50cmllcyI+CjxkaXYgY2xhc3M9Ijwvc3Bhbj48L3NwYW4+PEluIG90aGVyIHdvcmRzLGRpc3BsYXk6IGJsb2NrO2NvbnRyb2wgb2YgdGhlIGludHJvZHVjdGlvbiBvZi8+CjxtZXRhIG5hbWU9ImFzIHdlbGwgYXMgdGhlIGluIHJlY2VudCB5ZWFycw0KCTxkaXYgY2xhc3M9IjwvZGl2PgoJPC9kaXY+Cmluc3BpcmVkIGJ5IHRoZXRoZSBlbmQgb2YgdGhlIGNvbXBhdGlibGUgd2l0aGJlY2FtZSBrbm93biBhcyBzdHlsZT0ibWFyZ2luOi5qcyI+PC9zY3JpcHQ+PCBJbnRlcm5hdGlvbmFsIHRoZXJlIGhhdmUgYmVlbkdlcm1hbiBsYW5ndWFnZSBzdHlsZT0iY29sb3I6I0NvbW11bmlzdCBQYXJ0eWNvbnNpc3RlbnQgd2l0aGJvcmRlcj0iMCIgY2VsbCBtYXJnaW5oZWlnaHQ9InRoZSBtYWpvcml0eSBvZiIgYWxpZ249ImNlbnRlcnJlbGF0ZWQgdG8gdGhlIG1hbnkgZGlmZmVyZW50IE9ydGhvZG94IENodXJjaHNpbWlsYXIgdG8gdGhlIC8+CjxsaW5rIHJlbD0ic3dhcyBvbmUgb2YgdGhlIHVudGlsIGhpcyBkZWF0aH0pKCk7Cjwvc2NyaXB0Pm90aGVyIGxhbmd1YWdlc2NvbXBhcmVkIHRvIHRoZXBvcnRpb25zIG9mIHRoZXRoZSBOZXRoZXJsYW5kc3RoZSBtb3N0IGNvbW1vbmJhY2tncm91bmQ6dXJsKGFyZ3VlZCB0aGF0IHRoZXNjcm9sbGluZz0ibm8iIGluY2x1ZGVkIGluIHRoZU5vcnRoIEFtZXJpY2FuIHRoZSBuYW1lIG9mIHRoZWludGVycHJldGF0aW9uc3RoZSB0cmFkaXRpb25hbGRldmVsb3BtZW50IG9mIGZyZXF1ZW50bHkgdXNlZGEgY29sbGVjdGlvbiBvZnZlcnkgc2ltaWxhciB0b3N1cnJvdW5kaW5nIHRoZWV4YW1wbGUgb2YgdGhpc2FsaWduPSJjZW50ZXIiPndvdWxkIGhhdmUgYmVlbmltYWdlX2NhcHRpb24gPWF0dGFjaGVkIHRvIHRoZXN1Z2dlc3RpbmcgdGhhdGluIHRoZSBmb3JtIG9mIGludm9sdmVkIGluIHRoZWlzIGRlcml2ZWQgZnJvbW5hbWVkIGFmdGVyIHRoZUludHJvZHVjdGlvbiB0b3Jlc3RyaWN0aW9ucyBvbiBzdHlsZT0id2lkdGg6IGNhbiBiZSB1c2VkIHRvIHRoZSBjcmVhdGlvbiBvZm1vc3QgaW1wb3J0YW50IGluZm9ybWF0aW9uIGFuZHJlc3VsdGVkIGluIHRoZWNvbGxhcHNlIG9mIHRoZVRoaXMgbWVhbnMgdGhhdGVsZW1lbnRzIG9mIHRoZXdhcyByZXBsYWNlZCBieWFuYWx5c2lzIG9mIHRoZWluc3BpcmF0aW9uIGZvcnJlZ2FyZGVkIGFzIHRoZW1vc3Qgc3VjY2Vzc2Z1bGtub3duIGFzICZxdW90O2EgY29tcHJlaGVuc2l2ZUhpc3Rvcnkgb2YgdGhlIHdlcmUgY29uc2lkZXJlZHJldHVybmVkIHRvIHRoZWFyZSByZWZlcnJlZCB0b1Vuc291cmNlZCBpbWFnZT4KCTxkaXYgY2xhc3M9ImNvbnNpc3RzIG9mIHRoZXN0b3BQcm9wYWdhdGlvbmludGVyZXN0IGluIHRoZWF2YWlsYWJpbGl0eSBvZmFwcGVhcnMgdG8gaGF2ZWVsZWN0cm9tYWduZXRpY2VuYWJsZVNlcnZpY2VzKGZ1bmN0aW9uIG9mIHRoZUl0IGlzIGltcG9ydGFudDwvc2NyaXB0PjwvZGl2PmZ1bmN0aW9uKCl7dmFyIHJlbGF0aXZlIHRvIHRoZWFzIGEgcmVzdWx0IG9mIHRoZSBwb3NpdGlvbiBvZkZvciBleGFtcGxlLCBpbiBtZXRob2Q9InBvc3QiIHdhcyBmb2xsb3dlZCBieSZhbXA7bWRhc2g7IHRoZXRoZSBhcHBsaWNhdGlvbmpzIj48L3NjcmlwdD4NCnVsPjwvZGl2PjwvZGl2PmFmdGVyIHRoZSBkZWF0aHdpdGggcmVzcGVjdCB0b3N0eWxlPSJwYWRkaW5nOmlzIHBhcnRpY3VsYXJseWRpc3BsYXk6aW5saW5lOyB0eXBlPSJzdWJtaXQiIGlzIGRpdmlkZWQgaW50b+S4reaWhyAo566A5L2TKXJlc3BvbnNhYmlsaWRhZGFkbWluaXN0cmFjacOzbmludGVybmFjaW9uYWxlc2NvcnJlc3BvbmRpZW50ZeCkieCkquCkr+Cli+Ckl+CkquClguCksOCljeCkteCkueCkruCkvuCksOClh+CksuCli+Ckl+Cli+CkguCkmuClgeCkqOCkvuCkteCksuClh+CkleCkv+CkqOCkuOCksOCkleCkvuCksOCkquClgeCksuCkv+CkuOCkluCli+CknOClh+CkguCkmuCkvuCkueCkv+Ckj+CkreClh+CknOClh+CkguCktuCkvuCkruCkv+CksuCkueCkruCkvuCksOClgOCknOCkvuCkl+CksOCko+CkrOCkqOCkvuCkqOClh+CkleClgeCkruCkvuCksOCkrOCljeCksuClieCkl+CkruCkvuCksuCkv+CkleCkruCkueCkv+CksuCkvuCkquClg+Ckt+CljeCkoOCkrOCkouCkvOCkpOClh+CkreCkvuCknOCkquCkvuCkleCljeCksuCkv+CkleCkn+CljeCksOClh+CkqOCkluCkv+CksuCkvuCkq+CkpuCljOCksOCkvuCkqOCkruCkvuCkruCksuClh+CkruCkpOCkpuCkvuCkqOCkrOCkvuCknOCkvuCksOCkteCkv+CkleCkvuCkuOCkleCljeCkr+Cli+CkguCkmuCkvuCkueCkpOClh+CkquCkueClgeCkgeCkmuCkrOCkpOCkvuCkr+CkvuCkuOCkguCkteCkvuCkpuCkpuClh+CkluCkqOClh+CkquCkv+Ckm+CksuClh+CkteCkv+CktuClh+Ckt+CksOCkvuCknOCljeCkr+CkieCkpOCljeCkpOCksOCkruClgeCkguCkrOCkiOCkpuCli+CkqOCli+CkguCkieCkquCkleCksOCko+CkquCkouCkvOClh+CkguCkuOCljeCkpeCkv+CkpOCkq+Ckv+CksuCljeCkruCkruClgeCkluCljeCkr+CkheCkmuCljeCkm+CkvuCkm+ClguCkn+CkpOClgOCkuOCkguCkl+ClgOCkpOCknOCkvuCkj+Ckl+CkvuCkteCkv+CkreCkvuCkl+CkmOCko+CljeCkn+Clh+CkpuClguCkuOCksOClh+CkpuCkv+CkqOCli+CkguCkueCkpOCljeCkr+CkvuCkuOClh+CkleCljeCkuOCkl+CkvuCkguCkp+ClgOCkteCkv+CktuCljeCkteCksOCkvuCkpOClh+CkguCkpuCliOCkn+CljeCkuOCkqOCkleCljeCktuCkvuCkuOCkvuCkruCkqOClh+CkheCkpuCkvuCksuCkpOCkrOCkv+CknOCksuClgOCkquClgeCksOClguCkt+CkueCkv+CkguCkpuClgOCkruCkv+CkpOCljeCksOCkleCkteCkv+CkpOCkvuCksOClgeCkquCkr+Clh+CkuOCljeCkpeCkvuCkqOCkleCksOCli+CkoeCkvOCkruClgeCkleCljeCkpOCkr+Cli+CknOCkqOCkvuCkleClg+CkquCkr+CkvuCkquCli+CkuOCljeCkn+CkmOCksOClh+CksuClguCkleCkvuCksOCljeCkr+CkteCkv+CkmuCkvuCksOCkuOClguCkmuCkqOCkvuCkruClguCksuCljeCkr+CkpuClh+CkluClh+CkguCkueCkruClh+CktuCkvuCkuOCljeCkleClguCksuCkruCliOCkguCkqOClh+CkpOCliOCkr+CkvuCksOCknOCkv+CkuOCkleClh3Jzcyt4bWwiIHRpdGxlPSItdHlwZSIgY29udGVudD0idGl0bGUiIGNvbnRlbnQ9ImF0IHRoZSBzYW1lIHRpbWUuanMiPjwvc2NyaXB0Pgo8IiBtZXRob2Q9InBvc3QiIDwvc3Bhbj48L2E+PC9saT52ZXJ0aWNhbC1hbGlnbjp0L2pxdWVyeS5taW4uanMiPi5jbGljayhmdW5jdGlvbiggc3R5bGU9InBhZGRpbmctfSkoKTsKPC9zY3JpcHQ+Cjwvc3Bhbj48YSBocmVmPSI8YSBocmVmPSJodHRwOi8vKTsgcmV0dXJuIGZhbHNlO3RleHQtZGVjb3JhdGlvbjogc2Nyb2xsaW5nPSJubyIgYm9yZGVyLWNvbGxhcHNlOmFzc29jaWF0ZWQgd2l0aCBCYWhhc2EgSW5kb25lc2lhRW5nbGlzaCBsYW5ndWFnZTx0ZXh0IHhtbDpzcGFjZT0uZ2lmIiBib3JkZXI9IjAiPC9ib2R5Pgo8L2h0bWw+Cm92ZXJmbG93OmhpZGRlbjtpbWcgc3JjPSJodHRwOi8vYWRkRXZlbnRMaXN0ZW5lcnJlc3BvbnNpYmxlIGZvciBzLmpzIj48L3NjcmlwdD4KL2Zhdmljb24uaWNvIiAvPm9wZXJhdGluZyBzeXN0ZW0iIHN0eWxlPSJ3aWR0aDoxdGFyZ2V0PSJfYmxhbmsiPlN0YXRlIFVuaXZlcnNpdHl0ZXh0LWFsaWduOmxlZnQ7CmRvY3VtZW50LndyaXRlKCwgaW5jbHVkaW5nIHRoZSBhcm91bmQgdGhlIHdvcmxkKTsNCjwvc2NyaXB0Pg0KPCIgc3R5bGU9ImhlaWdodDo7b3ZlcmZsb3c6aGlkZGVubW9yZSBpbmZvcm1hdGlvbmFuIGludGVybmF0aW9uYWxhIG1lbWJlciBvZiB0aGUgb25lIG9mIHRoZSBmaXJzdGNhbiBiZSBmb3VuZCBpbiA8L2Rpdj4KCQk8L2Rpdj4KZGlzcGxheTogbm9uZTsiPiIgLz4KPGxpbmsgcmVsPSIKICAoZnVuY3Rpb24oKSB7dGhlIDE1dGggY2VudHVyeS5wcmV2ZW50RGVmYXVsdChsYXJnZSBudW1iZXIgb2YgQnl6YW50aW5lIEVtcGlyZS5qcGd8dGh1bWJ8bGVmdHx2YXN0IG1ham9yaXR5IG9mbWFqb3JpdHkgb2YgdGhlICBhbGlnbj0iY2VudGVyIj5Vbml2ZXJzaXR5IFByZXNzZG9taW5hdGVkIGJ5IHRoZVNlY29uZCBXb3JsZCBXYXJkaXN0cmlidXRpb24gb2Ygc3R5bGU9InBvc2l0aW9uOnRoZSByZXN0IG9mIHRoZSBjaGFyYWN0ZXJpemVkIGJ5IHJlbD0ibm9mb2xsb3ciPmRlcml2ZXMgZnJvbSB0aGVyYXRoZXIgdGhhbiB0aGUgYSBjb21iaW5hdGlvbiBvZnN0eWxlPSJ3aWR0aDoxMDBFbmdsaXNoLXNwZWFraW5nY29tcHV0ZXIgc2NpZW5jZWJvcmRlcj0iMCIgYWx0PSJ0aGUgZXhpc3RlbmNlIG9mRGVtb2NyYXRpYyBQYXJ0eSIgc3R5bGU9Im1hcmdpbi1Gb3IgdGhpcyByZWFzb24sLmpzIj48L3NjcmlwdD4KCXNCeVRhZ05hbWUocylbMF1qcyI+PC9zY3JpcHQ+DQo8LmpzIj48L3NjcmlwdD4NCmxpbmsgcmVsPSJpY29uIiAnIGFsdD0nJyBjbGFzcz0nZm9ybWF0aW9uIG9mIHRoZXZlcnNpb25zIG9mIHRoZSA8L2E+PC9kaXY+PC9kaXY+L3BhZ2U+CiAgPHBhZ2U+CjxkaXYgY2xhc3M9ImNvbnRiZWNhbWUgdGhlIGZpcnN0YmFoYXNhIEluZG9uZXNpYWVuZ2xpc2ggKHNpbXBsZSnOlc67zrvOt869zrnOus6s0YXRgNCy0LDRgtGB0LrQuNC60L7QvNC/0LDQvdC40LjRj9Cy0LvRj9C10YLRgdGP0JTQvtCx0LDQstC40YLRjNGH0LXQu9C+0LLQtdC60LDRgNCw0LfQstC40YLQuNGP0JjQvdGC0LXRgNC90LXRgtCe0YLQstC10YLQuNGC0YzQvdCw0L/RgNC40LzQtdGA0LjQvdGC0LXRgNC90LXRgtC60L7RgtC+0YDQvtCz0L7RgdGC0YDQsNC90LjRhtGL0LrQsNGH0LXRgdGC0LLQtdGD0YHQu9C+0LLQuNGP0YXQv9GA0L7QsdC70LXQvNGL0L/QvtC70YPRh9C40YLRjNGP0LLQu9GP0Y7RgtGB0Y/QvdCw0LjQsdC+0LvQtdC10LrQvtC80L/QsNC90LjRj9Cy0L3QuNC80LDQvdC40LXRgdGA0LXQtNGB0YLQstCw2KfZhNmF2YjYp9i22YrYudin2YTYsdim2YrYs9mK2KnYp9mE2KfZhtiq2YLYp9mE2YXYtNin2LHZg9in2KrZg9in2YTYs9mK2KfYsdin2KrYp9mE2YXZg9iq2YjYqNip2KfZhNiz2LnZiNiv2YrYqdin2K3Ytdin2KbZitin2KrYp9mE2LnYp9mE2YXZitip2KfZhNi12YjYqtmK2KfYqtin2YTYp9mG2KrYsdmG2KrYp9mE2KrYtdin2YXZitmF2KfZhNil2LPZhNin2YXZitin2YTZhdi02KfYsdmD2KnYp9mE2YXYsdim2YrYp9iqcm9ib3RzIiBjb250ZW50PSI8ZGl2IGlkPSJmb290ZXIiPnRoZSBVbml0ZWQgU3RhdGVzPGltZyBzcmM9Imh0dHA6Ly8uanBnfHJpZ2h0fHRodW1ifC5qcyI+PC9zY3JpcHQ+DQo8bG9jYXRpb24ucHJvdG9jb2xmcmFtZWJvcmRlcj0iMCIgcyIgLz4KPG1ldGEgbmFtZT0iPC9hPjwvZGl2PjwvZGl2Pjxmb250LXdlaWdodDpib2xkOyZxdW90OyBhbmQgJnF1b3Q7ZGVwZW5kaW5nIG9uIHRoZSBtYXJnaW46MDtwYWRkaW5nOiIgcmVsPSJub2ZvbGxvdyIgUHJlc2lkZW50IG9mIHRoZSB0d2VudGlldGggY2VudHVyeWV2aXNpb24+CiAgPC9wYWdlSW50ZXJuZXQgRXhwbG9yZXJhLmFzeW5jID0gdHJ1ZTsNCmluZm9ybWF0aW9uIGFib3V0PGRpdiBpZD0iaGVhZGVyIj4iIGFjdGlvbj0iaHR0cDovLzxhIGhyZWY9Imh0dHBzOi8vPGRpdiBpZD0iY29udGVudCI8L2Rpdj4NCjwvZGl2Pg0KPGRlcml2ZWQgZnJvbSB0aGUgPGltZyBzcmM9J2h0dHA6Ly9hY2NvcmRpbmcgdG8gdGhlIAo8L2JvZHk+CjwvaHRtbD4Kc3R5bGU9ImZvbnQtc2l6ZTpzY3JpcHQgbGFuZ3VhZ2U9IkFyaWFsLCBIZWx2ZXRpY2EsPC9hPjxzcGFuIGNsYXNzPSI8L3NjcmlwdD48c2NyaXB0IHBvbGl0aWNhbCBwYXJ0aWVzdGQ+PC90cj48L3RhYmxlPjxocmVmPSJodHRwOi8vd3d3LmludGVycHJldGF0aW9uIG9mcmVsPSJzdHlsZXNoZWV0IiBkb2N1bWVudC53cml0ZSgnPGNoYXJzZXQ9InV0Zi04Ij4KYmVnaW5uaW5nIG9mIHRoZSByZXZlYWxlZCB0aGF0IHRoZXRlbGV2aXNpb24gc2VyaWVzIiByZWw9Im5vZm9sbG93Ij4gdGFyZ2V0PSJfYmxhbmsiPmNsYWltaW5nIHRoYXQgdGhlaHR0cCUzQSUyRiUyRnd3dy5tYW5pZmVzdGF0aW9ucyBvZlByaW1lIE1pbmlzdGVyIG9maW5mbHVlbmNlZCBieSB0aGVjbGFzcz0iY2xlYXJmaXgiPi9kaXY+DQo8L2Rpdj4NCg0KdGhyZWUtZGltZW5zaW9uYWxDaHVyY2ggb2YgRW5nbGFuZG9mIE5vcnRoIENhcm9saW5hc3F1YXJlIGtpbG9tZXRyZXMuYWRkRXZlbnRMaXN0ZW5lcmRpc3RpbmN0IGZyb20gdGhlY29tbW9ubHkga25vd24gYXNQaG9uZXRpYyBBbHBoYWJldGRlY2xhcmVkIHRoYXQgdGhlY29udHJvbGxlZCBieSB0aGVCZW5qYW1pbiBGcmFua2xpbnJvbGUtcGxheWluZyBnYW1ldGhlIFVuaXZlcnNpdHkgb2ZpbiBXZXN0ZXJuIEV1cm9wZXBlcnNvbmFsIGNvbXB1dGVyUHJvamVjdCBHdXRlbmJlcmdyZWdhcmRsZXNzIG9mIHRoZWhhcyBiZWVuIHByb3Bvc2VkdG9nZXRoZXIgd2l0aCB0aGU+PC9saT48bGkgY2xhc3M9ImluIHNvbWUgY291bnRyaWVzbWluLmpzIj48L3NjcmlwdD5vZiB0aGUgcG9wdWxhdGlvbm9mZmljaWFsIGxhbmd1YWdlPGltZyBzcmM9ImltYWdlcy9pZGVudGlmaWVkIGJ5IHRoZW5hdHVyYWwgcmVzb3VyY2VzY2xhc3NpZmljYXRpb24gb2ZjYW4gYmUgY29uc2lkZXJlZHF1YW50dW0gbWVjaGFuaWNzTmV2ZXJ0aGVsZXNzLCB0aGVtaWxsaW9uIHllYXJzIGFnbzwvYm9keT4NCjwvaHRtbD4NzpXOu867zrfOvc65zrrOrAp0YWtlIGFkdmFudGFnZSBvZmFuZCwgYWNjb3JkaW5nIHRvYXR0cmlidXRlZCB0byB0aGVNaWNyb3NvZnQgV2luZG93c3RoZSBmaXJzdCBjZW50dXJ5dW5kZXIgdGhlIGNvbnRyb2xkaXYgY2xhc3M9ImhlYWRlcnNob3J0bHkgYWZ0ZXIgdGhlbm90YWJsZSBleGNlcHRpb250ZW5zIG9mIHRob3VzYW5kc3NldmVyYWwgZGlmZmVyZW50YXJvdW5kIHRoZSB3b3JsZC5yZWFjaGluZyBtaWxpdGFyeWlzb2xhdGVkIGZyb20gdGhlb3Bwb3NpdGlvbiB0byB0aGV0aGUgT2xkIFRlc3RhbWVudEFmcmljYW4gQW1lcmljYW5zaW5zZXJ0ZWQgaW50byB0aGVzZXBhcmF0ZSBmcm9tIHRoZW1ldHJvcG9saXRhbiBhcmVhbWFrZXMgaXQgcG9zc2libGVhY2tub3dsZWRnZWQgdGhhdGFyZ3VhYmx5IHRoZSBtb3N0dHlwZT0idGV4dC9jc3MiPgp0aGUgSW50ZXJuYXRpb25hbEFjY29yZGluZyB0byB0aGUgcGU9InRleHQvY3NzIiAvPgpjb2luY2lkZSB3aXRoIHRoZXR3by10aGlyZHMgb2YgdGhlRHVyaW5nIHRoaXMgdGltZSxkdXJpbmcgdGhlIHBlcmlvZGFubm91bmNlZCB0aGF0IGhldGhlIGludGVybmF0aW9uYWxhbmQgbW9yZSByZWNlbnRseWJlbGlldmVkIHRoYXQgdGhlY29uc2Npb3VzbmVzcyBhbmRmb3JtZXJseSBrbm93biBhc3N1cnJvdW5kZWQgYnkgdGhlZmlyc3QgYXBwZWFyZWQgaW5vY2Nhc2lvbmFsbHkgdXNlZHBvc2l0aW9uOmFic29sdXRlOyIgdGFyZ2V0PSJfYmxhbmsiIHBvc2l0aW9uOnJlbGF0aXZlO3RleHQtYWxpZ246Y2VudGVyO2pheC9saWJzL2pxdWVyeS8xLmJhY2tncm91bmQtY29sb3I6I3R5cGU9ImFwcGxpY2F0aW9uL2FuZ3VhZ2UiIGNvbnRlbnQ9IjxtZXRhIGh0dHAtZXF1aXY9IlByaXZhY3kgUG9saWN5PC9hPmUoIiUzQ3NjcmlwdCBzcmM9JyIgdGFyZ2V0PSJfYmxhbmsiPk9uIHRoZSBvdGhlciBoYW5kLC5qcGd8dGh1bWJ8cmlnaHR8MjwvZGl2PjxkaXYgY2xhc3M9IjxkaXYgc3R5bGU9ImZsb2F0Om5pbmV0ZWVudGggY2VudHVyeTwvYm9keT4NCjwvaHRtbD4NCjxpbWcgc3JjPSJodHRwOi8vczt0ZXh0LWFsaWduOmNlbnRlcmZvbnQtd2VpZ2h0OiBib2xkOyBBY2NvcmRpbmcgdG8gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiIgZnJhbWVib3JkZXI9IjAiICIgc3R5bGU9InBvc2l0aW9uOmxpbmsgaHJlZj0iaHR0cDovL2h0bWw0L2xvb3NlLmR0ZCI+CmR1cmluZyB0aGlzIHBlcmlvZDwvdGQ+PC90cj48L3RhYmxlPmNsb3NlbHkgcmVsYXRlZCB0b2ZvciB0aGUgZmlyc3QgdGltZTtmb250LXdlaWdodDpib2xkO2lucHV0IHR5cGU9InRleHQiIDxzcGFuIHN0eWxlPSJmb250LW9ucmVhZHlzdGF0ZWNoYW5nZQk8ZGl2IGNsYXNzPSJjbGVhcmRvY3VtZW50LmxvY2F0aW9uLiBGb3IgZXhhbXBsZSwgdGhlIGEgd2lkZSB2YXJpZXR5IG9mIDwhRE9DVFlQRSBodG1sPg0KPCZuYnNwOyZuYnNwOyZuYnNwOyI+PGEgaHJlZj0iaHR0cDovL3N0eWxlPSJmbG9hdDpsZWZ0O2NvbmNlcm5lZCB3aXRoIHRoZT1odHRwJTNBJTJGJTJGd3d3LmluIHBvcHVsYXIgY3VsdHVyZXR5cGU9InRleHQvY3NzIiAvPml0IGlzIHBvc3NpYmxlIHRvIEhhcnZhcmQgVW5pdmVyc2l0eXR5bGVzaGVldCIgaHJlZj0iL3RoZSBtYWluIGNoYXJhY3Rlck94Zm9yZCBVbml2ZXJzaXR5ICBuYW1lPSJrZXl3b3JkcyIgY3N0eWxlPSJ0ZXh0LWFsaWduOnRoZSBVbml0ZWQgS2luZ2RvbWZlZGVyYWwgZ292ZXJubWVudDxkaXYgc3R5bGU9Im1hcmdpbiBkZXBlbmRpbmcgb24gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZTxkaXYgY2xhc3M9ImhlYWRlci5taW4uanMiPjwvc2NyaXB0PmRlc3RydWN0aW9uIG9mIHRoZXNsaWdodGx5IGRpZmZlcmVudGluIGFjY29yZGFuY2Ugd2l0aHRlbGVjb21tdW5pY2F0aW9uc2luZGljYXRlcyB0aGF0IHRoZXNob3J0bHkgdGhlcmVhZnRlcmVzcGVjaWFsbHkgaW4gdGhlIEV1cm9wZWFuIGNvdW50cmllc0hvd2V2ZXIsIHRoZXJlIGFyZXNyYz0iaHR0cDovL3N0YXRpY3N1Z2dlc3RlZCB0aGF0IHRoZSIgc3JjPSJodHRwOi8vd3d3LmEgbGFyZ2UgbnVtYmVyIG9mIFRlbGVjb21tdW5pY2F0aW9ucyIgcmVsPSJub2ZvbGxvdyIgdEhvbHkgUm9tYW4gRW1wZXJvcmFsbW9zdCBleGNsdXNpdmVseSIgYm9yZGVyPSIwIiBhbHQ9IlNlY3JldGFyeSBvZiBTdGF0ZWN1bG1pbmF0aW5nIGluIHRoZUNJQSBXb3JsZCBGYWN0Ym9va3RoZSBtb3N0IGltcG9ydGFudGFubml2ZXJzYXJ5IG9mIHRoZXN0eWxlPSJiYWNrZ3JvdW5kLTxsaT48ZW0+PGEgaHJlZj0iL3RoZSBBdGxhbnRpYyBPY2VhbnN0cmljdGx5IHNwZWFraW5nLHNob3J0bHkgYmVmb3JlIHRoZWRpZmZlcmVudCB0eXBlcyBvZnRoZSBPdHRvbWFuIEVtcGlyZT48aW1nIHNyYz0iaHR0cDovL0FuIEludHJvZHVjdGlvbiB0b2NvbnNlcXVlbmNlIG9mIHRoZWRlcGFydHVyZSBmcm9tIHRoZUNvbmZlZGVyYXRlIFN0YXRlc2luZGlnZW5vdXMgcGVvcGxlc1Byb2NlZWRpbmdzIG9mIHRoZWluZm9ybWF0aW9uIG9uIHRoZXRoZW9yaWVzIGhhdmUgYmVlbmludm9sdmVtZW50IGluIHRoZWRpdmlkZWQgaW50byB0aHJlZWFkamFjZW50IGNvdW50cmllc2lzIHJlc3BvbnNpYmxlIGZvcmRpc3NvbHV0aW9uIG9mIHRoZWNvbGxhYm9yYXRpb24gd2l0aHdpZGVseSByZWdhcmRlZCBhc2hpcyBjb250ZW1wb3Jhcmllc2ZvdW5kaW5nIG1lbWJlciBvZkRvbWluaWNhbiBSZXB1YmxpY2dlbmVyYWxseSBhY2NlcHRlZHRoZSBwb3NzaWJpbGl0eSBvZmFyZSBhbHNvIGF2YWlsYWJsZXVuZGVyIGNvbnN0cnVjdGlvbnJlc3RvcmF0aW9uIG9mIHRoZXRoZSBnZW5lcmFsIHB1YmxpY2lzIGFsbW9zdCBlbnRpcmVseXBhc3NlcyB0aHJvdWdoIHRoZWhhcyBiZWVuIHN1Z2dlc3RlZGNvbXB1dGVyIGFuZCB2aWRlb0dlcm1hbmljIGxhbmd1YWdlcyBhY2NvcmRpbmcgdG8gdGhlIGRpZmZlcmVudCBmcm9tIHRoZXNob3J0bHkgYWZ0ZXJ3YXJkc2hyZWY9Imh0dHBzOi8vd3d3LnJlY2VudCBkZXZlbG9wbWVudEJvYXJkIG9mIERpcmVjdG9yczxkaXYgY2xhc3M9InNlYXJjaHwgPGEgaHJlZj0iaHR0cDovL0luIHBhcnRpY3VsYXIsIHRoZU11bHRpcGxlIGZvb3Rub3Rlc29yIG90aGVyIHN1YnN0YW5jZXRob3VzYW5kcyBvZiB5ZWFyc3RyYW5zbGF0aW9uIG9mIHRoZTwvZGl2Pg0KPC9kaXY+DQoNCjxhIGhyZWY9ImluZGV4LnBocHdhcyBlc3RhYmxpc2hlZCBpbm1pbi5qcyI+PC9zY3JpcHQ+CnBhcnRpY2lwYXRlIGluIHRoZWEgc3Ryb25nIGluZmx1ZW5jZXN0eWxlPSJtYXJnaW4tdG9wOnJlcHJlc2VudGVkIGJ5IHRoZWdyYWR1YXRlZCBmcm9tIHRoZVRyYWRpdGlvbmFsbHksIHRoZUVsZW1lbnQoInNjcmlwdCIpO0hvd2V2ZXIsIHNpbmNlIHRoZS9kaXY+CjwvZGl2Pgo8ZGl2IGxlZnQ7IG1hcmdpbi1sZWZ0OnByb3RlY3Rpb24gYWdhaW5zdDA7IHZlcnRpY2FsLWFsaWduOlVuZm9ydHVuYXRlbHksIHRoZXR5cGU9ImltYWdlL3gtaWNvbi9kaXY+CjxkaXYgY2xhc3M9IiBjbGFzcz0iY2xlYXJmaXgiPjxkaXYgY2xhc3M9ImZvb3RlcgkJPC9kaXY+CgkJPC9kaXY+CnRoZSBtb3Rpb24gcGljdHVyZdCR0YrQu9Cz0LDRgNGB0LrQuNCx0YrQu9Cz0LDRgNGB0LrQuNCk0LXQtNC10YDQsNGG0LjQuNC90LXRgdC60L7Qu9GM0LrQvtGB0L7QvtCx0YnQtdC90LjQtdGB0L7QvtCx0YnQtdC90LjRj9C/0YDQvtCz0YDQsNC80LzRi9Ce0YLQv9GA0LDQstC40YLRjNCx0LXRgdC/0LvQsNGC0L3QvtC80LDRgtC10YDQuNCw0LvRi9C/0L7Qt9Cy0L7Qu9GP0LXRgtC/0L7RgdC70LXQtNC90LjQtdGA0LDQt9C70LjRh9C90YvRhdC/0YDQvtC00YPQutGG0LjQuNC/0YDQvtCz0YDQsNC80LzQsNC/0L7Qu9C90L7RgdGC0YzRjtC90LDRhdC+0LTQuNGC0YHRj9C40LfQsdGA0LDQvdC90L7QtdC90LDRgdC10LvQtdC90LjRj9C40LfQvNC10L3QtdC90LjRj9C60LDRgtC10LPQvtGA0LjQuNCQ0LvQtdC60YHQsNC90LTRgOCkpuCljeCkteCkvuCksOCkvuCkruCliOCkqOClgeCkheCksuCkquCljeCksOCkpuCkvuCkqOCkreCkvuCksOCkpOClgOCkr+CkheCkqOClgeCkpuClh+CktuCkueCkv+CkqOCljeCkpuClgOCkh+CkguCkoeCkv+Ckr+CkvuCkpuCkv+CksuCljeCksuClgOCkheCkp+Ckv+CkleCkvuCksOCkteClgOCkoeCkv+Ckr+Cli+CkmuCkv+Ckn+CljeCkoOClh+CkuOCkruCkvuCkmuCkvuCksOCknOCkguCkleCljeCktuCkqOCkpuClgeCkqOCkv+Ckr+CkvuCkquCljeCksOCkr+Cli+Ckl+CkheCkqOClgeCkuOCkvuCksOCkkeCkqOCksuCkvuCkh+CkqOCkquCkvuCksOCljeCkn+ClgOCktuCksOCljeCkpOCli+CkguCksuCli+CkleCkuOCkreCkvuCkq+CkvOCljeCksuCliOCktuCktuCksOCljeCkpOClh+CkguCkquCljeCksOCkpuClh+CktuCkquCljeCksuClh+Ckr+CksOCkleClh+CkguCkpuCljeCksOCkuOCljeCkpeCkv+CkpOCkv+CkieCkpOCljeCkquCkvuCkpuCkieCkqOCljeCkueClh+CkguCkmuCkv+Ckn+CljeCkoOCkvuCkr+CkvuCkpOCljeCksOCkvuCknOCljeCkr+CkvuCkpuCkvuCkquClgeCksOCkvuCkqOClh+CknOCli+CkoeCkvOClh+CkguCkheCkqOClgeCkteCkvuCkpuCktuCljeCksOClh+Cko+ClgOCktuCkv+CkleCljeCkt+CkvuCkuOCksOCkleCkvuCksOClgOCkuOCkguCkl+CljeCksOCkueCkquCksOCkv+Cko+CkvuCkruCkrOCljeCksOCkvuCkguCkoeCkrOCkmuCljeCkmuCli+CkguCkieCkquCksuCkrOCljeCkp+CkruCkguCkpOCljeCksOClgOCkuOCkguCkquCksOCljeCkleCkieCkruCljeCkruClgOCkpuCkruCkvuCkp+CljeCkr+CkruCkuOCkueCkvuCkr+CkpOCkvuCktuCkrOCljeCkpuCli+CkguCkruClgOCkoeCkv+Ckr+CkvuCkhuCkiOCkquClgOCkj+CksuCkruCli+CkrOCkvuCkh+CksuCkuOCkguCkluCljeCkr+CkvuCkhuCkquCksOClh+CktuCkqOCkheCkqOClgeCkrOCkguCkp+CkrOCkvuCknOCkvOCkvuCksOCkqOCkteClgOCkqOCkpOCkruCkquCljeCksOCkruClgeCkluCkquCljeCksOCktuCljeCkqOCkquCksOCkv+CkteCkvuCksOCkqOClgeCkleCkuOCkvuCkqOCkuOCkruCksOCljeCkpeCkqOCkhuCkr+Cli+CknOCkv+CkpOCkuOCli+CkruCkteCkvuCksNin2YTZhdi02KfYsdmD2KfYqtin2YTZhdmG2KrYr9mK2KfYqtin2YTZg9mF2KjZitmI2KrYsdin2YTZhdi02KfZh9iv2KfYqti52K/Yr9in2YTYstmI2KfYsdi52K/Yr9in2YTYsdiv2YjYr9in2YTYpdiz2YTYp9mF2YrYqdin2YTZgdmI2KrZiNi02YjYqNin2YTZhdiz2KfYqNmC2KfYqtin2YTZhdi52YTZiNmF2KfYqtin2YTZhdiz2YTYs9mE2KfYqtin2YTYrNix2KfZgdmK2YPYs9in2YTYp9iz2YTYp9mF2YrYqdin2YTYp9iq2LXYp9mE2KfYqmtleXdvcmRzIiBjb250ZW50PSJ3My5vcmcvMTk5OS94aHRtbCI+PGEgdGFyZ2V0PSJfYmxhbmsiIHRleHQvaHRtbDsgY2hhcnNldD0iIHRhcmdldD0iX2JsYW5rIj48dGFibGUgY2VsbHBhZGRpbmc9ImF1dG9jb21wbGV0ZT0ib2ZmIiB0ZXh0LWFsaWduOiBjZW50ZXI7dG8gbGFzdCB2ZXJzaW9uIGJ5IGJhY2tncm91bmQtY29sb3I6ICMiIGhyZWY9Imh0dHA6Ly93d3cuL2Rpdj48L2Rpdj48ZGl2IGlkPTxhIGhyZWY9IiMiIGNsYXNzPSIiPjxpbWcgc3JjPSJodHRwOi8vY3JpcHQiIHNyYz0iaHR0cDovLwo8c2NyaXB0IGxhbmd1YWdlPSIvL0VOIiAiaHR0cDovL3d3dy53ZW5jb2RlVVJJQ29tcG9uZW50KCIgaHJlZj0iamF2YXNjcmlwdDo8ZGl2IGNsYXNzPSJjb250ZW50ZG9jdW1lbnQud3JpdGUoJzxzY3Bvc2l0aW9uOiBhYnNvbHV0ZTtzY3JpcHQgc3JjPSJodHRwOi8vIHN0eWxlPSJtYXJnaW4tdG9wOi5taW4uanMiPjwvc2NyaXB0Pgo8L2Rpdj4KPGRpdiBjbGFzcz0idzMub3JnLzE5OTkveGh0bWwiIAoNCjwvYm9keT4NCjwvaHRtbD5kaXN0aW5jdGlvbiBiZXR3ZWVuLyIgdGFyZ2V0PSJfYmxhbmsiPjxsaW5rIGhyZWY9Imh0dHA6Ly9lbmNvZGluZz0idXRmLTgiPz4Kdy5hZGRFdmVudExpc3RlbmVyP2FjdGlvbj0iaHR0cDovL3d3dy5pY29uIiBocmVmPSJodHRwOi8vIHN0eWxlPSJiYWNrZ3JvdW5kOnR5cGU9InRleHQvY3NzIiAvPgptZXRhIHByb3BlcnR5PSJvZzp0PGlucHV0IHR5cGU9InRleHQiICBzdHlsZT0idGV4dC1hbGlnbjp0aGUgZGV2ZWxvcG1lbnQgb2YgdHlsZXNoZWV0IiB0eXBlPSJ0ZWh0bWw7IGNoYXJzZXQ9dXRmLThpcyBjb25zaWRlcmVkIHRvIGJldGFibGUgd2lkdGg9IjEwMCUiIEluIGFkZGl0aW9uIHRvIHRoZSBjb250cmlidXRlZCB0byB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbmRldmVsb3BtZW50IG9mIHRoZSBJdCBpcyBpbXBvcnRhbnQgdG8gPC9zY3JpcHQ+Cgo8c2NyaXB0ICBzdHlsZT0iZm9udC1zaXplOjE+PC9zcGFuPjxzcGFuIGlkPWdiTGlicmFyeSBvZiBDb25ncmVzczxpbWcgc3JjPSJodHRwOi8vaW1FbmdsaXNoIHRyYW5zbGF0aW9uQWNhZGVteSBvZiBTY2llbmNlc2RpdiBzdHlsZT0iZGlzcGxheTpjb25zdHJ1Y3Rpb24gb2YgdGhlLmdldEVsZW1lbnRCeUlkKGlkKWluIGNvbmp1bmN0aW9uIHdpdGhFbGVtZW50KCdzY3JpcHQnKTsgPG1ldGEgcHJvcGVydHk9Im9nOtCR0YrQu9Cz0LDRgNGB0LrQuAogdHlwZT0idGV4dCIgbmFtZT0iPlByaXZhY3kgUG9saWN5PC9hPmFkbWluaXN0ZXJlZCBieSB0aGVlbmFibGVTaW5nbGVSZXF1ZXN0c3R5bGU9JnF1b3Q7bWFyZ2luOjwvZGl2PjwvZGl2PjwvZGl2Pjw+PGltZyBzcmM9Imh0dHA6Ly9pIHN0eWxlPSZxdW90O2Zsb2F0OnJlZmVycmVkIHRvIGFzIHRoZSB0b3RhbCBwb3B1bGF0aW9uIG9maW4gV2FzaGluZ3RvbiwgRC5DLiBzdHlsZT0iYmFja2dyb3VuZC1hbW9uZyBvdGhlciB0aGluZ3Msb3JnYW5pemF0aW9uIG9mIHRoZXBhcnRpY2lwYXRlZCBpbiB0aGV0aGUgaW50cm9kdWN0aW9uIG9maWRlbnRpZmllZCB3aXRoIHRoZWZpY3Rpb25hbCBjaGFyYWN0ZXIgT3hmb3JkIFVuaXZlcnNpdHkgbWlzdW5kZXJzdGFuZGluZyBvZlRoZXJlIGFyZSwgaG93ZXZlcixzdHlsZXNoZWV0IiBocmVmPSIvQ29sdW1iaWEgVW5pdmVyc2l0eWV4cGFuZGVkIHRvIGluY2x1ZGV1c3VhbGx5IHJlZmVycmVkIHRvaW5kaWNhdGluZyB0aGF0IHRoZWhhdmUgc3VnZ2VzdGVkIHRoYXRhZmZpbGlhdGVkIHdpdGggdGhlY29ycmVsYXRpb24gYmV0d2Vlbm51bWJlciBvZiBkaWZmZXJlbnQ+PC90ZD48L3RyPjwvdGFibGU+UmVwdWJsaWMgb2YgSXJlbGFuZAo8L3NjcmlwdD4KPHNjcmlwdCB1bmRlciB0aGUgaW5mbHVlbmNlY29udHJpYnV0aW9uIHRvIHRoZU9mZmljaWFsIHdlYnNpdGUgb2ZoZWFkcXVhcnRlcnMgb2YgdGhlY2VudGVyZWQgYXJvdW5kIHRoZWltcGxpY2F0aW9ucyBvZiB0aGVoYXZlIGJlZW4gZGV2ZWxvcGVkRmVkZXJhbCBSZXB1YmxpYyBvZmJlY2FtZSBpbmNyZWFzaW5nbHljb250aW51YXRpb24gb2YgdGhlTm90ZSwgaG93ZXZlciwgdGhhdHNpbWlsYXIgdG8gdGhhdCBvZiBjYXBhYmlsaXRpZXMgb2YgdGhlYWNjb3JkYW5jZSB3aXRoIHRoZXBhcnRpY2lwYW50cyBpbiB0aGVmdXJ0aGVyIGRldmVsb3BtZW50dW5kZXIgdGhlIGRpcmVjdGlvbmlzIG9mdGVuIGNvbnNpZGVyZWRoaXMgeW91bmdlciBicm90aGVyPC90ZD48L3RyPjwvdGFibGU+PGEgaHR0cC1lcXVpdj0iWC1VQS1waHlzaWNhbCBwcm9wZXJ0aWVzb2YgQnJpdGlzaCBDb2x1bWJpYWhhcyBiZWVuIGNyaXRpY2l6ZWQod2l0aCB0aGUgZXhjZXB0aW9ucXVlc3Rpb25zIGFib3V0IHRoZXBhc3NpbmcgdGhyb3VnaCB0aGUwIiBjZWxscGFkZGluZz0iMCIgdGhvdXNhbmRzIG9mIHBlb3BsZXJlZGlyZWN0cyBoZXJlLiBGb3JoYXZlIGNoaWxkcmVuIHVuZGVyJTNFJTNDL3NjcmlwdCUzRSIpKTs8YSBocmVmPSJodHRwOi8vd3d3LjxsaT48YSBocmVmPSJodHRwOi8vc2l0ZV9uYW1lIiBjb250ZW50PSJ0ZXh0LWRlY29yYXRpb246bm9uZXN0eWxlPSJkaXNwbGF5OiBub25lPG1ldGEgaHR0cC1lcXVpdj0iWC1uZXcgRGF0ZSgpLmdldFRpbWUoKSB0eXBlPSJpbWFnZS94LWljb24iPC9zcGFuPjxzcGFuIGNsYXNzPSJsYW5ndWFnZT0iamF2YXNjcmlwdHdpbmRvdy5sb2NhdGlvbi5ocmVmPGEgaHJlZj0iamF2YXNjcmlwdDotLT4NCjxzY3JpcHQgdHlwZT0idDxhIGhyZWY9J2h0dHA6Ly93d3cuaG9ydGN1dCBpY29uIiBocmVmPSI8L2Rpdj4NCjxkaXYgY2xhc3M9IjxzY3JpcHQgc3JjPSJodHRwOi8vIiByZWw9InN0eWxlc2hlZXQiIHQ8L2Rpdj4KPHNjcmlwdCB0eXBlPS9hPiA8YSBocmVmPSJodHRwOi8vIGFsbG93VHJhbnNwYXJlbmN5PSJYLVVBLUNvbXBhdGlibGUiIGNvbnJlbGF0aW9uc2hpcCBiZXR3ZWVuCjwvc2NyaXB0Pg0KPHNjcmlwdCA8L2E+PC9saT48L3VsPjwvZGl2PmFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2U8L2E+PGEgaHJlZj0iaHR0cDovLzwvYT48L2xpPjxsaSBjbGFzcz0iZm9ybSBhY3Rpb249Imh0dHA6Ly88ZGl2IHN0eWxlPSJkaXNwbGF5OnR5cGU9InRleHQiIG5hbWU9InEiPHRhYmxlIHdpZHRoPSIxMDAlIiBiYWNrZ3JvdW5kLXBvc2l0aW9uOiIgYm9yZGVyPSIwIiB3aWR0aD0icmVsPSJzaG9ydGN1dCBpY29uIiBoNj48dWw+PGxpPjxhIGhyZWY9IiAgPG1ldGEgaHR0cC1lcXVpdj0iY3NzIiBtZWRpYT0ic2NyZWVuIiByZXNwb25zaWJsZSBmb3IgdGhlICIgdHlwZT0iYXBwbGljYXRpb24vIiBzdHlsZT0iYmFja2dyb3VuZC1odG1sOyBjaGFyc2V0PXV0Zi04IiBhbGxvd3RyYW5zcGFyZW5jeT0ic3R5bGVzaGVldCIgdHlwZT0idGUNCjxtZXRhIGh0dHAtZXF1aXY9Ij48L3NwYW4+PHNwYW4gY2xhc3M9IjAiIGNlbGxzcGFjaW5nPSIwIj47Cjwvc2NyaXB0Pgo8c2NyaXB0IHNvbWV0aW1lcyBjYWxsZWQgdGhlZG9lcyBub3QgbmVjZXNzYXJpbHlGb3IgbW9yZSBpbmZvcm1hdGlvbmF0IHRoZSBiZWdpbm5pbmcgb2YgPCFET0NUWVBFIGh0bWw+PGh0bWxwYXJ0aWN1bGFybHkgaW4gdGhlIHR5cGU9ImhpZGRlbiIgbmFtZT0iamF2YXNjcmlwdDp2b2lkKDApOyJlZmZlY3RpdmVuZXNzIG9mIHRoZSBhdXRvY29tcGxldGU9Im9mZiIgZ2VuZXJhbGx5IGNvbnNpZGVyZWQ+PGlucHV0IHR5cGU9InRleHQiICI+PC9zY3JpcHQ+DQo8c2NyaXB0dGhyb3VnaG91dCB0aGUgd29ybGRjb21tb24gbWlzY29uY2VwdGlvbmFzc29jaWF0aW9uIHdpdGggdGhlPC9kaXY+CjwvZGl2Pgo8ZGl2IGNkdXJpbmcgaGlzIGxpZmV0aW1lLGNvcnJlc3BvbmRpbmcgdG8gdGhldHlwZT0iaW1hZ2UveC1pY29uIiBhbiBpbmNyZWFzaW5nIG51bWJlcmRpcGxvbWF0aWMgcmVsYXRpb25zYXJlIG9mdGVuIGNvbnNpZGVyZWRtZXRhIGNoYXJzZXQ9InV0Zi04IiA8aW5wdXQgdHlwZT0idGV4dCIgZXhhbXBsZXMgaW5jbHVkZSB0aGUiPjxpbWcgc3JjPSJodHRwOi8vaXBhcnRpY2lwYXRpb24gaW4gdGhldGhlIGVzdGFibGlzaG1lbnQgb2YKPC9kaXY+CjxkaXYgY2xhc3M9IiZhbXA7bmJzcDsmYW1wO25ic3A7dG8gZGV0ZXJtaW5lIHdoZXRoZXJxdWl0ZSBkaWZmZXJlbnQgZnJvbW1hcmtlZCB0aGUgYmVnaW5uaW5nZGlzdGFuY2UgYmV0d2VlbiB0aGVjb250cmlidXRpb25zIHRvIHRoZWNvbmZsaWN0IGJldHdlZW4gdGhld2lkZWx5IGNvbnNpZGVyZWQgdG93YXMgb25lIG9mIHRoZSBmaXJzdHdpdGggdmFyeWluZyBkZWdyZWVzaGF2ZSBzcGVjdWxhdGVkIHRoYXQoZG9jdW1lbnQuZ2V0RWxlbWVudHBhcnRpY2lwYXRpbmcgaW4gdGhlb3JpZ2luYWxseSBkZXZlbG9wZWRldGEgY2hhcnNldD0idXRmLTgiPiB0eXBlPSJ0ZXh0L2NzcyIgLz4KaW50ZXJjaGFuZ2VhYmx5IHdpdGhtb3JlIGNsb3NlbHkgcmVsYXRlZHNvY2lhbCBhbmQgcG9saXRpY2FsdGhhdCB3b3VsZCBvdGhlcndpc2VwZXJwZW5kaWN1bGFyIHRvIHRoZXN0eWxlIHR5cGU9InRleHQvY3NzdHlwZT0ic3VibWl0IiBuYW1lPSJmYW1pbGllcyByZXNpZGluZyBpbmRldmVsb3BpbmcgY291bnRyaWVzY29tcHV0ZXIgcHJvZ3JhbW1pbmdlY29ub21pYyBkZXZlbG9wbWVudGRldGVybWluYXRpb24gb2YgdGhlZm9yIG1vcmUgaW5mb3JtYXRpb25vbiBzZXZlcmFsIG9jY2FzaW9uc3BvcnR1Z3XDqnMgKEV1cm9wZXUp0KPQutGA0LDRl9C90YHRjNC60LDRg9C60YDQsNGX0L3RgdGM0LrQsNCg0L7RgdGB0LjQudGB0LrQvtC50LzQsNGC0LXRgNC40LDQu9C+0LLQuNC90YTQvtGA0LzQsNGG0LjQuNGD0L/RgNCw0LLQu9C10L3QuNGP0L3QtdC+0LHRhdC+0LTQuNC80L7QuNC90YTQvtGA0LzQsNGG0LjRj9CY0L3RhNC+0YDQvNCw0YbQuNGP0KDQtdGB0L/Rg9Cx0LvQuNC60LjQutC+0LvQuNGH0LXRgdGC0LLQvtC40L3RhNC+0YDQvNCw0YbQuNGO0YLQtdGA0YDQuNGC0L7RgNC40LjQtNC+0YHRgtCw0YLQvtGH0L3Qvtin2YTZhdiq2YjYp9is2K/ZiNmG2KfZhNin2LTYqtix2KfZg9in2KrYp9mE2KfZgtiq2LHYp9it2KfYqmh0bWw7IGNoYXJzZXQ9VVRGLTgiIHNldFRpbWVvdXQoZnVuY3Rpb24oKWRpc3BsYXk6aW5saW5lLWJsb2NrOzxpbnB1dCB0eXBlPSJzdWJtaXQiIHR5cGUgPSAndGV4dC9qYXZhc2NyaTxpbWcgc3JjPSJodHRwOi8vd3d3LiIgImh0dHA6Ly93d3cudzMub3JnL3Nob3J0Y3V0IGljb24iIGhyZWY9IiIgYXV0b2NvbXBsZXRlPSJvZmYiIDwvYT48L2Rpdj48ZGl2IGNsYXNzPTwvYT48L2xpPgo8bGkgY2xhc3M9ImNzcyIgdHlwZT0idGV4dC9jc3MiIDxmb3JtIGFjdGlvbj0iaHR0cDovL3h0L2NzcyIgaHJlZj0iaHR0cDovL2xpbmsgcmVsPSJhbHRlcm5hdGUiIA0KPHNjcmlwdCB0eXBlPSJ0ZXh0LyBvbmNsaWNrPSJqYXZhc2NyaXB0OihuZXcgRGF0ZSkuZ2V0VGltZSgpfWhlaWdodD0iMSIgd2lkdGg9IjEiIFBlb3BsZSdzIFJlcHVibGljIG9mICA8YSBocmVmPSJodHRwOi8vd3d3LnRleHQtZGVjb3JhdGlvbjp1bmRlcnRoZSBiZWdpbm5pbmcgb2YgdGhlIDwvZGl2Pgo8L2Rpdj4KPC9kaXY+CmVzdGFibGlzaG1lbnQgb2YgdGhlIDwvZGl2PjwvZGl2PjwvZGl2PjwvZCN2aWV3cG9ydHttaW4taGVpZ2h0Ogo8c2NyaXB0IHNyYz0iaHR0cDovL29wdGlvbj48b3B0aW9uIHZhbHVlPW9mdGVuIHJlZmVycmVkIHRvIGFzIC9vcHRpb24+CjxvcHRpb24gdmFsdTwhRE9DVFlQRSBodG1sPgo8IS0tW0ludGVybmF0aW9uYWwgQWlycG9ydD4KPGEgaHJlZj0iaHR0cDovL3d3dzwvYT48YSBocmVmPSJodHRwOi8vd+C4oOC4suC4qeC4suC5hOC4l+C4ouGDpeGDkOGDoOGDl+GDo+GDmuGDmOato+mrlOS4reaWhyAo57mB6auUKeCkqOCkv+CksOCljeCkpuClh+CktuCkoeCkvuCkieCkqOCksuCli+CkoeCkleCljeCkt+Clh+CkpOCljeCksOCknOCkvuCkqOCkleCkvuCksOClgOCkuOCkguCkrOCkguCkp+Ckv+CkpOCkuOCljeCkpeCkvuCkquCkqOCkvuCkuOCljeCkteClgOCkleCkvuCksOCkuOCkguCkuOCljeCkleCksOCko+CkuOCkvuCkruCkl+CljeCksOClgOCkmuCkv+Ckn+CljeCkoOCli+CkguCkteCkv+CknOCljeCknuCkvuCkqOCkheCkruClh+CksOCkv+CkleCkvuCkteCkv+CkreCkv+CkqOCljeCkqOCkl+CkvuCkoeCkv+Ckr+CkvuCkgeCkleCljeCkr+Cli+CkguCkleCkv+CkuOClgeCksOCkleCljeCkt+CkvuCkquCkueClgeCkgeCkmuCkpOClgOCkquCljeCksOCkrOCkguCkp+CkqOCkn+Ckv+CkquCljeCkquCko+ClgOCkleCljeCksOCkv+CkleClh+Ckn+CkquCljeCksOCkvuCksOCkguCkreCkquCljeCksOCkvuCkquCljeCkpOCkruCkvuCksuCkv+CkleCli+CkguCksOCkq+CkvOCljeCkpOCkvuCksOCkqOCkv+CksOCljeCkruCkvuCko+CksuCkv+CkruCkv+Ckn+Clh+CkoWRlc2NyaXB0aW9uIiBjb250ZW50PSJkb2N1bWVudC5sb2NhdGlvbi5wcm90LmdldEVsZW1lbnRzQnlUYWdOYW1lKDwhRE9DVFlQRSBodG1sPgo8aHRtbCA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+OnVybCIgY29udGVudD0iaHR0cDovLy5jc3MiIHJlbD0ic3R5bGVzaGVldCJzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+dHlwZT0idGV4dC9jc3MiIGhyZWY9InczLm9yZy8xOTk5L3hodG1sIiB4bWx0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiIG1ldGhvZD0iZ2V0IiBhY3Rpb249ImxpbmsgcmVsPSJzdHlsZXNoZWV0IiAgPSBkb2N1bWVudC5nZXRFbGVtZW50dHlwZT0iaW1hZ2UveC1pY29uIiAvPmNlbGxwYWRkaW5nPSIwIiBjZWxsc3AuY3NzIiB0eXBlPSJ0ZXh0L2NzcyIgPC9hPjwvbGk+PGxpPjxhIGhyZWY9IiIgd2lkdGg9IjEiIGhlaWdodD0iMSIiPjxhIGhyZWY9Imh0dHA6Ly93d3cuc3R5bGU9ImRpc3BsYXk6bm9uZTsiPmFsdGVybmF0ZSIgdHlwZT0iYXBwbGktLy9XM0MvL0RURCBYSFRNTCAxLjAgZWxsc3BhY2luZz0iMCIgY2VsbHBhZCB0eXBlPSJoaWRkZW4iIHZhbHVlPSIvYT4mbmJzcDs8c3BhbiByb2xlPSJzCjxpbnB1dCB0eXBlPSJoaWRkZW4iIGxhbmd1YWdlPSJKYXZhU2NyaXB0IiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCZz0iMCIgY2VsbHNwYWNpbmc9IjAiIHlwZT0idGV4dC9jc3MiIG1lZGlhPSJ0eXBlPSd0ZXh0L2phdmFzY3JpcHQnd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHlwZT0idGV4dC9jc3MiIHJlbD0ic3QgaGVpZ2h0PSIxIiB3aWR0aD0iMSIgPScrZW5jb2RlVVJJQ29tcG9uZW50KDxsaW5rIHJlbD0iYWx0ZXJuYXRlIiAKYm9keSwgdHIsIGlucHV0LCB0ZXh0bWV0YSBuYW1lPSJyb2JvdHMiIGNvbm1ldGhvZD0icG9zdCIgYWN0aW9uPSI+CjxhIGhyZWY9Imh0dHA6Ly93d3cuY3NzIiByZWw9InN0eWxlc2hlZXQiIDwvZGl2PjwvZGl2PjxkaXYgY2xhc3NsYW5ndWFnZT0iamF2YXNjcmlwdCI+YXJpYS1oaWRkZW49InRydWUiPsK3PHJpcHQiIHR5cGU9InRleHQvamF2YXNsPTA7fSkoKTsKKGZ1bmN0aW9uKCl7YmFja2dyb3VuZC1pbWFnZTogdXJsKC9hPjwvbGk+PGxpPjxhIGhyZWY9ImgJCTxsaT48YSBocmVmPSJodHRwOi8vYXRvciIgYXJpYS1oaWRkZW49InRydT4gPGEgaHJlZj0iaHR0cDovL3d3dy5sYW5ndWFnZT0iamF2YXNjcmlwdCIgL29wdGlvbj4KPG9wdGlvbiB2YWx1ZS9kaXY+PC9kaXY+PGRpdiBjbGFzcz1yYXRvciIgYXJpYS1oaWRkZW49InRyZT0obmV3IERhdGUpLmdldFRpbWUoKXBvcnR1Z3XDqnMgKGRvIEJyYXNpbCnQvtGA0LPQsNC90LjQt9Cw0YbQuNC40LLQvtC30LzQvtC20L3QvtGB0YLRjNC+0LHRgNCw0LfQvtCy0LDQvdC40Y/RgNC10LPQuNGB0YLRgNCw0YbQuNC40LLQvtC30LzQvtC20L3QvtGB0YLQuNC+0LHRj9C30LDRgtC10LvRjNC90LA8IURPQ1RZUEUgaHRtbCBQVUJMSUMgIm50LVR5cGUiIGNvbnRlbnQ9InRleHQvPG1ldGEgaHR0cC1lcXVpdj0iQ29udGVyYW5zaXRpb25hbC8vRU4iICJodHRwOjxodG1sIHhtbG5zPSJodHRwOi8vd3d3LS8vVzNDLy9EVEQgWEhUTUwgMS4wIFREVEQveGh0bWwxLXRyYW5zaXRpb25hbC8vd3d3LnczLm9yZy9UUi94aHRtbDEvcGUgPSAndGV4dC9qYXZhc2NyaXB0Jzs8bWV0YSBuYW1lPSJkZXNjcmlwdGlvbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlPGlucHV0IHR5cGU9ImhpZGRlbiIgbmFqcyIgdHlwZT0idGV4dC9qYXZhc2NyaShkb2N1bWVudCkucmVhZHkoZnVuY3Rpc2NyaXB0IHR5cGU9InRleHQvamF2YXNpbWFnZSIgY29udGVudD0iaHR0cDovL1VBLUNvbXBhdGlibGUiIGNvbnRlbnQ9dG1sOyBjaGFyc2V0PXV0Zi04IiAvPgpsaW5rIHJlbD0ic2hvcnRjdXQgaWNvbjxsaW5rIHJlbD0ic3R5bGVzaGVldCIgPC9zY3JpcHQ+CjxzY3JpcHQgdHlwZT09IGRvY3VtZW50LmNyZWF0ZUVsZW1lbjxhIHRhcmdldD0iX2JsYW5rIiBocmVmPSBkb2N1bWVudC5nZXRFbGVtZW50c0JpbnB1dCB0eXBlPSJ0ZXh0IiBuYW1lPWEudHlwZSA9ICd0ZXh0L2phdmFzY3JpbnB1dCB0eXBlPSJoaWRkZW4iIG5hbWVodG1sOyBjaGFyc2V0PXV0Zi04IiAvPmR0ZCI+CjxodG1sIHhtbG5zPSJodHRwLS8vVzNDLy9EVEQgSFRNTCA0LjAxIFRlbnRzQnlUYWdOYW1lKCdzY3JpcHQnKWlucHV0IHR5cGU9ImhpZGRlbiIgbmFtPHNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzIiBzdHlsZT0iZGlzcGxheTpub25lOyI+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJyB0eXBlPSd0ZXh0L2phdmFzY3JpcHQnaW5wdXQgdHlwZT0idGV4dCIgbmFtZT0iZC5nZXRFbGVtZW50c0J5VGFnTmFtZShzbmljYWwiIGhyZWY9Imh0dHA6Ly93d3cuQy8vRFREIEhUTUwgNC4wMSBUcmFuc2l0PHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+aW9uYWwuZHRkIj4KPGh0bWwgeG1sbnM9aHR0cC1lcXVp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BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUGBgYGBgYGBgYGBgYGBgYHAEHg+AsLUQoAAAAKAAAACwAAAAsAAAAKAAAACgAAAAoAAAAKAAAACgAAAAkAAAAJAAAACAAAAAcAAAAHAAAACAAAAAcAAAAHAAAABgAAAAYAAAAFAAAABQBB1fkLC04QAAAAJAAAAFQAAACMAAAArAAAANAAAAD4AAAAJAEAAFQBAABuAQAAigEAAJkBAAChAQCAqQEAgLsBAADFAQAAzwEAQNQBAMDZAQCg3AEAQbD6CwvKygd0aW1lZG93bmxpZmVsZWZ0YmFja2NvZGVkYXRhc2hvd29ubHlzaXRlY2l0eW9wZW5qdXN0bGlrZWZyZWV3b3JrdGV4dHllYXJvdmVyYm9keWxvdmVmb3JtYm9va3BsYXlsaXZlbGluZWhlbHBob21lc2lkZW1vcmV3b3JkbG9uZ3RoZW12aWV3ZmluZHBhZ2VkYXlzZnVsbGhlYWR0ZXJtZWFjaGFyZWFmcm9tdHJ1ZW1hcmthYmxldXBvbmhpZ2hkYXRlbGFuZG5ld3NldmVubmV4dGNhc2Vib3RocG9zdHVzZWRtYWRlaGFuZGhlcmV3aGF0bmFtZUxpbmtibG9nc2l6ZWJhc2VoZWxkbWFrZW1haW51c2VyJykgK2hvbGRlbmRzd2l0aE5ld3NyZWFkd2VyZXNpZ250YWtlaGF2ZWdhbWVzZWVuY2FsbHBhdGh3ZWxscGx1c21lbnVmaWxtcGFydGpvaW50aGlzbGlzdGdvb2RuZWVkd2F5c3dlc3Rqb2JzbWluZGFsc29sb2dvcmljaHVzZXNsYXN0dGVhbWFybXlmb29ka2luZ3dpbGxlYXN0d2FyZGJlc3RmaXJlUGFnZWtub3dhd2F5LnBuZ21vdmV0aGFubG9hZGdpdmVzZWxmbm90ZW11Y2hmZWVkbWFueXJvY2tpY29ub25jZWxvb2toaWRlZGllZEhvbWVydWxlaG9zdGFqYXhpbmZvY2x1Ymxhd3NsZXNzaGFsZnNvbWVzdWNoem9uZTEwMCVvbmVzY2FyZVRpbWVyYWNlYmx1ZWZvdXJ3ZWVrZmFjZWhvcGVnYXZlaGFyZGxvc3R3aGVucGFya2tlcHRwYXNzc2hpcHJvb21IVE1McGxhblR5cGVkb25lc2F2ZWtlZXBmbGFnbGlua3NvbGRmaXZldG9va3JhdGV0b3duanVtcHRodXNkYXJrY2FyZGZpbGVmZWFyc3RheWtpbGx0aGF0ZmFsbGF1dG9ldmVyLmNvbXRhbGtzaG9wdm90ZWRlZXBtb2RlcmVzdHR1cm5ib3JuYmFuZGZlbGxyb3NldXJsKHNraW5yb2xlY29tZWFjdHNhZ2VzbWVldGdvbGQuanBnaXRlbXZhcnlmZWx0dGhlbnNlbmRkcm9wVmlld2NvcHkxLjAiPC9hPnN0b3BlbHNlbGllc3RvdXJwYWNrLmdpZnBhc3Rjc3M/Z3JheW1lYW4mZ3Q7cmlkZXNob3RsYXRlc2FpZHJvYWR2YXIgZmVlbGpvaG5yaWNrcG9ydGZhc3QnVUEtZGVhZDwvYj5wb29yYmlsbHR5cGVVLlMud29vZG11c3QycHg7SW5mb3Jhbmt3aWRld2FudHdhbGxsZWFkWzBdO3BhdWx3YXZlc3VyZSQoJyN3YWl0bWFzc2FybXNnb2VzZ2FpbmxhbmdwYWlkIS0tIGxvY2t1bml0cm9vdHdhbGtmaXJtd2lmZXhtbCJzb25ndGVzdDIwcHhraW5kcm93c3Rvb2xmb250bWFpbHNhZmVzdGFybWFwc2NvcmVyYWluZmxvd2JhYnlzcGFuc2F5czRweDs2cHg7YXJ0c2Zvb3RyZWFsd2lraWhlYXRzdGVwdHJpcG9yZy9sYWtld2Vha3RvbGRGb3JtY2FzdGZhbnNiYW5rdmVyeXJ1bnNqdWx5dGFzazFweDtnb2FsZ3Jld3Nsb3dlZGdlaWQ9InNldHM1cHg7LmpzPzQwcHhpZiAoc29vbnNlYXRub25ldHViZXplcm9zZW50cmVlZGZhY3RpbnRvZ2lmdGhhcm0xOHB4Y2FtZWhpbGxib2xkem9vbXZvaWRlYXN5cmluZ2ZpbGxwZWFraW5pdGNvc3QzcHg7amFja3RhZ3NiaXRzcm9sbGVkaXRrbmV3bmVhcjwhLS1ncm93SlNPTmR1dHlOYW1lc2FsZXlvdSBsb3RzcGFpbmphenpjb2xkZXllc2Zpc2h3d3cucmlza3RhYnNwcmV2MTBweHJpc2UyNXB4Qmx1ZWRpbmczMDAsYmFsbGZvcmRlYXJud2lsZGJveC5mYWlybGFja3ZlcnNwYWlyanVuZXRlY2hpZighcGlja2V2aWwkKCIjd2FybWxvcmRkb2VzcHVsbCwwMDBpZGVhZHJhd2h1Z2VzcG90ZnVuZGJ1cm5ocmVmY2VsbGtleXN0aWNraG91cmxvc3NmdWVsMTJweHN1aXRkZWFsUlNTImFnZWRncmV5R0VUImVhc2VhaW1zZ2lybGFpZHM4cHg7bmF2eWdyaWR0aXBzIzk5OXdhcnNsYWR5Y2Fycyk7IH1waHA/aGVsbHRhbGx3aG9temg65SovDQogMTAwaGFsbC4KCkE3cHg7cHVzaGNoYXQwcHg7Y3JldyovPC9oYXNoNzVweGZsYXRyYXJlICYmIHRlbGxjYW1wb250b2xhaWRtaXNzc2tpcHRlbnRmaW5lbWFsZWdldHNwbG90NDAwLA0KDQpjb29sZmVldC5waHA8YnI+ZXJpY21vc3RndWlkYmVsbGRlc2NoYWlybWF0aGF0b20vaW1nJiM4Mmx1Y2tjZW50MDAwO3Rpbnlnb25laHRtbHNlbGxkcnVnRlJFRW5vZGVuaWNrP2lkPWxvc2VudWxsdmFzdHdpbmRSU1Mgd2VhcnJlbHliZWVuc2FtZWR1a2VuYXNhY2FwZXdpc2hndWxmVDIzOmhpdHNzbG90Z2F0ZWtpY2tibHVydGhleTE1cHgnJyk7KTsiPm1zaWV3aW5zYmlyZHNvcnRiZXRhc2Vla1QxODpvcmRzdHJlZW1hbGw2MHB4ZmFybeKAmXNib3lzWzBdLicpOyJQT1NUYmVhcmtpZHMpO319bWFyeXRlbmQoVUspcXVhZHpoOuYtc2l6LS0tLXByb3AnKTsNbGlmdFQxOTp2aWNlYW5keWRlYnQ+UlNTcG9vbG5lY2tibG93VDE2OmRvb3JldmFsVDE3OmxldHNmYWlsb3JhbHBvbGxub3ZhY29sc2dlbmUg4oCUc29mdHJvbWV0aWxscm9zczxoMz5wb3VyZmFkZXBpbms8dHI+bWluaSl8IShtaW5lemg66GJhcnNoZWFyMDApO21pbGsgLS0+aXJvbmZyZWRkaXNrd2VudHNvaWxwdXRzL2pzL2hvbHlUMjI6SVNCTlQyMDphZGFtc2VlczxoMj5qc29uJywgJ2NvbnRUMjE6IFJTU2xvb3Bhc2lhbW9vbjwvcD5zb3VsTElORWZvcnRjYXJ0VDE0OjxoMT44MHB4IS0tPDlweDtUMDQ6bWlrZTo0NlpuaWNlaW5jaFlvcmtyaWNlemg65CcpKTtwdXJlbWFnZXBhcmF0b25lYm9uZDozN1pfb2ZfJ10pOzAwMCx6aDrndGFua3lhcmRib3dsYnVzaDo1NlpKYXZhMzBweAp8fQolQzMlOjM0WmplZmZFWFBJY2FzaHZpc2Fnb2xmc25vd3poOulxdWVyLmNzc3NpY2ttZWF0bWluLmJpbmRkZWxsaGlyZXBpY3NyZW50OjM2WkhUVFAtMjAxZm90b3dvbGZFTkQgeGJveDo1NFpCT0RZZGljazsKfQpleGl0OjM1WnZhcnNiZWF0J30pO2RpZXQ5OTk7YW5uZX19PC9baV0uTGFuZ2ttwrJ3aXJldG95c2FkZHNzZWFsYWxleDsKCX1lY2hvbmluZS5vcmcwMDUpdG9ueWpld3NzYW5kbGVnc3Jvb2YwMDApIDIwMHdpbmVnZWFyZG9nc2Jvb3RnYXJ5Y3V0c3R5bGV0ZW1wdGlvbi54bWxjb2NrZ2FuZyQoJy41MHB4UGguRG1pc2NhbGFubG9hbmRlc2ttaWxlcnlhbnVuaXhkaXNjKTt9CmR1c3RjbGlwKS4KCjcwcHgtMjAwRFZEczddPjx0YXBlZGVtb2krKyl3YWdlZXVyb3BoaWxvcHRzaG9sZUZBUXNhc2luLTI2VGxhYnNwZXRzVVJMIGJ1bGtjb29rO30NCkhFQURbMF0pYWJicmp1YW4oMTk4bGVzaHR3aW48L2k+c29ueWd1eXNmdWNrcGlwZXwtCiEwMDIpbmRvd1sxXTtbXTsKTG9nIHNhbHQNCgkJYmFuZ3RyaW1iYXRoKXsNCjAwcHgKfSk7a2867GZlZXNhZD4NczovLyBbXTt0b2xscGx1Zygpewp7DQogLmpzJzIwMHBkdWFsYm9hdC5KUEcpOwp9cXVvdCk7CgonKTsKDQp9DTIwMTQyMDE1MjAxNjIwMTcyMDE4MjAxOTIwMjAyMDIxMjAyMjIwMjMyMDI0MjAyNTIwMjYyMDI3MjAyODIwMjkyMDMwMjAzMTIwMzIyMDMzMjAzNDIwMzUyMDM2MjAzNzIwMTMyMDEyMjAxMTIwMTAyMDA5MjAwODIwMDcyMDA2MjAwNTIwMDQyMDAzMjAwMjIwMDEyMDAwMTk5OTE5OTgxOTk3MTk5NjE5OTUxOTk0MTk5MzE5OTIxOTkxMTk5MDE5ODkxOTg4MTk4NzE5ODYxOTg1MTk4NDE5ODMxOTgyMTk4MTE5ODAxOTc5MTk3ODE5NzcxOTc2MTk3NTE5NzQxOTczMTk3MjE5NzExOTcwMTk2OTE5NjgxOTY3MTk2NjE5NjUxOTY0MTk2MzE5NjIxOTYxMTk2MDE5NTkxOTU4MTk1NzE5NTYxOTU1MTk1NDE5NTMxOTUyMTk1MTE5NTAxMDAwMTAyNDEzOTQwMDAwOTk5OWNvbW9tw6FzZXN0ZWVzdGFwZXJvdG9kb2hhY2VjYWRhYcOxb2JpZW5kw61hYXPDrXZpZGFjYXNvb3Ryb2Zvcm9zb2xvb3RyYWN1YWxkaWpvc2lkb2dyYW50aXBvdGVtYWRlYmVhbGdvcXXDqWVzdG9uYWRhdHJlc3BvY29jYXNhYmFqb3RvZGFzaW5vYWd1YXB1ZXN1bm9zYW50ZWRpY2VsdWlzZWxsYW1heW96b25hYW1vcnBpc29vYnJhY2xpY2VsbG9kaW9zaG9yYWNhc2nQt9Cw0L3QsNC+0LzRgNCw0YDRg9GC0LDQvdC10L/QvtC+0YLQuNC30L3QvtC00L7RgtC+0LbQtdC+0L3QuNGF0J3QsNC10LXQsdGL0LzRi9CS0YvRgdC+0LLRi9Cy0L7QndC+0L7QsdCf0L7Qu9C40L3QuNCg0KTQndC10JzRi9GC0YvQntC90LjQvNC00LDQl9Cw0JTQsNCd0YPQntCx0YLQtdCY0LfQtdC50L3Rg9C80LzQotGL0YPQttmB2YrYo9mG2YXYp9mF2LnZg9mE2KPZiNix2K/Zitin2YHZidmH2YjZhNmF2YTZg9in2YjZhNmH2KjYs9in2YTYpdmG2YfZitij2YrZgtiv2YfZhNir2YXYqNmH2YTZiNmE2YrYqNmE2KfZitio2YPYtNmK2KfZhdij2YXZhtiq2KjZitmE2YbYrdio2YfZhdmF2LTZiNi0Zmlyc3R2aWRlb2xpZ2h0d29ybGRtZWRpYXdoaXRlY2xvc2VibGFja3JpZ2h0c21hbGxib29rc3BsYWNlbXVzaWNmaWVsZG9yZGVycG9pbnR2YWx1ZWxldmVsdGFibGVib2FyZGhvdXNlZ3JvdXB3b3Jrc3llYXJzc3RhdGV0b2RheXdhdGVyc3RhcnRzdHlsZWRlYXRocG93ZXJwaG9uZW5pZ2h0ZXJyb3JpbnB1dGFib3V0dGVybXN0aXRsZXRvb2xzZXZlbnRsb2NhbHRpbWVzbGFyZ2V3b3Jkc2dhbWVzc2hvcnRzcGFjZWZvY3VzY2xlYXJtb2RlbGJsb2NrZ3VpZGVyYWRpb3NoYXJld29tZW5hZ2Fpbm1vbmV5aW1hZ2VuYW1lc3lvdW5nbGluZXNsYXRlcmNvbG9yZ3JlZW5mcm9udCZhbXA7d2F0Y2hmb3JjZXByaWNlcnVsZXNiZWdpbmFmdGVydmlzaXRpc3N1ZWFyZWFzYmVsb3dpbmRleHRvdGFsaG91cnNsYWJlbHByaW50cHJlc3NidWlsdGxpbmtzc3BlZWRzdHVkeXRyYWRlZm91bmRzZW5zZXVuZGVyc2hvd25mb3Jtc3JhbmdlYWRkZWRzdGlsbG1vdmVkdGFrZW5hYm92ZWZsYXNoZml4ZWRvZnRlbm90aGVydmlld3NjaGVja2xlZ2Fscml2ZXJpdGVtc3F1aWNrc2hhcGVodW1hbmV4aXN0Z29pbmdtb3ZpZXRoaXJkYmFzaWNwZWFjZXN0YWdld2lkdGhsb2dpbmlkZWFzd3JvdGVwYWdlc3VzZXJzZHJpdmVzdG9yZWJyZWFrc291dGh2b2ljZXNpdGVzbW9udGh3aGVyZWJ1aWxkd2hpY2hlYXJ0aGZvcnVtdGhyZWVzcG9ydHBhcnR5Q2xpY2tsb3dlcmxpdmVzY2xhc3NsYXllcmVudHJ5c3Rvcnl1c2FnZXNvdW5kY291cnR5b3VyIGJpcnRocG9wdXB0eXBlc2FwcGx5SW1hZ2ViZWluZ3VwcGVybm90ZXNldmVyeXNob3dzbWVhbnNleHRyYW1hdGNodHJhY2trbm93bmVhcmx5YmVnYW5zdXBlcnBhcGVybm9ydGhsZWFybmdpdmVubmFtZWRlbmRlZFRlcm1zcGFydHNHcm91cGJyYW5kdXNpbmd3b21hbmZhbHNlcmVhZHlhdWRpb3Rha2Vzd2hpbGUuY29tL2xpdmVkY2FzZXNkYWlseWNoaWxkZ3JlYXRqdWRnZXRob3NldW5pdHNuZXZlcmJyb2FkY29hc3Rjb3ZlcmFwcGxlZmlsZXNjeWNsZXNjZW5lcGxhbnNjbGlja3dyaXRlcXVlZW5waWVjZWVtYWlsZnJhbWVvbGRlcnBob3RvbGltaXRjYWNoZWNpdmlsc2NhbGVlbnRlcnRoZW1ldGhlcmV0b3VjaGJvdW5kcm95YWxhc2tlZHdob2xlc2luY2VzdG9jayBuYW1lZmFpdGhoZWFydGVtcHR5b2ZmZXJzY29wZW93bmVkbWlnaHRhbGJ1bXRoaW5rYmxvb2RhcnJheW1ham9ydHJ1c3RjYW5vbnVuaW9uY291bnR2YWxpZHN0b25lU3R5bGVMb2dpbmhhcHB5b2NjdXJsZWZ0OmZyZXNocXVpdGVmaWxtc2dyYWRlbmVlZHN1cmJhbmZpZ2h0YmFzaXNob3ZlcmF1dG87cm91dGUuaHRtbG1peGVkZmluYWxZb3VyIHNsaWRldG9waWNicm93bmFsb25lZHJhd25zcGxpdHJlYWNoUmlnaHRkYXRlc21hcmNocXVvdGVnb29kc0xpbmtzZG91YnRhc3luY3RodW1iYWxsb3djaGllZnlvdXRobm92ZWwxMHB4O3NlcnZldW50aWxoYW5kc0NoZWNrU3BhY2VxdWVyeWphbWVzZXF1YWx0d2ljZTAsMDAwU3RhcnRwYW5lbHNvbmdzcm91bmRlaWdodHNoaWZ0d29ydGhwb3N0c2xlYWRzd2Vla3Nhdm9pZHRoZXNlbWlsZXNwbGFuZXNtYXJ0YWxwaGFwbGFudG1hcmtzcmF0ZXNwbGF5c2NsYWltc2FsZXN0ZXh0c3N0YXJzd3Jvbmc8L2gzPnRoaW5nLm9yZy9tdWx0aWhlYXJkUG93ZXJzdGFuZHRva2Vuc29saWQodGhpc2JyaW5nc2hpcHNzdGFmZnRyaWVkY2FsbHNmdWxseWZhY3RzYWdlbnRUaGlzIC8vLS0+YWRtaW5lZ3lwdEV2ZW50MTVweDtFbWFpbHRydWUiY3Jvc3NzcGVudGJsb2dzYm94Ij5ub3RlZGxlYXZlY2hpbmFzaXplc2d1ZXN0PC9oND5yb2JvdGhlYXZ5dHJ1ZSxzZXZlbmdyYW5kY3JpbWVzaWduc2F3YXJlZGFuY2VwaGFzZT48IS0tZW5fVVMmIzM5OzIwMHB4X25hbWVsYXRpbmVuam95YWpheC5hdGlvbnNtaXRoVS5TLiBob2xkc3BldGVyaW5kaWFuYXYiPmNoYWluc2NvcmVjb21lc2RvaW5ncHJpb3JTaGFyZTE5OTBzcm9tYW5saXN0c2phcGFuZmFsbHN0cmlhbG93bmVyYWdyZWU8L2gyPmFidXNlYWxlcnRvcGVyYSItLy9XY2FyZHNoaWxsc3RlYW1zUGhvdG90cnV0aGNsZWFuLnBocD9zYWludG1ldGFsbG91aXNtZWFudHByb29mYnJpZWZyb3ciPmdlbnJldHJ1Y2tsb29rc1ZhbHVlRnJhbWUubmV0Ly0tPgo8dHJ5IHsKdmFyIG1ha2VzY29zdHNwbGFpbmFkdWx0cXVlc3R0cmFpbmxhYm9yaGVscHNjYXVzZW1hZ2ljbW90b3J0aGVpcjI1MHB4bGVhc3RzdGVwc0NvdW50Y291bGRnbGFzc3NpZGVzZnVuZHNob3RlbGF3YXJkbW91dGhtb3Zlc3BhcmlzZ2l2ZXNkdXRjaHRleGFzZnJ1aXRudWxsLHx8W107dG9wIj4KPCEtLVBPU1Qib2NlYW48YnIvPmZsb29yc3BlYWtkZXB0aCBzaXplYmFua3NjYXRjaGNoYXJ0MjBweDthbGlnbmRlYWxzd291bGQ1MHB4O3VybD0icGFya3Ntb3VzZU1vc3QgLi4uPC9hbW9uZ2JyYWluYm9keSBub25lO2Jhc2VkY2FycnlkcmFmdHJlZmVycGFnZV9ob21lLm1ldGVyZGVsYXlkcmVhbXByb3Zlam9pbnQ8L3RyPmRydWdzPCEtLSBhcHJpbGlkZWFsYWxsZW5leGFjdGZvcnRoY29kZXNsb2dpY1ZpZXcgc2VlbXNibGFua3BvcnRzICgyMDBzYXZlZF9saW5rZ29hbHNncmFudGdyZWVraG9tZXNyaW5nc3JhdGVkMzBweDt3aG9zZXBhcnNlKCk7IiBCbG9ja2xpbnV4am9uZXNwaXhlbCcpOyI+KTtpZigtbGVmdGRhdmlkaG9yc2VGb2N1c3JhaXNlYm94ZXNUcmFja2VtZW50PC9lbT5iYXIiPi5zcmM9dG93ZXJhbHQ9ImNhYmxlaGVucnkyNHB4O3NldHVwaXRhbHlzaGFycG1pbm9ydGFzdGV3YW50c3RoaXMucmVzZXR3aGVlbGdpcmxzL2Nzcy8xMDAlO2NsdWJzc3R1ZmZiaWJsZXZvdGVzIDEwMDBrb3JlYX0pOw0KYmFuZHNxdWV1ZT0ge307ODBweDtja2luZ3sNCgkJYWhlYWRjbG9ja2lyaXNobGlrZSByYXRpb3N0YXRzRm9ybSJ5YWhvbylbMF07QWJvdXRmaW5kczwvaDE+ZGVidWd0YXNrc1VSTCA9Y2VsbHN9KSgpOzEycHg7cHJpbWV0ZWxsc3R1cm5zMHg2MDAuanBnInNwYWluYmVhY2h0YXhlc21pY3JvYW5nZWwtLT48L2dpZnRzc3RldmUtbGlua2JvZHkufSk7Cgltb3VudCAoMTk5RkFRPC9yb2dlcmZyYW5rQ2xhc3MyOHB4O2ZlZWRzPGgxPjxzY290dHRlc3RzMjJweDtkcmluaykgfHwgbGV3aXNzaGFsbCMwMzk7IGZvciBsb3ZlZHdhc3RlMDBweDtqYTrjgnNpbW9uPGZvbnRyZXBseW1lZXRzdW50ZXJjaGVhcHRpZ2h0QnJhbmQpICE9IGRyZXNzY2xpcHNyb29tc29ua2V5bW9iaWxtYWluLk5hbWUgcGxhdGVmdW5ueXRyZWVzY29tLyIxLmpwZ3dtb2RlcGFyYW1TVEFSVGxlZnQgaWRkZW4sIDIwMSk7Cn0KZm9ybS52aXJ1c2NoYWlydHJhbnN3b3JzdFBhZ2VzaXRpb25wYXRjaDwhLS0Kby1jYWNmaXJtc3RvdXJzLDAwMCBhc2lhbmkrKyl7YWRvYmUnKVswXWlkPTEwYm90aDttZW51IC4yLm1pLnBuZyJrZXZpbmNvYWNoQ2hpbGRicnVjZTIuanBnVVJMKSsuanBnfHN1aXRlc2xpY2VoYXJyeTEyMCIgc3dlZXR0cj4NCm5hbWU9ZGllZ29wYWdlIHN3aXNzLS0+CgojZmZmOyI+TG9nLmNvbSJ0cmVhdHNoZWV0KSAmJiAxNHB4O3NsZWVwbnRlbnRmaWxlZGphOuODaWQ9ImNOYW1lIndvcnNlc2hvdHMtYm94LWRlbHRhCiZsdDtiZWFyczo0OFo8ZGF0YS1ydXJhbDwvYT4gc3BlbmRiYWtlcnNob3BzPSAiIjtwaHAiPmN0aW9uMTNweDticmlhbmhlbGxvc2l6ZT1vPSUyRiBqb2lubWF5YmU8aW1nIGltZyI+LCBmanNpbWciICIpWzBdTVRvcEJUeXBlIm5ld2x5RGFuc2tjemVjaHRyYWlsa25vd3M8L2g1PmZhcSI+emgtY24xMCk7Ci0xIik7dHlwZT1ibHVlc3RydWx5ZGF2aXMuanMnOz4NCjwhc3RlZWwgeW91IGgyPg0KZm9ybSBqZXN1czEwMCUgbWVudS4NCgkNCndhbGVzcmlza3N1bWVudGRkaW5nYi1saWt0ZWFjaGdpZiIgdmVnYXNkYW5za2Vlc3Rpc2hxaXBzdW9taXNvYnJlZGVzZGVlbnRyZXRvZG9zcHVlZGVhw7Fvc2VzdMOhdGllbmVoYXN0YW90cm9zcGFydGVkb25kZW51ZXZvaGFjZXJmb3JtYW1pc21vbWVqb3JtdW5kb2FxdcOtZMOtYXNzw7Nsb2F5dWRhZmVjaGF0b2Rhc3RhbnRvbWVub3NkYXRvc290cmFzc2l0aW9tdWNob2Fob3JhbHVnYXJtYXlvcmVzdG9zaG9yYXN0ZW5lcmFudGVzZm90b3Nlc3Rhc3Bhw61zbnVldmFzYWx1ZGZvcm9zbWVkaW9xdWllbm1lc2VzcG9kZXJjaGlsZXNlcsOhdmVjZXNkZWNpcmpvc8OpZXN0YXJ2ZW50YWdydXBvaGVjaG9lbGxvc3RlbmdvYW1pZ29jb3Nhc25pdmVsZ2VudGVtaXNtYWFpcmVzanVsaW90ZW1hc2hhY2lhZmF2b3JqdW5pb2xpYnJlcHVudG9idWVub2F1dG9yYWJyaWxidWVuYXRleHRvbWFyem9zYWJlcmxpc3RhbHVlZ29jw7Ntb2VuZXJvanVlZ29wZXLDumhhYmVyZXN0b3ludW5jYW11amVydmFsb3JmdWVyYWxpYnJvZ3VzdGFpZ3VhbHZvdG9zY2Fzb3NndcOtYXB1ZWRvc29tb3Nhdmlzb3VzdGVkZGViZW5ub2NoZWJ1c2NhZmFsdGFldXJvc3NlcmllZGljaG9jdXJzb2NsYXZlY2FzYXNsZcOzbnBsYXpvbGFyZ29vYnJhc3Zpc3RhYXBveW9qdW50b3RyYXRhdmlzdG9jcmVhcmNhbXBvaGVtb3NjaW5jb2NhcmdvcGlzb3NvcmRlbmhhY2Vuw6FyZWFkaXNjb3BlZHJvY2VyY2FwdWVkYXBhcGVsbWVub3LDunRpbGNsYXJvam9yZ2VjYWxsZXBvbmVydGFyZGVuYWRpZW1hcmNhc2lndWVlbGxhc3NpZ2xvY29jaGVtb3Rvc21hZHJlY2xhc2VyZXN0b25pw7FvcXVlZGFwYXNhcmJhbmNvaGlqb3N2aWFqZXBhYmxvw6lzdGV2aWVuZXJlaW5vZGVqYXJmb25kb2NhbmFsbm9ydGVsZXRyYWNhdXNhdG9tYXJtYW5vc2x1bmVzYXV0b3N2aWxsYXZlbmRvcGVzYXJ0aXBvc3RlbmdhbWFyY29sbGV2YXBhZHJldW5pZG92YW1vc3pvbmFzYW1ib3NiYW5kYW1hcmlhYWJ1c29tdWNoYXN1YmlycmlvamF2aXZpcmdyYWRvY2hpY2FhbGzDrWpvdmVuZGljaGFlc3RhbnRhbGVzc2FsaXJzdWVsb3Blc29zZmluZXNsbGFtYWJ1c2Nvw6lzdGFsbGVnYW5lZ3JvcGxhemFodW1vcnBhZ2FyanVudGFkb2JsZWlzbGFzYm9sc2FiYcOxb2hhYmxhbHVjaGHDgXJlYWRpY2VuanVnYXJub3Rhc3ZhbGxlYWxsw6FjYXJnYWRvbG9yYWJham9lc3TDqWd1c3RvbWVudGVtYXJpb2Zpcm1hY29zdG9maWNoYXBsYXRhaG9nYXJhcnRlc2xleWVzYXF1ZWxtdXNlb2Jhc2VzcG9jb3NtaXRhZGNpZWxvY2hpY29taWVkb2dhbmFyc2FudG9ldGFwYWRlYmVzcGxheWFyZWRlc3NpZXRlY29ydGVjb3JlYWR1ZGFzZGVzZW92aWVqb2Rlc2VhYWd1YXMmcXVvdDtkb21haW5jb21tb25zdGF0dXNldmVudHNtYXN0ZXJzeXN0ZW1hY3Rpb25iYW5uZXJyZW1vdmVzY3JvbGx1cGRhdGVnbG9iYWxtZWRpdW1maWx0ZXJudW1iZXJjaGFuZ2VyZXN1bHRwdWJsaWNzY3JlZW5jaG9vc2Vub3JtYWx0cmF2ZWxpc3N1ZXNzb3VyY2V0YXJnZXRzcHJpbmdtb2R1bGVtb2JpbGVzd2l0Y2hwaG90b3Nib3JkZXJyZWdpb25pdHNlbGZzb2NpYWxhY3RpdmVjb2x1bW5yZWNvcmRmb2xsb3d0aXRsZT5laXRoZXJsZW5ndGhmYW1pbHlmcmllbmRsYXlvdXRhdXRob3JjcmVhdGVyZXZpZXdzdW1tZXJzZXJ2ZXJwbGF5ZWRwbGF5ZXJleHBhbmRwb2xpY3lmb3JtYXRkb3VibGVwb2ludHNzZXJpZXNwZXJzb25saXZpbmdkZXNpZ25tb250aHNmb3JjZXN1bmlxdWV3ZWlnaHRwZW9wbGVlbmVyZ3luYXR1cmVzZWFyY2hmaWd1cmVoYXZpbmdjdXN0b21vZmZzZXRsZXR0ZXJ3aW5kb3dzdWJtaXRyZW5kZXJncm91cHN1cGxvYWRoZWFsdGhtZXRob2R2aWRlb3NzY2hvb2xmdXR1cmVzaGFkb3dkZWJhdGV2YWx1ZXNPYmplY3RvdGhlcnNyaWdodHNsZWFndWVjaHJvbWVzaW1wbGVub3RpY2VzaGFyZWRlbmRpbmdzZWFzb25yZXBvcnRvbmxpbmVzcXVhcmVidXR0b25pbWFnZXNlbmFibGVtb3ZpbmdsYXRlc3R3aW50ZXJGcmFuY2VwZXJpb2RzdHJvbmdyZXBlYXRMb25kb25kZXRhaWxmb3JtZWRkZW1hbmRzZWN1cmVwYXNzZWR0b2dnbGVwbGFjZXNkZXZpY2VzdGF0aWNjaXRpZXNzdHJlYW15ZWxsb3dhdHRhY2tzdHJlZXRmbGlnaHRoaWRkZW5pbmZvIj5vcGVuZWR1c2VmdWx2YWxsZXljYXVzZXNsZWFkZXJzZWNyZXRzZWNvbmRkYW1hZ2VzcG9ydHNleGNlcHRyYXRpbmdzaWduZWR0aGluZ3NlZmZlY3RmaWVsZHNzdGF0ZXNvZmZpY2V2aXN1YWxlZGl0b3J2b2x1bWVSZXBvcnRtdXNldW1tb3ZpZXNwYXJlbnRhY2Nlc3Ntb3N0bHltb3RoZXIiIGlkPSJtYXJrZXRncm91bmRjaGFuY2VzdXJ2ZXliZWZvcmVzeW1ib2xtb21lbnRzcGVlY2htb3Rpb25pbnNpZGVtYXR0ZXJDZW50ZXJvYmplY3RleGlzdHNtaWRkbGVFdXJvcGVncm93dGhsZWdhY3ltYW5uZXJlbm91Z2hjYXJlZXJhbnN3ZXJvcmlnaW5wb3J0YWxjbGllbnRzZWxlY3RyYW5kb21jbG9zZWR0b3BpY3Njb21pbmdmYXRoZXJvcHRpb25zaW1wbHlyYWlzZWRlc2NhcGVjaG9zZW5jaHVyY2hkZWZpbmVyZWFzb25jb3JuZXJvdXRwdXRtZW1vcnlpZnJhbWVwb2xpY2Vtb2RlbHNOdW1iZXJkdXJpbmdvZmZlcnNzdHlsZXNraWxsZWRsaXN0ZWRjYWxsZWRzaWx2ZXJtYXJnaW5kZWxldGViZXR0ZXJicm93c2VsaW1pdHNHbG9iYWxzaW5nbGV3aWRnZXRjZW50ZXJidWRnZXRub3dyYXBjcmVkaXRjbGFpbXNlbmdpbmVzYWZldHljaG9pY2VzcGlyaXQtc3R5bGVzcHJlYWRtYWtpbmduZWVkZWRydXNzaWFwbGVhc2VleHRlbnRTY3JpcHRicm9rZW5hbGxvd3NjaGFyZ2VkaXZpZGVmYWN0b3JtZW1iZXItYmFzZWR0aGVvcnljb25maWdhcm91bmR3b3JrZWRoZWxwZWRDaHVyY2hpbXBhY3RzaG91bGRhbHdheXNsb2dvIiBib3R0b21saXN0Ij4pe3ZhciBwcmVmaXhvcmFuZ2VIZWFkZXIucHVzaChjb3VwbGVnYXJkZW5icmlkZ2VsYXVuY2hSZXZpZXd0YWtpbmd2aXNpb25saXR0bGVkYXRpbmdCdXR0b25iZWF1dHl0aGVtZXNmb3Jnb3RTZWFyY2hhbmNob3JhbG1vc3Rsb2FkZWRDaGFuZ2VyZXR1cm5zdHJpbmdyZWxvYWRNb2JpbGVpbmNvbWVzdXBwbHlTb3VyY2VvcmRlcnN2aWV3ZWQmbmJzcDtjb3Vyc2VBYm91dCBpc2xhbmQ8aHRtbCBjb29raWVuYW1lPSJhbWF6b25tb2Rlcm5hZHZpY2VpbjwvYT46IFRoZSBkaWFsb2dob3VzZXNCRUdJTiBNZXhpY29zdGFydHNjZW50cmVoZWlnaHRhZGRpbmdJc2xhbmRhc3NldHNFbXBpcmVTY2hvb2xlZmZvcnRkaXJlY3RuZWFybHltYW51YWxTZWxlY3QuCgpPbmVqb2luZWRtZW51Ij5QaGlsaXBhd2FyZHNoYW5kbGVpbXBvcnRPZmZpY2VyZWdhcmRza2lsbHNuYXRpb25TcG9ydHNkZWdyZWV3ZWVrbHkgKGUuZy5iZWhpbmRkb2N0b3Jsb2dnZWR1bml0ZWQ8L2I+PC9iZWdpbnNwbGFudHNhc3Npc3RhcnRpc3Rpc3N1ZWQzMDBweHxjYW5hZGFhZ2VuY3lzY2hlbWVyZW1haW5CcmF6aWxzYW1wbGVsb2dvIj5iZXlvbmQtc2NhbGVhY2NlcHRzZXJ2ZWRtYXJpbmVGb290ZXJjYW1lcmE8L2gxPgpfZm9ybSJsZWF2ZXNzdHJlc3MiIC8+DQouZ2lmIiBvbmxvYWRsb2FkZXJPeGZvcmRzaXN0ZXJzdXJ2aXZsaXN0ZW5mZW1hbGVEZXNpZ25zaXplPSJhcHBlYWx0ZXh0Ij5sZXZlbHN0aGFua3NoaWdoZXJmb3JjZWRhbmltYWxhbnlvbmVBZnJpY2FhZ3JlZWRyZWNlbnRQZW9wbGU8YnIgLz53b25kZXJwcmljZXN0dXJuZWR8fCB7fTttYWluIj5pbmxpbmVzdW5kYXl3cmFwIj5mYWlsZWRjZW5zdXNtaW51dGViZWFjb25xdW90ZXMxNTBweHxlc3RhdGVyZW1vdGVlbWFpbCJsaW5rZWRyaWdodDtzaWduYWxmb3JtYWwxLmh0bWxzaWdudXBwcmluY2VmbG9hdDoucG5nIiBmb3J1bS5BY2Nlc3NwYXBlcnNzb3VuZHNleHRlbmRIZWlnaHRzbGlkZXJVVEYtOCImYW1wOyBCZWZvcmUuIFdpdGhzdHVkaW9vd25lcnNtYW5hZ2Vwcm9maXRqUXVlcnlhbm51YWxwYXJhbXNib3VnaHRmYW1vdXNnb29nbGVsb25nZXJpKyspIHtpc3JhZWxzYXlpbmdkZWNpZGVob21lIj5oZWFkZXJlbnN1cmVicmFuY2hwaWVjZXNibG9jaztzdGF0ZWR0b3AiPjxyYWNpbmdyZXNpemUtLSZndDtwYWNpdHlzZXh1YWxidXJlYXUuanBnIiAxMCwwMDBvYnRhaW50aXRsZXNhbW91bnQsIEluYy5jb21lZHltZW51IiBseXJpY3N0b2RheS5pbmRlZWRjb3VudHlfbG9nby5GYW1pbHlsb29rZWRNYXJrZXRsc2UgaWZQbGF5ZXJ0dXJrZXkpO3ZhciBmb3Jlc3RnaXZpbmdlcnJvcnNEb21haW59ZWxzZXtpbnNlcnRCbG9nPC9mb290ZXJsb2dpbi5mYXN0ZXJhZ2VudHM8Ym9keSAxMHB4IDBwcmFnbWFmcmlkYXlqdW5pb3Jkb2xsYXJwbGFjZWRjb3ZlcnNwbHVnaW41LDAwMCBwYWdlIj5ib3N0b24udGVzdChhdmF0YXJ0ZXN0ZWRfY291bnRmb3J1bXNzY2hlbWFpbmRleCxmaWxsZWRzaGFyZXNyZWFkZXJhbGVydChhcHBlYXJTdWJtaXRsaW5lIj5ib2R5Ij4KKiBUaGVUaG91Z2hzZWVpbmdqZXJzZXlOZXdzPC92ZXJpZnlleHBlcnRpbmp1cnl3aWR0aD1Db29raWVTVEFSVCBhY3Jvc3NfaW1hZ2V0aHJlYWRuYXRpdmVwb2NrZXRib3giPgpTeXN0ZW0gRGF2aWRjYW5jZXJ0YWJsZXNwcm92ZWRBcHJpbCByZWFsbHlkcml2ZXJpdGVtIj5tb3JlIj5ib2FyZHNjb2xvcnNjYW1wdXNmaXJzdCB8fCBbXTttZWRpYS5ndWl0YXJmaW5pc2h3aWR0aDpzaG93ZWRPdGhlciAucGhwIiBhc3N1bWVsYXllcnN3aWxzb25zdG9yZXNyZWxpZWZzd2VkZW5DdXN0b21lYXNpbHkgeW91ciBTdHJpbmcKCldoaWx0YXlsb3JjbGVhcjpyZXNvcnRmcmVuY2h0aG91Z2giKSArICI8Ym9keT5idXlpbmdicmFuZHNNZW1iZXJuYW1lIj5vcHBpbmdzZWN0b3I1cHg7Ij52c3BhY2Vwb3N0ZXJtYWpvciBjb2ZmZWVtYXJ0aW5tYXR1cmVoYXBwZW48L25hdj5rYW5zYXNsaW5rIj5JbWFnZXM9ZmFsc2V3aGlsZSBoc3BhY2UwJmFtcDsgCgpJbiAgcG93ZXJQb2xza2ktY29sb3Jqb3JkYW5Cb3R0b21TdGFydCAtY291bnQyLmh0bWxuZXdzIj4wMS5qcGdPbmxpbmUtcmlnaHRtaWxsZXJzZW5pb3JJU0JOIDAwLDAwMCBndWlkZXN2YWx1ZSllY3Rpb25yZXBhaXIueG1sIiAgcmlnaHRzLmh0bWwtYmxvY2tyZWdFeHA6aG92ZXJ3aXRoaW52aXJnaW5waG9uZXM8L3RyPg11c2luZyAKCXZhciA+Jyk7Cgk8L3RkPgo8L3RyPgpiYWhhc2FicmFzaWxnYWxlZ29tYWd5YXJwb2xza2lzcnBza2nYsdiv2YjkuK3mlofnroDkvZPnuYHpq5Tkv6Hmga/kuK3lm73miJHku6zkuIDkuKrlhazlj7jnrqHnkIborrrlnZvlj6/ku6XmnI3liqHml7bpl7TkuKrkurrkuqflk4Hoh6rlt7HkvIHkuJrmn6XnnIvlt6XkvZzogZTns7vmsqHmnInnvZHnq5nmiYDmnInor4TorrrkuK3lv4Pmlofnq6DnlKjmiLfpppbpobXkvZzogIXmioDmnK/pl67popjnm7jlhbPkuIvovb3mkJzntKLkvb/nlKjova/ku7blnKjnur/kuLvpopjotYTmlpnop4bpopHlm57lpI3ms6jlhoznvZHnu5zmlLbol4/lhoXlrrnmjqjojZDluILlnLrmtojmga/nqbrpl7Tlj5HluIPku4DkuYjlpb3lj4vnlJ/mtLvlm77niYflj5HlsZXlpoLmnpzmiYvmnLrmlrDpl7vmnIDmlrDmlrnlvI/ljJfkuqzmj5DkvpvlhbPkuo7mm7TlpJrov5nkuKrns7vnu5/nn6XpgZPmuLjmiI/lub/lkYrlhbbku5blj5HooajlronlhajnrKzkuIDkvJrlkZjov5vooYzngrnlh7vniYjmnYPnlLXlrZDkuJbnlYzorr7orqHlhY3otLnmlZnogrLliqDlhaXmtLvliqjku5bku6zllYblk4HljZrlrqLnjrDlnKjkuIrmtbflpoLkvZXlt7Lnu4/nlZnoqIDor6bnu4bnpL7ljLrnmbvlvZXmnKznq5npnIDopoHku7fmoLzmlK/mjIHlm73pmYXpk77mjqXlm73lrrblu7rorr7mnIvlj4vpmIXor7vms5XlvovkvY3nva7nu4/mtY7pgInmi6nov5nmoLflvZPliY3liIbnsbvmjpLooYzlm6DkuLrkuqTmmJPmnIDlkI7pn7PkuZDkuI3og73pgJrov4fooYzkuJrnp5HmioDlj6/og73orr7lpIflkIjkvZzlpKflrrbnpL7kvJrnoJTnqbbkuJPkuJrlhajpg6jpobnnm67ov5nph4zov5jmmK/lvIDlp4vmg4XlhrXnlLXohJHmlofku7blk4HniYzluK7liqnmlofljJbotYTmupDlpKflrablrabkuaDlnLDlnYDmtY/op4jmipXotYTlt6XnqIvopoHmsYLmgI7kuYjml7blgJnlip/og73kuLvopoHnm67liY3otYTorq/ln47luILmlrnms5XnlLXlvbHmi5vogZjlo7DmmI7ku7vkvZXlgaXlurfmlbDmja7nvo7lm73msb3ovabku4vnu43kvYbmmK/kuqTmtYHnlJ/kuqfmiYDku6XnlLXor53mmL7npLrkuIDkupvljZXkvY3kurrlkZjliIbmnpDlnLDlm77ml4XmuLjlt6XlhbflrabnlJ/ns7vliJfnvZHlj4vluJblrZDlr4bnoIHpopHpgZPmjqfliLblnLDljLrln7rmnKzlhajlm73nvZHkuIrph43opoHnrKzkuozllpzmrKLov5vlhaXlj4vmg4Xov5nkupvogIPor5Xlj5HnjrDln7norq3ku6XkuIrmlL/lupzmiJDkuLrnjq/looPpppnmuK/lkIzml7blqLHkuZDlj5HpgIHkuIDlrprlvIDlj5HkvZzlk4HmoIflh4bmrKLov47op6PlhrPlnLDmlrnkuIDkuIvku6Xlj4rotKPku7vmiJbogIXlrqLmiLfku6Pooajnp6/liIblpbPkurrmlbDnoIHplIDllK7lh7rnjrDnprvnur/lupTnlKjliJfooajkuI3lkIznvJbovpHnu5/orqHmn6Xor6LkuI3opoHmnInlhbPmnLrmnoTlvojlpJrmkq3mlL7nu4Tnu4fmlL/nrZbnm7TmjqXog73lipvmnaXmupDmmYLplpPnnIvliLDng63pl6jlhbPplK7kuJPljLrpnZ7luLjoi7Hor63nmb7luqbluIzmnJvnvo7lpbPmr5TovoPnn6Xor4bop4Tlrprlu7rorq7pg6jpl6jmhI/op4Hnsr7lvanml6XmnKzmj5Dpq5jlj5HoqIDmlrnpnaLln7rph5HlpITnkIbmnYPpmZDlvbHniYfpk7booYzov5jmnInliIbkuqvnianlk4Hnu4/okKXmt7vliqDkuJPlrrbov5nnp43or53popjotbfmnaXkuJrliqHlhazlkYrorrDlvZXnroDku4votKjph4/nlLfkurrlvbHlk43lvJXnlKjmiqXlkYrpg6jliIblv6vpgJ/lkqjor6Lml7blsJrms6jmhI/nlLPor7flrabmoKHlupTor6Xljoblj7Llj6rmmK/ov5Tlm57otK3kubDlkI3np7DkuLrkuobmiJDlip/or7TmmI7kvpvlupTlranlrZDkuJPpopjnqIvluo/kuIDoiKzmnIPlk6Hlj6rmnInlhbblroPkv53miqTogIzkuJTku4rlpKnnqpflj6PliqjmgIHnirbmgIHnibnliKvorqTkuLrlv4Xpobvmm7TmlrDlsI/or7TmiJHlgJHkvZzkuLrlqpLkvZPljIXmi6zpgqPkuYjkuIDmoLflm73lhoXmmK/lkKbmoLnmja7nlLXop4blrabpmaLlhbfmnInov4fnqIvnlLHkuo7kurrmiY3lh7rmnaXkuI3ov4fmraPlnKjmmI7mmJ/mlYXkuovlhbPns7vmoIfpopjllYbliqHovpPlhaXkuIDnm7Tln7rnoYDmlZnlrabkuobop6Plu7rnrZHnu5PmnpzlhajnkIPpgJrnn6XorqHliJLlr7nkuo7oibrmnK/nm7jlhozlj5HnlJ/nnJ/nmoTlu7rnq4vnrYnnuqfnsbvlnovnu4/pqozlrp7njrDliLbkvZzmnaXoh6rmoIfnrb7ku6XkuIvljp/liJvml6Dms5XlhbbkuK3lgIvkurrkuIDliIfmjIfljZflhbPpl63pm4blm6LnrKzkuInlhbPms6jlm6DmraTnhafniYfmt7HlnLPllYbkuJrlub/lt57ml6XmnJ/pq5jnuqfmnIDov5Hnu7zlkIjooajnpLrkuJPovpHooYzkuLrkuqTpgJror4Tku7fop4nlvpfnsr7ljY7lrrbluq3lrozmiJDmhJ/op4nlronoo4XlvpfliLDpgq7ku7bliLbluqbpo5/lk4Homb3nhLbovazovb3miqXku7forrDogIXmlrnmoYjooYzmlL/kurrmsJHnlKjlk4HkuJzopb/mj5Dlh7rphZLlupfnhLblkI7ku5jmrL7ng63ngrnku6XliY3lrozlhajlj5HluJborr7nva7pooblr7zlt6XkuJrljLvpmaLnnIvnnIvnu4/lhbjljp/lm6DlubPlj7DlkITnp43lop7liqDmnZDmlpnmlrDlop7kuYvlkI7ogYzkuJrmlYjmnpzku4rlubTorrrmlofmiJHlm73lkYror4nniYjkuLvkv67mlLnlj4LkuI7miZPljbDlv6vkuZDmnLrmorDop4LngrnlrZjlnKjnsr7npZ7ojrflvpfliKnnlKjnu6fnu63kvaDku6zov5nkuYjmqKHlvI/or63oqIDog73lpJ/pm4XomY7mk43kvZzpo47moLzkuIDotbfnp5HlrabkvZPogrLnn63kv6HmnaHku7bmsrvnlpfov5DliqjkuqfkuJrkvJrorq7lr7zoiKrlhYjnlJ/ogZTnm5/lj6/mmK/llY/poYznu5PmnoTkvZznlKjosIPmn6Xos4fmlpnoh6rliqjotJ/otKPlhpzkuJrorr/pl67lrp7mlr3mjqXlj5forqjorrrpgqPkuKrlj43ppojliqDlvLrlpbPmgKfojIPlm7TmnI3li5nkvJHpl7Lku4rml6XlrqLmnI3op4DnnIvlj4LliqDnmoTor53kuIDngrnkv53or4Hlm77kuabmnInmlYjmtYvor5Xnp7vliqjmiY3og73lhrPlrprogqHnpajkuI3mlq3pnIDmsYLkuI3lvpflip7ms5XkuYvpl7Tph4fnlKjokKXplIDmipXor4nnm67moIfniLHmg4XmkYTlvbHmnInkupvopIfoo73mloflrabmnLrkvJrmlbDlrZfoo4Xkv67otK3nianlhpzmnZHlhajpnaLnsr7lk4Hlhbblrp7kuovmg4XmsLTlubPmj5DnpLrkuIrluILosKLosKLmma7pgJrmlZnluIjkuIrkvKDnsbvliKvmrYzmm7Lmi6XmnInliJvmlrDphY3ku7blj6ropoHml7bku6Pos4foqIrovr7liLDkurrnlJ/orqLpmIXogIHluIjlsZXnpLrlv4PnkIbotLTlrZDntrLnq5nkuLvpoYzoh6rnhLbnuqfliKvnroDljZXmlLnpnanpgqPkupvmnaXor7TmiZPlvIDku6PnoIHliKDpmaTor4HliLjoioLnm67ph43ngrnmrKHmlbjlpJrlsJHop4TliJLotYTph5Hmib7liLDku6XlkI7lpKflhajkuLvpobXmnIDkvbPlm57nrZTlpKnkuIvkv53pmpznjrDku6Pmo4Dmn6XmipXnpajlsI/ml7bmspLmnInmraPluLjnlJroh7Pku6PnkIbnm67lvZXlhazlvIDlpI3liLbph5Hono3lubjnpo/niYjmnKzlvaLmiJDlh4blpIfooYzmg4Xlm57liLDmgJ3mg7PmgI7moLfljY/orq7orqTor4HmnIDlpb3kuqfnlJ/mjInnhafmnI3oo4Xlub/kuJzliqjmvKvph4fotK3mlrDmiYvnu4Tlm77pnaLmnb/lj4LogIPmlL/msrvlrrnmmJPlpKnlnLDliqrlipvkurrku6zljYfnuqfpgJ/luqbkurrnianosIPmlbTmtYHooYzpgKDmiJDmloflrZfpn6nlm73otLjmmJPlvIDlsZXnm7jpl5zooajnjrDlvbHop4blpoLmraTnvo7lrrnlpKflsI/miqXpgZPmnaHmrL7lv4Pmg4XorrjlpJrms5Xop4TlrrblsYXkuablupfov57mjqXnq4vljbPkuL7miqXmioDlt6flpaXov5DnmbvlhaXku6XmnaXnkIborrrkuovku7boh6rnlLHkuK3ljY7lip7lhazlpojlpojnnJ/mraPkuI3plJnlhajmloflkIjlkIzku7flgLzliKvkurrnm5HnnaPlhbfkvZPkuJbnuqrlm6LpmJ/liJvkuJrmib/mi4Xlop7plb/mnInkurrkv53mjIHllYblrrbnu7Tkv67lj7Dmub7lt6blj7PogqHku73nrZTmoYjlrp7pmYXnlLXkv6Hnu4/nkIbnlJ/lkb3lrqPkvKDku7vliqHmraPlvI/nibnoibLkuIvmnaXljY/kvJrlj6rog73lvZPnhLbph43mlrDlhaflrrnmjIflr7zov5DooYzml6Xlv5fos6PlrrbotoXov4flnJ/lnLDmtZnmsZ/mlK/ku5jmjqjlh7rnq5nplb/mna3lt57miafooYzliLbpgKDkuYvkuIDmjqjlub/njrDlnLrmj4/ov7Dlj5jljJbkvKDnu5/mrYzmiYvkv53pmanor77nqIvljLvnlpfnu4/ov4fov4fljrvkuYvliY3mlLblhaXlubTluqbmnYLlv5fnvo7kuL3mnIDpq5jnmbvpmYbmnKrmnaXliqDlt6XlhY3otKPmlZnnqIvniYjlnZfouqvkvZPph43luoblh7rllK7miJDmnKzlvaLlvI/lnJ/osYblh7rlg7nkuJzmlrnpgq7nrrHljZfkuqzmsYLogYzlj5blvpfogYzkvY3nm7jkv6HpobXpnaLliIbpkp/nvZHpobXnoa7lrprlm77kvovnvZHlnYDnp6/mnoHplJnor6/nm67nmoTlrp3otJ3mnLrlhbPpo47pmanmjojmnYPnl4Xmr5LlrqDnianpmaTkuoboqZXoq5bnlr7nl4Xlj4rml7bmsYLotK3nq5nngrnlhL/nq6Xmr4/lpKnkuK3lpK7orqTor4bmr4/kuKrlpKnmtKXlrZfkvZPlj7DngaPnu7TmiqTmnKzpobXkuKrmgKflrpjmlrnluLjop4Hnm7jmnLrmiJjnlaXlupTlvZPlvovluIjmlrnkvr/moKHlm63ogqHluILmiL/lsYvmoI/nm67lkZjlt6Xlr7zoh7TnqoHnhLbpgZPlhbfmnKznvZHnu5PlkIjmoaPmoYjlirPliqjlj6blpJbnvo7lhYPlvJXotbfmlLnlj5jnrKzlm5vkvJrorqHoqqrmmI7pmpDnp4Hlrp3lrp3op4TojIPmtojotLnlhbHlkIzlv5jorrDkvZPns7vluKbmnaXlkI3lrZfnmbzooajlvIDmlL7liqDnm5/lj5fliLDkuozmiYvlpKfph4/miJDkurrmlbDph4/lhbHkuqvljLrln5/lpbPlranljp/liJnmiYDlnKjnu5PmnZ/pgJrkv6HotoXnuqfphY3nva7lvZPml7bkvJjnp4DmgKfmhJ/miL/kuqfpgYrmiLLlh7rlj6Pmj5DkuqTlsLHkuJrkv53lgaXnqIvluqblj4LmlbDkuovkuJrmlbTkuKrlsbHkuJzmg4XmhJ/nibnmrorliIbpoZ7mkJzlsIvlsZ7kuo7pl6jmiLfotKLliqHlo7Dpn7Plj4rlhbbotKLnu4/lnZrmjIHlubLpg6jmiJDnq4vliKnnm4rogIPomZHmiJDpg73ljIXoo4XnlKjmiLbmr5TotZvmlofmmI7mi5vllYblrozmlbTnnJ/mmK/nnLznnZvkvJnkvLTlqIHmnJvpoobln5/ljavnlJ/kvJjmg6Doq5blo4flhazlhbHoia/lpb3lhYXliIbnrKblkIjpmYTku7bnibnngrnkuI3lj6/oi7HmlofotYTkuqfmoLnmnKzmmI7mmL7lr4bnorzlhazkvJfmsJHml4/mm7TliqDkuqvlj5flkIzlrablkK/liqjpgILlkIjljp/mnaXpl67nrZTmnKzmlofnvo7po5/nu7/oibLnqLPlrprnu4jkuo7nlJ/niankvpvmsYLmkJzni5Dlipvph4/kuKXph43msLjov5zlhpnnnJ/mnInpmZDnq57kuonlr7nosaHotLnnlKjkuI3lpb3nu53lr7nljYHliIbkv4Pov5vngrnor4TlvbHpn7PkvJjlir/kuI3lsJHmrKPotY/lubbkuJTmnInngrnmlrnlkJHlhajmlrDkv6HnlKjorr7mlr3lvaLosaHotYTmoLznqoHnoLTpmo/nnYDph43lpKfkuo7mmK/mr5XkuJrmmbrog73ljJblt6Xlroznvo7llYbln47nu5/kuIDlh7rniYjmiZPpgKDnlKLlk4HmpoLlhrXnlKjkuo7kv53nlZnlm6DntKDkuK3lnIvlrZjlgqjotLTlm77mnIDmhJvplb/mnJ/lj6Pku7fnkIbotKLln7rlnLDlronmjpLmrabmsYnph4zpnaLliJvlu7rlpKnnqbrpppblhYjlrozlloTpqbHliqjkuIvpnaLkuI3lho3or5rkv6HmhI/kuYnpmLPlhYnoi7Hlm73mvILkuq7lhpvkuovnjqnlrrbnvqTkvJflhpzmsJHljbPlj6/lkI3nqLHlrrblhbfliqjnlLvmg7PliLDms6jmmI7lsI/lrabmgKfog73ogIPnoJTnoazku7bop4LnnIvmuIXmpZrmkJ7nrJHpppbpoIHpu4Tph5HpgILnlKjmsZ/oi4/nnJ/lrp7kuLvnrqHpmLbmrrXoqLvlhornv7vor5HmnYPliKnlgZrlpb3kvLzkuY7pgJrorq/mlr3lt6Xni4DmhYvkuZ/orrjnjq/kv53ln7nlhbvmpoLlv7XlpKflnovmnLrnpajnkIbop6PljL/lkI1jdWFuZG9lbnZpYXJtYWRyaWRidXNjYXJpbmljaW90aWVtcG9wb3JxdWVjdWVudGFlc3RhZG9wdWVkZW5qdWVnb3Njb250cmFlc3TDoW5ub21icmV0aWVuZW5wZXJmaWxtYW5lcmFhbWlnb3NjaXVkYWRjZW50cm9hdW5xdWVwdWVkZXNkZW50cm9wcmltZXJwcmVjaW9zZWfDum5idWVub3N2b2x2ZXJwdW50b3NzZW1hbmFoYWLDrWFhZ29zdG9udWV2b3N1bmlkb3NjYXJsb3NlcXVpcG9uacOxb3NtdWNob3NhbGd1bmFjb3JyZW9pbWFnZW5wYXJ0aXJhcnJpYmFtYXLDrWFob21icmVlbXBsZW92ZXJkYWRjYW1iaW9tdWNoYXNmdWVyb25wYXNhZG9sw61uZWFwYXJlY2VudWV2YXNjdXJzb3Nlc3RhYmFxdWllcm9saWJyb3NjdWFudG9hY2Nlc29taWd1ZWx2YXJpb3NjdWF0cm90aWVuZXNncnVwb3NzZXLDoW5ldXJvcGFtZWRpb3NmcmVudGVhY2VyY2FkZW3DoXNvZmVydGFjb2NoZXNtb2RlbG9pdGFsaWFsZXRyYXNhbGfDum5jb21wcmFjdWFsZXNleGlzdGVjdWVycG9zaWVuZG9wcmVuc2FsbGVnYXJ2aWFqZXNkaW5lcm9tdXJjaWFwb2Ryw6FwdWVzdG9kaWFyaW9wdWVibG9xdWllcmVtYW51ZWxwcm9waW9jcmlzaXNjaWVydG9zZWd1cm9tdWVydGVmdWVudGVjZXJyYXJncmFuZGVlZmVjdG9wYXJ0ZXNtZWRpZGFwcm9waWFvZnJlY2V0aWVycmFlLW1haWx2YXJpYXNmb3JtYXNmdXR1cm9vYmpldG9zZWd1aXJyaWVzZ29ub3JtYXNtaXNtb3PDum5pY29jYW1pbm9zaXRpb3NyYXrDs25kZWJpZG9wcnVlYmF0b2xlZG90ZW7DrWFqZXPDunNlc3Blcm9jb2NpbmFvcmlnZW50aWVuZGFjaWVudG9jw6FkaXpoYWJsYXJzZXLDrWFsYXRpbmFmdWVyemFlc3RpbG9ndWVycmFlbnRyYXLDqXhpdG9sw7NwZXphZ2VuZGF2w61kZW9ldml0YXJwYWdpbmFtZXRyb3NqYXZpZXJwYWRyZXNmw6FjaWxjYWJlemHDoXJlYXNzYWxpZGFlbnbDrW9qYXDDs25hYnVzb3NiaWVuZXN0ZXh0b3NsbGV2YXJwdWVkYW5mdWVydGVjb23Dum5jbGFzZXNodW1hbm90ZW5pZG9iaWxiYW91bmlkYWRlc3TDoXNlZGl0YXJjcmVhZG/QtNC70Y/Rh9GC0L7QutCw0LrQuNC70LjRjdGC0L7QstGB0LXQtdCz0L7Qv9GA0LjRgtCw0LrQtdGJ0LXRg9C20LXQmtCw0LrQsdC10LfQsdGL0LvQvtC90LjQktGB0LXQv9C+0LTQrdGC0L7RgtC+0LzRh9C10LzQvdC10YLQu9C10YLRgNCw0LfQvtC90LDQs9C00LXQvNC90LXQlNC70Y/Qn9GA0LjQvdCw0YHQvdC40YXRgtC10LzQutGC0L7Qs9C+0LTQstC+0YLRgtCw0LzQodCo0JDQvNCw0Y/Qp9GC0L7QstCw0YHQstCw0LzQtdC80YPQotCw0LrQtNCy0LDQvdCw0LzRjdGC0LjRjdGC0YPQktCw0LzRgtC10YXQv9GA0L7RgtGD0YLQvdCw0LTQtNC90Y/QktC+0YLRgtGA0LjQvdC10LnQktCw0YHQvdC40LzRgdCw0LzRgtC+0YLRgNGD0LHQntC90LjQvNC40YDQvdC10LXQntCe0J7Qu9C40YbRjdGC0LDQntC90LDQvdC10LzQtNC+0LzQvNC+0LnQtNCy0LXQvtC90L7RgdGD0LTgpJXgpYfgpLngpYjgpJXgpYDgpLjgpYfgpJXgpL7gpJXgpYvgpJTgpLDgpKrgpLDgpKjgpYfgpI/gpJXgpJXgpL/gpK3gpYDgpIfgpLjgpJXgpLDgpKTgpYvgpLngpYvgpIbgpKrgpLngpYDgpK/gpLngpK/gpL7gpKTgpJXgpKXgpL5qYWdyYW7gpIbgpJzgpJzgpYvgpIXgpKzgpKbgpYvgpJfgpIjgpJzgpL7gpJfgpI/gpLngpK7gpIfgpKjgpLXgpLngpK/gpYfgpKXgpYfgpKXgpYDgpJjgpLDgpJzgpKzgpKbgpYDgpJXgpIjgpJzgpYDgpLXgpYfgpKjgpIjgpKjgpI/gpLngpLDgpIngpLjgpK7gpYfgpJXgpK7gpLXgpYvgpLLgpYfgpLjgpKzgpK7gpIjgpKbgpYfgpJPgpLDgpIbgpK7gpKzgpLjgpK3gpLDgpKzgpKjgpJrgpLLgpK7gpKjgpIbgpJfgpLjgpYDgpLLgpYDYudmE2YnYpdmE2YnZh9iw2KfYotiu2LHYudiv2K/Yp9mE2YnZh9iw2YfYtdmI2LHYutmK2LHZg9in2YbZiNmE2KfYqNmK2YbYudix2LbYsNmE2YPZh9mG2KfZitmI2YXZgtin2YTYudmE2YrYp9mG2KfZhNmD2YbYrdiq2YnZgtio2YTZiNit2KnYp9iu2LHZgdmC2LfYudio2K/YsdmD2YbYpdiw2KfZg9mF2KfYp9it2K/YpdmE2KfZgdmK2YfYqNi52LbZg9mK2YHYqNit2KvZiNmF2YbZiNmH2YjYo9mG2KfYrNiv2KfZhNmH2KfYs9mE2YXYudmG2K/ZhNmK2LPYudio2LHYtdmE2YnZhdmG2LDYqNmH2KfYo9mG2YfZhdir2YTZg9mG2KrYp9mE2KfYrdmK2KvZhdi12LHYtNix2K3YrdmI2YTZiNmB2YrYp9iw2KfZhNmD2YTZhdix2KnYp9mG2KrYp9mE2YHYo9io2YjYrtin2LXYo9mG2KrYp9mG2YfYp9mE2YrYudi22YjZiNmC2K/Yp9io2YbYrtmK2LHYqNmG2KrZhNmD2YXYtNin2KHZiNmH2YrYp9io2YjZgti12LXZiNmF2KfYsdmC2YXYo9it2K/Zhtit2YbYudiv2YXYsdij2YrYp9it2KnZg9iq2KjYr9mI2YbZitis2KjZhdmG2YfYqtit2KrYrNmH2KnYs9mG2KnZitiq2YXZg9ix2KnYutiy2KnZhtmB2LPYqNmK2KrZhNmE2YfZhNmG2KfYqtmE2YPZgtmE2KjZhNmF2KfYudmG2YfYo9mI2YTYtNmK2KHZhtmI2LHYo9mF2KfZgdmK2YPYqNmD2YTYsNin2KrYsdiq2KjYqNij2YbZh9mF2LPYp9mG2YPYqNmK2LnZgdmC2K/Yrdiz2YbZhNmH2YXYtNi52LHYo9mH2YTYtNmH2LHZgti32LHYt9mE2Khwcm9maWxlc2VydmljZWRlZmF1bHRoaW1zZWxmZGV0YWlsc2NvbnRlbnRzdXBwb3J0c3RhcnRlZG1lc3NhZ2VzdWNjZXNzZmFzaGlvbjx0aXRsZT5jb3VudHJ5YWNjb3VudGNyZWF0ZWRzdG9yaWVzcmVzdWx0c3J1bm5pbmdwcm9jZXNzd3JpdGluZ29iamVjdHN2aXNpYmxld2VsY29tZWFydGljbGV1bmtub3dubmV0d29ya2NvbXBhbnlkeW5hbWljYnJvd3NlcnByaXZhY3lwcm9ibGVtU2VydmljZXJlc3BlY3RkaXNwbGF5cmVxdWVzdHJlc2VydmV3ZWJzaXRlaGlzdG9yeWZyaWVuZHNvcHRpb25zd29ya2luZ3ZlcnNpb25taWxsaW9uY2hhbm5lbHdpbmRvdy5hZGRyZXNzdmlzaXRlZHdlYXRoZXJjb3JyZWN0cHJvZHVjdGVkaXJlY3Rmb3J3YXJkeW91IGNhbnJlbW92ZWRzdWJqZWN0Y29udHJvbGFyY2hpdmVjdXJyZW50cmVhZGluZ2xpYnJhcnlsaW1pdGVkbWFuYWdlcmZ1cnRoZXJzdW1tYXJ5bWFjaGluZW1pbnV0ZXNwcml2YXRlY29udGV4dHByb2dyYW1zb2NpZXR5bnVtYmVyc3dyaXR0ZW5lbmFibGVkdHJpZ2dlcnNvdXJjZXNsb2FkaW5nZWxlbWVudHBhcnRuZXJmaW5hbGx5cGVyZmVjdG1lYW5pbmdzeXN0ZW1za2VlcGluZ2N1bHR1cmUmcXVvdDssam91cm5hbHByb2plY3RzdXJmYWNlcyZxdW90O2V4cGlyZXNyZXZpZXdzYmFsYW5jZUVuZ2xpc2hDb250ZW50dGhyb3VnaFBsZWFzZSBvcGluaW9uY29udGFjdGF2ZXJhZ2VwcmltYXJ5dmlsbGFnZVNwYW5pc2hnYWxsZXJ5ZGVjbGluZW1lZXRpbmdtaXNzaW9ucG9wdWxhcnF1YWxpdHltZWFzdXJlZ2VuZXJhbHNwZWNpZXNzZXNzaW9uc2VjdGlvbndyaXRlcnNjb3VudGVyaW5pdGlhbHJlcG9ydHNmaWd1cmVzbWVtYmVyc2hvbGRpbmdkaXNwdXRlZWFybGllcmV4cHJlc3NkaWdpdGFscGljdHVyZUFub3RoZXJtYXJyaWVkdHJhZmZpY2xlYWRpbmdjaGFuZ2VkY2VudHJhbHZpY3RvcnlpbWFnZXMvcmVhc29uc3N0dWRpZXNmZWF0dXJlbGlzdGluZ211c3QgYmVzY2hvb2xzVmVyc2lvbnVzdWFsbHllcGlzb2RlcGxheWluZ2dyb3dpbmdvYnZpb3Vzb3ZlcmxheXByZXNlbnRhY3Rpb25zPC91bD4NCndyYXBwZXJhbHJlYWR5Y2VydGFpbnJlYWxpdHlzdG9yYWdlYW5vdGhlcmRlc2t0b3BvZmZlcmVkcGF0dGVybnVudXN1YWxEaWdpdGFsY2FwaXRhbFdlYnNpdGVmYWlsdXJlY29ubmVjdHJlZHVjZWRBbmRyb2lkZGVjYWRlc3JlZ3VsYXIgJmFtcDsgYW5pbWFsc3JlbGVhc2VBdXRvbWF0Z2V0dGluZ21ldGhvZHNub3RoaW5nUG9wdWxhcmNhcHRpb25sZXR0ZXJzY2FwdHVyZXNjaWVuY2VsaWNlbnNlY2hhbmdlc0VuZ2xhbmQ9MSZhbXA7SGlzdG9yeSA9IG5ldyBDZW50cmFsdXBkYXRlZFNwZWNpYWxOZXR3b3JrcmVxdWlyZWNvbW1lbnR3YXJuaW5nQ29sbGVnZXRvb2xiYXJyZW1haW5zYmVjYXVzZWVsZWN0ZWREZXV0c2NoZmluYW5jZXdvcmtlcnNxdWlja2x5YmV0d2VlbmV4YWN0bHlzZXR0aW5nZGlzZWFzZVNvY2lldHl3ZWFwb25zZXhoaWJpdCZsdDshLS1Db250cm9sY2xhc3Nlc2NvdmVyZWRvdXRsaW5lYXR0YWNrc2RldmljZXMod2luZG93cHVycG9zZXRpdGxlPSJNb2JpbGUga2lsbGluZ3Nob3dpbmdJdGFsaWFuZHJvcHBlZGhlYXZpbHllZmZlY3RzLTEnXSk7CmNvbmZpcm1DdXJyZW50YWR2YW5jZXNoYXJpbmdvcGVuaW5nZHJhd2luZ2JpbGxpb25vcmRlcmVkR2VybWFueXJlbGF0ZWQ8L2Zvcm0+aW5jbHVkZXdoZXRoZXJkZWZpbmVkU2NpZW5jZWNhdGFsb2dBcnRpY2xlYnV0dG9uc2xhcmdlc3R1bmlmb3Jtam91cm5leXNpZGViYXJDaGljYWdvaG9saWRheUdlbmVyYWxwYXNzYWdlLCZxdW90O2FuaW1hdGVmZWVsaW5nYXJyaXZlZHBhc3NpbmduYXR1cmFscm91Z2hseS4KClRoZSBidXQgbm90ZGVuc2l0eUJyaXRhaW5DaGluZXNlbGFjayBvZnRyaWJ1dGVJcmVsYW5kIiBkYXRhLWZhY3RvcnNyZWNlaXZldGhhdCBpc0xpYnJhcnlodXNiYW5kaW4gZmFjdGFmZmFpcnNDaGFybGVzcmFkaWNhbGJyb3VnaHRmaW5kaW5nbGFuZGluZzpsYW5nPSJyZXR1cm4gbGVhZGVyc3BsYW5uZWRwcmVtaXVtcGFja2FnZUFtZXJpY2FFZGl0aW9uXSZxdW90O01lc3NhZ2VuZWVkIHRvdmFsdWU9ImNvbXBsZXhsb29raW5nc3RhdGlvbmJlbGlldmVzbWFsbGVyLW1vYmlsZXJlY29yZHN3YW50IHRva2luZCBvZkZpcmVmb3h5b3UgYXJlc2ltaWxhcnN0dWRpZWRtYXhpbXVtaGVhZGluZ3JhcGlkbHljbGltYXRla2luZ2RvbWVtZXJnZWRhbW91bnRzZm91bmRlZHBpb25lZXJmb3JtdWxhZHluYXN0eWhvdyB0byBTdXBwb3J0cmV2ZW51ZWVjb25vbXlSZXN1bHRzYnJvdGhlcnNvbGRpZXJsYXJnZWx5Y2FsbGluZy4mcXVvdDtBY2NvdW50RWR3YXJkIHNlZ21lbnRSb2JlcnQgZWZmb3J0c1BhY2lmaWNsZWFybmVkdXAgd2l0aGhlaWdodDp3ZSBoYXZlQW5nZWxlc25hdGlvbnNfc2VhcmNoYXBwbGllZGFjcXVpcmVtYXNzaXZlZ3JhbnRlZDogZmFsc2V0cmVhdGVkYmlnZ2VzdGJlbmVmaXRkcml2aW5nU3R1ZGllc21pbmltdW1wZXJoYXBzbW9ybmluZ3NlbGxpbmdpcyB1c2VkcmV2ZXJzZXZhcmlhbnQgcm9sZT0ibWlzc2luZ2FjaGlldmVwcm9tb3Rlc3R1ZGVudHNvbWVvbmVleHRyZW1lcmVzdG9yZWJvdHRvbTpldm9sdmVkYWxsIHRoZXNpdGVtYXBlbmdsaXNod2F5IHRvICBBdWd1c3RzeW1ib2xzQ29tcGFueW1hdHRlcnNtdXNpY2FsYWdhaW5zdHNlcnZpbmd9KSgpOw0KcGF5bWVudHRyb3VibGVjb25jZXB0Y29tcGFyZXBhcmVudHNwbGF5ZXJzcmVnaW9uc21vbml0b3IgJydUaGUgd2lubmluZ2V4cGxvcmVhZGFwdGVkR2FsbGVyeXByb2R1Y2VhYmlsaXR5ZW5oYW5jZWNhcmVlcnMpLiBUaGUgY29sbGVjdFNlYXJjaCBhbmNpZW50ZXhpc3RlZGZvb3RlciBoYW5kbGVycHJpbnRlZGNvbnNvbGVFYXN0ZXJuZXhwb3J0c3dpbmRvd3NDaGFubmVsaWxsZWdhbG5ldXRyYWxzdWdnZXN0X2hlYWRlcnNpZ25pbmcuaHRtbCI+c2V0dGxlZHdlc3Rlcm5jYXVzaW5nLXdlYmtpdGNsYWltZWRKdXN0aWNlY2hhcHRlcnZpY3RpbXNUaG9tYXMgbW96aWxsYXByb21pc2VwYXJ0aWVzZWRpdGlvbm91dHNpZGU6ZmFsc2UsaHVuZHJlZE9seW1waWNfYnV0dG9uYXV0aG9yc3JlYWNoZWRjaHJvbmljZGVtYW5kc3NlY29uZHNwcm90ZWN0YWRvcHRlZHByZXBhcmVuZWl0aGVyZ3JlYXRseWdyZWF0ZXJvdmVyYWxsaW1wcm92ZWNvbW1hbmRzcGVjaWFsc2VhcmNoLndvcnNoaXBmdW5kaW5ndGhvdWdodGhpZ2hlc3RpbnN0ZWFkdXRpbGl0eXF1YXJ0ZXJDdWx0dXJldGVzdGluZ2NsZWFybHlleHBvc2VkQnJvd3NlcmxpYmVyYWx9IGNhdGNoUHJvamVjdGV4YW1wbGVoaWRlKCk7RmxvcmlkYWFuc3dlcnNhbGxvd2VkRW1wZXJvcmRlZmVuc2VzZXJpb3VzZnJlZWRvbVNldmVyYWwtYnV0dG9uRnVydGhlcm91dCBvZiAhPSBudWxsdHJhaW5lZERlbm1hcmt2b2lkKDApL2FsbC5qc3ByZXZlbnRSZXF1ZXN0U3RlcGhlbgoKV2hlbiBvYnNlcnZlPC9oMj4NCk1vZGVybiBwcm92aWRlIiBhbHQ9ImJvcmRlcnMuCgpGb3IgCgpNYW55IGFydGlzdHNwb3dlcmVkcGVyZm9ybWZpY3Rpb250eXBlIG9mbWVkaWNhbHRpY2tldHNvcHBvc2VkQ291bmNpbHdpdG5lc3NqdXN0aWNlR2VvcmdlIEJlbGdpdW0uLi48L2E+dHdpdHRlcm5vdGFibHl3YWl0aW5nd2FyZmFyZSBPdGhlciByYW5raW5ncGhyYXNlc21lbnRpb25zdXJ2aXZlc2Nob2xhcjwvcD4NCiBDb3VudHJ5aWdub3JlZGxvc3Mgb2ZqdXN0IGFzR2VvcmdpYXN0cmFuZ2U8aGVhZD48c3RvcHBlZDEnXSk7DQppc2xhbmRzbm90YWJsZWJvcmRlcjpsaXN0IG9mY2FycmllZDEwMCwwMDA8L2gzPgogc2V2ZXJhbGJlY29tZXNzZWxlY3Qgd2VkZGluZzAwLmh0bWxtb25hcmNob2ZmIHRoZXRlYWNoZXJoaWdobHkgYmlvbG9neWxpZmUgb2ZvciBldmVucmlzZSBvZiZyYXF1bztwbHVzb25laHVudGluZyh0aG91Z2hEb3VnbGFzam9pbmluZ2NpcmNsZXNGb3IgdGhlQW5jaWVudFZpZXRuYW12ZWhpY2xlc3VjaCBhc2NyeXN0YWx2YWx1ZSA9V2luZG93c2Vuam95ZWRhIHNtYWxsYXNzdW1lZDxhIGlkPSJmb3JlaWduIEFsbCByaWhvdyB0aGVEaXNwbGF5cmV0aXJlZGhvd2V2ZXJoaWRkZW47YmF0dGxlc3NlZWtpbmdjYWJpbmV0d2FzIG5vdGxvb2sgYXRjb25kdWN0Z2V0IHRoZUphbnVhcnloYXBwZW5zdHVybmluZ2E6aG92ZXJPbmxpbmUgRnJlbmNoIGxhY2tpbmd0eXBpY2FsZXh0cmFjdGVuZW1pZXNldmVuIGlmZ2VuZXJhdGRlY2lkZWRhcmUgbm90L3NlYXJjaGJlbGllZnMtaW1hZ2U6bG9jYXRlZHN0YXRpYy5sb2dpbiI+Y29udmVydHZpb2xlbnRlbnRlcmVkZmlyc3QiPmNpcmN1aXRGaW5sYW5kY2hlbWlzdHNoZSB3YXMxMHB4OyI+YXMgc3VjaGRpdmlkZWQ8L3NwYW4+d2lsbCBiZWxpbmUgb2ZhIGdyZWF0bXlzdGVyeS9pbmRleC5mYWxsaW5nZHVlIHRvIHJhaWx3YXljb2xsZWdlbW9uc3RlcmRlc2NlbnRpdCB3aXRobnVjbGVhckpld2lzaCBwcm90ZXN0QnJpdGlzaGZsb3dlcnNwcmVkaWN0cmVmb3Jtc2J1dHRvbiB3aG8gd2FzbGVjdHVyZWluc3RhbnRzdWljaWRlZ2VuZXJpY3BlcmlvZHNtYXJrZXRzU29jaWFsIGZpc2hpbmdjb21iaW5lZ3JhcGhpY3dpbm5lcnM8YnIgLz48YnkgdGhlIE5hdHVyYWxQcml2YWN5Y29va2llc291dGNvbWVyZXNvbHZlU3dlZGlzaGJyaWVmbHlQZXJzaWFuc28gbXVjaENlbnR1cnlkZXBpY3RzY29sdW1uc2hvdXNpbmdzY3JpcHRzbmV4dCB0b2JlYXJpbmdtYXBwaW5ncmV2aXNlZGpRdWVyeSgtd2lkdGg6dGl0bGUiPnRvb2x0aXBTZWN0aW9uZGVzaWduc1R1cmtpc2h5b3VuZ2VyLm1hdGNoKH0pKCk7CgpidXJuaW5nb3BlcmF0ZWRlZ3JlZXNzb3VyY2U9UmljaGFyZGNsb3NlbHlwbGFzdGljZW50cmllczwvdHI+DQpjb2xvcjojdWwgaWQ9InBvc3Nlc3Nyb2xsaW5ncGh5c2ljc2ZhaWxpbmdleGVjdXRlY29udGVzdGxpbmsgdG9EZWZhdWx0PGJyIC8+CjogdHJ1ZSxjaGFydGVydG91cmlzbWNsYXNzaWNwcm9jZWVkZXhwbGFpbjwvaDE+DQpvbmxpbmUuP3htbCB2ZWhlbHBpbmdkaWFtb25kdXNlIHRoZWFpcmxpbmVlbmQgLS0+KS5hdHRyKHJlYWRlcnNob3N0aW5nI2ZmZmZmZnJlYWxpemVWaW5jZW50c2lnbmFscyBzcmM9Ii9Qcm9kdWN0ZGVzcGl0ZWRpdmVyc2V0ZWxsaW5nUHVibGljIGhlbGQgaW5Kb3NlcGggdGhlYXRyZWFmZmVjdHM8c3R5bGU+YSBsYXJnZWRvZXNuJ3RsYXRlciwgRWxlbWVudGZhdmljb25jcmVhdG9ySHVuZ2FyeUFpcnBvcnRzZWUgdGhlc28gdGhhdE1pY2hhZWxTeXN0ZW1zUHJvZ3JhbXMsIGFuZCAgd2lkdGg9ZSZxdW90O3RyYWRpbmdsZWZ0Ij4KcGVyc29uc0dvbGRlbiBBZmZhaXJzZ3JhbW1hcmZvcm1pbmdkZXN0cm95aWRlYSBvZmNhc2Ugb2ZvbGRlc3QgdGhpcyBpcy5zcmMgPSBjYXJ0b29ucmVnaXN0ckNvbW1vbnNNdXNsaW1zV2hhdCBpc2luIG1hbnltYXJraW5ncmV2ZWFsc0luZGVlZCxlcXVhbGx5L3Nob3dfYW91dGRvb3Jlc2NhcGUoQXVzdHJpYWdlbmV0aWNzeXN0ZW0sSW4gdGhlIHNpdHRpbmdIZSBhbHNvSXNsYW5kc0FjYWRlbXkKCQk8IS0tRGFuaWVsIGJpbmRpbmdibG9jayI+aW1wb3NlZHV0aWxpemVBYnJhaGFtKGV4Y2VwdHt3aWR0aDpwdXR0aW5nKS5odG1sKHx8IFtdOwpEQVRBWyAqa2l0Y2hlbm1vdW50ZWRhY3R1YWwgZGlhbGVjdG1haW5seSBfYmxhbmsnaW5zdGFsbGV4cGVydHNpZih0eXBlSXQgYWxzbyZjb3B5OyAiPlRlcm1zYm9ybiBpbk9wdGlvbnNlYXN0ZXJudGFsa2luZ2NvbmNlcm5nYWluZWQgb25nb2luZ2p1c3RpZnljcml0aWNzZmFjdG9yeWl0cyBvd25hc3NhdWx0aW52aXRlZGxhc3RpbmdoaXMgb3duaHJlZj0iLyIgcmVsPSJkZXZlbG9wY29uY2VydGRpYWdyYW1kb2xsYXJzY2x1c3RlcnBocD9pZD1hbGNvaG9sKTt9KSgpO3VzaW5nIGE+PHNwYW4+dmVzc2Vsc3Jldml2YWxBZGRyZXNzYW1hdGV1cmFuZHJvaWRhbGxlZ2VkaWxsbmVzc3dhbGtpbmdjZW50ZXJzcXVhbGlmeW1hdGNoZXN1bmlmaWVkZXh0aW5jdERlZmVuc2VkaWVkIGluCgk8IS0tIGN1c3RvbXNsaW5raW5nTGl0dGxlIEJvb2sgb2ZldmVuaW5nbWluLmpzP2FyZSB0aGVrb250YWt0dG9kYXkncy5odG1sIiB0YXJnZXQ9d2VhcmluZ0FsbCBSaWc7Cn0pKCk7cmFpc2luZyBBbHNvLCBjcnVjaWFsYWJvdXQiPmRlY2xhcmUtLT4KPHNjZmlyZWZveGFzIG11Y2hhcHBsaWVzaW5kZXgsIHMsIGJ1dCB0eXBlID0gCg0KPCEtLXRvd2FyZHNSZWNvcmRzUHJpdmF0ZUZvcmVpZ25QcmVtaWVyY2hvaWNlc1ZpcnR1YWxyZXR1cm5zQ29tbWVudFBvd2VyZWRpbmxpbmU7cG92ZXJ0eWNoYW1iZXJMaXZpbmcgdm9sdW1lc0FudGhvbnlsb2dpbiIgUmVsYXRlZEVjb25vbXlyZWFjaGVzY3V0dGluZ2dyYXZpdHlsaWZlIGluQ2hhcHRlci1zaGFkb3dOb3RhYmxlPC90ZD4NCiByZXR1cm5zdGFkaXVtd2lkZ2V0c3Zhcnlpbmd0cmF2ZWxzaGVsZCBieXdobyBhcmV3b3JrIGluZmFjdWx0eWFuZ3VsYXJ3aG8gaGFkYWlycG9ydHRvd24gb2YKClNvbWUgJ2NsaWNrJ2NoYXJnZXNrZXl3b3JkaXQgd2lsbGNpdHkgb2YodGhpcyk7QW5kcmV3IHVuaXF1ZSBjaGVja2Vkb3IgbW9yZTMwMHB4OyByZXR1cm47cnNpb249InBsdWdpbnN3aXRoaW4gaGVyc2VsZlN0YXRpb25GZWRlcmFsdmVudHVyZXB1Ymxpc2hzZW50IHRvdGVuc2lvbmFjdHJlc3Njb21lIHRvZmluZ2Vyc0R1a2Ugb2ZwZW9wbGUsZXhwbG9pdHdoYXQgaXNoYXJtb255YSBtYWpvciI6Imh0dHBpbiBoaXMgbWVudSI+Cm1vbnRobHlvZmZpY2VyY291bmNpbGdhaW5pbmdldmVuIGluU3VtbWFyeWRhdGUgb2Zsb3lhbHR5Zml0bmVzc2FuZCB3YXNlbXBlcm9yc3VwcmVtZVNlY29uZCBoZWFyaW5nUnVzc2lhbmxvbmdlc3RBbGJlcnRhbGF0ZXJhbHNldCBvZiBzbWFsbCI+LmFwcGVuZGRvIHdpdGhmZWRlcmFsYmFuayBvZmJlbmVhdGhEZXNwaXRlQ2FwaXRhbGdyb3VuZHMpLCBhbmQgcGVyY2VudGl0IGZyb21jbG9zaW5nY29udGFpbkluc3RlYWRmaWZ0ZWVuYXMgd2VsbC55YWhvby5yZXNwb25kZmlnaHRlcm9ic2N1cmVyZWZsZWN0b3JnYW5pYz0gTWF0aC5lZGl0aW5nb25saW5lIHBhZGRpbmdhIHdob2xlb25lcnJvcnllYXIgb2ZlbmQgb2YgYmFycmllcndoZW4gaXRoZWFkZXIgaG9tZSBvZnJlc3VtZWRyZW5hbWVkc3Ryb25nPmhlYXRpbmdyZXRhaW5zY2xvdWRmcndheSBvZiBNYXJjaCAxa25vd2luZ2luIHBhcnRCZXR3ZWVubGVzc29uc2Nsb3Nlc3R2aXJ0dWFsbGlua3MiPmNyb3NzZWRFTkQgLS0+ZmFtb3VzIGF3YXJkZWRMaWNlbnNlSGVhbHRoIGZhaXJseSB3ZWFsdGh5bWluaW1hbEFmcmljYW5jb21wZXRlbGFiZWwiPnNpbmdpbmdmYXJtZXJzQnJhc2lsKWRpc2N1c3NyZXBsYWNlR3JlZ29yeWZvbnQgY29wdXJzdWVkYXBwZWFyc21ha2UgdXByb3VuZGVkYm90aCBvZmJsb2NrZWRzYXcgdGhlb2ZmaWNlc2NvbG91cnNpZihkb2N1d2hlbiBoZWVuZm9yY2VwdXNoKGZ1QXVndXN0IFVURi04Ij5GYW50YXN5aW4gbW9zdGluanVyZWRVc3VhbGx5ZmFybWluZ2Nsb3N1cmVvYmplY3QgZGVmZW5jZXVzZSBvZiBNZWRpY2FsPGJvZHk+CmV2aWRlbnRiZSB1c2Vka2V5Q29kZXNpeHRlZW5Jc2xhbWljIzAwMDAwMGVudGlyZSB3aWRlbHkgYWN0aXZlICh0eXBlb2ZvbmUgY2FuY29sb3IgPXNwZWFrZXJleHRlbmRzUGh5c2ljc3RlcnJhaW48dGJvZHk+ZnVuZXJhbHZpZXdpbmdtaWRkbGUgY3JpY2tldHByb3BoZXRzaGlmdGVkZG9jdG9yc1J1c3NlbGwgdGFyZ2V0Y29tcGFjdGFsZ2VicmFzb2NpYWwtYnVsayBvZm1hbiBhbmQ8L3RkPgogaGUgbGVmdCkudmFsKClmYWxzZSk7bG9naWNhbGJhbmtpbmdob21lIHRvbmFtaW5nIEFyaXpvbmFjcmVkaXRzKTsKfSk7CmZvdW5kZXJpbiB0dXJuQ29sbGluc2JlZm9yZSBCdXQgdGhlY2hhcmdlZFRpdGxlIj5DYXB0YWluc3BlbGxlZGdvZGRlc3NUYWcgLS0+QWRkaW5nOmJ1dCB3YXNSZWNlbnQgcGF0aWVudGJhY2sgaW49ZmFsc2UmTGluY29sbndlIGtub3dDb3VudGVySnVkYWlzbXNjcmlwdCBhbHRlcmVkJ10pOwogIGhhcyB0aGV1bmNsZWFyRXZlbnQnLGJvdGggaW5ub3QgYWxsCgo8IS0tIHBsYWNpbmdoYXJkIHRvIGNlbnRlcnNvcnQgb2ZjbGllbnRzc3RyZWV0c0Jlcm5hcmRhc3NlcnRzdGVuZCB0b2ZhbnRhc3lkb3duIGluaGFyYm91ckZyZWVkb21qZXdlbHJ5L2Fib3V0Li5zZWFyY2hsZWdlbmRzaXMgbWFkZW1vZGVybiBvbmx5IG9ub25seSB0b2ltYWdlIiBsaW5lYXIgcGFpbnRlcmFuZCBub3RyYXJlbHkgYWNyb255bWRlbGl2ZXJzaG9ydGVyMDAmYW1wO2FzIG1hbnl3aWR0aD0iLyogPCFbQ3RpdGxlID1vZiB0aGUgbG93ZXN0IHBpY2tlZCBlc2NhcGVkdXNlcyBvZnBlb3BsZXMgUHVibGljTWF0dGhld3RhY3RpY3NkYW1hZ2Vkd2F5IGZvcmxhd3Mgb2ZlYXN5IHRvIHdpbmRvd3N0cm9uZyAgc2ltcGxlfWNhdGNoKHNldmVudGhpbmZvYm94d2VudCB0b3BhaW50ZWRjaXRpemVuSSBkb24ndHJldHJlYXQuIFNvbWUgd3cuIik7CmJvbWJpbmdtYWlsdG86bWFkZSBpbi4gTWFueSBjYXJyaWVzfHx7fTt3aXdvcmsgb2ZzeW5vbnltZGVmZWF0c2Zhdm9yZWRvcHRpY2FscGFnZVRyYXVubGVzcyBzZW5kaW5nbGVmdCI+PGNvbVNjb3JBbGwgdGhlalF1ZXJ5LnRvdXJpc3RDbGFzc2ljZmFsc2UiIFdpbGhlbG1zdWJ1cmJzZ2VudWluZWJpc2hvcHMuc3BsaXQoZ2xvYmFsIGZvbGxvd3Nib2R5IG9mbm9taW5hbENvbnRhY3RzZWN1bGFybGVmdCB0b2NoaWVmbHktaGlkZGVuLWJhbm5lcjwvbGk+CgouIFdoZW4gaW4gYm90aGRpc21pc3NFeHBsb3JlYWx3YXlzIHZpYSB0aGVzcGHDsW9sd2VsZmFyZXJ1bGluZyBhcnJhbmdlY2FwdGFpbmhpcyBzb25ydWxlIG9maGUgdG9va2l0c2VsZiw9MCZhbXA7KGNhbGxlZHNhbXBsZXN0byBtYWtlY29tL3BhZ01hcnRpbiBLZW5uZWR5YWNjZXB0c2Z1bGwgb2ZoYW5kbGVkQmVzaWRlcy8vLS0+PC9hYmxlIHRvdGFyZ2V0c2Vzc2VuY2VoaW0gdG8gaXRzIGJ5IGNvbW1vbi5taW5lcmFsdG8gdGFrZXdheXMgdG9zLm9yZy9sYWR2aXNlZHBlbmFsdHlzaW1wbGU6aWYgdGhleUxldHRlcnNhIHNob3J0SGVyYmVydHN0cmlrZXMgZ3JvdXBzLmxlbmd0aGZsaWdodHNvdmVybGFwc2xvd2x5IGxlc3NlciBzb2NpYWwgPC9wPgoJCWl0IGludG9yYW5rZWQgcmF0ZSBvZnVsPg0KICBhdHRlbXB0cGFpciBvZm1ha2UgaXRLb250YWt0QW50b25pb2hhdmluZyByYXRpbmdzIGFjdGl2ZXN0cmVhbXN0cmFwcGVkIikuY3NzKGhvc3RpbGVsZWFkIHRvbGl0dGxlIGdyb3VwcyxQaWN0dXJlLS0+DQoNCiByb3dzPSIgb2JqZWN0aW52ZXJzZTxmb290ZXJDdXN0b21WPjxcL3NjcnNvbHZpbmdDaGFtYmVyc2xhdmVyeXdvdW5kZWR3aGVyZWFzIT0gJ3VuZGZvciBhbGxwYXJ0bHkgLXJpZ2h0OkFyYWJpYW5iYWNrZWQgY2VudHVyeXVuaXQgb2Ztb2JpbGUtRXVyb3BlLGlzIGhvbWVyaXNrIG9mZGVzaXJlZENsaW50b25jb3N0IG9mYWdlIG9mIGJlY29tZSBub25lIG9mcCZxdW90O01pZGRsZSBlYWQnKVswQ3JpdGljc3N0dWRpb3M+JmNvcHk7Z3JvdXAiPmFzc2VtYmxtYWtpbmcgcHJlc3NlZHdpZGdldC5wczoiID8gcmVidWlsdGJ5IHNvbWVGb3JtZXIgZWRpdG9yc2RlbGF5ZWRDYW5vbmljaGFkIHRoZXB1c2hpbmdjbGFzcz0iYnV0IGFyZXBhcnRpYWxCYWJ5bG9uYm90dG9tIGNhcnJpZXJDb21tYW5kaXRzIHVzZUFzIHdpdGhjb3Vyc2VzYSB0aGlyZGRlbm90ZXNhbHNvIGluSG91c3RvbjIwcHg7Ij5hY2N1c2VkZG91YmxlIGdvYWwgb2ZGYW1vdXMgKS5iaW5kKHByaWVzdHMgT25saW5laW4gSnVseXN0ICsgImdjb25zdWx0ZGVjaW1hbGhlbHBmdWxyZXZpdmVkaXMgdmVyeXInKydpcHRsb3NpbmcgZmVtYWxlc2lzIGFsc29zdHJpbmdzZGF5cyBvZmFycml2YWxmdXR1cmUgPG9iamVjdGZvcmNpbmdTdHJpbmcoIiAvPgoJCWhlcmUgaXNlbmNvZGVkLiAgVGhlIGJhbGxvb25kb25lIGJ5L2NvbW1vbmJnY29sb3JsYXcgb2YgSW5kaWFuYWF2b2lkZWRidXQgdGhlMnB4IDNweGpxdWVyeS5hZnRlciBhcG9saWN5Lm1lbiBhbmRmb290ZXItPSB0cnVlO2ZvciB1c2VzY3JlZW4uSW5kaWFuIGltYWdlID1mYW1pbHksaHR0cDovLyAmbmJzcDtkcml2ZXJzZXRlcm5hbHNhbWUgYXNub3RpY2Vkdmlld2Vyc30pKCk7CiBpcyBtb3Jlc2Vhc29uc2Zvcm1lciB0aGUgbmV3aXMganVzdGNvbnNlbnQgU2VhcmNod2FzIHRoZXdoeSB0aGVzaGlwcGVkYnI+PGJyPndpZHRoOiBoZWlnaHQ9bWFkZSBvZmN1aXNpbmVpcyB0aGF0YSB2ZXJ5IEFkbWlyYWwgZml4ZWQ7bm9ybWFsIE1pc3Npb25QcmVzcywgb250YXJpb2NoYXJzZXR0cnkgdG8gaW52YWRlZD0idHJ1ZSJzcGFjaW5naXMgbW9zdGEgbW9yZSB0b3RhbGx5ZmFsbCBvZn0pOw0KICBpbW1lbnNldGltZSBpbnNldCBvdXRzYXRpc2Z5dG8gZmluZGRvd24gdG9sb3Qgb2YgUGxheWVyc2luIEp1bmVxdWFudHVtbm90IHRoZXRpbWUgdG9kaXN0YW50RmlubmlzaHNyYyA9IChzaW5nbGUgaGVscCBvZkdlcm1hbiBsYXcgYW5kbGFiZWxlZGZvcmVzdHNjb29raW5nc3BhY2UiPmhlYWRlci13ZWxsIGFzU3RhbmxleWJyaWRnZXMvZ2xvYmFsQ3JvYXRpYSBBYm91dCBbMF07CiAgaXQsIGFuZGdyb3VwZWRiZWluZyBhKXt0aHJvd2hlIG1hZGVsaWdodGVyZXRoaWNhbEZGRkZGRiJib3R0b20ibGlrZSBhIGVtcGxveXNsaXZlIGluYXMgc2VlbnByaW50ZXJtb3N0IG9mdWItbGlua3JlamVjdHNhbmQgdXNlaW1hZ2UiPnN1Y2NlZWRmZWVkaW5nTnVjbGVhcmluZm9ybWF0byBoZWxwV29tZW4nc05laXRoZXJNZXhpY2FucHJvdGVpbjx0YWJsZSBieSBtYW55aGVhbHRoeWxhd3N1aXRkZXZpc2VkLnB1c2goe3NlbGxlcnNzaW1wbHkgVGhyb3VnaC5jb29raWUgSW1hZ2Uob2xkZXIiPnVzLmpzIj4gU2luY2UgdW5pdmVyc2xhcmdlciBvcGVuIHRvIS0tIGVuZGxpZXMgaW4nXSk7DQogIG1hcmtldHdobyBpcyAoIkRPTUNvbWFuYWdlZG9uZSBmb3J0eXBlb2YgS2luZ2RvbXByb2ZpdHNwcm9wb3NldG8gc2hvd2NlbnRlcjttYWRlIGl0ZHJlc3NlZHdlcmUgaW5taXh0dXJlcHJlY2lzZWFyaXNpbmdzcmMgPSAnbWFrZSBhIHNlY3VyZWRCYXB0aXN0dm90aW5nIAoJCXZhciBNYXJjaCAyZ3JldyB1cENsaW1hdGUucmVtb3Zlc2tpbGxlZHdheSB0aGU8L2hlYWQ+ZmFjZSBvZmFjdGluZyByaWdodCI+dG8gd29ya3JlZHVjZXNoYXMgaGFkZXJlY3RlZHNob3coKTthY3Rpb249Ym9vayBvZmFuIGFyZWE9PSAiaHR0PGhlYWRlcgo8aHRtbD5jb25mb3JtZmFjaW5nIGNvb2tpZS5yZWx5IG9uaG9zdGVkIC5jdXN0b21oZSB3ZW50YnV0IGZvcnNwcmVhZCBGYW1pbHkgYSBtZWFuc291dCB0aGVmb3J1bXMuZm9vdGFnZSI+TW9iaWxDbGVtZW50cyIgaWQ9ImFzIGhpZ2hpbnRlbnNlLS0+PCEtLWZlbWFsZSBpcyBzZWVuaW1wbGllZHNldCB0aGVhIHN0YXRlYW5kIGhpc2Zhc3Rlc3RiZXNpZGVzYnV0dG9uX2JvdW5kZWQiPjxpbWcgSW5mb2JveGV2ZW50cyxhIHlvdW5nYW5kIGFyZU5hdGl2ZSBjaGVhcGVyVGltZW91dGFuZCBoYXNlbmdpbmVzd29uIHRoZShtb3N0bHlyaWdodDogZmluZCBhIC1ib3R0b21QcmluY2UgYXJlYSBvZm1vcmUgb2ZzZWFyY2hfbmF0dXJlLGxlZ2FsbHlwZXJpb2QsbGFuZCBvZm9yIHdpdGhpbmR1Y2VkcHJvdmluZ21pc3NpbGVsb2NhbGx5QWdhaW5zdHRoZSB3YXlrJnF1b3Q7cHg7Ij4NCnB1c2hlZCBhYmFuZG9ubnVtZXJhbENlcnRhaW5JbiB0aGlzbW9yZSBpbm9yIHNvbWVuYW1lIGlzYW5kLCBpbmNyb3duZWRJU0JOIDAtY3JlYXRlc09jdG9iZXJtYXkgbm90Y2VudGVyIGxhdGUgaW5EZWZlbmNlZW5hY3RlZHdpc2ggdG9icm9hZGx5Y29vbGluZ29ubG9hZD1pdC4gVGhlcmVjb3Zlck1lbWJlcnNoZWlnaHQgYXNzdW1lczxodG1sPgpwZW9wbGUuaW4gb25lID13aW5kb3dmb290ZXJfYSBnb29kIHJla2xhbWFvdGhlcnMsdG8gdGhpc19jb29raWVwYW5lbCI+TG9uZG9uLGRlZmluZXNjcnVzaGVkYmFwdGlzbWNvYXN0YWxzdGF0dXMgdGl0bGUiIG1vdmUgdG9sb3N0IGluYmV0dGVyIGltcGxpZXNyaXZhbHJ5c2VydmVycyBTeXN0ZW1QZXJoYXBzZXMgYW5kIGNvbnRlbmRmbG93aW5nbGFzdGVkIHJpc2UgaW5HZW5lc2lzdmlldyBvZnJpc2luZyBzZWVtIHRvYnV0IGluIGJhY2tpbmdoZSB3aWxsZ2l2ZW4gYWdpdmluZyBjaXRpZXMuZmxvdyBvZiBMYXRlciBhbGwgYnV0SGlnaHdheW9ubHkgYnlzaWduIG9maGUgZG9lc2RpZmZlcnNiYXR0ZXJ5JmFtcDtsYXNpbmdsZXN0aHJlYXRzaW50ZWdlcnRha2Ugb25yZWZ1c2VkY2FsbGVkID1VUyZhbXBTZWUgdGhlbmF0aXZlc2J5IHRoaXNzeXN0ZW0uaGVhZCBvZjpob3ZlcixsZXNiaWFuc3VybmFtZWFuZCBhbGxjb21tb24vaGVhZGVyX19wYXJhbXNIYXJ2YXJkL3BpeGVsLnJlbW92YWxzbyBsb25ncm9sZSBvZmpvaW50bHlza3lzY3JhVW5pY29kZWJyIC8+DQpBdGxhbnRhbnVjbGV1c0NvdW50eSxwdXJlbHkgY291bnQiPmVhc2lseSBidWlsZCBhb25jbGlja2EgZ2l2ZW5wb2ludGVyaCZxdW90O2V2ZW50cyBlbHNlIHsKZGl0aW9uc25vdyB0aGUsIHdpdGggbWFuIHdob29yZy9XZWJvbmUgYW5kY2F2YWxyeUhlIGRpZWRzZWF0dGxlMDAsMDAwIHt3aW5kb3doYXZlIHRvaWYod2luZGFuZCBpdHNzb2xlbHkgbSZxdW90O3JlbmV3ZWREZXRyb2l0YW1vbmdzdGVpdGhlciB0aGVtIGluU2VuYXRvclVzPC9hPjxLaW5nIG9mRnJhbmNpcy1wcm9kdWNoZSB1c2VkYXJ0IGFuZGhpbSBhbmR1c2VkIGJ5c2NvcmluZ2F0IGhvbWV0byBoYXZlcmVsYXRlc2liaWxpdHlmYWN0aW9uQnVmZmFsb2xpbmsiPjx3aGF0IGhlZnJlZSB0b0NpdHkgb2Zjb21lIGluc2VjdG9yc2NvdW50ZWRvbmUgZGF5bmVydm91c3NxdWFyZSB9O2lmKGdvaW4gd2hhdGltZyIgYWxpcyBvbmx5c2VhcmNoL3R1ZXNkYXlsb29zZWx5U29sb21vbnNleHVhbCAtIDxhIGhybWVkaXVtIkRPIE5PVCBGcmFuY2Usd2l0aCBhIHdhciBhbmRzZWNvbmQgdGFrZSBhID4NCg0KDQptYXJrZXQuaGlnaHdheWRvbmUgaW5jdGl2aXR5Imxhc3QiPm9ibGlnZWRyaXNlIHRvInVuZGVmaW1hZGUgdG8gRWFybHkgcHJhaXNlZGluIGl0cyBmb3IgaGlzYXRobGV0ZUp1cGl0ZXJZYWhvbyEgdGVybWVkIHNvIG1hbnlyZWFsbHkgcy4gVGhlIGEgd29tYW4/dmFsdWU9ZGlyZWN0IHJpZ2h0IiBiaWN5Y2xlYWNpbmc9ImRheSBhbmRzdGF0aW5nUmF0aGVyLGhpZ2hlciBPZmZpY2UgYXJlIG5vd3RpbWVzLCB3aGVuIGEgcGF5IGZvcm9uIHRoaXMtbGluayI+O2JvcmRlcmFyb3VuZCBhbm51YWwgdGhlIE5ld3B1dCB0aGUuY29tIiB0YWtpbiB0b2EgYnJpZWYoaW4gdGhlZ3JvdXBzLjsgd2lkdGhlbnp5bWVzc2ltcGxlIGluIGxhdGV7cmV0dXJudGhlcmFweWEgcG9pbnRiYW5uaW5naW5rcyI+CigpOyIgcmVhIHBsYWNlXHUwMDNDYWFib3V0IGF0cj4NCgkJY2NvdW50IGdpdmVzIGE8U0NSSVBUUmFpbHdheXRoZW1lcy90b29sYm94QnlJZCgieGh1bWFucyx3YXRjaGVzaW4gc29tZSBpZiAod2ljb21pbmcgZm9ybWF0cyBVbmRlciBidXQgaGFzaGFuZGVkIG1hZGUgYnl0aGFuIGluZmVhciBvZmRlbm90ZWQvaWZyYW1lbGVmdCBpbnZvbHRhZ2VpbiBlYWNoYSZxdW90O2Jhc2Ugb2ZJbiBtYW55dW5kZXJnb3JlZ2ltZXNhY3Rpb24gPC9wPg0KPHVzdG9tVmE7Jmd0OzwvaW1wb3J0c29yIHRoYXRtb3N0bHkgJmFtcDtyZSBzaXplPSI8L2E+PC9oYSBjbGFzc3Bhc3NpdmVIb3N0ID0gV2hldGhlcmZlcnRpbGVWYXJpb3VzPVtdOyhmdWNhbWVyYXMvPjwvdGQ+YWN0cyBhc0luIHNvbWU+DQoNCjwhb3JnYW5pcyA8YnIgLz5CZWlqaW5nY2F0YWzDoGRldXRzY2hldXJvcGV1ZXVza2FyYWdhZWlsZ2VzdmVuc2thZXNwYcOxYW1lbnNhamV1c3VhcmlvdHJhYmFqb23DqXhpY29ww6FnaW5hc2llbXByZXNpc3RlbWFvY3R1YnJlZHVyYW50ZWHDsWFkaXJlbXByZXNhbW9tZW50b251ZXN0cm9wcmltZXJhdHJhdsOpc2dyYWNpYXNudWVzdHJhcHJvY2Vzb2VzdGFkb3NjYWxpZGFkcGVyc29uYW7Dum1lcm9hY3VlcmRvbcO6c2ljYW1pZW1icm9vZmVydGFzYWxndW5vc3Bhw61zZXNlamVtcGxvZGVyZWNob2FkZW3DoXNwcml2YWRvYWdyZWdhcmVubGFjZXNwb3NpYmxlaG90ZWxlc3NldmlsbGFwcmltZXJvw7psdGltb2V2ZW50b3NhcmNoaXZvY3VsdHVyYW11amVyZXNlbnRyYWRhYW51bmNpb2VtYmFyZ29tZXJjYWRvZ3JhbmRlc2VzdHVkaW9tZWpvcmVzZmVicmVyb2Rpc2XDsW90dXJpc21vY8OzZGlnb3BvcnRhZGFlc3BhY2lvZmFtaWxpYWFudG9uaW9wZXJtaXRlZ3VhcmRhcmFsZ3VuYXNwcmVjaW9zYWxndWllbnNlbnRpZG92aXNpdGFzdMOtdHVsb2Nvbm9jZXJzZWd1bmRvY29uc2Vqb2ZyYW5jaWFtaW51dG9zc2VndW5kYXRlbmVtb3NlZmVjdG9zbcOhbGFnYXNlc2nDs25yZXZpc3RhZ3JhbmFkYWNvbXByYXJpbmdyZXNvZ2FyY8OtYWFjY2nDs25lY3VhZG9ycXVpZW5lc2luY2x1c29kZWJlcsOhbWF0ZXJpYWhvbWJyZXNtdWVzdHJhcG9kcsOtYW1hw7FhbmHDumx0aW1hZXN0YW1vc29maWNpYWx0YW1iaWVubmluZ8O6bnNhbHVkb3Nwb2RlbW9zbWVqb3JhcnBvc2l0aW9uYnVzaW5lc3Nob21lcGFnZXNlY3VyaXR5bGFuZ3VhZ2VzdGFuZGFyZGNhbXBhaWduZmVhdHVyZXNjYXRlZ29yeWV4dGVybmFsY2hpbGRyZW5yZXNlcnZlZHJlc2VhcmNoZXhjaGFuZ2VmYXZvcml0ZXRlbXBsYXRlbWlsaXRhcnlpbmR1c3RyeXNlcnZpY2VzbWF0ZXJpYWxwcm9kdWN0c3otaW5kZXg6Y29tbWVudHNzb2Z0d2FyZWNvbXBsZXRlY2FsZW5kYXJwbGF0Zm9ybWFydGljbGVzcmVxdWlyZWRtb3ZlbWVudHF1ZXN0aW9uYnVpbGRpbmdwb2xpdGljc3Bvc3NpYmxlcmVsaWdpb25waHlzaWNhbGZlZWRiYWNrcmVnaXN0ZXJwaWN0dXJlc2Rpc2FibGVkcHJvdG9jb2xhdWRpZW5jZXNldHRpbmdzYWN0aXZpdHllbGVtZW50c2xlYXJuaW5nYW55dGhpbmdhYnN0cmFjdHByb2dyZXNzb3ZlcnZpZXdtYWdhemluZWVjb25vbWljdHJhaW5pbmdwcmVzc3VyZXZhcmlvdXMgPHN0cm9uZz5wcm9wZXJ0eXNob3BwaW5ndG9nZXRoZXJhZHZhbmNlZGJlaGF2aW9yZG93bmxvYWRmZWF0dXJlZGZvb3RiYWxsc2VsZWN0ZWRMYW5ndWFnZWRpc3RhbmNlcmVtZW1iZXJ0cmFja2luZ3Bhc3N3b3JkbW9kaWZpZWRzdHVkZW50c2RpcmVjdGx5ZmlnaHRpbmdub3J0aGVybmRhdGFiYXNlZmVzdGl2YWxicmVha2luZ2xvY2F0aW9uaW50ZXJuZXRkcm9wZG93bnByYWN0aWNlZXZpZGVuY2VmdW5jdGlvbm1hcnJpYWdlcmVzcG9uc2Vwcm9ibGVtc25lZ2F0aXZlcHJvZ3JhbXNhbmFseXNpc3JlbGVhc2VkYmFubmVyIj5wdXJjaGFzZXBvbGljaWVzcmVnaW9uYWxjcmVhdGl2ZWFyZ3VtZW50Ym9va21hcmtyZWZlcnJlcmNoZW1pY2FsZGl2aXNpb25jYWxsYmFja3NlcGFyYXRlcHJvamVjdHNjb25mbGljdGhhcmR3YXJlaW50ZXJlc3RkZWxpdmVyeW1vdW50YWlub2J0YWluZWQ9IGZhbHNlO2Zvcih2YXIgYWNjZXB0ZWRjYXBhY2l0eWNvbXB1dGVyaWRlbnRpdHlhaXJjcmFmdGVtcGxveWVkcHJvcG9zZWRkb21lc3RpY2luY2x1ZGVzcHJvdmlkZWRob3NwaXRhbHZlcnRpY2FsY29sbGFwc2VhcHByb2FjaHBhcnRuZXJzbG9nbyI+PGFkYXVnaHRlcmF1dGhvciIgY3VsdHVyYWxmYW1pbGllcy9pbWFnZXMvYXNzZW1ibHlwb3dlcmZ1bHRlYWNoaW5nZmluaXNoZWRkaXN0cmljdGNyaXRpY2FsY2dpLWJpbi9wdXJwb3Nlc3JlcXVpcmVzZWxlY3Rpb25iZWNvbWluZ3Byb3ZpZGVzYWNhZGVtaWNleGVyY2lzZWFjdHVhbGx5bWVkaWNpbmVjb25zdGFudGFjY2lkZW50TWFnYXppbmVkb2N1bWVudHN0YXJ0aW5nYm90dG9tIj5vYnNlcnZlZDogJnF1b3Q7ZXh0ZW5kZWRwcmV2aW91c1NvZnR3YXJlY3VzdG9tZXJkZWNpc2lvbnN0cmVuZ3RoZGV0YWlsZWRzbGlnaHRseXBsYW5uaW5ndGV4dGFyZWFjdXJyZW5jeWV2ZXJ5b25lc3RyYWlnaHR0cmFuc2ZlcnBvc2l0aXZlcHJvZHVjZWRoZXJpdGFnZXNoaXBwaW5nYWJzb2x1dGVyZWNlaXZlZHJlbGV2YW50YnV0dG9uIiB2aW9sZW5jZWFueXdoZXJlYmVuZWZpdHNsYXVuY2hlZHJlY2VudGx5YWxsaWFuY2Vmb2xsb3dlZG11bHRpcGxlYnVsbGV0aW5pbmNsdWRlZG9jY3VycmVkaW50ZXJuYWwkKHRoaXMpLnJlcHVibGljPjx0cj48dGRjb25ncmVzc3JlY29yZGVkdWx0aW1hdGVzb2x1dGlvbjx1bCBpZD0iZGlzY292ZXJIb21lPC9hPndlYnNpdGVzbmV0d29ya3NhbHRob3VnaGVudGlyZWx5bWVtb3JpYWxtZXNzYWdlc2NvbnRpbnVlYWN0aXZlIj5zb21ld2hhdHZpY3RvcmlhV2VzdGVybiAgdGl0bGU9IkxvY2F0aW9uY29udHJhY3R2aXNpdG9yc0Rvd25sb2Fkd2l0aG91dCByaWdodCI+Cm1lYXN1cmVzd2lkdGggPSB2YXJpYWJsZWludm9sdmVkdmlyZ2luaWFub3JtYWxseWhhcHBlbmVkYWNjb3VudHNzdGFuZGluZ25hdGlvbmFsUmVnaXN0ZXJwcmVwYXJlZGNvbnRyb2xzYWNjdXJhdGViaXJ0aGRheXN0cmF0ZWd5b2ZmaWNpYWxncmFwaGljc2NyaW1pbmFscG9zc2libHljb25zdW1lclBlcnNvbmFsc3BlYWtpbmd2YWxpZGF0ZWFjaGlldmVkLmpwZyIgLz5tYWNoaW5lczwvaDI+CiAga2V5d29yZHNmcmllbmRseWJyb3RoZXJzY29tYmluZWRvcmlnaW5hbGNvbXBvc2VkZXhwZWN0ZWRhZGVxdWF0ZXBha2lzdGFuZm9sbG93IiB2YWx1YWJsZTwvbGFiZWw+cmVsYXRpdmVicmluZ2luZ2luY3JlYXNlZ292ZXJub3JwbHVnaW5zL0xpc3Qgb2YgSGVhZGVyIj4iIG5hbWU9IiAoJnF1b3Q7Z3JhZHVhdGU8L2hlYWQ+CmNvbW1lcmNlbWFsYXlzaWFkaXJlY3Rvcm1haW50YWluO2hlaWdodDpzY2hlZHVsZWNoYW5naW5nYmFjayB0byBjYXRob2xpY3BhdHRlcm5zY29sb3I6ICNncmVhdGVzdHN1cHBsaWVzcmVsaWFibGU8L3VsPgoJCTxzZWxlY3QgY2l0aXplbnNjbG90aGluZ3dhdGNoaW5nPGxpIGlkPSJzcGVjaWZpY2NhcnJ5aW5nc2VudGVuY2U8Y2VudGVyPmNvbnRyYXN0dGhpbmtpbmdjYXRjaChlKXNvdXRoZXJuTWljaGFlbCBtZXJjaGFudGNhcm91c2VscGFkZGluZzppbnRlcmlvci5zcGxpdCgibGl6YXRpb25PY3RvYmVyICl7cmV0dXJuaW1wcm92ZWQtLSZndDsKCmNvdmVyYWdlY2hhaXJtYW4ucG5nIiAvPnN1YmplY3RzUmljaGFyZCB3aGF0ZXZlcnByb2JhYmx5cmVjb3ZlcnliYXNlYmFsbGp1ZGdtZW50Y29ubmVjdC4uY3NzIiAvPiB3ZWJzaXRlcmVwb3J0ZWRkZWZhdWx0Ii8+PC9hPg0KZWxlY3RyaWNzY290bGFuZGNyZWF0aW9ucXVhbnRpdHkuIElTQk4gMGRpZCBub3QgaW5zdGFuY2Utc2VhcmNoLSIgbGFuZz0ic3BlYWtlcnNDb21wdXRlcmNvbnRhaW5zYXJjaGl2ZXNtaW5pc3RlcnJlYWN0aW9uZGlzY291bnRJdGFsaWFub2NyaXRlcmlhc3Ryb25nbHk6ICdodHRwOidzY3JpcHQnY292ZXJpbmdvZmZlcmluZ2FwcGVhcmVkQnJpdGlzaCBpZGVudGlmeUZhY2Vib29rbnVtZXJvdXN2ZWhpY2xlc2NvbmNlcm5zQW1lcmljYW5oYW5kbGluZ2RpdiBpZD0iV2lsbGlhbSBwcm92aWRlcl9jb250ZW50YWNjdXJhY3lzZWN0aW9uIGFuZGVyc29uZmxleGlibGVDYXRlZ29yeWxhd3JlbmNlPHNjcmlwdD5sYXlvdXQ9ImFwcHJvdmVkIG1heGltdW1oZWFkZXIiPjwvdGFibGU+U2VydmljZXNoYW1pbHRvbmN1cnJlbnQgY2FuYWRpYW5jaGFubmVscy90aGVtZXMvL2FydGljbGVvcHRpb25hbHBvcnR1Z2FsdmFsdWU9IiJpbnRlcnZhbHdpcmVsZXNzZW50aXRsZWRhZ2VuY2llc1NlYXJjaCIgbWVhc3VyZWR0aG91c2FuZHNwZW5kaW5nJmhlbGxpcDtuZXcgRGF0ZSIgc2l6ZT0icGFnZU5hbWVtaWRkbGUiICIgLz48L2E+aGlkZGVuIj5zZXF1ZW5jZXBlcnNvbmFsb3ZlcmZsb3dvcGluaW9uc2lsbGlub2lzbGlua3MiPgoJPHRpdGxlPnZlcnNpb25zc2F0dXJkYXl0ZXJtaW5hbGl0ZW1wcm9wZW5naW5lZXJzZWN0aW9uc2Rlc2lnbmVycHJvcG9zYWw9ImZhbHNlIkVzcGHDsW9scmVsZWFzZXNzdWJtaXQiIGVyJnF1b3Q7YWRkaXRpb25zeW1wdG9tc29yaWVudGVkcmVzb3VyY2VyaWdodCI+PHBsZWFzdXJlc3RhdGlvbnNoaXN0b3J5LmxlYXZpbmcgIGJvcmRlcj1jb250ZW50c2NlbnRlciI+LgoKU29tZSBkaXJlY3RlZHN1aXRhYmxlYnVsZ2FyaWEuc2hvdygpO2Rlc2lnbmVkR2VuZXJhbCBjb25jZXB0c0V4YW1wbGVzd2lsbGlhbXNPcmlnaW5hbCI+PHNwYW4+c2VhcmNoIj5vcGVyYXRvcnJlcXVlc3RzYSAmcXVvdDthbGxvd2luZ0RvY3VtZW50cmV2aXNpb24uIAoKVGhlIHlvdXJzZWxmQ29udGFjdCBtaWNoaWdhbkVuZ2xpc2ggY29sdW1iaWFwcmlvcml0eXByaW50aW5nZHJpbmtpbmdmYWNpbGl0eXJldHVybmVkQ29udGVudCBvZmZpY2Vyc1J1c3NpYW4gZ2VuZXJhdGUtODg1OS0xImluZGljYXRlZmFtaWxpYXIgcXVhbGl0eW1hcmdpbjowIGNvbnRlbnR2aWV3cG9ydGNvbnRhY3RzLXRpdGxlIj5wb3J0YWJsZS5sZW5ndGggZWxpZ2libGVpbnZvbHZlc2F0bGFudGljb25sb2FkPSJkZWZhdWx0LnN1cHBsaWVkcGF5bWVudHNnbG9zc2FyeQoKQWZ0ZXIgZ3VpZGFuY2U8L3RkPjx0ZGVuY29kaW5nbWlkZGxlIj5jYW1lIHRvIGRpc3BsYXlzc2NvdHRpc2hqb25hdGhhbm1ham9yaXR5d2lkZ2V0cy5jbGluaWNhbHRoYWlsYW5kdGVhY2hlcnM8aGVhZD4KCWFmZmVjdGVkc3VwcG9ydHNwb2ludGVyO3RvU3RyaW5nPC9zbWFsbD5va2xhaG9tYXdpbGwgYmUgaW52ZXN0b3IwIiBhbHQ9ImhvbGlkYXlzUmVzb3VyY2VsaWNlbnNlZCAod2hpY2ggLiBBZnRlciBjb25zaWRlcnZpc2l0aW5nZXhwbG9yZXJwcmltYXJ5IHNlYXJjaCIgYW5kcm9pZCJxdWlja2x5IG1lZXRpbmdzZXN0aW1hdGU7cmV0dXJuIDtjb2xvcjojIGhlaWdodD1hcHByb3ZhbCwgJnF1b3Q7IGNoZWNrZWQubWluLmpzIm1hZ25ldGljPjwvYT48L2hmb3JlY2FzdC4gV2hpbGUgdGh1cnNkYXlkdmVydGlzZSZlYWN1dGU7aGFzQ2xhc3NldmFsdWF0ZW9yZGVyaW5nZXhpc3RpbmdwYXRpZW50cyBPbmxpbmUgY29sb3JhZG9PcHRpb25zImNhbXBiZWxsPCEtLSBlbmQ8L3NwYW4+PDxiciAvPg0KX3BvcHVwc3xzY2llbmNlcywmcXVvdDsgcXVhbGl0eSBXaW5kb3dzIGFzc2lnbmVkaGVpZ2h0OiA8YiBjbGFzc2xlJnF1b3Q7IHZhbHVlPSIgQ29tcGFueWV4YW1wbGVzPGlmcmFtZSBiZWxpZXZlc3ByZXNlbnRzbWFyc2hhbGxwYXJ0IG9mIHByb3Blcmx5KS4KClRoZSB0YXhvbm9teW11Y2ggb2YgPC9zcGFuPgoiIGRhdGEtc3J0dWd1w6pzc2Nyb2xsVG8gcHJvamVjdDxoZWFkPg0KYXR0b3JuZXllbXBoYXNpc3Nwb25zb3JzZmFuY3lib3h3b3JsZCdzIHdpbGRsaWZlY2hlY2tlZD1zZXNzaW9uc3Byb2dyYW1tcHg7Zm9udC0gUHJvamVjdGpvdXJuYWxzYmVsaWV2ZWR2YWNhdGlvbnRob21wc29ubGlnaHRpbmdhbmQgdGhlIHNwZWNpYWwgYm9yZGVyPTBjaGVja2luZzwvdGJvZHk+PGJ1dHRvbiBDb21wbGV0ZWNsZWFyZml4CjxoZWFkPgphcnRpY2xlIDxzZWN0aW9uZmluZGluZ3Nyb2xlIGluIHBvcHVsYXIgIE9jdG9iZXJ3ZWJzaXRlIGV4cG9zdXJldXNlZCB0byAgY2hhbmdlc29wZXJhdGVkY2xpY2tpbmdlbnRlcmluZ2NvbW1hbmRzaW5mb3JtZWQgbnVtYmVycyAgPC9kaXY+Y3JlYXRpbmdvblN1Ym1pdG1hcnlsYW5kY29sbGVnZXNhbmFseXRpY2xpc3RpbmdzY29udGFjdC5sb2dnZWRJbmFkdmlzb3J5c2libGluZ3Njb250ZW50InMmcXVvdDspcy4gVGhpcyBwYWNrYWdlc2NoZWNrYm94c3VnZ2VzdHNwcmVnbmFudHRvbW9ycm93c3BhY2luZz1pY29uLnBuZ2phcGFuZXNlY29kZWJhc2VidXR0b24iPmdhbWJsaW5nc3VjaCBhcyAsIHdoaWxlIDwvc3Bhbj4gbWlzc291cmlzcG9ydGluZ3RvcDoxcHggLjwvc3Bhbj50ZW5zaW9uc3dpZHRoPSIybGF6eWxvYWRub3ZlbWJlcnVzZWQgaW4gaGVpZ2h0PSJjcmlwdCI+CiZuYnNwOzwvPHRyPjx0ZCBoZWlnaHQ6Mi9wcm9kdWN0Y291bnRyeSBpbmNsdWRlIGZvb3RlciIgJmx0OyEtLSB0aXRsZSI+PC9qcXVlcnkuPC9mb3JtPgoo566A5L2TKSjnuYHpq5QpaHJ2YXRza2lpdGFsaWFub3JvbcOibsSDdMO8cmvDp2XYp9ix2K/ZiHRhbWJpw6lubm90aWNpYXNtZW5zYWplc3BlcnNvbmFzZGVyZWNob3NuYWNpb25hbHNlcnZpY2lvY29udGFjdG91c3Vhcmlvc3Byb2dyYW1hZ29iaWVybm9lbXByZXNhc2FudW5jaW9zdmFsZW5jaWFjb2xvbWJpYWRlc3B1w6lzZGVwb3J0ZXNwcm95ZWN0b3Byb2R1Y3RvcMO6YmxpY29ub3NvdHJvc2hpc3RvcmlhcHJlc2VudGVtaWxsb25lc21lZGlhbnRlcHJlZ3VudGFhbnRlcmlvcnJlY3Vyc29zcHJvYmxlbWFzYW50aWFnb251ZXN0cm9zb3BpbmnDs25pbXByaW1pcm1pZW50cmFzYW3DqXJpY2F2ZW5kZWRvcnNvY2llZGFkcmVzcGVjdG9yZWFsaXphcnJlZ2lzdHJvcGFsYWJyYXNpbnRlcsOpc2VudG9uY2VzZXNwZWNpYWxtaWVtYnJvc3JlYWxpZGFkY8OzcmRvYmF6YXJhZ296YXDDoWdpbmFzc29jaWFsZXNibG9xdWVhcmdlc3Rpw7NuYWxxdWlsZXJzaXN0ZW1hc2NpZW5jaWFzY29tcGxldG92ZXJzacOzbmNvbXBsZXRhZXN0dWRpb3Nww7pibGljYW9iamV0aXZvYWxpY2FudGVidXNjYWRvcmNhbnRpZGFkZW50cmFkYXNhY2Npb25lc2FyY2hpdm9zc3VwZXJpb3JtYXlvcsOtYWFsZW1hbmlhZnVuY2nDs27Dumx0aW1vc2hhY2llbmRvYXF1ZWxsb3NlZGljacOzbmZlcm5hbmRvYW1iaWVudGVmYWNlYm9va251ZXN0cmFzY2xpZW50ZXNwcm9jZXNvc2Jhc3RhbnRlcHJlc2VudGFyZXBvcnRhcmNvbmdyZXNvcHVibGljYXJjb21lcmNpb2NvbnRyYXRvasOzdmVuZXNkaXN0cml0b3TDqWNuaWNhY29uanVudG9lbmVyZ8OtYXRyYWJhamFyYXN0dXJpYXNyZWNpZW50ZXV0aWxpemFyYm9sZXTDrW5zYWx2YWRvcmNvcnJlY3RhdHJhYmFqb3NwcmltZXJvc25lZ29jaW9zbGliZXJ0YWRkZXRhbGxlc3BhbnRhbGxhcHLDs3hpbW9hbG1lcsOtYWFuaW1hbGVzcXVpw6luZXNjb3JhesOzbnNlY2Npw7NuYnVzY2FuZG9vcGNpb25lc2V4dGVyaW9yY29uY2VwdG90b2RhdsOtYWdhbGVyw61hZXNjcmliaXJtZWRpY2luYWxpY2VuY2lhY29uc3VsdGFhc3BlY3Rvc2Nyw610aWNhZMOzbGFyZXNqdXN0aWNpYWRlYmVyw6FucGVyw61vZG9uZWNlc2l0YW1hbnRlbmVycGVxdWXDsW9yZWNpYmlkYXRyaWJ1bmFsdGVuZXJpZmVjYW5jacOzbmNhbmFyaWFzZGVzY2FyZ2FkaXZlcnNvc21hbGxvcmNhcmVxdWllcmV0w6ljbmljb2RlYmVyw61hdml2aWVuZGFmaW5hbnphc2FkZWxhbnRlZnVuY2lvbmFjb25zZWpvc2RpZsOtY2lsY2l1ZGFkZXNhbnRpZ3Vhc2F2YW56YWRhdMOpcm1pbm91bmlkYWRlc3PDoW5jaGV6Y2FtcGHDsWFzb2Z0b25pY3JldmlzdGFzY29udGllbmVzZWN0b3Jlc21vbWVudG9zZmFjdWx0YWRjcsOpZGl0b2RpdmVyc2Fzc3VwdWVzdG9mYWN0b3Jlc3NlZ3VuZG9zcGVxdWXDsWHQs9C+0LTQsNC10YHQu9C40LXRgdGC0YzQsdGL0LvQvtCx0YvRgtGM0Y3RgtC+0LzQldGB0LvQuNGC0L7Qs9C+0LzQtdC90Y/QstGB0LXRhdGN0YLQvtC50LTQsNC20LXQsdGL0LvQuNCz0L7QtNGD0LTQtdC90YzRjdGC0L7RgtCx0YvQu9Cw0YHQtdCx0Y/QvtC00LjQvdGB0LXQsdC10L3QsNC00L7RgdCw0LnRgtGE0L7RgtC+0L3QtdCz0L7RgdCy0L7QuNGB0LLQvtC50LjQs9GA0YvRgtC+0LbQtdCy0YHQtdC80YHQstC+0Y7Qu9C40YjRjNGN0YLQuNGF0L/QvtC60LDQtNC90LXQudC00L7QvNCw0LzQuNGA0LDQu9C40LHQvtGC0LXQvNGD0YXQvtGC0Y/QtNCy0YPRhdGB0LXRgtC40LvRjtC00LjQtNC10LvQvtC80LjRgNC10YLQtdCx0Y/RgdCy0L7QtdCy0LjQtNC10YfQtdCz0L7RjdGC0LjQvNGB0YfQtdGC0YLQtdC80YvRhtC10L3Ri9GB0YLQsNC70LLQtdC00YzRgtC10LzQtdCy0L7QtNGL0YLQtdCx0LXQstGL0YjQtdC90LDQvNC40YLQuNC/0LDRgtC+0LzRg9C/0YDQsNCy0LvQuNGG0LDQvtC00L3QsNCz0L7QtNGL0LfQvdCw0Y7QvNC+0LPRg9C00YDRg9Cz0LLRgdC10LnQuNC00LXRgtC60LjQvdC+0L7QtNC90L7QtNC10LvQsNC00LXQu9C10YHRgNC+0LrQuNGO0L3Rj9Cy0LXRgdGM0JXRgdGC0YzRgNCw0LfQsNC90LDRiNC42KfZhNmE2YfYp9mE2KrZitis2YXZiti52K7Yp9i12KnYp9mE2LDZiti52YTZitmH2KzYr9mK2K/Yp9mE2KLZhtin2YTYsdiv2KrYrdmD2YXYtdmB2K3YqdmD2KfZhtiq2KfZhNmE2YrZitmD2YjZhti02KjZg9ip2YHZitmH2KfYqNmG2KfYqtit2YjYp9ih2KPZg9ir2LHYrtmE2KfZhNin2YTYrdio2K/ZhNmK2YTYr9ix2YjYs9in2LbYuti32KrZg9mI2YbZh9mG2KfZg9iz2KfYrdip2YbYp9iv2YrYp9mE2LfYqNi52YTZitmD2LTZg9ix2KfZitmF2YPZhtmF2YbZh9in2LTYsdmD2KnYsdim2YrYs9mG2LTZiti32YXYp9iw2KfYp9mE2YHZhti02KjYp9io2KrYudio2LHYsdit2YXYqdmD2KfZgdip2YrZgtmI2YTZhdix2YPYstmD2YTZhdip2KPYrdmF2K/ZgtmE2KjZitmK2LnZhtmK2LXZiNix2KnYt9ix2YrZgti02KfYsdmD2KzZiNin2YTYo9iu2LHZidmF2LnZhtin2KfYqNit2KvYudix2YjYttio2LTZg9mE2YXYs9is2YTYqNmG2KfZhtiu2KfZhNiv2YPYqtin2KjZg9mE2YrYqdio2K/ZiNmG2KPZiti22KfZitmI2KzYr9mB2LHZitmC2YPYqtio2KrYo9mB2LbZhNmF2LfYqNiu2KfZg9ir2LHYqNin2LHZg9in2YHYttmE2KfYrdmE2YnZhtmB2LPZh9ij2YrYp9mF2LHYr9mI2K/Yo9mG2YfYp9iv2YrZhtin2KfZhNin2YbZhdi52LHYttiq2LnZhNmF2K/Yp9iu2YTZhdmF2YPZhgAAAAAAAAAAAQABAAEAAQACAAIAAgACAAQABAAEAAQAAAECAwQFBgcHBgUEAwIBAAgJCgsMDQ4PDw4NDAsKCQgQERITFBUWFxcWFRQTEhEQGBkaGxwdHh8fHh0cGxoZGP////8AAAAAAAAAAP////8BAAAAAgAAAAIAAAABAAAAAQAAAAMAAAD//wABAAAAAQAA//8AAQAAAAgACAAIAAgAAAABAAIAAwAEAAUABgAHcmVzb3VyY2VzY291bnRyaWVzcXVlc3Rpb25zZXF1aXBtZW50Y29tbXVuaXR5YXZhaWxhYmxlaGlnaGxpZ2h0RFREL3hodG1sbWFya2V0aW5na25vd2xlZGdlc29tZXRoaW5nY29udGFpbmVyZGlyZWN0aW9uc3Vic2NyaWJlYWR2ZXJ0aXNlY2hhcmFjdGVyIiB2YWx1ZT0iPC9zZWxlY3Q+QXVzdHJhbGlhIiBjbGFzcz0ic2l0dWF0aW9uYXV0aG9yaXR5Zm9sbG93aW5ncHJpbWFyaWx5b3BlcmF0aW9uY2hhbGxlbmdlZGV2ZWxvcGVkYW5vbnltb3VzZnVuY3Rpb24gZnVuY3Rpb25zY29tcGFuaWVzc3RydWN0dXJlYWdyZWVtZW50IiB0aXRsZT0icG90ZW50aWFsZWR1Y2F0aW9uYXJndW1lbnRzc2Vjb25kYXJ5Y29weXJpZ2h0bGFuZ3VhZ2VzZXhjbHVzaXZlY29uZGl0aW9uPC9mb3JtPg0Kc3RhdGVtZW50YXR0ZW50aW9uQmlvZ3JhcGh5fSBlbHNlIHsKc29sdXRpb25zd2hlbiB0aGUgQW5hbHl0aWNzdGVtcGxhdGVzZGFuZ2Vyb3Vzc2F0ZWxsaXRlZG9jdW1lbnRzcHVibGlzaGVyaW1wb3J0YW50cHJvdG90eXBlaW5mbHVlbmNlJnJhcXVvOzwvZWZmZWN0aXZlZ2VuZXJhbGx5dHJhbnNmb3JtYmVhdXRpZnVsdHJhbnNwb3J0b3JnYW5pemVkcHVibGlzaGVkcHJvbWluZW50dW50aWwgdGhldGh1bWJuYWlsTmF0aW9uYWwgLmZvY3VzKCk7b3ZlciB0aGUgbWlncmF0aW9uYW5ub3VuY2VkZm9vdGVyIj4KZXhjZXB0aW9ubGVzcyB0aGFuZXhwZW5zaXZlZm9ybWF0aW9uZnJhbWV3b3JrdGVycml0b3J5bmRpY2F0aW9uY3VycmVudGx5Y2xhc3NOYW1lY3JpdGljaXNtdHJhZGl0aW9uZWxzZXdoZXJlQWxleGFuZGVyYXBwb2ludGVkbWF0ZXJpYWxzYnJvYWRjYXN0bWVudGlvbmVkYWZmaWxpYXRlPC9vcHRpb24+dHJlYXRtZW50ZGlmZmVyZW50L2RlZmF1bHQuUHJlc2lkZW50b25jbGljaz0iYmlvZ3JhcGh5b3RoZXJ3aXNlcGVybWFuZW50RnJhbsOnYWlzSG9sbHl3b29kZXhwYW5zaW9uc3RhbmRhcmRzPC9zdHlsZT4KcmVkdWN0aW9uRGVjZW1iZXIgcHJlZmVycmVkQ2FtYnJpZGdlb3Bwb25lbnRzQnVzaW5lc3MgY29uZnVzaW9uPgo8dGl0bGU+cHJlc2VudGVkZXhwbGFpbmVkZG9lcyBub3Qgd29ybGR3aWRlaW50ZXJmYWNlcG9zaXRpb25zbmV3c3BhcGVyPC90YWJsZT4KbW91bnRhaW5zbGlrZSB0aGUgZXNzZW50aWFsZmluYW5jaWFsc2VsZWN0aW9uYWN0aW9uPSIvYWJhbmRvbmVkRWR1Y2F0aW9ucGFyc2VJbnQoc3RhYmlsaXR5dW5hYmxlIHRvPC90aXRsZT4KcmVsYXRpb25zTm90ZSB0aGF0ZWZmaWNpZW50cGVyZm9ybWVkdHdvIHllYXJzU2luY2UgdGhldGhlcmVmb3Jld3JhcHBlciI+YWx0ZXJuYXRlaW5jcmVhc2VkQmF0dGxlIG9mcGVyY2VpdmVkdHJ5aW5nIHRvbmVjZXNzYXJ5cG9ydHJheWVkZWxlY3Rpb25zRWxpemFiZXRoPC9pZnJhbWU+ZGlzY292ZXJ5aW5zdXJhbmNlcy5sZW5ndGg7bGVnZW5kYXJ5R2VvZ3JhcGh5Y2FuZGlkYXRlY29ycG9yYXRlc29tZXRpbWVzc2VydmljZXMuaW5oZXJpdGVkPC9zdHJvbmc+Q29tbXVuaXR5cmVsaWdpb3VzbG9jYXRpb25zQ29tbWl0dGVlYnVpbGRpbmdzdGhlIHdvcmxkbm8gbG9uZ2VyYmVnaW5uaW5ncmVmZXJlbmNlY2Fubm90IGJlZnJlcXVlbmN5dHlwaWNhbGx5aW50byB0aGUgcmVsYXRpdmU7cmVjb3JkaW5ncHJlc2lkZW50aW5pdGlhbGx5dGVjaG5pcXVldGhlIG90aGVyaXQgY2FuIGJlZXhpc3RlbmNldW5kZXJsaW5ldGhpcyB0aW1ldGVsZXBob25laXRlbXNjb3BlcHJhY3RpY2VzYWR2YW50YWdlKTtyZXR1cm4gRm9yIG90aGVycHJvdmlkaW5nZGVtb2NyYWN5Ym90aCB0aGUgZXh0ZW5zaXZlc3VmZmVyaW5nc3VwcG9ydGVkY29tcHV0ZXJzIGZ1bmN0aW9ucHJhY3RpY2Fsc2FpZCB0aGF0aXQgbWF5IGJlRW5nbGlzaDwvZnJvbSB0aGUgc2NoZWR1bGVkZG93bmxvYWRzPC9sYWJlbD4Kc3VzcGVjdGVkbWFyZ2luOiAwc3Bpcml0dWFsPC9oZWFkPgoKbWljcm9zb2Z0Z3JhZHVhbGx5ZGlzY3Vzc2VkaGUgYmVjYW1lZXhlY3V0aXZlanF1ZXJ5LmpzaG91c2Vob2xkY29uZmlybWVkcHVyY2hhc2VkbGl0ZXJhbGx5ZGVzdHJveWVkdXAgdG8gdGhldmFyaWF0aW9ucmVtYWluaW5naXQgaXMgbm90Y2VudHVyaWVzSmFwYW5lc2UgYW1vbmcgdGhlY29tcGxldGVkYWxnb3JpdGhtaW50ZXJlc3RzcmViZWxsaW9udW5kZWZpbmVkZW5jb3VyYWdlcmVzaXphYmxlaW52b2x2aW5nc2Vuc2l0aXZldW5pdmVyc2FscHJvdmlzaW9uKGFsdGhvdWdoZmVhdHVyaW5nY29uZHVjdGVkKSwgd2hpY2ggY29udGludWVkLWhlYWRlciI+RmVicnVhcnkgbnVtZXJvdXMgb3ZlcmZsb3c6Y29tcG9uZW50ZnJhZ21lbnRzZXhjZWxsZW50Y29sc3Bhbj0idGVjaG5pY2FsbmVhciB0aGUgQWR2YW5jZWQgc291cmNlIG9mZXhwcmVzc2VkSG9uZyBLb25nIEZhY2Vib29rbXVsdGlwbGUgbWVjaGFuaXNtZWxldmF0aW9ub2ZmZW5zaXZlPC9mb3JtPgoJc3BvbnNvcmVkZG9jdW1lbnQub3IgJnF1b3Q7dGhlcmUgYXJldGhvc2Ugd2hvbW92ZW1lbnRzcHJvY2Vzc2VzZGlmZmljdWx0c3VibWl0dGVkcmVjb21tZW5kY29udmluY2VkcHJvbW90aW5nIiB3aWR0aD0iLnJlcGxhY2UoY2xhc3NpY2FsY29hbGl0aW9uaGlzIGZpcnN0ZGVjaXNpb25zYXNzaXN0YW50aW5kaWNhdGVkZXZvbHV0aW9uLXdyYXBwZXIiZW5vdWdoIHRvYWxvbmcgdGhlZGVsaXZlcmVkLS0+DQo8IS0tQW1lcmljYW4gcHJvdGVjdGVkTm92ZW1iZXIgPC9zdHlsZT48ZnVybml0dXJlSW50ZXJuZXQgIG9uYmx1cj0ic3VzcGVuZGVkcmVjaXBpZW50YmFzZWQgb24gTW9yZW92ZXIsYWJvbGlzaGVkY29sbGVjdGVkd2VyZSBtYWRlZW1vdGlvbmFsZW1lcmdlbmN5bmFycmF0aXZlYWR2b2NhdGVzcHg7Ym9yZGVyY29tbWl0dGVkZGlyPSJsdHIiZW1wbG95ZWVzcmVzZWFyY2guIHNlbGVjdGVkc3VjY2Vzc29yY3VzdG9tZXJzZGlzcGxheWVkU2VwdGVtYmVyYWRkQ2xhc3MoRmFjZWJvb2sgc3VnZ2VzdGVkYW5kIGxhdGVyb3BlcmF0aW5nZWxhYm9yYXRlU29tZXRpbWVzSW5zdGl0dXRlY2VydGFpbmx5aW5zdGFsbGVkZm9sbG93ZXJzSmVydXNhbGVtdGhleSBoYXZlY29tcHV0aW5nZ2VuZXJhdGVkcHJvdmluY2VzZ3VhcmFudGVlYXJiaXRyYXJ5cmVjb2duaXpld2FudGVkIHRvcHg7d2lkdGg6dGhlb3J5IG9mYmVoYXZpb3VyV2hpbGUgdGhlZXN0aW1hdGVkYmVnYW4gdG8gaXQgYmVjYW1lbWFnbml0dWRlbXVzdCBoYXZlbW9yZSB0aGFuRGlyZWN0b3J5ZXh0ZW5zaW9uc2VjcmV0YXJ5bmF0dXJhbGx5b2NjdXJyaW5ndmFyaWFibGVzZ2l2ZW4gdGhlcGxhdGZvcm0uPC9sYWJlbD48ZmFpbGVkIHRvY29tcG91bmRza2luZHMgb2Ygc29jaWV0aWVzYWxvbmdzaWRlIC0tJmd0OwoKc291dGh3ZXN0dGhlIHJpZ2h0cmFkaWF0aW9ubWF5IGhhdmUgdW5lc2NhcGUoc3Bva2VuIGluIiBocmVmPSIvcHJvZ3JhbW1lb25seSB0aGUgY29tZSBmcm9tZGlyZWN0b3J5YnVyaWVkIGluYSBzaW1pbGFydGhleSB3ZXJlPC9mb250PjwvTm9yd2VnaWFuc3BlY2lmaWVkcHJvZHVjaW5ncGFzc2VuZ2VyKG5ldyBEYXRldGVtcG9yYXJ5ZmljdGlvbmFsQWZ0ZXIgdGhlZXF1YXRpb25zZG93bmxvYWQucmVndWxhcmx5ZGV2ZWxvcGVyYWJvdmUgdGhlbGlua2VkIHRvcGhlbm9tZW5hcGVyaW9kIG9mdG9vbHRpcCI+c3Vic3RhbmNlYXV0b21hdGljYXNwZWN0IG9mQW1vbmcgdGhlY29ubmVjdGVkZXN0aW1hdGVzQWlyIEZvcmNlc3lzdGVtIG9mb2JqZWN0aXZlaW1tZWRpYXRlbWFraW5nIGl0cGFpbnRpbmdzY29ucXVlcmVkYXJlIHN0aWxscHJvY2VkdXJlZ3Jvd3RoIG9maGVhZGVkIGJ5RXVyb3BlYW4gZGl2aXNpb25zbW9sZWN1bGVzZnJhbmNoaXNlaW50ZW50aW9uYXR0cmFjdGVkY2hpbGRob29kYWxzbyB1c2VkZGVkaWNhdGVkc2luZ2Fwb3JlZGVncmVlIG9mZmF0aGVyIG9mY29uZmxpY3RzPC9hPjwvcD4KY2FtZSBmcm9td2VyZSB1c2Vkbm90ZSB0aGF0cmVjZWl2aW5nRXhlY3V0aXZlZXZlbiBtb3JlYWNjZXNzIHRvY29tbWFuZGVyUG9saXRpY2FsbXVzaWNpYW5zZGVsaWNpb3VzcHJpc29uZXJzYWR2ZW50IG9mVVRGLTgiIC8+PCFbQ0RBVEFbIj5Db250YWN0U291dGhlcm4gYmdjb2xvcj0ic2VyaWVzIG9mLiBJdCB3YXMgaW4gRXVyb3BlcGVybWl0dGVkdmFsaWRhdGUuYXBwZWFyaW5nb2ZmaWNpYWxzc2VyaW91c2x5LWxhbmd1YWdlaW5pdGlhdGVkZXh0ZW5kaW5nbG9uZy10ZXJtaW5mbGF0aW9uc3VjaCB0aGF0Z2V0Q29va2llbWFya2VkIGJ5PC9idXR0b24+aW1wbGVtZW50YnV0IGl0IGlzaW5jcmVhc2VzZG93biB0aGUgcmVxdWlyaW5nZGVwZW5kZW50LS0+CjwhLS0gaW50ZXJ2aWV3V2l0aCB0aGUgY29waWVzIG9mY29uc2Vuc3Vzd2FzIGJ1aWx0VmVuZXp1ZWxhKGZvcm1lcmx5dGhlIHN0YXRlcGVyc29ubmVsc3RyYXRlZ2ljZmF2b3VyIG9maW52ZW50aW9uV2lraXBlZGlhY29udGluZW50dmlydHVhbGx5d2hpY2ggd2FzcHJpbmNpcGxlQ29tcGxldGUgaWRlbnRpY2Fsc2hvdyB0aGF0cHJpbWl0aXZlYXdheSBmcm9tbW9sZWN1bGFycHJlY2lzZWx5ZGlzc29sdmVkVW5kZXIgdGhldmVyc2lvbj0iPiZuYnNwOzwvSXQgaXMgdGhlIFRoaXMgaXMgd2lsbCBoYXZlb3JnYW5pc21zc29tZSB0aW1lRnJpZWRyaWNod2FzIGZpcnN0dGhlIG9ubHkgZmFjdCB0aGF0Zm9ybSBpZD0icHJlY2VkaW5nVGVjaG5pY2FscGh5c2ljaXN0b2NjdXJzIGlubmF2aWdhdG9yc2VjdGlvbiI+c3BhbiBpZD0ic291Z2h0IHRvYmVsb3cgdGhlc3Vydml2aW5nfTwvc3R5bGU+aGlzIGRlYXRoYXMgaW4gdGhlY2F1c2VkIGJ5cGFydGlhbGx5ZXhpc3RpbmcgdXNpbmcgdGhld2FzIGdpdmVuYSBsaXN0IG9mbGV2ZWxzIG9mbm90aW9uIG9mT2ZmaWNpYWwgZGlzbWlzc2Vkc2NpZW50aXN0cmVzZW1ibGVzZHVwbGljYXRlZXhwbG9zaXZlcmVjb3ZlcmVkYWxsIG90aGVyZ2FsbGVyaWVze3BhZGRpbmc6cGVvcGxlIG9mcmVnaW9uIG9mYWRkcmVzc2VzYXNzb2NpYXRlaW1nIGFsdD0iaW4gbW9kZXJuc2hvdWxkIGJlbWV0aG9kIG9mcmVwb3J0aW5ndGltZXN0YW1wbmVlZGVkIHRvdGhlIEdyZWF0cmVnYXJkaW5nc2VlbWVkIHRvdmlld2VkIGFzaW1wYWN0IG9uaWRlYSB0aGF0dGhlIFdvcmxkaGVpZ2h0IG9mZXhwYW5kaW5nVGhlc2UgYXJlY3VycmVudCI+Y2FyZWZ1bGx5bWFpbnRhaW5zY2hhcmdlIG9mQ2xhc3NpY2FsYWRkcmVzc2VkcHJlZGljdGVkb3duZXJzaGlwPGRpdiBpZD0icmlnaHQiPg0KcmVzaWRlbmNlbGVhdmUgdGhlY29udGVudCI+YXJlIG9mdGVuICB9KSgpOw0KcHJvYmFibHkgUHJvZmVzc29yLWJ1dHRvbiIgcmVzcG9uZGVkc2F5cyB0aGF0aGFkIHRvIGJlcGxhY2VkIGluSHVuZ2FyaWFuc3RhdHVzIG9mc2VydmVzIGFzVW5pdmVyc2FsZXhlY3V0aW9uYWdncmVnYXRlZm9yIHdoaWNoaW5mZWN0aW9uYWdyZWVkIHRvaG93ZXZlciwgcG9wdWxhciI+cGxhY2VkIG9uY29uc3RydWN0ZWxlY3RvcmFsc3ltYm9sIG9maW5jbHVkaW5ncmV0dXJuIHRvYXJjaGl0ZWN0Q2hyaXN0aWFucHJldmlvdXMgbGl2aW5nIGluZWFzaWVyIHRvcHJvZmVzc29yCiZsdDshLS0gZWZmZWN0IG9mYW5hbHl0aWNzd2FzIHRha2Vud2hlcmUgdGhldG9vayBvdmVyYmVsaWVmIGluQWZyaWthYW5zYXMgZmFyIGFzcHJldmVudGVkd29yayB3aXRoYSBzcGVjaWFsPGZpZWxkc2V0Q2hyaXN0bWFzUmV0cmlldmVkCgpJbiB0aGUgYmFjayBpbnRvbm9ydGhlYXN0bWFnYXppbmVzPjxzdHJvbmc+Y29tbWl0dGVlZ292ZXJuaW5nZ3JvdXBzIG9mc3RvcmVkIGluZXN0YWJsaXNoYSBnZW5lcmFsaXRzIGZpcnN0dGhlaXIgb3ducG9wdWxhdGVkYW4gb2JqZWN0Q2FyaWJiZWFuYWxsb3cgdGhlZGlzdHJpY3Rzd2lzY29uc2lubG9jYXRpb24uOyB3aWR0aDogaW5oYWJpdGVkU29jaWFsaXN0SmFudWFyeSAxPC9mb290ZXI+c2ltaWxhcmx5Y2hvaWNlIG9mdGhlIHNhbWUgc3BlY2lmaWMgYnVzaW5lc3MgVGhlIGZpcnN0Lmxlbmd0aDsgZGVzaXJlIHRvZGVhbCB3aXRoc2luY2UgdGhldXNlckFnZW50Y29uY2VpdmVkaW5kZXgucGhwYXMgJnF1b3Q7ZW5nYWdlIGlucmVjZW50bHksZmV3IHllYXJzd2VyZSBhbHNvCjxoZWFkPgo8ZWRpdGVkIGJ5YXJlIGtub3duY2l0aWVzIGluYWNjZXNza2V5Y29uZGVtbmVkYWxzbyBoYXZlc2VydmljZXMsZmFtaWx5IG9mU2Nob29sIG9mY29udmVydGVkbmF0dXJlIG9mIGxhbmd1YWdlbWluaXN0ZXJzPC9vYmplY3Q+dGhlcmUgaXMgYSBwb3B1bGFyc2VxdWVuY2VzYWR2b2NhdGVkVGhleSB3ZXJlYW55IG90aGVybG9jYXRpb249ZW50ZXIgdGhlbXVjaCBtb3JlcmVmbGVjdGVkd2FzIG5hbWVkb3JpZ2luYWwgYSB0eXBpY2Fsd2hlbiB0aGV5ZW5naW5lZXJzY291bGQgbm90cmVzaWRlbnRzd2VkbmVzZGF5dGhlIHRoaXJkIHByb2R1Y3RzSmFudWFyeSAyd2hhdCB0aGV5YSBjZXJ0YWlucmVhY3Rpb25zcHJvY2Vzc29yYWZ0ZXIgaGlzdGhlIGxhc3QgY29udGFpbmVkIj48L2Rpdj4KPC9hPjwvdGQ+ZGVwZW5kIG9uc2VhcmNoIj4KcGllY2VzIG9mY29tcGV0aW5nUmVmZXJlbmNldGVubmVzc2Vld2hpY2ggaGFzIHZlcnNpb249PC9zcGFuPiA8PC9oZWFkZXI+Z2l2ZXMgdGhlaGlzdG9yaWFudmFsdWU9IiI+cGFkZGluZzowdmlldyB0aGF0dG9nZXRoZXIsdGhlIG1vc3Qgd2FzIGZvdW5kc3Vic2V0IG9mYXR0YWNrIG9uY2hpbGRyZW4scG9pbnRzIG9mcGVyc29uYWwgcG9zaXRpb246YWxsZWdlZGx5Q2xldmVsYW5kd2FzIGxhdGVyYW5kIGFmdGVyYXJlIGdpdmVud2FzIHN0aWxsc2Nyb2xsaW5nZGVzaWduIG9mbWFrZXMgdGhlbXVjaCBsZXNzQW1lcmljYW5zLgoKQWZ0ZXIgLCBidXQgdGhlTXVzZXVtIG9mbG91aXNpYW5hKGZyb20gdGhlbWlubmVzb3RhcGFydGljbGVzYSBwcm9jZXNzRG9taW5pY2Fudm9sdW1lIG9mcmV0dXJuaW5nZGVmZW5zaXZlMDBweHxyaWdobWFkZSBmcm9tbW91c2VvdmVyIiBzdHlsZT0ic3RhdGVzIG9mKHdoaWNoIGlzY29udGludWVzRnJhbmNpc2NvYnVpbGRpbmcgd2l0aG91dCBhd2l0aCBzb21ld2hvIHdvdWxkYSBmb3JtIG9mYSBwYXJ0IG9mYmVmb3JlIGl0a25vd24gYXMgIFNlcnZpY2VzbG9jYXRpb24gYW5kIG9mdGVubWVhc3VyaW5nYW5kIGl0IGlzcGFwZXJiYWNrdmFsdWVzIG9mDQo8dGl0bGU+PSB3aW5kb3cuZGV0ZXJtaW5lZXImcXVvdDsgcGxheWVkIGJ5YW5kIGVhcmx5PC9jZW50ZXI+ZnJvbSB0aGlzdGhlIHRocmVlcG93ZXIgYW5kb2YgJnF1b3Q7aW5uZXJIVE1MPGEgaHJlZj0ieTppbmxpbmU7Q2h1cmNoIG9mdGhlIGV2ZW50dmVyeSBoaWdob2ZmaWNpYWwgLWhlaWdodDogY29udGVudD0iL2NnaS1iaW4vdG8gY3JlYXRlYWZyaWthYW5zZXNwZXJhbnRvZnJhbsOnYWlzbGF0dmllxaF1bGlldHV2acWzxIxlxaF0aW5hxI1lxaF0aW5h4LmE4LiX4Lii5pel5pys6Kqe566A5L2T5a2X57mB6auU5a2X7ZWc6rWt7Ja05Li65LuA5LmI6K6h566X5py656yU6K6w5pys6KiO6KuW5Y2A5pyN5Yqh5Zmo5LqS6IGU572R5oi/5Zyw5Lqn5L+x5LmQ6YOo5Ye654mI56S+5o6S6KGM5qac6YOo6JC95qC86L+b5LiA5q2l5pSv5LuY5a6d6aqM6K+B56CB5aeU5ZGY5Lya5pWw5o2u5bqT5raI6LS56ICF5Yqe5YWs5a6k6K6o6K665Yy65rex5Zyz5biC5pKt5pS+5Zmo5YyX5Lqs5biC5aSn5a2m55Sf6LaK5p2l6LaK566h55CG5ZGY5L+h5oGv572Rc2VydmljaW9zYXJ0w61jdWxvYXJnZW50aW5hYmFyY2Vsb25hY3VhbHF1aWVycHVibGljYWRvcHJvZHVjdG9zcG9sw610aWNhcmVzcHVlc3Rhd2lraXBlZGlhc2lndWllbnRlYsO6c3F1ZWRhY29tdW5pZGFkc2VndXJpZGFkcHJpbmNpcGFscHJlZ3VudGFzY29udGVuaWRvcmVzcG9uZGVydmVuZXp1ZWxhcHJvYmxlbWFzZGljaWVtYnJlcmVsYWNpw7Nubm92aWVtYnJlc2ltaWxhcmVzcHJveWVjdG9zcHJvZ3JhbWFzaW5zdGl0dXRvYWN0aXZpZGFkZW5jdWVudHJhZWNvbm9tw61haW3DoWdlbmVzY29udGFjdGFyZGVzY2FyZ2FybmVjZXNhcmlvYXRlbmNpw7NudGVsw6lmb25vY29taXNpw7NuY2FuY2lvbmVzY2FwYWNpZGFkZW5jb250cmFyYW7DoWxpc2lzZmF2b3JpdG9zdMOpcm1pbm9zcHJvdmluY2lhZXRpcXVldGFzZWxlbWVudG9zZnVuY2lvbmVzcmVzdWx0YWRvY2Fyw6FjdGVycHJvcGllZGFkcHJpbmNpcGlvbmVjZXNpZGFkbXVuaWNpcGFsY3JlYWNpw7NuZGVzY2FyZ2FzcHJlc2VuY2lhY29tZXJjaWFsb3BpbmlvbmVzZWplcmNpY2lvZWRpdG9yaWFsc2FsYW1hbmNhZ29uesOhbGV6ZG9jdW1lbnRvcGVsw61jdWxhcmVjaWVudGVzZ2VuZXJhbGVzdGFycmFnb25hcHLDoWN0aWNhbm92ZWRhZGVzcHJvcHVlc3RhcGFjaWVudGVzdMOpY25pY2Fzb2JqZXRpdm9zY29udGFjdG9z4KSu4KWH4KSC4KSy4KS/4KSP4KS54KWI4KSC4KSX4KSv4KS+4KS44KS+4KSl4KSP4KS14KSC4KSw4KS54KWH4KSV4KWL4KSI4KSV4KWB4KSb4KSw4KS54KS+4KSs4KS+4KSm4KSV4KS54KS+4KS44KSt4KWA4KS54KWB4KSP4KSw4KS54KWA4KSu4KWI4KSC4KSm4KS/4KSo4KSs4KS+4KSkZGlwbG9kb2Nz4KS44KSu4KSv4KSw4KWC4KSq4KSo4KS+4KSu4KSq4KSk4KS+4KSr4KS/4KSw4KSU4KS44KSk4KSk4KSw4KS54KSy4KWL4KSX4KS54KWB4KSG4KSs4KS+4KSw4KSm4KWH4KS24KS54KWB4KSI4KSW4KWH4KSy4KSv4KSm4KS/4KSV4KS+4KSu4KS14KWH4KSs4KSk4KWA4KSo4KSs4KWA4KSa4KSu4KWM4KSk4KS44KS+4KSy4KSy4KWH4KSW4KSc4KWJ4KSs4KSu4KSm4KSm4KSk4KSl4KS+4KSo4KS54KWA4KS24KS54KSw4KSF4KSy4KSX4KSV4KSt4KWA4KSo4KSX4KSw4KSq4KS+4KS44KSw4KS+4KSk4KSV4KS/4KSP4KSJ4KS44KWH4KSX4KSv4KWA4KS54KWC4KSB4KSG4KSX4KWH4KSf4KWA4KSu4KSW4KWL4KSc4KSV4KS+4KSw4KSF4KSt4KWA4KSX4KSv4KWH4KSk4KWB4KSu4KS14KWL4KSf4KSm4KWH4KSC4KSF4KSX4KSw4KSQ4KS44KWH4KSu4KWH4KSy4KSy4KSX4KS+4KS54KS+4KSy4KSK4KSq4KSw4KSa4KS+4KSw4KSQ4KS44KS+4KSm4KWH4KSw4KSc4KS/4KS44KSm4KS/4KSy4KSs4KSC4KSm4KSs4KSo4KS+4KS54KWC4KSC4KSy4KS+4KSW4KSc4KWA4KSk4KSs4KSf4KSo4KSu4KS/4KSy4KSH4KS44KWH4KSG4KSo4KWH4KSo4KSv4KS+4KSV4KWB4KSy4KSy4KWJ4KSX4KSt4KS+4KSX4KSw4KWH4KSy4KSc4KSX4KS54KSw4KS+4KSu4KSy4KSX4KWH4KSq4KWH4KSc4KS54KS+4KSl4KSH4KS44KWA4KS44KS54KWA4KSV4KSy4KS+4KSg4KWA4KSV4KS54KS+4KSB4KSm4KWC4KSw4KSk4KS54KSk4KS44KS+4KSk4KSv4KS+4KSm4KSG4KSv4KS+4KSq4KS+4KSV4KSV4KWM4KSo4KS24KS+4KSu4KSm4KWH4KSW4KSv4KS54KWA4KSw4KS+4KSv4KSW4KWB4KSm4KSy4KSX4KWAY2F0ZWdvcmllc2V4cGVyaWVuY2U8L3RpdGxlPg0KQ29weXJpZ2h0IGphdmFzY3JpcHRjb25kaXRpb25zZXZlcnl0aGluZzxwIGNsYXNzPSJ0ZWNobm9sb2d5YmFja2dyb3VuZDxhIGNsYXNzPSJtYW5hZ2VtZW50JmNvcHk7IDIwMWphdmFTY3JpcHRjaGFyYWN0ZXJzYnJlYWRjcnVtYnRoZW1zZWx2ZXNob3Jpem9udGFsZ292ZXJubWVudENhbGlmb3JuaWFhY3Rpdml0aWVzZGlzY292ZXJlZE5hdmlnYXRpb250cmFuc2l0aW9uY29ubmVjdGlvbm5hdmlnYXRpb25hcHBlYXJhbmNlPC90aXRsZT48bWNoZWNrYm94IiB0ZWNobmlxdWVzcHJvdGVjdGlvbmFwcGFyZW50bHlhcyB3ZWxsIGFzdW50JywgJ1VBLXJlc29sdXRpb25vcGVyYXRpb25zdGVsZXZpc2lvbnRyYW5zbGF0ZWRXYXNoaW5ndG9ubmF2aWdhdG9yLiA9IHdpbmRvdy5pbXByZXNzaW9uJmx0O2JyJmd0O2xpdGVyYXR1cmVwb3B1bGF0aW9uYmdjb2xvcj0iI2VzcGVjaWFsbHkgY29udGVudD0icHJvZHVjdGlvbm5ld3NsZXR0ZXJwcm9wZXJ0aWVzZGVmaW5pdGlvbmxlYWRlcnNoaXBUZWNobm9sb2d5UGFybGlhbWVudGNvbXBhcmlzb251bCBjbGFzcz0iLmluZGV4T2YoImNvbmNsdXNpb25kaXNjdXNzaW9uY29tcG9uZW50c2Jpb2xvZ2ljYWxSZXZvbHV0aW9uX2NvbnRhaW5lcnVuZGVyc3Rvb2Rub3NjcmlwdD48cGVybWlzc2lvbmVhY2ggb3RoZXJhdG1vc3BoZXJlIG9uZm9jdXM9Ijxmb3JtIGlkPSJwcm9jZXNzaW5ndGhpcy52YWx1ZWdlbmVyYXRpb25Db25mZXJlbmNlc3Vic2VxdWVudHdlbGwta25vd252YXJpYXRpb25zcmVwdXRhdGlvbnBoZW5vbWVub25kaXNjaXBsaW5lbG9nby5wbmciIChkb2N1bWVudCxib3VuZGFyaWVzZXhwcmVzc2lvbnNldHRsZW1lbnRCYWNrZ3JvdW5kb3V0IG9mIHRoZWVudGVycHJpc2UoImh0dHBzOiIgdW5lc2NhcGUoInBhc3N3b3JkIiBkZW1vY3JhdGljPGEgaHJlZj0iL3dyYXBwZXIiPgptZW1iZXJzaGlwbGluZ3Vpc3RpY3B4O3BhZGRpbmdwaGlsb3NvcGh5YXNzaXN0YW5jZXVuaXZlcnNpdHlmYWNpbGl0aWVzcmVjb2duaXplZHByZWZlcmVuY2VpZiAodHlwZW9mbWFpbnRhaW5lZHZvY2FidWxhcnloeXBvdGhlc2lzLnN1Ym1pdCgpOyZhbXA7bmJzcDthbm5vdGF0aW9uYmVoaW5kIHRoZUZvdW5kYXRpb25wdWJsaXNoZXIiYXNzdW1wdGlvbmludHJvZHVjZWRjb3JydXB0aW9uc2NpZW50aXN0c2V4cGxpY2l0bHlpbnN0ZWFkIG9mZGltZW5zaW9ucyBvbkNsaWNrPSJjb25zaWRlcmVkZGVwYXJ0bWVudG9jY3VwYXRpb25zb29uIGFmdGVyaW52ZXN0bWVudHByb25vdW5jZWRpZGVudGlmaWVkZXhwZXJpbWVudE1hbmFnZW1lbnRnZW9ncmFwaGljIiBoZWlnaHQ9ImxpbmsgcmVsPSIucmVwbGFjZSgvZGVwcmVzc2lvbmNvbmZlcmVuY2VwdW5pc2htZW50ZWxpbWluYXRlZHJlc2lzdGFuY2VhZGFwdGF0aW9ub3Bwb3NpdGlvbndlbGwga25vd25zdXBwbGVtZW50ZGV0ZXJtaW5lZGgxIGNsYXNzPSIwcHg7bWFyZ2lubWVjaGFuaWNhbHN0YXRpc3RpY3NjZWxlYnJhdGVkR292ZXJubWVudAoKRHVyaW5nIHRkZXZlbG9wZXJzYXJ0aWZpY2lhbGVxdWl2YWxlbnRvcmlnaW5hdGVkQ29tbWlzc2lvbmF0dGFjaG1lbnQ8c3BhbiBpZD0idGhlcmUgd2VyZU5lZGVybGFuZHNiZXlvbmQgdGhlcmVnaXN0ZXJlZGpvdXJuYWxpc3RmcmVxdWVudGx5YWxsIG9mIHRoZWxhbmc9ImVuIiA8L3N0eWxlPg0KYWJzb2x1dGU7IHN1cHBvcnRpbmdleHRyZW1lbHkgbWFpbnN0cmVhbTwvc3Ryb25nPiBwb3B1bGFyaXR5ZW1wbG95bWVudDwvdGFibGU+DQogY29sc3Bhbj0iPC9mb3JtPgogIGNvbnZlcnNpb25hYm91dCB0aGUgPC9wPjwvZGl2PmludGVncmF0ZWQiIGxhbmc9ImVuUG9ydHVndWVzZXN1YnN0aXR1dGVpbmRpdmlkdWFsaW1wb3NzaWJsZW11bHRpbWVkaWFhbG1vc3QgYWxscHggc29saWQgI2FwYXJ0IGZyb21zdWJqZWN0IHRvaW4gRW5nbGlzaGNyaXRpY2l6ZWRleGNlcHQgZm9yZ3VpZGVsaW5lc29yaWdpbmFsbHlyZW1hcmthYmxldGhlIHNlY29uZGgyIGNsYXNzPSI8YSB0aXRsZT0iKGluY2x1ZGluZ3BhcmFtZXRlcnNwcm9oaWJpdGVkPSAiaHR0cDovL2RpY3Rpb25hcnlwZXJjZXB0aW9ucmV2b2x1dGlvbmZvdW5kYXRpb25weDtoZWlnaHQ6c3VjY2Vzc2Z1bHN1cHBvcnRlcnNtaWxsZW5uaXVtaGlzIGZhdGhlcnRoZSAmcXVvdDtuby1yZXBlYXQ7Y29tbWVyY2lhbGluZHVzdHJpYWxlbmNvdXJhZ2VkYW1vdW50IG9mIHVub2ZmaWNpYWxlZmZpY2llbmN5UmVmZXJlbmNlc2Nvb3JkaW5hdGVkaXNjbGFpbWVyZXhwZWRpdGlvbmRldmVsb3BpbmdjYWxjdWxhdGVkc2ltcGxpZmllZGxlZ2l0aW1hdGVzdWJzdHJpbmcoMCIgY2xhc3M9ImNvbXBsZXRlbHlpbGx1c3RyYXRlZml2ZSB5ZWFyc2luc3RydW1lbnRQdWJsaXNoaW5nMSIgY2xhc3M9InBzeWNob2xvZ3ljb25maWRlbmNlbnVtYmVyIG9mIGFic2VuY2Ugb2Zmb2N1c2VkIG9uam9pbmVkIHRoZXN0cnVjdHVyZXNwcmV2aW91c2x5PjwvaWZyYW1lPm9uY2UgYWdhaW5idXQgcmF0aGVyaW1taWdyYW50c29mIGNvdXJzZSxhIGdyb3VwIG9mTGl0ZXJhdHVyZVVubGlrZSB0aGU8L2E+Jm5ic3A7CmZ1bmN0aW9uIGl0IHdhcyB0aGVDb252ZW50aW9uYXV0b21vYmlsZVByb3Rlc3RhbnRhZ2dyZXNzaXZlYWZ0ZXIgdGhlIFNpbWlsYXJseSwiIC8+PC9kaXY+Y29sbGVjdGlvbg0KZnVuY3Rpb252aXNpYmlsaXR5dGhlIHVzZSBvZnZvbHVudGVlcnNhdHRyYWN0aW9udW5kZXIgdGhlIHRocmVhdGVuZWQqPCFbQ0RBVEFbaW1wb3J0YW5jZWluIGdlbmVyYWx0aGUgbGF0dGVyPC9mb3JtPgo8Ly5pbmRleE9mKCdpID0gMDsgaSA8ZGlmZmVyZW5jZWRldm90ZWQgdG90cmFkaXRpb25zc2VhcmNoIGZvcnVsdGltYXRlbHl0b3VybmFtZW50YXR0cmlidXRlc3NvLWNhbGxlZCB9Cjwvc3R5bGU+ZXZhbHVhdGlvbmVtcGhhc2l6ZWRhY2Nlc3NpYmxlPC9zZWN0aW9uPnN1Y2Nlc3Npb25hbG9uZyB3aXRoTWVhbndoaWxlLGluZHVzdHJpZXM8L2E+PGJyIC8+aGFzIGJlY29tZWFzcGVjdHMgb2ZUZWxldmlzaW9uc3VmZmljaWVudGJhc2tldGJhbGxib3RoIHNpZGVzY29udGludWluZ2FuIGFydGljbGU8aW1nIGFsdD0iYWR2ZW50dXJlc2hpcyBtb3RoZXJtYW5jaGVzdGVycHJpbmNpcGxlc3BhcnRpY3VsYXJjb21tZW50YXJ5ZWZmZWN0cyBvZmRlY2lkZWQgdG8iPjxzdHJvbmc+cHVibGlzaGVyc0pvdXJuYWwgb2ZkaWZmaWN1bHR5ZmFjaWxpdGF0ZWFjY2VwdGFibGVzdHlsZS5jc3MiCWZ1bmN0aW9uIGlubm92YXRpb24+Q29weXJpZ2h0c2l0dWF0aW9uc3dvdWxkIGhhdmVidXNpbmVzc2VzRGljdGlvbmFyeXN0YXRlbWVudHNvZnRlbiB1c2VkcGVyc2lzdGVudGluIEphbnVhcnljb21wcmlzaW5nPC90aXRsZT4KCWRpcGxvbWF0aWNjb250YWluaW5ncGVyZm9ybWluZ2V4dGVuc2lvbnNtYXkgbm90IGJlY29uY2VwdCBvZiBvbmNsaWNrPSJJdCBpcyBhbHNvZmluYW5jaWFsIG1ha2luZyB0aGVMdXhlbWJvdXJnYWRkaXRpb25hbGFyZSBjYWxsZWRlbmdhZ2VkIGluInNjcmlwdCIpO2J1dCBpdCB3YXNlbGVjdHJvbmljb25zdWJtaXQ9Igo8IS0tIEVuZCBlbGVjdHJpY2Fsb2ZmaWNpYWxseXN1Z2dlc3Rpb250b3Agb2YgdGhldW5saWtlIHRoZUF1c3RyYWxpYW5PcmlnaW5hbGx5cmVmZXJlbmNlcwo8L2hlYWQ+DQpyZWNvZ25pc2VkaW5pdGlhbGl6ZWxpbWl0ZWQgdG9BbGV4YW5kcmlhcmV0aXJlbWVudEFkdmVudHVyZXNmb3VyIHllYXJzCgombHQ7IS0tIGluY3JlYXNpbmdkZWNvcmF0aW9uaDMgY2xhc3M9Im9yaWdpbnMgb2ZvYmxpZ2F0aW9ucmVndWxhdGlvbmNsYXNzaWZpZWQoZnVuY3Rpb24oYWR2YW50YWdlc2JlaW5nIHRoZSBoaXN0b3JpYW5zPGJhc2UgaHJlZnJlcGVhdGVkbHl3aWxsaW5nIHRvY29tcGFyYWJsZWRlc2lnbmF0ZWRub21pbmF0aW9uZnVuY3Rpb25hbGluc2lkZSB0aGVyZXZlbGF0aW9uZW5kIG9mIHRoZXMgZm9yIHRoZSBhdXRob3JpemVkcmVmdXNlZCB0b3Rha2UgcGxhY2VhdXRvbm9tb3VzY29tcHJvbWlzZXBvbGl0aWNhbCByZXN0YXVyYW50dHdvIG9mIHRoZUZlYnJ1YXJ5IDJxdWFsaXR5IG9mc3dmb2JqZWN0LnVuZGVyc3RhbmRuZWFybHkgYWxsd3JpdHRlbiBieWludGVydmlld3MiIHdpZHRoPSIxd2l0aGRyYXdhbGZsb2F0OmxlZnRpcyB1c3VhbGx5Y2FuZGlkYXRlc25ld3NwYXBlcnNteXN0ZXJpb3VzRGVwYXJ0bWVudGJlc3Qga25vd25wYXJsaWFtZW50c3VwcHJlc3NlZGNvbnZlbmllbnRyZW1lbWJlcmVkZGlmZmVyZW50IHN5c3RlbWF0aWNoYXMgbGVkIHRvcHJvcGFnYW5kYWNvbnRyb2xsZWRpbmZsdWVuY2VzY2VyZW1vbmlhbHByb2NsYWltZWRQcm90ZWN0aW9ubGkgY2xhc3M9IlNjaWVudGlmaWNjbGFzcz0ibm8tdHJhZGVtYXJrc21vcmUgdGhhbiB3aWRlc3ByZWFkTGliZXJhdGlvbnRvb2sgcGxhY2VkYXkgb2YgdGhlYXMgbG9uZyBhc2ltcHJpc29uZWRBZGRpdGlvbmFsCjxoZWFkPgo8bUxhYm9yYXRvcnlOb3ZlbWJlciAyZXhjZXB0aW9uc0luZHVzdHJpYWx2YXJpZXR5IG9mZmxvYXQ6IGxlZkR1cmluZyB0aGVhc3Nlc3NtZW50aGF2ZSBiZWVuIGRlYWxzIHdpdGhTdGF0aXN0aWNzb2NjdXJyZW5jZS91bD48L2Rpdj5jbGVhcmZpeCI+dGhlIHB1YmxpY21hbnkgeWVhcnN3aGljaCB3ZXJlb3ZlciB0aW1lLHN5bm9ueW1vdXNjb250ZW50Ij4KcHJlc3VtYWJseWhpcyBmYW1pbHl1c2VyQWdlbnQudW5leHBlY3RlZGluY2x1ZGluZyBjaGFsbGVuZ2VkYSBtaW5vcml0eXVuZGVmaW5lZCJiZWxvbmdzIHRvdGFrZW4gZnJvbWluIE9jdG9iZXJwb3NpdGlvbjogc2FpZCB0byBiZXJlbGlnaW91cyBGZWRlcmF0aW9uIHJvd3NwYW49Im9ubHkgYSBmZXdtZWFudCB0aGF0bGVkIHRvIHRoZS0tPg0KPGRpdiA8ZmllbGRzZXQ+QXJjaGJpc2hvcCBjbGFzcz0ibm9iZWluZyB1c2VkYXBwcm9hY2hlc3ByaXZpbGVnZXNub3NjcmlwdD4KcmVzdWx0cyBpbm1heSBiZSB0aGVFYXN0ZXIgZWdnbWVjaGFuaXNtc3JlYXNvbmFibGVQb3B1bGF0aW9uQ29sbGVjdGlvbnNlbGVjdGVkIj5ub3NjcmlwdD4NL2luZGV4LnBocGFycml2YWwgb2YtanNzZGsnKSk7bWFuYWdlZCB0b2luY29tcGxldGVjYXN1YWx0aWVzY29tcGxldGlvbkNocmlzdGlhbnNTZXB0ZW1iZXIgYXJpdGhtZXRpY3Byb2NlZHVyZXNtaWdodCBoYXZlUHJvZHVjdGlvbml0IGFwcGVhcnNQaGlsb3NvcGh5ZnJpZW5kc2hpcGxlYWRpbmcgdG9naXZpbmcgdGhldG93YXJkIHRoZWd1YXJhbnRlZWRkb2N1bWVudGVkY29sb3I6IzAwMHZpZGVvIGdhbWVjb21taXNzaW9ucmVmbGVjdGluZ2NoYW5nZSB0aGVhc3NvY2lhdGVkc2Fucy1zZXJpZm9ua2V5cHJlc3M7IHBhZGRpbmc6SGUgd2FzIHRoZXVuZGVybHlpbmd0eXBpY2FsbHkgLCBhbmQgdGhlIHNyY0VsZW1lbnRzdWNjZXNzaXZlc2luY2UgdGhlIHNob3VsZCBiZSBuZXR3b3JraW5nYWNjb3VudGluZ3VzZSBvZiB0aGVsb3dlciB0aGFuc2hvd3MgdGhhdDwvc3Bhbj4KCQljb21wbGFpbnRzY29udGludW91c3F1YW50aXRpZXNhc3Ryb25vbWVyaGUgZGlkIG5vdGR1ZSB0byBpdHNhcHBsaWVkIHRvYW4gYXZlcmFnZWVmZm9ydHMgdG90aGUgZnV0dXJlYXR0ZW1wdCB0b1RoZXJlZm9yZSxjYXBhYmlsaXR5UmVwdWJsaWNhbndhcyBmb3JtZWRFbGVjdHJvbmlja2lsb21ldGVyc2NoYWxsZW5nZXNwdWJsaXNoaW5ndGhlIGZvcm1lcmluZGlnZW5vdXNkaXJlY3Rpb25zc3Vic2lkaWFyeWNvbnNwaXJhY3lkZXRhaWxzIG9mYW5kIGluIHRoZWFmZm9yZGFibGVzdWJzdGFuY2VzcmVhc29uIGZvcmNvbnZlbnRpb25pdGVtdHlwZT0iYWJzb2x1dGVseXN1cHBvc2VkbHlyZW1haW5lZCBhYXR0cmFjdGl2ZXRyYXZlbGxpbmdzZXBhcmF0ZWx5Zm9jdXNlcyBvbmVsZW1lbnRhcnlhcHBsaWNhYmxlZm91bmQgdGhhdHN0eWxlc2hlZXRtYW51c2NyaXB0c3RhbmRzIGZvciBuby1yZXBlYXQoc29tZXRpbWVzQ29tbWVyY2lhbGluIEFtZXJpY2F1bmRlcnRha2VucXVhcnRlciBvZmFuIGV4YW1wbGVwZXJzb25hbGx5aW5kZXgucGhwPzwvYnV0dG9uPgpwZXJjZW50YWdlYmVzdC1rbm93bmNyZWF0aW5nIGEiIGRpcj0ibHRyTGlldXRlbmFudAo8ZGl2IGlkPSJ0aGV5IHdvdWxkYWJpbGl0eSBvZm1hZGUgdXAgb2Zub3RlZCB0aGF0Y2xlYXIgdGhhdGFyZ3VlIHRoYXR0byBhbm90aGVyY2hpbGRyZW4nc3B1cnBvc2Ugb2Zmb3JtdWxhdGVkYmFzZWQgdXBvbnRoZSByZWdpb25zdWJqZWN0IG9mcGFzc2VuZ2Vyc3Bvc3Nlc3Npb24uCgpJbiB0aGUgQmVmb3JlIHRoZWFmdGVyd2FyZHNjdXJyZW50bHkgYWNyb3NzIHRoZXNjaWVudGlmaWNjb21tdW5pdHkuY2FwaXRhbGlzbWluIEdlcm1hbnlyaWdodC13aW5ndGhlIHN5c3RlbVNvY2lldHkgb2Zwb2xpdGljaWFuZGlyZWN0aW9uOndlbnQgb24gdG9yZW1vdmFsIG9mIE5ldyBZb3JrIGFwYXJ0bWVudHNpbmRpY2F0aW9uZHVyaW5nIHRoZXVubGVzcyB0aGVoaXN0b3JpY2FsaGFkIGJlZW4gYWRlZmluaXRpdmVpbmdyZWRpZW50YXR0ZW5kYW5jZUNlbnRlciBmb3Jwcm9taW5lbmNlcmVhZHlTdGF0ZXN0cmF0ZWdpZXNidXQgaW4gdGhlYXMgcGFydCBvZmNvbnN0aXR1dGVjbGFpbSB0aGF0bGFib3JhdG9yeWNvbXBhdGlibGVmYWlsdXJlIG9mLCBzdWNoIGFzIGJlZ2FuIHdpdGh1c2luZyB0aGUgdG8gcHJvdmlkZWZlYXR1cmUgb2Zmcm9tIHdoaWNoLyIgY2xhc3M9Imdlb2xvZ2ljYWxzZXZlcmFsIG9mZGVsaWJlcmF0ZWltcG9ydGFudCBob2xkcyB0aGF0aW5nJnF1b3Q7IHZhbGlnbj10b3B0aGUgR2VybWFub3V0c2lkZSBvZm5lZ290aWF0ZWRoaXMgY2FyZWVyc2VwYXJhdGlvbmlkPSJzZWFyY2h3YXMgY2FsbGVkdGhlIGZvdXJ0aHJlY3JlYXRpb25vdGhlciB0aGFucHJldmVudGlvbndoaWxlIHRoZSBlZHVjYXRpb24sY29ubmVjdGluZ2FjY3VyYXRlbHl3ZXJlIGJ1aWx0d2FzIGtpbGxlZGFncmVlbWVudHNtdWNoIG1vcmUgRHVlIHRvIHRoZXdpZHRoOiAxMDBzb21lIG90aGVyS2luZ2RvbSBvZnRoZSBlbnRpcmVmYW1vdXMgZm9ydG8gY29ubmVjdG9iamVjdGl2ZXN0aGUgRnJlbmNocGVvcGxlIGFuZGZlYXR1cmVkIj5pcyBzYWlkIHRvc3RydWN0dXJhbHJlZmVyZW5kdW1tb3N0IG9mdGVuYSBzZXBhcmF0ZS0+CjxkaXYgaWQgT2ZmaWNpYWwgd29ybGR3aWRlLmFyaWEtbGFiZWx0aGUgcGxhbmV0YW5kIGl0IHdhc2QiIHZhbHVlPSJsb29raW5nIGF0YmVuZWZpY2lhbGFyZSBpbiB0aGVtb25pdG9yaW5ncmVwb3J0ZWRseXRoZSBtb2Rlcm53b3JraW5nIG9uYWxsb3dlZCB0b3doZXJlIHRoZSBpbm5vdmF0aXZlPC9hPjwvZGl2PnNvdW5kdHJhY2tzZWFyY2hGb3JtdGVuZCB0byBiZWlucHV0IGlkPSJvcGVuaW5nIG9mcmVzdHJpY3RlZGFkb3B0ZWQgYnlhZGRyZXNzaW5ndGhlb2xvZ2lhbm1ldGhvZHMgb2Z2YXJpYW50IG9mQ2hyaXN0aWFuIHZlcnkgbGFyZ2VhdXRvbW90aXZlYnkgZmFyIHRoZXJhbmdlIGZyb21wdXJzdWl0IG9mZm9sbG93IHRoZWJyb3VnaHQgdG9pbiBFbmdsYW5kYWdyZWUgdGhhdGFjY3VzZWQgb2Zjb21lcyBmcm9tcHJldmVudGluZ2RpdiBzdHlsZT1oaXMgb3IgaGVydHJlbWVuZG91c2ZyZWVkb20gb2Zjb25jZXJuaW5nMCAxZW0gMWVtO0Jhc2tldGJhbGwvc3R5bGUuY3NzYW4gZWFybGllcmV2ZW4gYWZ0ZXIvIiB0aXRsZT0iLmNvbS9pbmRleHRha2luZyB0aGVwaXR0c2J1cmdoY29udGVudCI+DTxzY3JpcHQ+KGZ0dXJuZWQgb3V0aGF2aW5nIHRoZTwvc3Bhbj4NCiBvY2Nhc2lvbmFsYmVjYXVzZSBpdHN0YXJ0ZWQgdG9waHlzaWNhbGx5PjwvZGl2PgogIGNyZWF0ZWQgYnlDdXJyZW50bHksIGJnY29sb3I9InRhYmluZGV4PSJkaXNhc3Ryb3VzQW5hbHl0aWNzIGFsc28gaGFzIGE+PGRpdiBpZD0iPC9zdHlsZT4KPGNhbGxlZCBmb3JzaW5nZXIgYW5kLnNyYyA9ICIvL3Zpb2xhdGlvbnN0aGlzIHBvaW50Y29uc3RhbnRseWlzIGxvY2F0ZWRyZWNvcmRpbmdzZCBmcm9tIHRoZW5lZGVybGFuZHNwb3J0dWd1w6pz16LXkdeo15nXqtmB2KfYsdiz24xkZXNhcnJvbGxvY29tZW50YXJpb2VkdWNhY2nDs25zZXB0aWVtYnJlcmVnaXN0cmFkb2RpcmVjY2nDs251YmljYWNpw7NucHVibGljaWRhZHJlc3B1ZXN0YXNyZXN1bHRhZG9zaW1wb3J0YW50ZXJlc2VydmFkb3NhcnTDrWN1bG9zZGlmZXJlbnRlc3NpZ3VpZW50ZXNyZXDDumJsaWNhc2l0dWFjacOzbm1pbmlzdGVyaW9wcml2YWNpZGFkZGlyZWN0b3Jpb2Zvcm1hY2nDs25wb2JsYWNpw7NucHJlc2lkZW50ZWNvbnRlbmlkb3NhY2Nlc29yaW9zdGVjaG5vcmF0aXBlcnNvbmFsZXNjYXRlZ29yw61hZXNwZWNpYWxlc2Rpc3BvbmlibGVhY3R1YWxpZGFkcmVmZXJlbmNpYXZhbGxhZG9saWRiaWJsaW90ZWNhcmVsYWNpb25lc2NhbGVuZGFyaW9wb2zDrXRpY2FzYW50ZXJpb3Jlc2RvY3VtZW50b3NuYXR1cmFsZXphbWF0ZXJpYWxlc2RpZmVyZW5jaWFlY29uw7NtaWNhdHJhbnNwb3J0ZXJvZHLDrWd1ZXpwYXJ0aWNpcGFyZW5jdWVudHJhbmRpc2N1c2nDs25lc3RydWN0dXJhZnVuZGFjacOzbmZyZWN1ZW50ZXNwZXJtYW5lbnRldG90YWxtZW50ZdC80L7QttC90L7QsdGD0LTQtdGC0LzQvtC20LXRgtCy0YDQtdC80Y/RgtCw0LrQttC10YfRgtC+0LHRi9Cx0L7Qu9C10LXQvtGH0LXQvdGM0Y3RgtC+0LPQvtC60L7Qs9C00LDQv9C+0YHQu9C10LLRgdC10LPQvtGB0LDQudGC0LXRh9C10YDQtdC30LzQvtCz0YPRgtGB0LDQudGC0LDQttC40LfQvdC40LzQtdC20LTRg9Cx0YPQtNGD0YLQn9C+0LjRgdC60LfQtNC10YHRjNCy0LjQtNC10L7RgdCy0Y/Qt9C40L3Rg9C20L3QvtGB0LLQvtC10LnQu9GO0LTQtdC50L/QvtGA0L3QvtC80L3QvtCz0L7QtNC10YLQtdC50YHQstC+0LjRhdC/0YDQsNCy0LDRgtCw0LrQvtC50LzQtdGB0YLQvtC40LzQtdC10YLQttC40LfQvdGM0L7QtNC90L7QudC70YPRh9GI0LXQv9C10YDQtdC00YfQsNGB0YLQuNGH0LDRgdGC0YzRgNCw0LHQvtGC0L3QvtCy0YvRhdC/0YDQsNCy0L7RgdC+0LHQvtC50L/QvtGC0L7QvNC80LXQvdC10LXRh9C40YHQu9C10L3QvtCy0YvQtdGD0YHQu9GD0LPQvtC60L7Qu9C+0L3QsNC30LDQtNGC0LDQutC+0LXRgtC+0LPQtNCw0L/QvtGH0YLQuNCf0L7RgdC70LXRgtCw0LrQuNC10L3QvtCy0YvQudGB0YLQvtC40YLRgtCw0LrQuNGF0YHRgNCw0LfRg9Ch0LDQvdC60YLRhNC+0YDRg9C80JrQvtCz0LTQsNC60L3QuNCz0LjRgdC70L7QstCw0L3QsNGI0LXQudC90LDQudGC0LjRgdCy0L7QuNC80YHQstGP0LfRjNC70Y7QsdC+0LnRh9Cw0YHRgtC+0YHRgNC10LTQuNCa0YDQvtC80LXQpNC+0YDRg9C80YDRi9C90LrQtdGB0YLQsNC70LjQv9C+0LjRgdC60YLRi9GB0Y/Rh9C80LXRgdGP0YbRhtC10L3RgtGA0YLRgNGD0LTQsNGB0LDQvNGL0YXRgNGL0L3QutCw0J3QvtCy0YvQudGH0LDRgdC+0LLQvNC10YHRgtCw0YTQuNC70YzQvNC80LDRgNGC0LDRgdGC0YDQsNC90LzQtdGB0YLQtdGC0LXQutGB0YLQvdCw0YjQuNGF0LzQuNC90YPRgtC40LzQtdC90LjQuNC80LXRjtGC0L3QvtC80LXRgNCz0L7RgNC+0LTRgdCw0LzQvtC80Y3RgtC+0LzRg9C60L7QvdGG0LXRgdCy0L7QtdC80LrQsNC60L7QudCQ0YDRhdC40LLZhdmG2KrYr9mJ2KXYsdiz2KfZhNix2LPYp9mE2KnYp9mE2LnYp9mF2YPYqtio2YfYp9io2LHYp9mF2KzYp9mE2YrZiNmF2KfZhNi12YjYsdis2K/Zitiv2KnYp9mE2LnYttmI2KXYttin2YHYqdin2YTZgtiz2YXYp9mE2LnYp9io2KrYrdmF2YrZhNmF2YTZgdin2KrZhdmE2KrZgtmJ2KrYudiv2YrZhNin2YTYtNi52LHYo9iu2KjYp9ix2KrYt9mI2YrYsdi52YTZitmD2YXYpdix2YHYp9mC2LfZhNio2KfYqtin2YTZhNi62KnYqtix2KrZitio2KfZhNmG2KfYs9in2YTYtNmK2K7ZhdmG2KrYr9mK2KfZhNi52LHYqNin2YTZgti12LXYp9mB2YTYp9mF2LnZhNmK2YfYp9iq2K3Yr9mK2KvYp9mE2YTZh9mF2KfZhNi52YXZhNmF2YPYqtio2KnZitmF2YPZhtmD2KfZhNi32YHZhNmB2YrYr9mK2YjYpdiv2KfYsdip2KrYp9ix2YrYrtin2YTYtdit2KnYqtiz2KzZitmE2KfZhNmI2YLYqti52YbYr9mF2KfZhdiv2YrZhtip2KrYtdmF2YrZhdij2LHYtNmK2YHYp9mE2LDZitmG2LnYsdio2YrYqdio2YjYp9io2KnYo9mE2LnYp9io2KfZhNiz2YHYsdmF2LTYp9mD2YTYqti52KfZhNmJ2KfZhNij2YjZhNin2YTYs9mG2KnYrNin2YXYudip2KfZhNi12K3Zgdin2YTYr9mK2YbZg9mE2YXYp9iq2KfZhNiu2KfYtdin2YTZhdmE2YHYo9i52LbYp9ih2YPYqtin2KjYqdin2YTYrtmK2LHYsdiz2KfYptmE2KfZhNmC2YTYqNin2YTYo9iv2KjZhdmC2KfYt9i52YXYsdin2LPZhNmF2YbYt9mC2KnYp9mE2YPYqtio2KfZhNix2KzZhNin2LTYqtix2YPYp9mE2YLYr9mF2YrYudi32YrZg3NCeVRhZ05hbWUoLmpwZyIgYWx0PSIxcHggc29saWQgIy5naWYiIGFsdD0idHJhbnNwYXJlbnRpbmZvcm1hdGlvbmFwcGxpY2F0aW9uIiBvbmNsaWNrPSJlc3RhYmxpc2hlZGFkdmVydGlzaW5nLnBuZyIgYWx0PSJlbnZpcm9ubWVudHBlcmZvcm1hbmNlYXBwcm9wcmlhdGUmYW1wO21kYXNoO2ltbWVkaWF0ZWx5PC9zdHJvbmc+PC9yYXRoZXIgdGhhbnRlbXBlcmF0dXJlZGV2ZWxvcG1lbnRjb21wZXRpdGlvbnBsYWNlaG9sZGVydmlzaWJpbGl0eTpjb3B5cmlnaHQiPjAiIGhlaWdodD0iZXZlbiB0aG91Z2hyZXBsYWNlbWVudGRlc3RpbmF0aW9uQ29ycG9yYXRpb248dWwgY2xhc3M9IkFzc29jaWF0aW9uaW5kaXZpZHVhbHNwZXJzcGVjdGl2ZXNldFRpbWVvdXQodXJsKGh0dHA6Ly9tYXRoZW1hdGljc21hcmdpbi10b3A6ZXZlbnR1YWxseSBkZXNjcmlwdGlvbikgbm8tcmVwZWF0Y29sbGVjdGlvbnMuSlBHfHRodW1ifHBhcnRpY2lwYXRlL2hlYWQ+PGJvZHlmbG9hdDpsZWZ0OzxsaSBjbGFzcz0iaHVuZHJlZHMgb2YKCkhvd2V2ZXIsIGNvbXBvc2l0aW9uY2xlYXI6Ym90aDtjb29wZXJhdGlvbndpdGhpbiB0aGUgbGFiZWwgZm9yPSJib3JkZXItdG9wOk5ldyBaZWFsYW5kcmVjb21tZW5kZWRwaG90b2dyYXBoeWludGVyZXN0aW5nJmx0O3N1cCZndDtjb250cm92ZXJzeU5ldGhlcmxhbmRzYWx0ZXJuYXRpdmVtYXhsZW5ndGg9InN3aXR6ZXJsYW5kRGV2ZWxvcG1lbnRlc3NlbnRpYWxseQoKQWx0aG91Z2ggPC90ZXh0YXJlYT50aHVuZGVyYmlyZHJlcHJlc2VudGVkJmFtcDtuZGFzaDtzcGVjdWxhdGlvbmNvbW11bml0aWVzbGVnaXNsYXRpb25lbGVjdHJvbmljcwoJPGRpdiBpZD0iaWxsdXN0cmF0ZWRlbmdpbmVlcmluZ3RlcnJpdG9yaWVzYXV0aG9yaXRpZXNkaXN0cmlidXRlZDYiIGhlaWdodD0ic2Fucy1zZXJpZjtjYXBhYmxlIG9mIGRpc2FwcGVhcmVkaW50ZXJhY3RpdmVsb29raW5nIGZvcml0IHdvdWxkIGJlQWZnaGFuaXN0YW53YXMgY3JlYXRlZE1hdGguZmxvb3Ioc3Vycm91bmRpbmdjYW4gYWxzbyBiZW9ic2VydmF0aW9ubWFpbnRlbmFuY2VlbmNvdW50ZXJlZDxoMiBjbGFzcz0ibW9yZSByZWNlbnRpdCBoYXMgYmVlbmludmFzaW9uIG9mKS5nZXRUaW1lKClmdW5kYW1lbnRhbERlc3BpdGUgdGhlIj48ZGl2IGlkPSJpbnNwaXJhdGlvbmV4YW1pbmF0aW9ucHJlcGFyYXRpb25leHBsYW5hdGlvbjxpbnB1dCBpZD0iPC9hPjwvc3Bhbj52ZXJzaW9ucyBvZmluc3RydW1lbnRzYmVmb3JlIHRoZSAgPSAnaHR0cDovL0Rlc2NyaXB0aW9ucmVsYXRpdmVseSAuc3Vic3RyaW5nKGVhY2ggb2YgdGhlZXhwZXJpbWVudHNpbmZsdWVudGlhbGludGVncmF0aW9ubWFueSBwZW9wbGVkdWUgdG8gdGhlIGNvbWJpbmF0aW9uZG8gbm90IGhhdmVNaWRkbGUgRWFzdDxub3NjcmlwdD48Y29weXJpZ2h0IiBwZXJoYXBzIHRoZWluc3RpdHV0aW9uaW4gRGVjZW1iZXJhcnJhbmdlbWVudG1vc3QgZmFtb3VzcGVyc29uYWxpdHljcmVhdGlvbiBvZmxpbWl0YXRpb25zZXhjbHVzaXZlbHlzb3ZlcmVpZ250eS1jb250ZW50Ij4KPHRkIGNsYXNzPSJ1bmRlcmdyb3VuZHBhcmFsbGVsIHRvZG9jdHJpbmUgb2ZvY2N1cGllZCBieXRlcm1pbm9sb2d5UmVuYWlzc2FuY2VhIG51bWJlciBvZnN1cHBvcnQgZm9yZXhwbG9yYXRpb25yZWNvZ25pdGlvbnByZWRlY2Vzc29yPGltZyBzcmM9Ii88aDEgY2xhc3M9InB1YmxpY2F0aW9ubWF5IGFsc28gYmVzcGVjaWFsaXplZDwvZmllbGRzZXQ+cHJvZ3Jlc3NpdmVtaWxsaW9ucyBvZnN0YXRlcyB0aGF0ZW5mb3JjZW1lbnRhcm91bmQgdGhlIG9uZSBhbm90aGVyLnBhcmVudE5vZGVhZ3JpY3VsdHVyZUFsdGVybmF0aXZlcmVzZWFyY2hlcnN0b3dhcmRzIHRoZU1vc3Qgb2YgdGhlbWFueSBvdGhlciAoZXNwZWNpYWxseTx0ZCB3aWR0aD0iO3dpZHRoOjEwMCVpbmRlcGVuZGVudDxoMyBjbGFzcz0iIG9uY2hhbmdlPSIpLmFkZENsYXNzKGludGVyYWN0aW9uT25lIG9mIHRoZSBkYXVnaHRlciBvZmFjY2Vzc29yaWVzYnJhbmNoZXMgb2YNCjxkaXYgaWQ9InRoZSBsYXJnZXN0ZGVjbGFyYXRpb25yZWd1bGF0aW9uc0luZm9ybWF0aW9udHJhbnNsYXRpb25kb2N1bWVudGFyeWluIG9yZGVyIHRvIj4KPGhlYWQ+CjwiIGhlaWdodD0iMWFjcm9zcyB0aGUgb3JpZW50YXRpb24pOzwvc2NyaXB0PmltcGxlbWVudGVkY2FuIGJlIHNlZW50aGVyZSB3YXMgYWRlbW9uc3RyYXRlY29udGFpbmVyIj5jb25uZWN0aW9uc3RoZSBCcml0aXNod2FzIHdyaXR0ZW4haW1wb3J0YW50O3B4OyBtYXJnaW4tZm9sbG93ZWQgYnlhYmlsaXR5IHRvIGNvbXBsaWNhdGVkZHVyaW5nIHRoZSBpbW1pZ3JhdGlvbmFsc28gY2FsbGVkPGg0IGNsYXNzPSJkaXN0aW5jdGlvbnJlcGxhY2VkIGJ5Z292ZXJubWVudHNsb2NhdGlvbiBvZmluIE5vdmVtYmVyd2hldGhlciB0aGU8L3A+CjwvZGl2PmFjcXVpc2l0aW9uY2FsbGVkIHRoZSBwZXJzZWN1dGlvbmRlc2lnbmF0aW9ue2ZvbnQtc2l6ZTphcHBlYXJlZCBpbmludmVzdGlnYXRlZXhwZXJpZW5jZWRtb3N0IGxpa2VseXdpZGVseSB1c2VkZGlzY3Vzc2lvbnNwcmVzZW5jZSBvZiAoZG9jdW1lbnQuZXh0ZW5zaXZlbHlJdCBoYXMgYmVlbml0IGRvZXMgbm90Y29udHJhcnkgdG9pbmhhYml0YW50c2ltcHJvdmVtZW50c2Nob2xhcnNoaXBjb25zdW1wdGlvbmluc3RydWN0aW9uZm9yIGV4YW1wbGVvbmUgb3IgbW9yZXB4OyBwYWRkaW5ndGhlIGN1cnJlbnRhIHNlcmllcyBvZmFyZSB1c3VhbGx5cm9sZSBpbiB0aGVwcmV2aW91c2x5IGRlcml2YXRpdmVzZXZpZGVuY2Ugb2ZleHBlcmllbmNlc2NvbG9yc2NoZW1lc3RhdGVkIHRoYXRjZXJ0aWZpY2F0ZTwvYT48L2Rpdj4KIHNlbGVjdGVkPSJoaWdoIHNjaG9vbHJlc3BvbnNlIHRvY29tZm9ydGFibGVhZG9wdGlvbiBvZnRocmVlIHllYXJzdGhlIGNvdW50cnlpbiBGZWJydWFyeXNvIHRoYXQgdGhlcGVvcGxlIHdobyBwcm92aWRlZCBieTxwYXJhbSBuYW1lYWZmZWN0ZWQgYnlpbiB0ZXJtcyBvZmFwcG9pbnRtZW50SVNPLTg4NTktMSJ3YXMgYm9ybiBpbmhpc3RvcmljYWwgcmVnYXJkZWQgYXNtZWFzdXJlbWVudGlzIGJhc2VkIG9uIGFuZCBvdGhlciA6IGZ1bmN0aW9uKHNpZ25pZmljYW50Y2VsZWJyYXRpb250cmFuc21pdHRlZC9qcy9qcXVlcnkuaXMga25vd24gYXN0aGVvcmV0aWNhbCB0YWJpbmRleD0iaXQgY291bGQgYmU8bm9zY3JpcHQ+CmhhdmluZyBiZWVuDQo8aGVhZD4NCjwgJnF1b3Q7VGhlIGNvbXBpbGF0aW9uaGUgaGFkIGJlZW5wcm9kdWNlZCBieXBoaWxvc29waGVyY29uc3RydWN0ZWRpbnRlbmRlZCB0b2Ftb25nIG90aGVyY29tcGFyZWQgdG90byBzYXkgdGhhdEVuZ2luZWVyaW5nYSBkaWZmZXJlbnRyZWZlcnJlZCB0b2RpZmZlcmVuY2VzYmVsaWVmIHRoYXRwaG90b2dyYXBoc2lkZW50aWZ5aW5nSGlzdG9yeSBvZiBSZXB1YmxpYyBvZm5lY2Vzc2FyaWx5cHJvYmFiaWxpdHl0ZWNobmljYWxseWxlYXZpbmcgdGhlc3BlY3RhY3VsYXJmcmFjdGlvbiBvZmVsZWN0cmljaXR5aGVhZCBvZiB0aGVyZXN0YXVyYW50c3BhcnRuZXJzaGlwZW1waGFzaXMgb25tb3N0IHJlY2VudHNoYXJlIHdpdGggc2F5aW5nIHRoYXRmaWxsZWQgd2l0aGRlc2lnbmVkIHRvaXQgaXMgb2Z0ZW4iPjwvaWZyYW1lPmFzIGZvbGxvd3M6bWVyZ2VkIHdpdGh0aHJvdWdoIHRoZWNvbW1lcmNpYWwgcG9pbnRlZCBvdXRvcHBvcnR1bml0eXZpZXcgb2YgdGhlcmVxdWlyZW1lbnRkaXZpc2lvbiBvZnByb2dyYW1taW5naGUgcmVjZWl2ZWRzZXRJbnRlcnZhbCI+PC9zcGFuPjwvaW4gTmV3IFlvcmthZGRpdGlvbmFsIGNvbXByZXNzaW9uCgo8ZGl2IGlkPSJpbmNvcnBvcmF0ZTs8L3NjcmlwdD48YXR0YWNoRXZlbnRiZWNhbWUgdGhlICIgdGFyZ2V0PSJfY2FycmllZCBvdXRTb21lIG9mIHRoZXNjaWVuY2UgYW5kdGhlIHRpbWUgb2ZDb250YWluZXIiPm1haW50YWluaW5nQ2hyaXN0b3BoZXJNdWNoIG9mIHRoZXdyaXRpbmdzIG9mIiBoZWlnaHQ9IjJzaXplIG9mIHRoZXZlcnNpb24gb2YgbWl4dHVyZSBvZiBiZXR3ZWVuIHRoZUV4YW1wbGVzIG9mZWR1Y2F0aW9uYWxjb21wZXRpdGl2ZSBvbnN1Ym1pdD0iZGlyZWN0b3Igb2ZkaXN0aW5jdGl2ZS9EVEQgWEhUTUwgcmVsYXRpbmcgdG90ZW5kZW5jeSB0b3Byb3ZpbmNlIG9md2hpY2ggd291bGRkZXNwaXRlIHRoZXNjaWVudGlmaWMgbGVnaXNsYXR1cmUuaW5uZXJIVE1MIGFsbGVnYXRpb25zQWdyaWN1bHR1cmV3YXMgdXNlZCBpbmFwcHJvYWNoIHRvaW50ZWxsaWdlbnR5ZWFycyBsYXRlcixzYW5zLXNlcmlmZGV0ZXJtaW5pbmdQZXJmb3JtYW5jZWFwcGVhcmFuY2VzLCB3aGljaCBpcyBmb3VuZGF0aW9uc2FiYnJldmlhdGVkaGlnaGVyIHRoYW5zIGZyb20gdGhlIGluZGl2aWR1YWwgY29tcG9zZWQgb2ZzdXBwb3NlZCB0b2NsYWltcyB0aGF0YXR0cmlidXRpb25mb250LXNpemU6MWVsZW1lbnRzIG9mSGlzdG9yaWNhbCBoaXMgYnJvdGhlcmF0IHRoZSB0aW1lYW5uaXZlcnNhcnlnb3Zlcm5lZCBieXJlbGF0ZWQgdG8gdWx0aW1hdGVseSBpbm5vdmF0aW9uc2l0IGlzIHN0aWxsY2FuIG9ubHkgYmVkZWZpbml0aW9uc3RvR01UU3RyaW5nQSBudW1iZXIgb2ZpbWcgY2xhc3M9IkV2ZW50dWFsbHksd2FzIGNoYW5nZWRvY2N1cnJlZCBpbm5laWdoYm9yaW5nZGlzdGluZ3Vpc2h3aGVuIGhlIHdhc2ludHJvZHVjaW5ndGVycmVzdHJpYWxNYW55IG9mIHRoZWFyZ3VlcyB0aGF0YW4gQW1lcmljYW5jb25xdWVzdCBvZndpZGVzcHJlYWQgd2VyZSBraWxsZWRzY3JlZW4gYW5kIEluIG9yZGVyIHRvZXhwZWN0ZWQgdG9kZXNjZW5kYW50c2FyZSBsb2NhdGVkbGVnaXNsYXRpdmVnZW5lcmF0aW9ucyBiYWNrZ3JvdW5kbW9zdCBwZW9wbGV5ZWFycyBhZnRlcnRoZXJlIGlzIG5vdGhlIGhpZ2hlc3RmcmVxdWVudGx5IHRoZXkgZG8gbm90YXJndWVkIHRoYXRzaG93ZWQgdGhhdHByZWRvbWluYW50dGhlb2xvZ2ljYWxieSB0aGUgdGltZWNvbnNpZGVyaW5nc2hvcnQtbGl2ZWQ8L3NwYW4+PC9hPmNhbiBiZSB1c2VkdmVyeSBsaXR0bGVvbmUgb2YgdGhlIGhhZCBhbHJlYWR5aW50ZXJwcmV0ZWRjb21tdW5pY2F0ZWZlYXR1cmVzIG9mZ292ZXJubWVudCw8L25vc2NyaXB0PmVudGVyZWQgdGhlIiBoZWlnaHQ9IjNJbmRlcGVuZGVudHBvcHVsYXRpb25zbGFyZ2Utc2NhbGUuIEFsdGhvdWdoIHVzZWQgaW4gdGhlZGVzdHJ1Y3Rpb25wb3NzaWJpbGl0eXN0YXJ0aW5nIGludHdvIG9yIG1vcmVleHByZXNzaW9uc3N1Ym9yZGluYXRlbGFyZ2VyIHRoYW5oaXN0b3J5IGFuZDwvb3B0aW9uPg0KQ29udGluZW50YWxlbGltaW5hdGluZ3dpbGwgbm90IGJlcHJhY3RpY2Ugb2ZpbiBmcm9udCBvZnNpdGUgb2YgdGhlZW5zdXJlIHRoYXR0byBjcmVhdGUgYW1pc3Npc3NpcHBpcG90ZW50aWFsbHlvdXRzdGFuZGluZ2JldHRlciB0aGFud2hhdCBpcyBub3dzaXR1YXRlZCBpbm1ldGEgbmFtZT0iVHJhZGl0aW9uYWxzdWdnZXN0aW9uc1RyYW5zbGF0aW9udGhlIGZvcm0gb2ZhdG1vc3BoZXJpY2lkZW9sb2dpY2FsZW50ZXJwcmlzZXNjYWxjdWxhdGluZ2Vhc3Qgb2YgdGhlcmVtbmFudHMgb2ZwbHVnaW5zcGFnZS9pbmRleC5waHA/cmVtYWluZWQgaW50cmFuc2Zvcm1lZEhlIHdhcyBhbHNvd2FzIGFscmVhZHlzdGF0aXN0aWNhbGluIGZhdm9yIG9mTWluaXN0cnkgb2Ztb3ZlbWVudCBvZmZvcm11bGF0aW9uaXMgcmVxdWlyZWQ8bGluayByZWw9IlRoaXMgaXMgdGhlIDxhIGhyZWY9Ii9wb3B1bGFyaXplZGludm9sdmVkIGluYXJlIHVzZWQgdG9hbmQgc2V2ZXJhbG1hZGUgYnkgdGhlc2VlbXMgdG8gYmVsaWtlbHkgdGhhdFBhbGVzdGluaWFubmFtZWQgYWZ0ZXJpdCBoYWQgYmVlbm1vc3QgY29tbW9udG8gcmVmZXIgdG9idXQgdGhpcyBpc2NvbnNlY3V0aXZldGVtcG9yYXJpbHlJbiBnZW5lcmFsLGNvbnZlbnRpb25zdGFrZXMgcGxhY2VzdWJkaXZpc2lvbnRlcnJpdG9yaWFsb3BlcmF0aW9uYWxwZXJtYW5lbnRseXdhcyBsYXJnZWx5b3V0YnJlYWsgb2ZpbiB0aGUgcGFzdGZvbGxvd2luZyBhIHhtbG5zOm9nPSI+PGEgY2xhc3M9ImNsYXNzPSJ0ZXh0Q29udmVyc2lvbiBtYXkgYmUgdXNlZG1hbnVmYWN0dXJlYWZ0ZXIgYmVpbmdjbGVhcmZpeCI+CnF1ZXN0aW9uIG9md2FzIGVsZWN0ZWR0byBiZWNvbWUgYWJlY2F1c2Ugb2Ygc29tZSBwZW9wbGVpbnNwaXJlZCBieXN1Y2Nlc3NmdWwgYSB0aW1lIHdoZW5tb3JlIGNvbW1vbmFtb25nc3QgdGhlYW4gb2ZmaWNpYWx3aWR0aDoxMDAlO3RlY2hub2xvZ3ksd2FzIGFkb3B0ZWR0byBrZWVwIHRoZXNldHRsZW1lbnRzbGl2ZSBiaXJ0aHNpbmRleC5odG1sIkNvbm5lY3RpY3V0YXNzaWduZWQgdG8mYW1wO3RpbWVzO2FjY291bnQgZm9yYWxpZ249cmlnaHR0aGUgY29tcGFueWFsd2F5cyBiZWVucmV0dXJuZWQgdG9pbnZvbHZlbWVudEJlY2F1c2UgdGhldGhpcyBwZXJpb2QiIG5hbWU9InEiIGNvbmZpbmVkIHRvYSByZXN1bHQgb2Z2YWx1ZT0iIiAvPmlzIGFjdHVhbGx5RW52aXJvbm1lbnQNCjwvaGVhZD4NCkNvbnZlcnNlbHksPgo8ZGl2IGlkPSIwIiB3aWR0aD0iMWlzIHByb2JhYmx5aGF2ZSBiZWNvbWVjb250cm9sbGluZ3RoZSBwcm9ibGVtY2l0aXplbnMgb2Zwb2xpdGljaWFuc3JlYWNoZWQgdGhlYXMgZWFybHkgYXM6bm9uZTsgb3Zlcjx0YWJsZSBjZWxsdmFsaWRpdHkgb2ZkaXJlY3RseSB0b29ubW91c2Vkb3dud2hlcmUgaXQgaXN3aGVuIGl0IHdhc21lbWJlcnMgb2YgcmVsYXRpb24gdG9hY2NvbW1vZGF0ZWFsb25nIHdpdGggSW4gdGhlIGxhdGV0aGUgRW5nbGlzaGRlbGljaW91cyI+dGhpcyBpcyBub3R0aGUgcHJlc2VudGlmIHRoZXkgYXJlYW5kIGZpbmFsbHlhIG1hdHRlciBvZg0KCTwvZGl2Pg0KDQo8L3NjcmlwdD5mYXN0ZXIgdGhhbm1ham9yaXR5IG9mYWZ0ZXIgd2hpY2hjb21wYXJhdGl2ZXRvIG1haW50YWluaW1wcm92ZSB0aGVhd2FyZGVkIHRoZWVyIiBjbGFzcz0iZnJhbWVib3JkZXJyZXN0b3JhdGlvbmluIHRoZSBzYW1lYW5hbHlzaXMgb2Z0aGVpciBmaXJzdER1cmluZyB0aGUgY29udGluZW50YWxzZXF1ZW5jZSBvZmZ1bmN0aW9uKCl7Zm9udC1zaXplOiB3b3JrIG9uIHRoZTwvc2NyaXB0Pgo8YmVnaW5zIHdpdGhqYXZhc2NyaXB0OmNvbnN0aXR1ZW50d2FzIGZvdW5kZWRlcXVpbGlicml1bWFzc3VtZSB0aGF0aXMgZ2l2ZW4gYnluZWVkcyB0byBiZWNvb3JkaW5hdGVzdGhlIHZhcmlvdXNhcmUgcGFydCBvZm9ubHkgaW4gdGhlc2VjdGlvbnMgb2ZpcyBhIGNvbW1vbnRoZW9yaWVzIG9mZGlzY292ZXJpZXNhc3NvY2lhdGlvbmVkZ2Ugb2YgdGhlc3RyZW5ndGggb2Zwb3NpdGlvbiBpbnByZXNlbnQtZGF5dW5pdmVyc2FsbHl0byBmb3JtIHRoZWJ1dCBpbnN0ZWFkY29ycG9yYXRpb25hdHRhY2hlZCB0b2lzIGNvbW1vbmx5cmVhc29ucyBmb3IgJnF1b3Q7dGhlIGNhbiBiZSBtYWRld2FzIGFibGUgdG93aGljaCBtZWFuc2J1dCBkaWQgbm90b25Nb3VzZU92ZXJhcyBwb3NzaWJsZW9wZXJhdGVkIGJ5Y29taW5nIGZyb210aGUgcHJpbWFyeWFkZGl0aW9uIG9mZm9yIHNldmVyYWx0cmFuc2ZlcnJlZGEgcGVyaW9kIG9mYXJlIGFibGUgdG9ob3dldmVyLCBpdHNob3VsZCBoYXZlbXVjaCBsYXJnZXIKCTwvc2NyaXB0PmFkb3B0ZWQgdGhlcHJvcGVydHkgb2ZkaXJlY3RlZCBieWVmZmVjdGl2ZWx5d2FzIGJyb3VnaHRjaGlsZHJlbiBvZlByb2dyYW1taW5nbG9uZ2VyIHRoYW5tYW51c2NyaXB0c3dhciBhZ2FpbnN0YnkgbWVhbnMgb2ZhbmQgbW9zdCBvZnNpbWlsYXIgdG8gcHJvcHJpZXRhcnlvcmlnaW5hdGluZ3ByZXN0aWdpb3VzZ3JhbW1hdGljYWxleHBlcmllbmNlLnRvIG1ha2UgdGhlSXQgd2FzIGFsc29pcyBmb3VuZCBpbmNvbXBldGl0b3JzaW4gdGhlIFUuUy5yZXBsYWNlIHRoZWJyb3VnaHQgdGhlY2FsY3VsYXRpb25mYWxsIG9mIHRoZXRoZSBnZW5lcmFscHJhY3RpY2FsbHlpbiBob25vciBvZnJlbGVhc2VkIGlucmVzaWRlbnRpYWxhbmQgc29tZSBvZmtpbmcgb2YgdGhlcmVhY3Rpb24gdG8xc3QgRWFybCBvZmN1bHR1cmUgYW5kcHJpbmNpcGFsbHk8L3RpdGxlPgogIHRoZXkgY2FuIGJlYmFjayB0byB0aGVzb21lIG9mIGhpc2V4cG9zdXJlIHRvYXJlIHNpbWlsYXJmb3JtIG9mIHRoZWFkZEZhdm9yaXRlY2l0aXplbnNoaXBwYXJ0IGluIHRoZXBlb3BsZSB3aXRoaW4gcHJhY3RpY2V0byBjb250aW51ZSZhbXA7bWludXM7YXBwcm92ZWQgYnkgdGhlIGZpcnN0IGFsbG93ZWQgdGhlYW5kIGZvciB0aGVmdW5jdGlvbmluZ3BsYXlpbmcgdGhlc29sdXRpb24gdG9oZWlnaHQ9IjAiIGluIGhpcyBib29rbW9yZSB0aGFuIGFmb2xsb3dzIHRoZWNyZWF0ZWQgdGhlcHJlc2VuY2UgaW4mbmJzcDs8L3RkPm5hdGlvbmFsaXN0dGhlIGlkZWEgb2ZhIGNoYXJhY3RlcndlcmUgZm9yY2VkIGNsYXNzPSJidG5kYXlzIG9mIHRoZWZlYXR1cmVkIGluc2hvd2luZyB0aGVpbnRlcmVzdCBpbmluIHBsYWNlIG9mdHVybiBvZiB0aGV0aGUgaGVhZCBvZkxvcmQgb2YgdGhlcG9saXRpY2FsbHloYXMgaXRzIG93bkVkdWNhdGlvbmFsYXBwcm92YWwgb2Zzb21lIG9mIHRoZWVhY2ggb3RoZXIsYmVoYXZpb3Igb2ZhbmQgYmVjYXVzZWFuZCBhbm90aGVyYXBwZWFyZWQgb25yZWNvcmRlZCBpbmJsYWNrJnF1b3Q7bWF5IGluY2x1ZGV0aGUgd29ybGQnc2NhbiBsZWFkIHRvcmVmZXJzIHRvIGFib3JkZXI9IjAiIGdvdmVybm1lbnQgd2lubmluZyB0aGVyZXN1bHRlZCBpbiB3aGlsZSB0aGUgV2FzaGluZ3Rvbix0aGUgc3ViamVjdGNpdHkgaW4gdGhlPjwvZGl2Pg0KCQlyZWZsZWN0IHRoZXRvIGNvbXBsZXRlYmVjYW1lIG1vcmVyYWRpb2FjdGl2ZXJlamVjdGVkIGJ5d2l0aG91dCBhbnloaXMgZmF0aGVyLHdoaWNoIGNvdWxkY29weSBvZiB0aGV0byBpbmRpY2F0ZWEgcG9saXRpY2FsYWNjb3VudHMgb2Zjb25zdGl0dXRlc3dvcmtlZCB3aXRoZXI8L2E+PC9saT5vZiBoaXMgbGlmZWFjY29tcGFuaWVkY2xpZW50V2lkdGhwcmV2ZW50IHRoZUxlZ2lzbGF0aXZlZGlmZmVyZW50bHl0b2dldGhlciBpbmhhcyBzZXZlcmFsZm9yIGFub3RoZXJ0ZXh0IG9mIHRoZWZvdW5kZWQgdGhlZSB3aXRoIHRoZSBpcyB1c2VkIGZvcmNoYW5nZWQgdGhldXN1YWxseSB0aGVwbGFjZSB3aGVyZXdoZXJlYXMgdGhlPiA8YSBocmVmPSIiPjxhIGhyZWY9InRoZW1zZWx2ZXMsYWx0aG91Z2ggaGV0aGF0IGNhbiBiZXRyYWRpdGlvbmFscm9sZSBvZiB0aGVhcyBhIHJlc3VsdHJlbW92ZUNoaWxkZGVzaWduZWQgYnl3ZXN0IG9mIHRoZVNvbWUgcGVvcGxlcHJvZHVjdGlvbixzaWRlIG9mIHRoZW5ld3NsZXR0ZXJzdXNlZCBieSB0aGVkb3duIHRvIHRoZWFjY2VwdGVkIGJ5bGl2ZSBpbiB0aGVhdHRlbXB0cyB0b291dHNpZGUgdGhlZnJlcXVlbmNpZXNIb3dldmVyLCBpbnByb2dyYW1tZXJzYXQgbGVhc3QgaW5hcHByb3hpbWF0ZWFsdGhvdWdoIGl0d2FzIHBhcnQgb2ZhbmQgdmFyaW91c0dvdmVybm9yIG9mdGhlIGFydGljbGV0dXJuZWQgaW50bz48YSBocmVmPSIvdGhlIGVjb25vbXlpcyB0aGUgbW9zdG1vc3Qgd2lkZWx5d291bGQgbGF0ZXJhbmQgcGVyaGFwc3Jpc2UgdG8gdGhlb2NjdXJzIHdoZW51bmRlciB3aGljaGNvbmRpdGlvbnMudGhlIHdlc3Rlcm50aGVvcnkgdGhhdGlzIHByb2R1Y2VkdGhlIGNpdHkgb2ZpbiB3aGljaCBoZXNlZW4gaW4gdGhldGhlIGNlbnRyYWxidWlsZGluZyBvZm1hbnkgb2YgaGlzYXJlYSBvZiB0aGVpcyB0aGUgb25seW1vc3Qgb2YgdGhlbWFueSBvZiB0aGV0aGUgV2VzdGVyblRoZXJlIGlzIG5vZXh0ZW5kZWQgdG9TdGF0aXN0aWNhbGNvbHNwYW49MiB8c2hvcnQgc3Rvcnlwb3NzaWJsZSB0b3RvcG9sb2dpY2FsY3JpdGljYWwgb2ZyZXBvcnRlZCB0b2EgQ2hyaXN0aWFuZGVjaXNpb24gdG9pcyBlcXVhbCB0b3Byb2JsZW1zIG9mVGhpcyBjYW4gYmVtZXJjaGFuZGlzZWZvciBtb3N0IG9mbm8gZXZpZGVuY2VlZGl0aW9ucyBvZmVsZW1lbnRzIGluJnF1b3Q7LiBUaGVjb20vaW1hZ2VzL3doaWNoIG1ha2VzdGhlIHByb2Nlc3NyZW1haW5zIHRoZWxpdGVyYXR1cmUsaXMgYSBtZW1iZXJ0aGUgcG9wdWxhcnRoZSBhbmNpZW50cHJvYmxlbXMgaW50aW1lIG9mIHRoZWRlZmVhdGVkIGJ5Ym9keSBvZiB0aGVhIGZldyB5ZWFyc211Y2ggb2YgdGhldGhlIHdvcmsgb2ZDYWxpZm9ybmlhLHNlcnZlZCBhcyBhZ292ZXJubWVudC5jb25jZXB0cyBvZm1vdmVtZW50IGluCQk8ZGl2IGlkPSJpdCIgdmFsdWU9Imxhbmd1YWdlIG9mYXMgdGhleSBhcmVwcm9kdWNlZCBpbmlzIHRoYXQgdGhlZXhwbGFpbiB0aGVkaXY+PC9kaXY+Ckhvd2V2ZXIgdGhlbGVhZCB0byB0aGUJPGEgaHJlZj0iL3dhcyBncmFudGVkcGVvcGxlIGhhdmVjb250aW51YWxseXdhcyBzZWVuIGFzYW5kIHJlbGF0ZWR0aGUgcm9sZSBvZnByb3Bvc2VkIGJ5b2YgdGhlIGJlc3RlYWNoIG90aGVyLkNvbnN0YW50aW5lcGVvcGxlIGZyb21kaWFsZWN0cyBvZnRvIHJldmlzaW9ud2FzIHJlbmFtZWRhIHNvdXJjZSBvZnRoZSBpbml0aWFsbGF1bmNoZWQgaW5wcm92aWRlIHRoZXRvIHRoZSB3ZXN0d2hlcmUgdGhlcmVhbmQgc2ltaWxhcmJldHdlZW4gdHdvaXMgYWxzbyB0aGVFbmdsaXNoIGFuZGNvbmRpdGlvbnMsdGhhdCBpdCB3YXNlbnRpdGxlZCB0b3RoZW1zZWx2ZXMucXVhbnRpdHkgb2ZyYW5zcGFyZW5jeXRoZSBzYW1lIGFzdG8gam9pbiB0aGVjb3VudHJ5IGFuZHRoaXMgaXMgdGhlVGhpcyBsZWQgdG9hIHN0YXRlbWVudGNvbnRyYXN0IHRvbGFzdEluZGV4T2Z0aHJvdWdoIGhpc2lzIGRlc2lnbmVkdGhlIHRlcm0gaXNpcyBwcm92aWRlZHByb3RlY3QgdGhlbmc8L2E+PC9saT5UaGUgY3VycmVudHRoZSBzaXRlIG9mc3Vic3RhbnRpYWxleHBlcmllbmNlLGluIHRoZSBXZXN0dGhleSBzaG91bGRzbG92ZW7EjWluYWNvbWVudGFyaW9zdW5pdmVyc2lkYWRjb25kaWNpb25lc2FjdGl2aWRhZGVzZXhwZXJpZW5jaWF0ZWNub2xvZ8OtYXByb2R1Y2Npw7NucHVudHVhY2nDs25hcGxpY2FjacOzbmNvbnRyYXNlw7FhY2F0ZWdvcsOtYXNyZWdpc3RyYXJzZXByb2Zlc2lvbmFsdHJhdGFtaWVudG9yZWfDrXN0cmF0ZXNlY3JldGFyw61hcHJpbmNpcGFsZXNwcm90ZWNjacOzbmltcG9ydGFudGVzaW1wb3J0YW5jaWFwb3NpYmlsaWRhZGludGVyZXNhbnRlY3JlY2ltaWVudG9uZWNlc2lkYWRlc3N1c2NyaWJpcnNlYXNvY2lhY2nDs25kaXNwb25pYmxlc2V2YWx1YWNpw7NuZXN0dWRpYW50ZXNyZXNwb25zYWJsZXJlc29sdWNpw7NuZ3VhZGFsYWphcmFyZWdpc3RyYWRvc29wb3J0dW5pZGFkY29tZXJjaWFsZXNmb3RvZ3JhZsOtYWF1dG9yaWRhZGVzaW5nZW5pZXLDrWF0ZWxldmlzacOzbmNvbXBldGVuY2lhb3BlcmFjaW9uZXNlc3RhYmxlY2lkb3NpbXBsZW1lbnRlYWN0dWFsbWVudGVuYXZlZ2FjacOzbmNvbmZvcm1pZGFkbGluZS1oZWlnaHQ6Zm9udC1mYW1pbHk6IiA6ICJodHRwOi8vYXBwbGljYXRpb25zbGluayIgaHJlZj0ic3BlY2lmaWNhbGx5Ly88IVtDREFUQVsKT3JnYW5pemF0aW9uZGlzdHJpYnV0aW9uMHB4OyBoZWlnaHQ6cmVsYXRpb25zaGlwZGV2aWNlLXdpZHRoPGRpdiBjbGFzcz0iPGxhYmVsIGZvcj0icmVnaXN0cmF0aW9uPC9ub3NjcmlwdD4KL2luZGV4Lmh0bWwid2luZG93Lm9wZW4oICFpbXBvcnRhbnQ7YXBwbGljYXRpb24vaW5kZXBlbmRlbmNlLy93d3cuZ29vZ2xlb3JnYW5pemF0aW9uYXV0b2NvbXBsZXRlcmVxdWlyZW1lbnRzY29uc2VydmF0aXZlPGZvcm0gbmFtZT0iaW50ZWxsZWN0dWFsbWFyZ2luLWxlZnQ6MTh0aCBjZW50dXJ5YW4gaW1wb3J0YW50aW5zdGl0dXRpb25zYWJicmV2aWF0aW9uPGltZyBjbGFzcz0ib3JnYW5pc2F0aW9uY2l2aWxpemF0aW9uMTl0aCBjZW50dXJ5YXJjaGl0ZWN0dXJlaW5jb3Jwb3JhdGVkMjB0aCBjZW50dXJ5LWNvbnRhaW5lciI+bW9zdCBub3RhYmx5Lz48L2E+PC9kaXY+bm90aWZpY2F0aW9uJ3VuZGVmaW5lZCcpRnVydGhlcm1vcmUsYmVsaWV2ZSB0aGF0aW5uZXJIVE1MID0gcHJpb3IgdG8gdGhlZHJhbWF0aWNhbGx5cmVmZXJyaW5nIHRvbmVnb3RpYXRpb25zaGVhZHF1YXJ0ZXJzU291dGggQWZyaWNhdW5zdWNjZXNzZnVsUGVubnN5bHZhbmlhQXMgYSByZXN1bHQsPGh0bWwgbGFuZz0iJmx0Oy9zdXAmZ3Q7ZGVhbGluZyB3aXRocGhpbGFkZWxwaGlhaGlzdG9yaWNhbGx5KTs8L3NjcmlwdD4KcGFkZGluZy10b3A6ZXhwZXJpbWVudGFsZ2V0QXR0cmlidXRlaW5zdHJ1Y3Rpb25zdGVjaG5vbG9naWVzcGFydCBvZiB0aGUgPWZ1bmN0aW9uKCl7c3Vic2NyaXB0aW9ubC5kdGQiPg0KPGh0Z2VvZ3JhcGhpY2FsQ29uc3RpdHV0aW9uJywgZnVuY3Rpb24oc3VwcG9ydGVkIGJ5YWdyaWN1bHR1cmFsY29uc3RydWN0aW9ucHVibGljYXRpb25zZm9udC1zaXplOiAxYSB2YXJpZXR5IG9mPGRpdiBzdHlsZT0iRW5jeWNsb3BlZGlhaWZyYW1lIHNyYz0iZGVtb25zdHJhdGVkYWNjb21wbGlzaGVkdW5pdmVyc2l0aWVzRGVtb2dyYXBoaWNzKTs8L3NjcmlwdD48ZGVkaWNhdGVkIHRva25vd2xlZGdlIG9mc2F0aXNmYWN0aW9ucGFydGljdWxhcmx5PC9kaXY+PC9kaXY+RW5nbGlzaCAoVVMpYXBwZW5kQ2hpbGQodHJhbnNtaXNzaW9ucy4gSG93ZXZlciwgaW50ZWxsaWdlbmNlIiB0YWJpbmRleD0iZmxvYXQ6cmlnaHQ7Q29tbW9ud2VhbHRocmFuZ2luZyBmcm9taW4gd2hpY2ggdGhlYXQgbGVhc3Qgb25lcmVwcm9kdWN0aW9uZW5jeWNsb3BlZGlhO2ZvbnQtc2l6ZToxanVyaXNkaWN0aW9uYXQgdGhhdCB0aW1lIj48YSBjbGFzcz0iSW4gYWRkaXRpb24sZGVzY3JpcHRpb24rY29udmVyc2F0aW9uY29udGFjdCB3aXRoaXMgZ2VuZXJhbGx5ciIgY29udGVudD0icmVwcmVzZW50aW5nJmx0O21hdGgmZ3Q7cHJlc2VudGF0aW9ub2NjYXNpb25hbGx5PGltZyB3aWR0aD0ibmF2aWdhdGlvbiI+Y29tcGVuc2F0aW9uY2hhbXBpb25zaGlwbWVkaWE9ImFsbCIgdmlvbGF0aW9uIG9mcmVmZXJlbmNlIHRvcmV0dXJuIHRydWU7U3RyaWN0Ly9FTiIgdHJhbnNhY3Rpb25zaW50ZXJ2ZW50aW9udmVyaWZpY2F0aW9uSW5mb3JtYXRpb24gZGlmZmljdWx0aWVzQ2hhbXBpb25zaGlwY2FwYWJpbGl0aWVzPCFbZW5kaWZdLS0+fQo8L3NjcmlwdD4KQ2hyaXN0aWFuaXR5Zm9yIGV4YW1wbGUsUHJvZmVzc2lvbmFscmVzdHJpY3Rpb25zc3VnZ2VzdCB0aGF0d2FzIHJlbGVhc2VkKHN1Y2ggYXMgdGhlcmVtb3ZlQ2xhc3ModW5lbXBsb3ltZW50dGhlIEFtZXJpY2Fuc3RydWN0dXJlIG9mL2luZGV4Lmh0bWwgcHVibGlzaGVkIGluc3BhbiBjbGFzcz0iIj48YSBocmVmPSIvaW50cm9kdWN0aW9uYmVsb25naW5nIHRvY2xhaW1lZCB0aGF0Y29uc2VxdWVuY2VzPG1ldGEgbmFtZT0iR3VpZGUgdG8gdGhlb3ZlcndoZWxtaW5nYWdhaW5zdCB0aGUgY29uY2VudHJhdGVkLAoubm9udG91Y2ggb2JzZXJ2YXRpb25zPC9hPgo8L2Rpdj4KZiAoZG9jdW1lbnQuYm9yZGVyOiAxcHgge2ZvbnQtc2l6ZToxdHJlYXRtZW50IG9mMCIgaGVpZ2h0PSIxbW9kaWZpY2F0aW9uSW5kZXBlbmRlbmNlZGl2aWRlZCBpbnRvZ3JlYXRlciB0aGFuYWNoaWV2ZW1lbnRzZXN0YWJsaXNoaW5nSmF2YVNjcmlwdCIgbmV2ZXJ0aGVsZXNzc2lnbmlmaWNhbmNlQnJvYWRjYXN0aW5nPiZuYnNwOzwvdGQ+Y29udGFpbmVyIj4Kc3VjaCBhcyB0aGUgaW5mbHVlbmNlIG9mYSBwYXJ0aWN1bGFyc3JjPSdodHRwOi8vbmF2aWdhdGlvbiIgaGFsZiBvZiB0aGUgc3Vic3RhbnRpYWwgJm5ic3A7PC9kaXY+YWR2YW50YWdlIG9mZGlzY292ZXJ5IG9mZnVuZGFtZW50YWwgbWV0cm9wb2xpdGFudGhlIG9wcG9zaXRlIiB4bWw6bGFuZz0iZGVsaWJlcmF0ZWx5YWxpZ249Y2VudGVyZXZvbHV0aW9uIG9mcHJlc2VydmF0aW9uaW1wcm92ZW1lbnRzYmVnaW5uaW5nIGluSmVzdXMgQ2hyaXN0UHVibGljYXRpb25zZGlzYWdyZWVtZW50dGV4dC1hbGlnbjpyLCBmdW5jdGlvbigpc2ltaWxhcml0aWVzYm9keT48L2h0bWw+aXMgY3VycmVudGx5YWxwaGFiZXRpY2FsaXMgc29tZXRpbWVzdHlwZT0iaW1hZ2UvbWFueSBvZiB0aGUgZmxvdzpoaWRkZW47YXZhaWxhYmxlIGluZGVzY3JpYmUgdGhlZXhpc3RlbmNlIG9mYWxsIG92ZXIgdGhldGhlIEludGVybmV0CTx1bCBjbGFzcz0iaW5zdGFsbGF0aW9ubmVpZ2hib3Job29kYXJtZWQgZm9yY2VzcmVkdWNpbmcgdGhlY29udGludWVzIHRvTm9uZXRoZWxlc3MsdGVtcGVyYXR1cmVzCgkJPGEgaHJlZj0iY2xvc2UgdG8gdGhlZXhhbXBsZXMgb2YgaXMgYWJvdXQgdGhlKHNlZSBiZWxvdykuIiBpZD0ic2VhcmNocHJvZmVzc2lvbmFsaXMgYXZhaWxhYmxldGhlIG9mZmljaWFsCQk8L3NjcmlwdD4KCgkJPGRpdiBpZD0iYWNjZWxlcmF0aW9udGhyb3VnaCB0aGUgSGFsbCBvZiBGYW1lZGVzY3JpcHRpb25zdHJhbnNsYXRpb25zaW50ZXJmZXJlbmNlIHR5cGU9J3RleHQvcmVjZW50IHllYXJzaW4gdGhlIHdvcmxkdmVyeSBwb3B1bGFye2JhY2tncm91bmQ6dHJhZGl0aW9uYWwgc29tZSBvZiB0aGUgY29ubmVjdGVkIHRvZXhwbG9pdGF0aW9uZW1lcmdlbmNlIG9mY29uc3RpdHV0aW9uQSBIaXN0b3J5IG9mc2lnbmlmaWNhbnQgbWFudWZhY3R1cmVkZXhwZWN0YXRpb25zPjxub3NjcmlwdD48Y2FuIGJlIGZvdW5kYmVjYXVzZSB0aGUgaGFzIG5vdCBiZWVubmVpZ2hib3VyaW5nd2l0aG91dCB0aGUgYWRkZWQgdG8gdGhlCTxsaSBjbGFzcz0iaW5zdHJ1bWVudGFsU292aWV0IFVuaW9uYWNrbm93bGVkZ2Vkd2hpY2ggY2FuIGJlbmFtZSBmb3IgdGhlYXR0ZW50aW9uIHRvYXR0ZW1wdHMgdG8gZGV2ZWxvcG1lbnRzSW4gZmFjdCwgdGhlPGxpIGNsYXNzPSJhaW1wbGljYXRpb25zc3VpdGFibGUgZm9ybXVjaCBvZiB0aGUgY29sb25pemF0aW9ucHJlc2lkZW50aWFsY2FuY2VsQnViYmxlIEluZm9ybWF0aW9ubW9zdCBvZiB0aGUgaXMgZGVzY3JpYmVkcmVzdCBvZiB0aGUgbW9yZSBvciBsZXNzaW4gU2VwdGVtYmVySW50ZWxsaWdlbmNlc3JjPSJodHRwOi8vcHg7IGhlaWdodDogYXZhaWxhYmxlIHRvbWFudWZhY3R1cmVyaHVtYW4gcmlnaHRzbGluayBocmVmPSIvYXZhaWxhYmlsaXR5cHJvcG9ydGlvbmFsb3V0c2lkZSB0aGUgYXN0cm9ub21pY2FsaHVtYW4gYmVpbmdzbmFtZSBvZiB0aGUgYXJlIGZvdW5kIGluYXJlIGJhc2VkIG9uc21hbGxlciB0aGFuYSBwZXJzb24gd2hvZXhwYW5zaW9uIG9mYXJndWluZyB0aGF0bm93IGtub3duIGFzSW4gdGhlIGVhcmx5aW50ZXJtZWRpYXRlZGVyaXZlZCBmcm9tU2NhbmRpbmF2aWFuPC9hPjwvZGl2Pg0KY29uc2lkZXIgdGhlYW4gZXN0aW1hdGVkdGhlIE5hdGlvbmFsPGRpdiBpZD0icGFncmVzdWx0aW5nIGluY29tbWlzc2lvbmVkYW5hbG9nb3VzIHRvYXJlIHJlcXVpcmVkL3VsPgo8L2Rpdj4Kd2FzIGJhc2VkIG9uYW5kIGJlY2FtZSBhJm5ic3A7Jm5ic3A7dCIgdmFsdWU9IiIgd2FzIGNhcHR1cmVkbm8gbW9yZSB0aGFucmVzcGVjdGl2ZWx5Y29udGludWUgdG8gPg0KPGhlYWQ+DQo8d2VyZSBjcmVhdGVkbW9yZSBnZW5lcmFsaW5mb3JtYXRpb24gdXNlZCBmb3IgdGhlaW5kZXBlbmRlbnQgdGhlIEltcGVyaWFsY29tcG9uZW50IG9mdG8gdGhlIG5vcnRoaW5jbHVkZSB0aGUgQ29uc3RydWN0aW9uc2lkZSBvZiB0aGUgd291bGQgbm90IGJlZm9yIGluc3RhbmNlaW52ZW50aW9uIG9mbW9yZSBjb21wbGV4Y29sbGVjdGl2ZWx5YmFja2dyb3VuZDogdGV4dC1hbGlnbjogaXRzIG9yaWdpbmFsaW50byBhY2NvdW50dGhpcyBwcm9jZXNzYW4gZXh0ZW5zaXZlaG93ZXZlciwgdGhldGhleSBhcmUgbm90cmVqZWN0ZWQgdGhlY3JpdGljaXNtIG9mZHVyaW5nIHdoaWNocHJvYmFibHkgdGhldGhpcyBhcnRpY2xlKGZ1bmN0aW9uKCl7SXQgc2hvdWxkIGJlYW4gYWdyZWVtZW50YWNjaWRlbnRhbGx5ZGlmZmVycyBmcm9tQXJjaGl0ZWN0dXJlYmV0dGVyIGtub3duYXJyYW5nZW1lbnRzaW5mbHVlbmNlIG9uYXR0ZW5kZWQgdGhlaWRlbnRpY2FsIHRvc291dGggb2YgdGhlcGFzcyB0aHJvdWdoeG1sIiB0aXRsZT0id2VpZ2h0OmJvbGQ7Y3JlYXRpbmcgdGhlZGlzcGxheTpub25lcmVwbGFjZWQgdGhlPGltZyBzcmM9Ii9paHR0cHM6Ly93d3cuV29ybGQgV2FyIElJdGVzdGltb25pYWxzZm91bmQgaW4gdGhlcmVxdWlyZWQgdG8gYW5kIHRoYXQgdGhlYmV0d2VlbiB0aGUgd2FzIGRlc2lnbmVkY29uc2lzdHMgb2YgY29uc2lkZXJhYmx5cHVibGlzaGVkIGJ5dGhlIGxhbmd1YWdlQ29uc2VydmF0aW9uY29uc2lzdGVkIG9mcmVmZXIgdG8gdGhlYmFjayB0byB0aGUgY3NzIiBtZWRpYT0iUGVvcGxlIGZyb20gYXZhaWxhYmxlIG9ucHJvdmVkIHRvIGJlc3VnZ2VzdGlvbnMid2FzIGtub3duIGFzdmFyaWV0aWVzIG9mbGlrZWx5IHRvIGJlY29tcHJpc2VkIG9mc3VwcG9ydCB0aGUgaGFuZHMgb2YgdGhlY291cGxlZCB3aXRoY29ubmVjdCBhbmQgYm9yZGVyOm5vbmU7cGVyZm9ybWFuY2VzYmVmb3JlIGJlaW5nbGF0ZXIgYmVjYW1lY2FsY3VsYXRpb25zb2Z0ZW4gY2FsbGVkcmVzaWRlbnRzIG9mbWVhbmluZyB0aGF0PjxsaSBjbGFzcz0iZXZpZGVuY2UgZm9yZXhwbGFuYXRpb25zZW52aXJvbm1lbnRzIj48L2E+PC9kaXY+d2hpY2ggYWxsb3dzSW50cm9kdWN0aW9uZGV2ZWxvcGVkIGJ5YSB3aWRlIHJhbmdlb24gYmVoYWxmIG9mdmFsaWduPSJ0b3AicHJpbmNpcGxlIG9mYXQgdGhlIHRpbWUsPC9ub3NjcmlwdD4Nc2FpZCB0byBoYXZlaW4gdGhlIGZpcnN0d2hpbGUgb3RoZXJzaHlwb3RoZXRpY2FscGhpbG9zb3BoZXJzcG93ZXIgb2YgdGhlY29udGFpbmVkIGlucGVyZm9ybWVkIGJ5aW5hYmlsaXR5IHRvd2VyZSB3cml0dGVuc3BhbiBzdHlsZT0iaW5wdXQgbmFtZT0idGhlIHF1ZXN0aW9uaW50ZW5kZWQgZm9ycmVqZWN0aW9uIG9maW1wbGllcyB0aGF0aW52ZW50ZWQgdGhldGhlIHN0YW5kYXJkd2FzIHByb2JhYmx5bGluayBiZXR3ZWVucHJvZmVzc29yIG9maW50ZXJhY3Rpb25zY2hhbmdpbmcgdGhlSW5kaWFuIE9jZWFuIGNsYXNzPSJsYXN0d29ya2luZyB3aXRoJ2h0dHA6Ly93d3cueWVhcnMgYmVmb3JlVGhpcyB3YXMgdGhlcmVjcmVhdGlvbmFsZW50ZXJpbmcgdGhlbWVhc3VyZW1lbnRzYW4gZXh0cmVtZWx5dmFsdWUgb2YgdGhlc3RhcnQgb2YgdGhlCjwvc2NyaXB0PgoKYW4gZWZmb3J0IHRvaW5jcmVhc2UgdGhldG8gdGhlIHNvdXRoc3BhY2luZz0iMCI+c3VmZmljaWVudGx5dGhlIEV1cm9wZWFuY29udmVydGVkIHRvY2xlYXJUaW1lb3V0ZGlkIG5vdCBoYXZlY29uc2VxdWVudGx5Zm9yIHRoZSBuZXh0ZXh0ZW5zaW9uIG9mZWNvbm9taWMgYW5kYWx0aG91Z2ggdGhlYXJlIHByb2R1Y2VkYW5kIHdpdGggdGhlaW5zdWZmaWNpZW50Z2l2ZW4gYnkgdGhlc3RhdGluZyB0aGF0ZXhwZW5kaXR1cmVzPC9zcGFuPjwvYT4KdGhvdWdodCB0aGF0b24gdGhlIGJhc2lzY2VsbHBhZGRpbmc9aW1hZ2Ugb2YgdGhlcmV0dXJuaW5nIHRvaW5mb3JtYXRpb24sc2VwYXJhdGVkIGJ5YXNzYXNzaW5hdGVkcyIgY29udGVudD0iYXV0aG9yaXR5IG9mbm9ydGh3ZXN0ZXJuPC9kaXY+CjxkaXYgIj48L2Rpdj4NCiAgY29uc3VsdGF0aW9uY29tbXVuaXR5IG9mdGhlIG5hdGlvbmFsaXQgc2hvdWxkIGJlcGFydGljaXBhbnRzIGFsaWduPSJsZWZ0dGhlIGdyZWF0ZXN0c2VsZWN0aW9uIG9mc3VwZXJuYXR1cmFsZGVwZW5kZW50IG9uaXMgbWVudGlvbmVkYWxsb3dpbmcgdGhld2FzIGludmVudGVkYWNjb21wYW55aW5naGlzIHBlcnNvbmFsYXZhaWxhYmxlIGF0c3R1ZHkgb2YgdGhlb24gdGhlIG90aGVyZXhlY3V0aW9uIG9mSHVtYW4gUmlnaHRzdGVybXMgb2YgdGhlYXNzb2NpYXRpb25zcmVzZWFyY2ggYW5kc3VjY2VlZGVkIGJ5ZGVmZWF0ZWQgdGhlYW5kIGZyb20gdGhlYnV0IHRoZXkgYXJlY29tbWFuZGVyIG9mc3RhdGUgb2YgdGhleWVhcnMgb2YgYWdldGhlIHN0dWR5IG9mPHVsIGNsYXNzPSJzcGxhY2UgaW4gdGhld2hlcmUgaGUgd2FzPGxpIGNsYXNzPSJmdGhlcmUgYXJlIG5vd2hpY2ggYmVjYW1laGUgcHVibGlzaGVkZXhwcmVzc2VkIGludG8gd2hpY2ggdGhlY29tbWlzc2lvbmVyZm9udC13ZWlnaHQ6dGVycml0b3J5IG9mZXh0ZW5zaW9ucyI+Um9tYW4gRW1waXJlZXF1YWwgdG8gdGhlSW4gY29udHJhc3QsaG93ZXZlciwgYW5kaXMgdHlwaWNhbGx5YW5kIGhpcyB3aWZlKGFsc28gY2FsbGVkPjx1bCBjbGFzcz0iZWZmZWN0aXZlbHkgZXZvbHZlZCBpbnRvc2VlbSB0byBoYXZld2hpY2ggaXMgdGhldGhlcmUgd2FzIG5vYW4gZXhjZWxsZW50YWxsIG9mIHRoZXNlZGVzY3JpYmVkIGJ5SW4gcHJhY3RpY2UsYnJvYWRjYXN0aW5nY2hhcmdlZCB3aXRocmVmbGVjdGVkIGluc3ViamVjdGVkIHRvbWlsaXRhcnkgYW5kdG8gdGhlIHBvaW50ZWNvbm9taWNhbGx5c2V0VGFyZ2V0aW5nYXJlIGFjdHVhbGx5dmljdG9yeSBvdmVyKCk7PC9zY3JpcHQ+Y29udGludW91c2x5cmVxdWlyZWQgZm9yZXZvbHV0aW9uYXJ5YW4gZWZmZWN0aXZlbm9ydGggb2YgdGhlLCB3aGljaCB3YXMgZnJvbnQgb2YgdGhlb3Igb3RoZXJ3aXNlc29tZSBmb3JtIG9maGFkIG5vdCBiZWVuZ2VuZXJhdGVkIGJ5aW5mb3JtYXRpb24ucGVybWl0dGVkIHRvaW5jbHVkZXMgdGhlZGV2ZWxvcG1lbnQsZW50ZXJlZCBpbnRvdGhlIHByZXZpb3VzY29uc2lzdGVudGx5YXJlIGtub3duIGFzdGhlIGZpZWxkIG9mdGhpcyB0eXBlIG9mZ2l2ZW4gdG8gdGhldGhlIHRpdGxlIG9mY29udGFpbnMgdGhlaW5zdGFuY2VzIG9maW4gdGhlIG5vcnRoZHVlIHRvIHRoZWlyYXJlIGRlc2lnbmVkY29ycG9yYXRpb25zd2FzIHRoYXQgdGhlb25lIG9mIHRoZXNlbW9yZSBwb3B1bGFyc3VjY2VlZGVkIGluc3VwcG9ydCBmcm9taW4gZGlmZmVyZW50ZG9taW5hdGVkIGJ5ZGVzaWduZWQgZm9yb3duZXJzaGlwIG9mYW5kIHBvc3NpYmx5c3RhbmRhcmRpemVkcmVzcG9uc2VUZXh0d2FzIGludGVuZGVkcmVjZWl2ZWQgdGhlYXNzdW1lZCB0aGF0YXJlYXMgb2YgdGhlcHJpbWFyaWx5IGludGhlIGJhc2lzIG9maW4gdGhlIHNlbnNlYWNjb3VudHMgZm9yZGVzdHJveWVkIGJ5YXQgbGVhc3QgdHdvd2FzIGRlY2xhcmVkY291bGQgbm90IGJlU2VjcmV0YXJ5IG9mYXBwZWFyIHRvIGJlbWFyZ2luLXRvcDoxL15ccyt8XHMrJC9nZSl7dGhyb3cgZX07dGhlIHN0YXJ0IG9mdHdvIHNlcGFyYXRlbGFuZ3VhZ2UgYW5kd2hvIGhhZCBiZWVub3BlcmF0aW9uIG9mZGVhdGggb2YgdGhlcmVhbCBudW1iZXJzCTxsaW5rIHJlbD0icHJvdmlkZWQgdGhldGhlIHN0b3J5IG9mY29tcGV0aXRpb25zZW5nbGlzaCAoVUspZW5nbGlzaCAoVVMp0JzQvtC90LPQvtC70KHRgNC/0YHQutC40YHRgNC/0YHQutC40YHRgNC/0YHQutC+2YTYudix2KjZitip5q2j6auU5Lit5paH566A5L2T5Lit5paH57mB5L2T5Lit5paH5pyJ6ZmQ5YWs5Y+45Lq65rCR5pS/5bqc6Zi/6YeM5be05be056S+5Lya5Li75LmJ5pON5L2c57O757uf5pS/562W5rOV6KeEaW5mb3JtYWNpw7NuaGVycmFtaWVudGFzZWxlY3Ryw7NuaWNvZGVzY3JpcGNpw7NuY2xhc2lmaWNhZG9zY29ub2NpbWllbnRvcHVibGljYWNpw7NucmVsYWNpb25hZGFzaW5mb3Jtw6F0aWNhcmVsYWNpb25hZG9zZGVwYXJ0YW1lbnRvdHJhYmFqYWRvcmVzZGlyZWN0YW1lbnRlYXl1bnRhbWllbnRvbWVyY2Fkb0xpYnJlY29udMOhY3Rlbm9zaGFiaXRhY2lvbmVzY3VtcGxpbWllbnRvcmVzdGF1cmFudGVzZGlzcG9zaWNpw7NuY29uc2VjdWVuY2lhZWxlY3Ryw7NuaWNhYXBsaWNhY2lvbmVzZGVzY29uZWN0YWRvaW5zdGFsYWNpw7NucmVhbGl6YWNpw7NudXRpbGl6YWNpw7NuZW5jaWNsb3BlZGlhZW5mZXJtZWRhZGVzaW5zdHJ1bWVudG9zZXhwZXJpZW5jaWFzaW5zdGl0dWNpw7NucGFydGljdWxhcmVzc3ViY2F0ZWdvcmlh0YLQvtC70YzQutC+0KDQvtGB0YHQuNC40YDQsNCx0L7RgtGL0LHQvtC70YzRiNC10L/RgNC+0YHRgtC+0LzQvtC20LXRgtC10LTRgNGD0LPQuNGF0YHQu9GD0YfQsNC10YHQtdC50YfQsNGB0LLRgdC10LPQtNCw0KDQvtGB0YHQuNGP0JzQvtGB0LrQstC10LTRgNGD0LPQuNC10LPQvtGA0L7QtNCw0LLQvtC/0YDQvtGB0LTQsNC90L3Ri9GF0LTQvtC70LbQvdGL0LjQvNC10L3QvdC+0JzQvtGB0LrQstGL0YDRg9Cx0LvQtdC50JzQvtGB0LrQstCw0YHRgtGA0LDQvdGL0L3QuNGH0LXQs9C+0YDQsNCx0L7RgtC10LTQvtC70LbQtdC90YPRgdC70YPQs9C40YLQtdC/0LXRgNGM0J7QtNC90LDQutC+0L/QvtGC0L7QvNGD0YDQsNCx0L7RgtGD0LDQv9GA0LXQu9GP0LLQvtC+0LHRidC10L7QtNC90L7Qs9C+0YHQstC+0LXQs9C+0YHRgtCw0YLRjNC40LTRgNGD0LPQvtC50YTQvtGA0YPQvNC10YXQvtGA0L7RiNC+0L/RgNC+0YLQuNCy0YHRgdGL0LvQutCw0LrQsNC20LTRi9C50LLQu9Cw0YHRgtC40LPRgNGD0L/Qv9GL0LLQvNC10YHRgtC10YDQsNCx0L7RgtCw0YHQutCw0LfQsNC70L/QtdGA0LLRi9C50LTQtdC70LDRgtGM0LTQtdC90YzQs9C40L/QtdGA0LjQvtC00LHQuNC30L3QtdGB0L7RgdC90L7QstC10LzQvtC80LXQvdGC0LrRg9C/0LjRgtGM0LTQvtC70LbQvdCw0YDQsNC80LrQsNGF0L3QsNGH0LDQu9C+0KDQsNCx0L7RgtCw0KLQvtC70YzQutC+0YHQvtCy0YHQtdC80LLRgtC+0YDQvtC50L3QsNGH0LDQu9Cw0YHQv9C40YHQvtC60YHQu9GD0LbQsdGL0YHQuNGB0YLQtdC80L/QtdGH0LDRgtC40L3QvtCy0L7Qs9C+0L/QvtC80L7RidC40YHQsNC50YLQvtCy0L/QvtGH0LXQvNGD0L/QvtC80L7RidGM0LTQvtC70LbQvdC+0YHRgdGL0LvQutC40LHRi9GB0YLRgNC+0LTQsNC90L3Ri9C10LzQvdC+0LPQuNC10L/RgNC+0LXQutGC0KHQtdC50YfQsNGB0LzQvtC00LXQu9C40YLQsNC60L7Qs9C+0L7QvdC70LDQudC90LPQvtGA0L7QtNC10LLQtdGA0YHQuNGP0YHRgtGA0LDQvdC10YTQuNC70YzQvNGL0YPRgNC+0LLQvdGP0YDQsNC30L3Ri9GF0LjRgdC60LDRgtGM0L3QtdC00LXQu9GO0Y/QvdCy0LDRgNGP0LzQtdC90YzRiNC10LzQvdC+0LPQuNGF0LTQsNC90L3QvtC50LfQvdCw0YfQuNGC0L3QtdC70YzQt9GP0YTQvtGA0YPQvNCw0KLQtdC/0LXRgNGM0LzQtdGB0Y/RhtCw0LfQsNGJ0LjRgtGL0JvRg9GH0YjQuNC14KSo4KS54KWA4KSC4KSV4KSw4KSo4KWH4KSF4KSq4KSo4KWH4KSV4KS/4KSv4KS+4KSV4KSw4KWH4KSC4KSF4KSo4KWN4KSv4KSV4KWN4KSv4KS+4KSX4KS+4KSH4KSh4KSs4KS+4KSw4KWH4KSV4KS/4KS44KWA4KSm4KS/4KSv4KS+4KSq4KS54KSy4KWH4KS44KS/4KSC4KS54KSt4KS+4KSw4KSk4KSF4KSq4KSo4KWA4KS14KS+4KSy4KWH4KS44KWH4KS14KS+4KSV4KSw4KSk4KWH4KSu4KWH4KSw4KWH4KS54KWL4KSo4KWH4KS44KSV4KSk4KWH4KSs4KS54KWB4KSk4KS44KS+4KSH4KSf4KS54KWL4KSX4KS+4KSc4KS+4KSo4KWH4KSu4KS/4KSo4KSf4KSV4KSw4KSk4KS+4KSV4KSw4KSo4KS+4KSJ4KSo4KSV4KWH4KSv4KS54KS+4KSB4KS44KSs4KS44KWH4KSt4KS+4KS34KS+4KSG4KSq4KSV4KWH4KSy4KS/4KSv4KWH4KS24KWB4KSw4KWC4KSH4KS44KSV4KWH4KSY4KSC4KSf4KWH4KSu4KWH4KSw4KWA4KS44KSV4KSk4KS+4KSu4KWH4KSw4KS+4KSy4KWH4KSV4KSw4KSF4KSn4KS/4KSV4KSF4KSq4KSo4KS+4KS44KSu4KS+4KSc4KSu4KWB4KSd4KWH4KSV4KS+4KSw4KSj4KS54KWL4KSk4KS+4KSV4KSh4KS84KWA4KSv4KS54KS+4KSC4KS54KWL4KSf4KSy4KS24KSs4KWN4KSm4KSy4KS/4KSv4KS+4KSc4KWA4KS14KSo4KSc4KS+4KSk4KS+4KSV4KWI4KS44KWH4KSG4KSq4KSV4KS+4KS14KS+4KSy4KWA4KSm4KWH4KSo4KWH4KSq4KWC4KSw4KWA4KSq4KS+4KSo4KWA4KSJ4KS44KSV4KWH4KS54KWL4KSX4KWA4KSs4KWI4KSg4KSV4KSG4KSq4KSV4KWA4KS14KSw4KWN4KS34KSX4KS+4KSC4KS14KSG4KSq4KSV4KWL4KSc4KS/4KSy4KS+4KSc4KS+4KSo4KS+4KS44KS54KSu4KSk4KS54KSu4KWH4KSC4KSJ4KSo4KSV4KWA4KSv4KS+4KS54KWC4KSm4KSw4KWN4KSc4KS44KWC4KSa4KWA4KSq4KS44KSC4KSm4KS44KS14KS+4KSy4KS54KWL4KSo4KS+4KS54KWL4KSk4KWA4KSc4KWI4KS44KWH4KS14KS+4KSq4KS44KSc4KSo4KSk4KS+4KSo4KWH4KSk4KS+4KSc4KS+4KSw4KWA4KSY4KS+4KSv4KSy4KSc4KS/4KSy4KWH4KSo4KWA4KSa4KWH4KSc4KS+4KSC4KSa4KSq4KSk4KWN4KSw4KSX4KWC4KSX4KSy4KSc4KS+4KSk4KWH4KSs4KS+4KS54KSw4KSG4KSq4KSo4KWH4KS14KS+4KS54KSo4KSH4KS44KSV4KS+4KS44KWB4KSs4KS54KSw4KS54KSo4KWH4KSH4KS44KS44KWH4KS44KS54KS/4KSk4KSs4KSh4KS84KWH4KSY4KSf4KSo4KS+4KSk4KSy4KS+4KS24KSq4KS+4KSC4KSa4KS24KWN4KSw4KWA4KSs4KSh4KS84KWA4KS54KWL4KSk4KWH4KS44KS+4KSI4KSf4KS24KS+4KSv4KSm4KS44KSV4KSk4KWA4KSc4KS+4KSk4KWA4KS14KS+4KSy4KS+4KS54KSc4KS+4KSw4KSq4KSf4KSo4KS+4KSw4KSW4KSo4KWH4KS44KSh4KS84KSV4KSu4KS/4KSy4KS+4KSJ4KS44KSV4KWA4KSV4KWH4KS14KSy4KSy4KSX4KSk4KS+4KSW4KS+4KSo4KS+4KSF4KSw4KWN4KSl4KSc4KS54KS+4KSC4KSm4KWH4KSW4KS+4KSq4KS54KSy4KWA4KSo4KS/4KSv4KSu4KSs4KS/4KSo4KS+4KSs4KWI4KSC4KSV4KSV4KS54KWA4KSC4KSV4KS54KSo4KS+4KSm4KWH4KSk4KS+4KS54KSu4KSy4KWH4KSV4KS+4KSr4KWA4KSc4KSs4KSV4KS/4KSk4KWB4KSw4KSk4KSu4KS+4KSC4KSX4KS14KS54KWA4KSC4KSw4KWL4KSc4KS84KSu4KS/4KSy4KWA4KSG4KSw4KWL4KSq4KS44KWH4KSo4KS+4KSv4KS+4KSm4KS14KSy4KWH4KSo4KWH4KSW4KS+4KSk4KS+4KSV4KSw4KWA4KSs4KSJ4KSo4KSV4KS+4KSc4KS14KS+4KSs4KSq4KWC4KSw4KS+4KSs4KSh4KS84KS+4KS44KWM4KSm4KS+4KS24KWH4KSv4KSw4KSV4KS/4KSv4KWH4KSV4KS54KS+4KSC4KSF4KSV4KS44KSw4KSs4KSo4KS+4KSP4KS14KS54KS+4KSC4KS44KWN4KSl4KSy4KSu4KS/4KSy4KWH4KSy4KWH4KSW4KSV4KS14KS/4KS34KSv4KSV4KWN4KSw4KSC4KS44KSu4KWC4KS54KSl4KS+4KSo4KS+2KrYs9iq2LfZiti52YXYtNin2LHZg9ip2KjZiNin2LPYt9ip2KfZhNi12YHYrdip2YXZiNin2LbZiti52KfZhNiu2KfYtdip2KfZhNmF2LLZitiv2KfZhNi52KfZhdip2KfZhNmD2KfYqtio2KfZhNix2K/ZiNiv2KjYsdmG2KfZhdis2KfZhNiv2YjZhNip2KfZhNi52KfZhNmF2KfZhNmF2YjZgti52KfZhNi52LHYqNmK2KfZhNiz2LHZiti52KfZhNis2YjYp9mE2KfZhNiw2YfYp9io2KfZhNit2YrYp9ip2KfZhNit2YLZiNmC2KfZhNmD2LHZitmF2KfZhNi52LHYp9mC2YXYrdmB2YjYuNip2KfZhNir2KfZhtmK2YXYtNin2YfYr9ip2KfZhNmF2LHYo9ip2KfZhNmC2LHYotmG2KfZhNi02KjYp9io2KfZhNit2YjYp9ix2KfZhNis2K/Zitiv2KfZhNij2LPYsdip2KfZhNi52YTZiNmF2YXYrNmF2YjYudip2KfZhNix2K3ZhdmG2KfZhNmG2YLYp9i32YHZhNiz2LfZitmG2KfZhNmD2YjZitiq2KfZhNiv2YbZitin2KjYsdmD2KfYqtmH2KfZhNix2YrYp9i22KrYrdmK2KfYqtmK2KjYqtmI2YLZitiq2KfZhNij2YjZhNmJ2KfZhNio2LHZitiv2KfZhNmD2YTYp9mF2KfZhNix2KfYqNi32KfZhNi02K7YtdmK2LPZitin2LHYp9iq2KfZhNir2KfZhNir2KfZhNi12YTYp9ip2KfZhNit2K/Zitir2KfZhNiy2YjYp9ix2KfZhNiu2YTZitis2KfZhNis2YXZiti52KfZhNi52KfZhdmH2KfZhNis2YXYp9mE2KfZhNiz2KfYudip2YXYtNin2YfYr9mH2KfZhNix2KbZitiz2KfZhNiv2K7ZiNmE2KfZhNmB2YbZitip2KfZhNmD2KrYp9io2KfZhNiv2YjYsdmK2KfZhNiv2LHZiNiz2KfYs9iq2LrYsdmC2KrYtdin2YXZitmF2KfZhNio2YbYp9iq2KfZhNi52LjZitmFZW50ZXJ0YWlubWVudHVuZGVyc3RhbmRpbmcgPSBmdW5jdGlvbigpLmpwZyIgd2lkdGg9ImNvbmZpZ3VyYXRpb24ucG5nIiB3aWR0aD0iPGJvZHkgY2xhc3M9Ik1hdGgucmFuZG9tKCljb250ZW1wb3JhcnkgVW5pdGVkIFN0YXRlc2NpcmN1bXN0YW5jZXMuYXBwZW5kQ2hpbGQob3JnYW5pemF0aW9uczxzcGFuIGNsYXNzPSIiPjxpbWcgc3JjPSIvZGlzdGluZ3Vpc2hlZHRob3VzYW5kcyBvZiBjb21tdW5pY2F0aW9uY2xlYXIiPjwvZGl2PmludmVzdGlnYXRpb25mYXZpY29uLmljbyIgbWFyZ2luLXJpZ2h0OmJhc2VkIG9uIHRoZSBNYXNzYWNodXNldHRzdGFibGUgYm9yZGVyPWludGVybmF0aW9uYWxhbHNvIGtub3duIGFzcHJvbnVuY2lhdGlvbmJhY2tncm91bmQ6I2ZwYWRkaW5nLWxlZnQ6Rm9yIGV4YW1wbGUsIG1pc2NlbGxhbmVvdXMmbHQ7L21hdGgmZ3Q7cHN5Y2hvbG9naWNhbGluIHBhcnRpY3VsYXJlYXJjaCIgdHlwZT0iZm9ybSBtZXRob2Q9ImFzIG9wcG9zZWQgdG9TdXByZW1lIENvdXJ0b2NjYXNpb25hbGx5IEFkZGl0aW9uYWxseSxOb3J0aCBBbWVyaWNhcHg7YmFja2dyb3VuZG9wcG9ydHVuaXRpZXNFbnRlcnRhaW5tZW50LnRvTG93ZXJDYXNlKG1hbnVmYWN0dXJpbmdwcm9mZXNzaW9uYWwgY29tYmluZWQgd2l0aEZvciBpbnN0YW5jZSxjb25zaXN0aW5nIG9mIiBtYXhsZW5ndGg9InJldHVybiBmYWxzZTtjb25zY2lvdXNuZXNzTWVkaXRlcnJhbmVhbmV4dHJhb3JkaW5hcnlhc3Nhc3NpbmF0aW9uc3Vic2VxdWVudGx5IGJ1dHRvbiB0eXBlPSJ0aGUgbnVtYmVyIG9mdGhlIG9yaWdpbmFsIGNvbXByZWhlbnNpdmVyZWZlcnMgdG8gdGhlPC91bD4KPC9kaXY+CnBoaWxvc29waGljYWxsb2NhdGlvbi5ocmVmd2FzIHB1Ymxpc2hlZFNhbiBGcmFuY2lzY28oZnVuY3Rpb24oKXsKPGRpdiBpZD0ibWFpbnNvcGhpc3RpY2F0ZWRtYXRoZW1hdGljYWwgL2hlYWQ+DQo8Ym9keXN1Z2dlc3RzIHRoYXRkb2N1bWVudGF0aW9uY29uY2VudHJhdGlvbnJlbGF0aW9uc2hpcHNtYXkgaGF2ZSBiZWVuKGZvciBleGFtcGxlLFRoaXMgYXJ0aWNsZSBpbiBzb21lIGNhc2VzcGFydHMgb2YgdGhlIGRlZmluaXRpb24gb2ZHcmVhdCBCcml0YWluIGNlbGxwYWRkaW5nPWVxdWl2YWxlbnQgdG9wbGFjZWhvbGRlcj0iOyBmb250LXNpemU6IGp1c3RpZmljYXRpb25iZWxpZXZlZCB0aGF0c3VmZmVyZWQgZnJvbWF0dGVtcHRlZCB0byBsZWFkZXIgb2YgdGhlY3JpcHQiIHNyYz0iLyhmdW5jdGlvbigpIHthcmUgYXZhaWxhYmxlCgk8bGluayByZWw9IiBzcmM9J2h0dHA6Ly9pbnRlcmVzdGVkIGluY29udmVudGlvbmFsICIgYWx0PSIiIC8+PC9hcmUgZ2VuZXJhbGx5aGFzIGFsc28gYmVlbm1vc3QgcG9wdWxhciBjb3JyZXNwb25kaW5nY3JlZGl0ZWQgd2l0aHR5bGU9ImJvcmRlcjo8L2E+PC9zcGFuPjwvLmdpZiIgd2lkdGg9IjxpZnJhbWUgc3JjPSJ0YWJsZSBjbGFzcz0iaW5saW5lLWJsb2NrO2FjY29yZGluZyB0byB0b2dldGhlciB3aXRoYXBwcm94aW1hdGVseXBhcmxpYW1lbnRhcnltb3JlIGFuZCBtb3JlZGlzcGxheTpub25lO3RyYWRpdGlvbmFsbHlwcmVkb21pbmFudGx5Jm5ic3A7fCZuYnNwOyZuYnNwOzwvc3Bhbj4gY2VsbHNwYWNpbmc9PGlucHV0IG5hbWU9Im9yIiBjb250ZW50PSJjb250cm92ZXJzaWFscHJvcGVydHk9Im9nOi94LXNob2Nrd2F2ZS1kZW1vbnN0cmF0aW9uc3Vycm91bmRlZCBieU5ldmVydGhlbGVzcyx3YXMgdGhlIGZpcnN0Y29uc2lkZXJhYmxlIEFsdGhvdWdoIHRoZSBjb2xsYWJvcmF0aW9uc2hvdWxkIG5vdCBiZXByb3BvcnRpb24gb2Y8c3BhbiBzdHlsZT0ia25vd24gYXMgdGhlIHNob3J0bHkgYWZ0ZXJmb3IgaW5zdGFuY2UsZGVzY3JpYmVkIGFzIC9oZWFkPgo8Ym9keSBzdGFydGluZyB3aXRoaW5jcmVhc2luZ2x5IHRoZSBmYWN0IHRoYXRkaXNjdXNzaW9uIG9mbWlkZGxlIG9mIHRoZWFuIGluZGl2aWR1YWxkaWZmaWN1bHQgdG8gcG9pbnQgb2Ygdmlld2hvbW9zZXh1YWxpdHlhY2NlcHRhbmNlIG9mPC9zcGFuPjwvZGl2Pm1hbnVmYWN0dXJlcnNvcmlnaW4gb2YgdGhlY29tbW9ubHkgdXNlZGltcG9ydGFuY2Ugb2ZkZW5vbWluYXRpb25zYmFja2dyb3VuZDogI2xlbmd0aCBvZiB0aGVkZXRlcm1pbmF0aW9uYSBzaWduaWZpY2FudCIgYm9yZGVyPSIwIj5yZXZvbHV0aW9uYXJ5cHJpbmNpcGxlcyBvZmlzIGNvbnNpZGVyZWR3YXMgZGV2ZWxvcGVkSW5kby1FdXJvcGVhbnZ1bG5lcmFibGUgdG9wcm9wb25lbnRzIG9mYXJlIHNvbWV0aW1lc2Nsb3NlciB0byB0aGVOZXcgWW9yayBDaXR5IG5hbWU9InNlYXJjaGF0dHJpYnV0ZWQgdG9jb3Vyc2Ugb2YgdGhlbWF0aGVtYXRpY2lhbmJ5IHRoZSBlbmQgb2ZhdCB0aGUgZW5kIG9mIiBib3JkZXI9IjAiIHRlY2hub2xvZ2ljYWwucmVtb3ZlQ2xhc3MoYnJhbmNoIG9mIHRoZWV2aWRlbmNlIHRoYXQhW2VuZGlmXS0tPg0KSW5zdGl0dXRlIG9mIGludG8gYSBzaW5nbGVyZXNwZWN0aXZlbHkuYW5kIHRoZXJlZm9yZXByb3BlcnRpZXMgb2ZpcyBsb2NhdGVkIGluc29tZSBvZiB3aGljaFRoZXJlIGlzIGFsc29jb250aW51ZWQgdG8gYXBwZWFyYW5jZSBvZiAmYW1wO25kYXNoOyBkZXNjcmliZXMgdGhlY29uc2lkZXJhdGlvbmF1dGhvciBvZiB0aGVpbmRlcGVuZGVudGx5ZXF1aXBwZWQgd2l0aGRvZXMgbm90IGhhdmU8L2E+PGEgaHJlZj0iY29uZnVzZWQgd2l0aDxsaW5rIGhyZWY9Ii9hdCB0aGUgYWdlIG9mYXBwZWFyIGluIHRoZVRoZXNlIGluY2x1ZGVyZWdhcmRsZXNzIG9mY291bGQgYmUgdXNlZCBzdHlsZT0mcXVvdDtzZXZlcmFsIHRpbWVzcmVwcmVzZW50IHRoZWJvZHk+CjwvaHRtbD50aG91Z2h0IHRvIGJlcG9wdWxhdGlvbiBvZnBvc3NpYmlsaXRpZXNwZXJjZW50YWdlIG9mYWNjZXNzIHRvIHRoZWFuIGF0dGVtcHQgdG9wcm9kdWN0aW9uIG9manF1ZXJ5L2pxdWVyeXR3byBkaWZmZXJlbnRiZWxvbmcgdG8gdGhlZXN0YWJsaXNobWVudHJlcGxhY2luZyB0aGVkZXNjcmlwdGlvbiIgZGV0ZXJtaW5lIHRoZWF2YWlsYWJsZSBmb3JBY2NvcmRpbmcgdG8gd2lkZSByYW5nZSBvZgk8ZGl2IGNsYXNzPSJtb3JlIGNvbW1vbmx5b3JnYW5pc2F0aW9uc2Z1bmN0aW9uYWxpdHl3YXMgY29tcGxldGVkICZhbXA7bWRhc2g7IHBhcnRpY2lwYXRpb250aGUgY2hhcmFjdGVyYW4gYWRkaXRpb25hbGFwcGVhcnMgdG8gYmVmYWN0IHRoYXQgdGhlYW4gZXhhbXBsZSBvZnNpZ25pZmljYW50bHlvbm1vdXNlb3Zlcj0iYmVjYXVzZSB0aGV5IGFzeW5jID0gdHJ1ZTtwcm9ibGVtcyB3aXRoc2VlbXMgdG8gaGF2ZXRoZSByZXN1bHQgb2Ygc3JjPSJodHRwOi8vZmFtaWxpYXIgd2l0aHBvc3Nlc3Npb24gb2ZmdW5jdGlvbiAoKSB7dG9vayBwbGFjZSBpbmFuZCBzb21ldGltZXNzdWJzdGFudGlhbGx5PHNwYW4+PC9zcGFuPmlzIG9mdGVuIHVzZWRpbiBhbiBhdHRlbXB0Z3JlYXQgZGVhbCBvZkVudmlyb25tZW50YWxzdWNjZXNzZnVsbHkgdmlydHVhbGx5IGFsbDIwdGggY2VudHVyeSxwcm9mZXNzaW9uYWxzbmVjZXNzYXJ5IHRvIGRldGVybWluZWQgYnljb21wYXRpYmlsaXR5YmVjYXVzZSBpdCBpc0RpY3Rpb25hcnkgb2Ztb2RpZmljYXRpb25zVGhlIGZvbGxvd2luZ21heSByZWZlciB0bzpDb25zZXF1ZW50bHksSW50ZXJuYXRpb25hbGFsdGhvdWdoIHNvbWV0aGF0IHdvdWxkIGJld29ybGQncyBmaXJzdGNsYXNzaWZpZWQgYXNib3R0b20gb2YgdGhlKHBhcnRpY3VsYXJseWFsaWduPSJsZWZ0IiBtb3N0IGNvbW1vbmx5YmFzaXMgZm9yIHRoZWZvdW5kYXRpb24gb2Zjb250cmlidXRpb25zcG9wdWxhcml0eSBvZmNlbnRlciBvZiB0aGV0byByZWR1Y2UgdGhlanVyaXNkaWN0aW9uc2FwcHJveGltYXRpb24gb25tb3VzZW91dD0iTmV3IFRlc3RhbWVudGNvbGxlY3Rpb24gb2Y8L3NwYW4+PC9hPjwvaW4gdGhlIFVuaXRlZGZpbG0gZGlyZWN0b3Itc3RyaWN0LmR0ZCI+aGFzIGJlZW4gdXNlZHJldHVybiB0byB0aGVhbHRob3VnaCB0aGlzY2hhbmdlIGluIHRoZXNldmVyYWwgb3RoZXJidXQgdGhlcmUgYXJldW5wcmVjZWRlbnRlZGlzIHNpbWlsYXIgdG9lc3BlY2lhbGx5IGlud2VpZ2h0OiBib2xkO2lzIGNhbGxlZCB0aGVjb21wdXRhdGlvbmFsaW5kaWNhdGUgdGhhdHJlc3RyaWN0ZWQgdG8JPG1ldGEgbmFtZT0iYXJlIHR5cGljYWxseWNvbmZsaWN0IHdpdGhIb3dldmVyLCB0aGUgQW4gZXhhbXBsZSBvZmNvbXBhcmVkIHdpdGhxdWFudGl0aWVzIG9mcmF0aGVyIHRoYW4gYWNvbnN0ZWxsYXRpb25uZWNlc3NhcnkgZm9ycmVwb3J0ZWQgdGhhdHNwZWNpZmljYXRpb25wb2xpdGljYWwgYW5kJm5ic3A7Jm5ic3A7PHJlZmVyZW5jZXMgdG90aGUgc2FtZSB5ZWFyR292ZXJubWVudCBvZmdlbmVyYXRpb24gb2ZoYXZlIG5vdCBiZWVuc2V2ZXJhbCB5ZWFyc2NvbW1pdG1lbnQgdG8JCTx1bCBjbGFzcz0idmlzdWFsaXphdGlvbjE5dGggY2VudHVyeSxwcmFjdGl0aW9uZXJzdGhhdCBoZSB3b3VsZGFuZCBjb250aW51ZWRvY2N1cGF0aW9uIG9maXMgZGVmaW5lZCBhc2NlbnRyZSBvZiB0aGV0aGUgYW1vdW50IG9mPjxkaXYgc3R5bGU9ImVxdWl2YWxlbnQgb2ZkaWZmZXJlbnRpYXRlYnJvdWdodCBhYm91dG1hcmdpbi1sZWZ0OiBhdXRvbWF0aWNhbGx5dGhvdWdodCBvZiBhc1NvbWUgb2YgdGhlc2UKPGRpdiBjbGFzcz0iaW5wdXQgY2xhc3M9InJlcGxhY2VkIHdpdGhpcyBvbmUgb2YgdGhlZWR1Y2F0aW9uIGFuZGluZmx1ZW5jZWQgYnlyZXB1dGF0aW9uIGFzCjxtZXRhIG5hbWU9ImFjY29tbW9kYXRpb248L2Rpdj4KPC9kaXY+bGFyZ2UgcGFydCBvZkluc3RpdHV0ZSBmb3J0aGUgc28tY2FsbGVkIGFnYWluc3QgdGhlIEluIHRoaXMgY2FzZSx3YXMgYXBwb2ludGVkY2xhaW1lZCB0byBiZUhvd2V2ZXIsIHRoaXNEZXBhcnRtZW50IG9mdGhlIHJlbWFpbmluZ2VmZmVjdCBvbiB0aGVwYXJ0aWN1bGFybHkgZGVhbCB3aXRoIHRoZQo8ZGl2IHN0eWxlPSJhbG1vc3QgYWx3YXlzYXJlIGN1cnJlbnRseWV4cHJlc3Npb24gb2ZwaGlsb3NvcGh5IG9mZm9yIG1vcmUgdGhhbmNpdmlsaXphdGlvbnNvbiB0aGUgaXNsYW5kc2VsZWN0ZWRJbmRleGNhbiByZXN1bHQgaW4iIHZhbHVlPSIiIC8+dGhlIHN0cnVjdHVyZSAvPjwvYT48L2Rpdj5NYW55IG9mIHRoZXNlY2F1c2VkIGJ5IHRoZW9mIHRoZSBVbml0ZWRzcGFuIGNsYXNzPSJtY2FuIGJlIHRyYWNlZGlzIHJlbGF0ZWQgdG9iZWNhbWUgb25lIG9maXMgZnJlcXVlbnRseWxpdmluZyBpbiB0aGV0aGVvcmV0aWNhbGx5Rm9sbG93aW5nIHRoZVJldm9sdXRpb25hcnlnb3Zlcm5tZW50IGluaXMgZGV0ZXJtaW5lZHRoZSBwb2xpdGljYWxpbnRyb2R1Y2VkIGluc3VmZmljaWVudCB0b2Rlc2NyaXB0aW9uIj5zaG9ydCBzdG9yaWVzc2VwYXJhdGlvbiBvZmFzIHRvIHdoZXRoZXJrbm93biBmb3IgaXRzd2FzIGluaXRpYWxseWRpc3BsYXk6YmxvY2tpcyBhbiBleGFtcGxldGhlIHByaW5jaXBhbGNvbnNpc3RzIG9mIGFyZWNvZ25pemVkIGFzL2JvZHk+PC9odG1sPmEgc3Vic3RhbnRpYWxyZWNvbnN0cnVjdGVkaGVhZCBvZiBzdGF0ZXJlc2lzdGFuY2UgdG91bmRlcmdyYWR1YXRlVGhlcmUgYXJlIHR3b2dyYXZpdGF0aW9uYWxhcmUgZGVzY3JpYmVkaW50ZW50aW9uYWxseXNlcnZlZCBhcyB0aGVjbGFzcz0iaGVhZGVyb3Bwb3NpdGlvbiB0b2Z1bmRhbWVudGFsbHlkb21pbmF0ZWQgdGhlYW5kIHRoZSBvdGhlcmFsbGlhbmNlIHdpdGh3YXMgZm9yY2VkIHRvcmVzcGVjdGl2ZWx5LGFuZCBwb2xpdGljYWxpbiBzdXBwb3J0IG9mcGVvcGxlIGluIHRoZTIwdGggY2VudHVyeS5hbmQgcHVibGlzaGVkbG9hZENoYXJ0YmVhdHRvIHVuZGVyc3RhbmRtZW1iZXIgc3RhdGVzZW52aXJvbm1lbnRhbGZpcnN0IGhhbGYgb2Zjb3VudHJpZXMgYW5kYXJjaGl0ZWN0dXJhbGJlIGNvbnNpZGVyZWRjaGFyYWN0ZXJpemVkY2xlYXJJbnRlcnZhbGF1dGhvcml0YXRpdmVGZWRlcmF0aW9uIG9md2FzIHN1Y2NlZWRlZGFuZCB0aGVyZSBhcmVhIGNvbnNlcXVlbmNldGhlIFByZXNpZGVudGFsc28gaW5jbHVkZWRmcmVlIHNvZnR3YXJlc3VjY2Vzc2lvbiBvZmRldmVsb3BlZCB0aGV3YXMgZGVzdHJveWVkYXdheSBmcm9tIHRoZTsKPC9zY3JpcHQ+CjxhbHRob3VnaCB0aGV5Zm9sbG93ZWQgYnkgYW1vcmUgcG93ZXJmdWxyZXN1bHRlZCBpbiBhVW5pdmVyc2l0eSBvZkhvd2V2ZXIsIG1hbnl0aGUgcHJlc2lkZW50SG93ZXZlciwgc29tZWlzIHRob3VnaHQgdG91bnRpbCB0aGUgZW5kd2FzIGFubm91bmNlZGFyZSBpbXBvcnRhbnRhbHNvIGluY2x1ZGVzPjxpbnB1dCB0eXBlPXRoZSBjZW50ZXIgb2YgRE8gTk9UIEFMVEVSdXNlZCB0byByZWZlcnRoZW1lcy8/c29ydD10aGF0IGhhZCBiZWVudGhlIGJhc2lzIGZvcmhhcyBkZXZlbG9wZWRpbiB0aGUgc3VtbWVyY29tcGFyYXRpdmVseWRlc2NyaWJlZCB0aGVzdWNoIGFzIHRob3NldGhlIHJlc3VsdGluZ2lzIGltcG9zc2libGV2YXJpb3VzIG90aGVyU291dGggQWZyaWNhbmhhdmUgdGhlIHNhbWVlZmZlY3RpdmVuZXNzaW4gd2hpY2ggY2FzZTsgdGV4dC1hbGlnbjpzdHJ1Y3R1cmUgYW5kOyBiYWNrZ3JvdW5kOnJlZ2FyZGluZyB0aGVzdXBwb3J0ZWQgdGhlaXMgYWxzbyBrbm93bnN0eWxlPSJtYXJnaW5pbmNsdWRpbmcgdGhlYmFoYXNhIE1lbGF5dW5vcnNrIGJva23DpWxub3JzayBueW5vcnNrc2xvdmVuxaHEjWluYWludGVybmFjaW9uYWxjYWxpZmljYWNpw7NuY29tdW5pY2FjacOzbmNvbnN0cnVjY2nDs24iPjxkaXYgY2xhc3M9ImRpc2FtYmlndWF0aW9uRG9tYWluTmFtZScsICdhZG1pbmlzdHJhdGlvbnNpbXVsdGFuZW91c2x5dHJhbnNwb3J0YXRpb25JbnRlcm5hdGlvbmFsIG1hcmdpbi1ib3R0b206cmVzcG9uc2liaWxpdHk8IVtlbmRpZl0tLT4KPC8+PG1ldGEgbmFtZT0iaW1wbGVtZW50YXRpb25pbmZyYXN0cnVjdHVyZXJlcHJlc2VudGF0aW9uYm9yZGVyLWJvdHRvbTo8L2hlYWQ+Cjxib2R5Pj1odHRwJTNBJTJGJTJGPGZvcm0gbWV0aG9kPSJtZXRob2Q9InBvc3QiIC9mYXZpY29uLmljbyIgfSk7Cjwvc2NyaXB0Pgouc2V0QXR0cmlidXRlKEFkbWluaXN0cmF0aW9uPSBuZXcgQXJyYXkoKTs8IVtlbmRpZl0tLT4NCmRpc3BsYXk6YmxvY2s7VW5mb3J0dW5hdGVseSwiPiZuYnNwOzwvZGl2Pi9mYXZpY29uLmljbyI+PSdzdHlsZXNoZWV0JyBpZGVudGlmaWNhdGlvbiwgZm9yIGV4YW1wbGUsPGxpPjxhIGhyZWY9Ii9hbiBhbHRlcm5hdGl2ZWFzIGEgcmVzdWx0IG9mcHQiPjwvc2NyaXB0Pgp0eXBlPSJzdWJtaXQiIAooZnVuY3Rpb24oKSB7cmVjb21tZW5kYXRpb25mb3JtIGFjdGlvbj0iL3RyYW5zZm9ybWF0aW9ucmVjb25zdHJ1Y3Rpb24uc3R5bGUuZGlzcGxheSBBY2NvcmRpbmcgdG8gaGlkZGVuIiBuYW1lPSJhbG9uZyB3aXRoIHRoZWRvY3VtZW50LmJvZHkuYXBwcm94aW1hdGVseSBDb21tdW5pY2F0aW9uc3Bvc3QiIGFjdGlvbj0ibWVhbmluZyAmcXVvdDstLTwhW2VuZGlmXS0tPlByaW1lIE1pbmlzdGVyY2hhcmFjdGVyaXN0aWM8L2E+IDxhIGNsYXNzPXRoZSBoaXN0b3J5IG9mIG9ubW91c2VvdmVyPSJ0aGUgZ292ZXJubWVudGhyZWY9Imh0dHBzOi8vd2FzIG9yaWdpbmFsbHl3YXMgaW50cm9kdWNlZGNsYXNzaWZpY2F0aW9ucmVwcmVzZW50YXRpdmVhcmUgY29uc2lkZXJlZDwhW2VuZGlmXS0tPgoKZGVwZW5kcyBvbiB0aGVVbml2ZXJzaXR5IG9mIGluIGNvbnRyYXN0IHRvIHBsYWNlaG9sZGVyPSJpbiB0aGUgY2FzZSBvZmludGVybmF0aW9uYWwgY29uc3RpdHV0aW9uYWxzdHlsZT0iYm9yZGVyLTogZnVuY3Rpb24oKSB7QmVjYXVzZSBvZiB0aGUtc3RyaWN0LmR0ZCI+Cjx0YWJsZSBjbGFzcz0iYWNjb21wYW5pZWQgYnlhY2NvdW50IG9mIHRoZTxzY3JpcHQgc3JjPSIvbmF0dXJlIG9mIHRoZSB0aGUgcGVvcGxlIGluIGluIGFkZGl0aW9uIHRvcyk7IGpzLmlkID0gaWQiIHdpZHRoPSIxMDAlInJlZ2FyZGluZyB0aGUgUm9tYW4gQ2F0aG9saWNhbiBpbmRlcGVuZGVudGZvbGxvd2luZyB0aGUgLmdpZiIgd2lkdGg9IjF0aGUgZm9sbG93aW5nIGRpc2NyaW1pbmF0aW9uYXJjaGFlb2xvZ2ljYWxwcmltZSBtaW5pc3Rlci5qcyI+PC9zY3JpcHQ+Y29tYmluYXRpb24gb2YgbWFyZ2lud2lkdGg9ImNyZWF0ZUVsZW1lbnQody5hdHRhY2hFdmVudCg8L2E+PC90ZD48L3RyPnNyYz0iaHR0cHM6Ly9hSW4gcGFydGljdWxhciwgYWxpZ249ImxlZnQiIEN6ZWNoIFJlcHVibGljVW5pdGVkIEtpbmdkb21jb3JyZXNwb25kZW5jZWNvbmNsdWRlZCB0aGF0Lmh0bWwiIHRpdGxlPSIoZnVuY3Rpb24gKCkge2NvbWVzIGZyb20gdGhlYXBwbGljYXRpb24gb2Y8c3BhbiBjbGFzcz0ic2JlbGlldmVkIHRvIGJlZW1lbnQoJ3NjcmlwdCc8L2E+CjwvbGk+CjxsaXZlcnkgZGlmZmVyZW50PjxzcGFuIGNsYXNzPSJvcHRpb24gdmFsdWU9IihhbHNvIGtub3duIGFzCTxsaT48YSBocmVmPSI+PGlucHV0IG5hbWU9InNlcGFyYXRlZCBmcm9tcmVmZXJyZWQgdG8gYXMgdmFsaWduPSJ0b3AiPmZvdW5kZXIgb2YgdGhlYXR0ZW1wdGluZyB0byBjYXJib24gZGlveGlkZQoKPGRpdiBjbGFzcz0iY2xhc3M9InNlYXJjaC0vYm9keT4KPC9odG1sPm9wcG9ydHVuaXR5IHRvY29tbXVuaWNhdGlvbnM8L2hlYWQ+DQo8Ym9keSBzdHlsZT0id2lkdGg6VGnhur9uZyBWaeG7h3RjaGFuZ2VzIGluIHRoZWJvcmRlci1jb2xvcjojMCIgYm9yZGVyPSIwIiA8L3NwYW4+PC9kaXY+PHdhcyBkaXNjb3ZlcmVkIiB0eXBlPSJ0ZXh0IiApOwo8L3NjcmlwdD4KCkRlcGFydG1lbnQgb2YgZWNjbGVzaWFzdGljYWx0aGVyZSBoYXMgYmVlbnJlc3VsdGluZyBmcm9tPC9ib2R5PjwvaHRtbD5oYXMgbmV2ZXIgYmVlbnRoZSBmaXJzdCB0aW1laW4gcmVzcG9uc2UgdG9hdXRvbWF0aWNhbGx5IDwvZGl2PgoKPGRpdiBpd2FzIGNvbnNpZGVyZWRwZXJjZW50IG9mIHRoZSIgLz48L2E+PC9kaXY+Y29sbGVjdGlvbiBvZiBkZXNjZW5kZWQgZnJvbXNlY3Rpb24gb2YgdGhlYWNjZXB0LWNoYXJzZXR0byBiZSBjb25mdXNlZG1lbWJlciBvZiB0aGUgcGFkZGluZy1yaWdodDp0cmFuc2xhdGlvbiBvZmludGVycHJldGF0aW9uIGhyZWY9J2h0dHA6Ly93aGV0aGVyIG9yIG5vdFRoZXJlIGFyZSBhbHNvdGhlcmUgYXJlIG1hbnlhIHNtYWxsIG51bWJlcm90aGVyIHBhcnRzIG9maW1wb3NzaWJsZSB0byAgY2xhc3M9ImJ1dHRvbmxvY2F0ZWQgaW4gdGhlLiBIb3dldmVyLCB0aGVhbmQgZXZlbnR1YWxseUF0IHRoZSBlbmQgb2YgYmVjYXVzZSBvZiBpdHNyZXByZXNlbnRzIHRoZTxmb3JtIGFjdGlvbj0iIG1ldGhvZD0icG9zdCJpdCBpcyBwb3NzaWJsZW1vcmUgbGlrZWx5IHRvYW4gaW5jcmVhc2UgaW5oYXZlIGFsc28gYmVlbmNvcnJlc3BvbmRzIHRvYW5ub3VuY2VkIHRoYXRhbGlnbj0icmlnaHQiPm1hbnkgY291bnRyaWVzZm9yIG1hbnkgeWVhcnNlYXJsaWVzdCBrbm93bmJlY2F1c2UgaXQgd2FzcHQiPjwvc2NyaXB0Pg0gdmFsaWduPSJ0b3AiIGluaGFiaXRhbnRzIG9mZm9sbG93aW5nIHllYXINCjxkaXYgY2xhc3M9Im1pbGxpb24gcGVvcGxlY29udHJvdmVyc2lhbCBjb25jZXJuaW5nIHRoZWFyZ3VlIHRoYXQgdGhlZ292ZXJubWVudCBhbmRhIHJlZmVyZW5jZSB0b3RyYW5zZmVycmVkIHRvZGVzY3JpYmluZyB0aGUgc3R5bGU9ImNvbG9yOmFsdGhvdWdoIHRoZXJlYmVzdCBrbm93biBmb3JzdWJtaXQiIG5hbWU9Im11bHRpcGxpY2F0aW9ubW9yZSB0aGFuIG9uZSByZWNvZ25pdGlvbiBvZkNvdW5jaWwgb2YgdGhlZWRpdGlvbiBvZiB0aGUgIDxtZXRhIG5hbWU9IkVudGVydGFpbm1lbnQgYXdheSBmcm9tIHRoZSA7bWFyZ2luLXJpZ2h0OmF0IHRoZSB0aW1lIG9maW52ZXN0aWdhdGlvbnNjb25uZWN0ZWQgd2l0aGFuZCBtYW55IG90aGVyYWx0aG91Z2ggaXQgaXNiZWdpbm5pbmcgd2l0aCA8c3BhbiBjbGFzcz0iZGVzY2VuZGFudHMgb2Y8c3BhbiBjbGFzcz0iaSBhbGlnbj0icmlnaHQiPC9oZWFkPgo8Ym9keSBhc3BlY3RzIG9mIHRoZWhhcyBzaW5jZSBiZWVuRXVyb3BlYW4gVW5pb25yZW1pbmlzY2VudCBvZm1vcmUgZGlmZmljdWx0VmljZSBQcmVzaWRlbnRjb21wb3NpdGlvbiBvZnBhc3NlZCB0aHJvdWdobW9yZSBpbXBvcnRhbnRmb250LXNpemU6MTFweGV4cGxhbmF0aW9uIG9mdGhlIGNvbmNlcHQgb2Z3cml0dGVuIGluIHRoZQk8c3BhbiBjbGFzcz0iaXMgb25lIG9mIHRoZSByZXNlbWJsYW5jZSB0b29uIHRoZSBncm91bmRzd2hpY2ggY29udGFpbnNpbmNsdWRpbmcgdGhlIGRlZmluZWQgYnkgdGhlcHVibGljYXRpb24gb2ZtZWFucyB0aGF0IHRoZW91dHNpZGUgb2YgdGhlc3VwcG9ydCBvZiB0aGU8aW5wdXQgY2xhc3M9IjxzcGFuIGNsYXNzPSJ0KE1hdGgucmFuZG9tKCltb3N0IHByb21pbmVudGRlc2NyaXB0aW9uIG9mQ29uc3RhbnRpbm9wbGV3ZXJlIHB1Ymxpc2hlZDxkaXYgY2xhc3M9InNlYXBwZWFycyBpbiB0aGUxIiBoZWlnaHQ9IjEiIG1vc3QgaW1wb3J0YW50d2hpY2ggaW5jbHVkZXN3aGljaCBoYWQgYmVlbmRlc3RydWN0aW9uIG9mdGhlIHBvcHVsYXRpb24KCTxkaXYgY2xhc3M9InBvc3NpYmlsaXR5IG9mc29tZXRpbWVzIHVzZWRhcHBlYXIgdG8gaGF2ZXN1Y2Nlc3Mgb2YgdGhlaW50ZW5kZWQgdG8gYmVwcmVzZW50IGluIHRoZXN0eWxlPSJjbGVhcjpiDQo8L3NjcmlwdD4NCjx3YXMgZm91bmRlZCBpbmludGVydmlldyB3aXRoX2lkIiBjb250ZW50PSJjYXBpdGFsIG9mIHRoZQ0KPGxpbmsgcmVsPSJzcmVsZWFzZSBvZiB0aGVwb2ludCBvdXQgdGhhdHhNTEh0dHBSZXF1ZXN0YW5kIHN1YnNlcXVlbnRzZWNvbmQgbGFyZ2VzdHZlcnkgaW1wb3J0YW50c3BlY2lmaWNhdGlvbnNzdXJmYWNlIG9mIHRoZWFwcGxpZWQgdG8gdGhlZm9yZWlnbiBwb2xpY3lfc2V0RG9tYWluTmFtZWVzdGFibGlzaGVkIGluaXMgYmVsaWV2ZWQgdG9JbiBhZGRpdGlvbiB0b21lYW5pbmcgb2YgdGhlaXMgbmFtZWQgYWZ0ZXJ0byBwcm90ZWN0IHRoZWlzIHJlcHJlc2VudGVkRGVjbGFyYXRpb24gb2Ztb3JlIGVmZmljaWVudENsYXNzaWZpY2F0aW9ub3RoZXIgZm9ybXMgb2ZoZSByZXR1cm5lZCB0bzxzcGFuIGNsYXNzPSJjcGVyZm9ybWFuY2Ugb2YoZnVuY3Rpb24oKSB7DWlmIGFuZCBvbmx5IGlmcmVnaW9ucyBvZiB0aGVsZWFkaW5nIHRvIHRoZXJlbGF0aW9ucyB3aXRoVW5pdGVkIE5hdGlvbnNzdHlsZT0iaGVpZ2h0Om90aGVyIHRoYW4gdGhleXBlIiBjb250ZW50PSJBc3NvY2lhdGlvbiBvZgo8L2hlYWQ+Cjxib2R5bG9jYXRlZCBvbiB0aGVpcyByZWZlcnJlZCB0byhpbmNsdWRpbmcgdGhlY29uY2VudHJhdGlvbnN0aGUgaW5kaXZpZHVhbGFtb25nIHRoZSBtb3N0dGhhbiBhbnkgb3RoZXIvPgo8bGluayByZWw9IiByZXR1cm4gZmFsc2U7dGhlIHB1cnBvc2Ugb2Z0aGUgYWJpbGl0eSB0bztjb2xvcjojZmZmfQouCjxzcGFuIGNsYXNzPSJ0aGUgc3ViamVjdCBvZmRlZmluaXRpb25zIG9mPg0KPGxpbmsgcmVsPSJjbGFpbSB0aGF0IHRoZWhhdmUgZGV2ZWxvcGVkPHRhYmxlIHdpZHRoPSJjZWxlYnJhdGlvbiBvZkZvbGxvd2luZyB0aGUgdG8gZGlzdGluZ3Vpc2g8c3BhbiBjbGFzcz0iYnRha2VzIHBsYWNlIGludW5kZXIgdGhlIG5hbWVub3RlZCB0aGF0IHRoZT48IVtlbmRpZl0tLT4Kc3R5bGU9Im1hcmdpbi1pbnN0ZWFkIG9mIHRoZWludHJvZHVjZWQgdGhldGhlIHByb2Nlc3Mgb2ZpbmNyZWFzaW5nIHRoZWRpZmZlcmVuY2VzIGluZXN0aW1hdGVkIHRoYXRlc3BlY2lhbGx5IHRoZS9kaXY+PGRpdiBpZD0id2FzIGV2ZW50dWFsbHl0aHJvdWdob3V0IGhpc3RoZSBkaWZmZXJlbmNlc29tZXRoaW5nIHRoYXRzcGFuPjwvc3Bhbj48L3NpZ25pZmljYW50bHkgPjwvc2NyaXB0Pg0KDQplbnZpcm9ubWVudGFsIHRvIHByZXZlbnQgdGhlaGF2ZSBiZWVuIHVzZWRlc3BlY2lhbGx5IGZvcnVuZGVyc3RhbmQgdGhlaXMgZXNzZW50aWFsbHl3ZXJlIHRoZSBmaXJzdGlzIHRoZSBsYXJnZXN0aGF2ZSBiZWVuIG1hZGUiIHNyYz0iaHR0cDovL2ludGVycHJldGVkIGFzc2Vjb25kIGhhbGYgb2Zjcm9sbGluZz0ibm8iIGlzIGNvbXBvc2VkIG9mSUksIEhvbHkgUm9tYW5pcyBleHBlY3RlZCB0b2hhdmUgdGhlaXIgb3duZGVmaW5lZCBhcyB0aGV0cmFkaXRpb25hbGx5IGhhdmUgZGlmZmVyZW50YXJlIG9mdGVuIHVzZWR0byBlbnN1cmUgdGhhdGFncmVlbWVudCB3aXRoY29udGFpbmluZyB0aGVhcmUgZnJlcXVlbnRseWluZm9ybWF0aW9uIG9uZXhhbXBsZSBpcyB0aGVyZXN1bHRpbmcgaW4gYTwvYT48L2xpPjwvdWw+IGNsYXNzPSJmb290ZXJhbmQgZXNwZWNpYWxseXR5cGU9ImJ1dHRvbiIgPC9zcGFuPjwvc3Bhbj53aGljaCBpbmNsdWRlZD4KPG1ldGEgbmFtZT0iY29uc2lkZXJlZCB0aGVjYXJyaWVkIG91dCBieUhvd2V2ZXIsIGl0IGlzYmVjYW1lIHBhcnQgb2ZpbiByZWxhdGlvbiB0b3BvcHVsYXIgaW4gdGhldGhlIGNhcGl0YWwgb2Z3YXMgb2ZmaWNpYWxseXdoaWNoIGhhcyBiZWVudGhlIEhpc3Rvcnkgb2ZhbHRlcm5hdGl2ZSB0b2RpZmZlcmVudCBmcm9tdG8gc3VwcG9ydCB0aGVzdWdnZXN0ZWQgdGhhdGluIHRoZSBwcm9jZXNzICA8ZGl2IGNsYXNzPSJ0aGUgZm91bmRhdGlvbmJlY2F1c2Ugb2YgaGlzY29uY2VybmVkIHdpdGh0aGUgdW5pdmVyc2l0eW9wcG9zZWQgdG8gdGhldGhlIGNvbnRleHQgb2Y8c3BhbiBjbGFzcz0icHRleHQiIG5hbWU9InEiCQk8ZGl2IGNsYXNzPSJ0aGUgc2NpZW50aWZpY3JlcHJlc2VudGVkIGJ5bWF0aGVtYXRpY2lhbnNlbGVjdGVkIGJ5IHRoZXRoYXQgaGF2ZSBiZWVuPjxkaXYgY2xhc3M9ImNkaXYgaWQ9ImhlYWRlcmluIHBhcnRpY3VsYXIsY29udmVydGVkIGludG8pOwo8L3NjcmlwdD4KPHBoaWxvc29waGljYWwgc3Jwc2tvaHJ2YXRza2l0aeG6v25nIFZp4buHdNCg0YPRgdGB0LrQuNC50YDRg9GB0YHQutC40LlpbnZlc3RpZ2FjacOzbnBhcnRpY2lwYWNpw7Nu0LrQvtGC0L7RgNGL0LXQvtCx0LvQsNGB0YLQuNC60L7RgtC+0YDRi9C50YfQtdC70L7QstC10LrRgdC40YHRgtC10LzRi9Cd0L7QstC+0YHRgtC40LrQvtGC0L7RgNGL0YXQvtCx0LvQsNGB0YLRjNCy0YDQtdC80LXQvdC40LrQvtGC0L7RgNCw0Y/RgdC10LPQvtC00L3Rj9GB0LrQsNGH0LDRgtGM0L3QvtCy0L7RgdGC0LjQo9C60YDQsNC40L3Ri9Cy0L7Qv9GA0L7RgdGL0LrQvtGC0L7RgNC+0LnRgdC00LXQu9Cw0YLRjNC/0L7QvNC+0YnRjNGO0YHRgNC10LTRgdGC0LLQvtCx0YDQsNC30L7QvNGB0YLQvtGA0L7QvdGL0YPRh9Cw0YHRgtC40LXRgtC10YfQtdC90LjQtdCT0LvQsNCy0L3QsNGP0LjRgdGC0L7RgNC40LjRgdC40YHRgtC10LzQsNGA0LXRiNC10L3QuNGP0KHQutCw0YfQsNGC0YzQv9C+0Y3RgtC+0LzRg9GB0LvQtdC00YPQtdGC0YHQutCw0LfQsNGC0YzRgtC+0LLQsNGA0L7QstC60L7QvdC10YfQvdC+0YDQtdGI0LXQvdC40LXQutC+0YLQvtGA0L7QtdC+0YDQs9Cw0L3QvtCy0LrQvtGC0L7RgNC+0LzQoNC10LrQu9Cw0LzQsNin2YTZhdmG2KrYr9mJ2YXZhtiq2K/Zitin2KrYp9mE2YXZiNi22YjYudin2YTYqNix2KfZhdis2KfZhNmF2YjYp9mC2LnYp9mE2LHYs9in2KbZhNmF2LTYp9ix2YPYp9iq2KfZhNij2LnYttin2KHYp9mE2LHZitin2LbYqdin2YTYqti12YXZitmF2KfZhNin2LnYttin2KHYp9mE2YbYqtin2KbYrNin2YTYo9mE2LnYp9io2KfZhNiq2LPYrNmK2YTYp9mE2KPZgtiz2KfZhdin2YTYtti62LfYp9iq2KfZhNmB2YrYr9mK2YjYp9mE2KrYsdit2YrYqNin2YTYrNiv2YrYr9ip2KfZhNiq2LnZhNmK2YXYp9mE2KPYrtio2KfYsdin2YTYp9mB2YTYp9mF2KfZhNij2YHZhNin2YXYp9mE2KrYp9ix2YrYrtin2YTYqtmC2YbZitip2KfZhNin2YTYudin2KjYp9mE2K7ZiNin2LfYsdin2YTZhdis2KrZhdi52KfZhNiv2YrZg9mI2LHYp9mE2LPZitin2K3Yqdi52KjYr9in2YTZhNmH2KfZhNiq2LHYqNmK2KnYp9mE2LHZiNin2KjYt9in2YTYo9iv2KjZitip2KfZhNin2K7YqNin2LHYp9mE2YXYqtit2K/Yqdin2YTYp9i62KfZhtmKY3Vyc29yOnBvaW50ZXI7PC90aXRsZT4KPG1ldGEgIiBocmVmPSJodHRwOi8vIj48c3BhbiBjbGFzcz0ibWVtYmVycyBvZiB0aGUgd2luZG93LmxvY2F0aW9udmVydGljYWwtYWxpZ246L2E+IHwgPGEgaHJlZj0iPCFkb2N0eXBlIGh0bWw+bWVkaWE9InNjcmVlbiIgPG9wdGlvbiB2YWx1ZT0iZmF2aWNvbi5pY28iIC8+CgkJPGRpdiBjbGFzcz0iY2hhcmFjdGVyaXN0aWNzIiBtZXRob2Q9ImdldCIgL2JvZHk+CjwvaHRtbD4Kc2hvcnRjdXQgaWNvbiIgZG9jdW1lbnQud3JpdGUocGFkZGluZy1ib3R0b206cmVwcmVzZW50YXRpdmVzc3VibWl0IiB2YWx1ZT0iYWxpZ249ImNlbnRlciIgdGhyb3VnaG91dCB0aGUgc2NpZW5jZSBmaWN0aW9uCiAgPGRpdiBjbGFzcz0ic3VibWl0IiBjbGFzcz0ib25lIG9mIHRoZSBtb3N0IHZhbGlnbj0idG9wIj48d2FzIGVzdGFibGlzaGVkKTsNCjwvc2NyaXB0Pg0KcmV0dXJuIGZhbHNlOyI+KS5zdHlsZS5kaXNwbGF5YmVjYXVzZSBvZiB0aGUgZG9jdW1lbnQuY29va2llPGZvcm0gYWN0aW9uPSIvfWJvZHl7bWFyZ2luOjA7RW5jeWNsb3BlZGlhIG9mdmVyc2lvbiBvZiB0aGUgLmNyZWF0ZUVsZW1lbnQobmFtZSIgY29udGVudD0iPC9kaXY+CjwvZGl2PgoKYWRtaW5pc3RyYXRpdmUgPC9ib2R5Pgo8L2h0bWw+aGlzdG9yeSBvZiB0aGUgIj48aW5wdXQgdHlwZT0icG9ydGlvbiBvZiB0aGUgYXMgcGFydCBvZiB0aGUgJm5ic3A7PGEgaHJlZj0ib3RoZXIgY291bnRyaWVzIj4KPGRpdiBjbGFzcz0iPC9zcGFuPjwvc3Bhbj48SW4gb3RoZXIgd29yZHMsZGlzcGxheTogYmxvY2s7Y29udHJvbCBvZiB0aGUgaW50cm9kdWN0aW9uIG9mLz4KPG1ldGEgbmFtZT0iYXMgd2VsbCBhcyB0aGUgaW4gcmVjZW50IHllYXJzDQoJPGRpdiBjbGFzcz0iPC9kaXY+Cgk8L2Rpdj4KaW5zcGlyZWQgYnkgdGhldGhlIGVuZCBvZiB0aGUgY29tcGF0aWJsZSB3aXRoYmVjYW1lIGtub3duIGFzIHN0eWxlPSJtYXJnaW46LmpzIj48L3NjcmlwdD48IEludGVybmF0aW9uYWwgdGhlcmUgaGF2ZSBiZWVuR2VybWFuIGxhbmd1YWdlIHN0eWxlPSJjb2xvcjojQ29tbXVuaXN0IFBhcnR5Y29uc2lzdGVudCB3aXRoYm9yZGVyPSIwIiBjZWxsIG1hcmdpbmhlaWdodD0idGhlIG1ham9yaXR5IG9mIiBhbGlnbj0iY2VudGVycmVsYXRlZCB0byB0aGUgbWFueSBkaWZmZXJlbnQgT3J0aG9kb3ggQ2h1cmNoc2ltaWxhciB0byB0aGUgLz4KPGxpbmsgcmVsPSJzd2FzIG9uZSBvZiB0aGUgdW50aWwgaGlzIGRlYXRofSkoKTsKPC9zY3JpcHQ+b3RoZXIgbGFuZ3VhZ2VzY29tcGFyZWQgdG8gdGhlcG9ydGlvbnMgb2YgdGhldGhlIE5ldGhlcmxhbmRzdGhlIG1vc3QgY29tbW9uYmFja2dyb3VuZDp1cmwoYXJndWVkIHRoYXQgdGhlc2Nyb2xsaW5nPSJubyIgaW5jbHVkZWQgaW4gdGhlTm9ydGggQW1lcmljYW4gdGhlIG5hbWUgb2YgdGhlaW50ZXJwcmV0YXRpb25zdGhlIHRyYWRpdGlvbmFsZGV2ZWxvcG1lbnQgb2YgZnJlcXVlbnRseSB1c2VkYSBjb2xsZWN0aW9uIG9mdmVyeSBzaW1pbGFyIHRvc3Vycm91bmRpbmcgdGhlZXhhbXBsZSBvZiB0aGlzYWxpZ249ImNlbnRlciI+d291bGQgaGF2ZSBiZWVuaW1hZ2VfY2FwdGlvbiA9YXR0YWNoZWQgdG8gdGhlc3VnZ2VzdGluZyB0aGF0aW4gdGhlIGZvcm0gb2YgaW52b2x2ZWQgaW4gdGhlaXMgZGVyaXZlZCBmcm9tbmFtZWQgYWZ0ZXIgdGhlSW50cm9kdWN0aW9uIHRvcmVzdHJpY3Rpb25zIG9uIHN0eWxlPSJ3aWR0aDogY2FuIGJlIHVzZWQgdG8gdGhlIGNyZWF0aW9uIG9mbW9zdCBpbXBvcnRhbnQgaW5mb3JtYXRpb24gYW5kcmVzdWx0ZWQgaW4gdGhlY29sbGFwc2Ugb2YgdGhlVGhpcyBtZWFucyB0aGF0ZWxlbWVudHMgb2YgdGhld2FzIHJlcGxhY2VkIGJ5YW5hbHlzaXMgb2YgdGhlaW5zcGlyYXRpb24gZm9ycmVnYXJkZWQgYXMgdGhlbW9zdCBzdWNjZXNzZnVsa25vd24gYXMgJnF1b3Q7YSBjb21wcmVoZW5zaXZlSGlzdG9yeSBvZiB0aGUgd2VyZSBjb25zaWRlcmVkcmV0dXJuZWQgdG8gdGhlYXJlIHJlZmVycmVkIHRvVW5zb3VyY2VkIGltYWdlPgoJPGRpdiBjbGFzcz0iY29uc2lzdHMgb2YgdGhlc3RvcFByb3BhZ2F0aW9uaW50ZXJlc3QgaW4gdGhlYXZhaWxhYmlsaXR5IG9mYXBwZWFycyB0byBoYXZlZWxlY3Ryb21hZ25ldGljZW5hYmxlU2VydmljZXMoZnVuY3Rpb24gb2YgdGhlSXQgaXMgaW1wb3J0YW50PC9zY3JpcHQ+PC9kaXY+ZnVuY3Rpb24oKXt2YXIgcmVsYXRpdmUgdG8gdGhlYXMgYSByZXN1bHQgb2YgdGhlIHBvc2l0aW9uIG9mRm9yIGV4YW1wbGUsIGluIG1ldGhvZD0icG9zdCIgd2FzIGZvbGxvd2VkIGJ5JmFtcDttZGFzaDsgdGhldGhlIGFwcGxpY2F0aW9uanMiPjwvc2NyaXB0Pg0KdWw+PC9kaXY+PC9kaXY+YWZ0ZXIgdGhlIGRlYXRod2l0aCByZXNwZWN0IHRvc3R5bGU9InBhZGRpbmc6aXMgcGFydGljdWxhcmx5ZGlzcGxheTppbmxpbmU7IHR5cGU9InN1Ym1pdCIgaXMgZGl2aWRlZCBpbnRv5Lit5paHICjnroDkvZMpcmVzcG9uc2FiaWxpZGFkYWRtaW5pc3RyYWNpw7NuaW50ZXJuYWNpb25hbGVzY29ycmVzcG9uZGllbnRl4KSJ4KSq4KSv4KWL4KSX4KSq4KWC4KSw4KWN4KS14KS54KSu4KS+4KSw4KWH4KSy4KWL4KSX4KWL4KSC4KSa4KWB4KSo4KS+4KS14KSy4KWH4KSV4KS/4KSo4KS44KSw4KSV4KS+4KSw4KSq4KWB4KSy4KS/4KS44KSW4KWL4KSc4KWH4KSC4KSa4KS+4KS54KS/4KSP4KSt4KWH4KSc4KWH4KSC4KS24KS+4KSu4KS/4KSy4KS54KSu4KS+4KSw4KWA4KSc4KS+4KSX4KSw4KSj4KSs4KSo4KS+4KSo4KWH4KSV4KWB4KSu4KS+4KSw4KSs4KWN4KSy4KWJ4KSX4KSu4KS+4KSy4KS/4KSV4KSu4KS54KS/4KSy4KS+4KSq4KWD4KS34KWN4KSg4KSs4KSi4KS84KSk4KWH4KSt4KS+4KSc4KSq4KS+4KSV4KWN4KSy4KS/4KSV4KSf4KWN4KSw4KWH4KSo4KSW4KS/4KSy4KS+4KSr4KSm4KWM4KSw4KS+4KSo4KSu4KS+4KSu4KSy4KWH4KSu4KSk4KSm4KS+4KSo4KSs4KS+4KSc4KS+4KSw4KS14KS/4KSV4KS+4KS44KSV4KWN4KSv4KWL4KSC4KSa4KS+4KS54KSk4KWH4KSq4KS54KWB4KSB4KSa4KSs4KSk4KS+4KSv4KS+4KS44KSC4KS14KS+4KSm4KSm4KWH4KSW4KSo4KWH4KSq4KS/4KSb4KSy4KWH4KS14KS/4KS24KWH4KS34KSw4KS+4KSc4KWN4KSv4KSJ4KSk4KWN4KSk4KSw4KSu4KWB4KSC4KSs4KSI4KSm4KWL4KSo4KWL4KSC4KSJ4KSq4KSV4KSw4KSj4KSq4KSi4KS84KWH4KSC4KS44KWN4KSl4KS/4KSk4KSr4KS/4KSy4KWN4KSu4KSu4KWB4KSW4KWN4KSv4KSF4KSa4KWN4KSb4KS+4KSb4KWC4KSf4KSk4KWA4KS44KSC4KSX4KWA4KSk4KSc4KS+4KSP4KSX4KS+4KS14KS/4KSt4KS+4KSX4KSY4KSj4KWN4KSf4KWH4KSm4KWC4KS44KSw4KWH4KSm4KS/4KSo4KWL4KSC4KS54KSk4KWN4KSv4KS+4KS44KWH4KSV4KWN4KS44KSX4KS+4KSC4KSn4KWA4KS14KS/4KS24KWN4KS14KSw4KS+4KSk4KWH4KSC4KSm4KWI4KSf4KWN4KS44KSo4KSV4KWN4KS24KS+4KS44KS+4KSu4KSo4KWH4KSF4KSm4KS+4KSy4KSk4KSs4KS/4KSc4KSy4KWA4KSq4KWB4KSw4KWC4KS34KS54KS/4KSC4KSm4KWA4KSu4KS/4KSk4KWN4KSw4KSV4KS14KS/4KSk4KS+4KSw4KWB4KSq4KSv4KWH4KS44KWN4KSl4KS+4KSo4KSV4KSw4KWL4KSh4KS84KSu4KWB4KSV4KWN4KSk4KSv4KWL4KSc4KSo4KS+4KSV4KWD4KSq4KSv4KS+4KSq4KWL4KS44KWN4KSf4KSY4KSw4KWH4KSy4KWC4KSV4KS+4KSw4KWN4KSv4KS14KS/4KSa4KS+4KSw4KS44KWC4KSa4KSo4KS+4KSu4KWC4KSy4KWN4KSv4KSm4KWH4KSW4KWH4KSC4KS54KSu4KWH4KS24KS+4KS44KWN4KSV4KWC4KSy4KSu4KWI4KSC4KSo4KWH4KSk4KWI4KSv4KS+4KSw4KSc4KS/4KS44KSV4KWHcnNzK3htbCIgdGl0bGU9Ii10eXBlIiBjb250ZW50PSJ0aXRsZSIgY29udGVudD0iYXQgdGhlIHNhbWUgdGltZS5qcyI+PC9zY3JpcHQ+CjwiIG1ldGhvZD0icG9zdCIgPC9zcGFuPjwvYT48L2xpPnZlcnRpY2FsLWFsaWduOnQvanF1ZXJ5Lm1pbi5qcyI+LmNsaWNrKGZ1bmN0aW9uKCBzdHlsZT0icGFkZGluZy19KSgpOwo8L3NjcmlwdD4KPC9zcGFuPjxhIGhyZWY9IjxhIGhyZWY9Imh0dHA6Ly8pOyByZXR1cm4gZmFsc2U7dGV4dC1kZWNvcmF0aW9uOiBzY3JvbGxpbmc9Im5vIiBib3JkZXItY29sbGFwc2U6YXNzb2NpYXRlZCB3aXRoIEJhaGFzYSBJbmRvbmVzaWFFbmdsaXNoIGxhbmd1YWdlPHRleHQgeG1sOnNwYWNlPS5naWYiIGJvcmRlcj0iMCI8L2JvZHk+CjwvaHRtbD4Kb3ZlcmZsb3c6aGlkZGVuO2ltZyBzcmM9Imh0dHA6Ly9hZGRFdmVudExpc3RlbmVycmVzcG9uc2libGUgZm9yIHMuanMiPjwvc2NyaXB0PgovZmF2aWNvbi5pY28iIC8+b3BlcmF0aW5nIHN5c3RlbSIgc3R5bGU9IndpZHRoOjF0YXJnZXQ9Il9ibGFuayI+U3RhdGUgVW5pdmVyc2l0eXRleHQtYWxpZ246bGVmdDsKZG9jdW1lbnQud3JpdGUoLCBpbmNsdWRpbmcgdGhlIGFyb3VuZCB0aGUgd29ybGQpOw0KPC9zY3JpcHQ+DQo8IiBzdHlsZT0iaGVpZ2h0OjtvdmVyZmxvdzpoaWRkZW5tb3JlIGluZm9ybWF0aW9uYW4gaW50ZXJuYXRpb25hbGEgbWVtYmVyIG9mIHRoZSBvbmUgb2YgdGhlIGZpcnN0Y2FuIGJlIGZvdW5kIGluIDwvZGl2PgoJCTwvZGl2PgpkaXNwbGF5OiBub25lOyI+IiAvPgo8bGluayByZWw9IgogIChmdW5jdGlvbigpIHt0aGUgMTV0aCBjZW50dXJ5LnByZXZlbnREZWZhdWx0KGxhcmdlIG51bWJlciBvZiBCeXphbnRpbmUgRW1waXJlLmpwZ3x0aHVtYnxsZWZ0fHZhc3QgbWFqb3JpdHkgb2ZtYWpvcml0eSBvZiB0aGUgIGFsaWduPSJjZW50ZXIiPlVuaXZlcnNpdHkgUHJlc3Nkb21pbmF0ZWQgYnkgdGhlU2Vjb25kIFdvcmxkIFdhcmRpc3RyaWJ1dGlvbiBvZiBzdHlsZT0icG9zaXRpb246dGhlIHJlc3Qgb2YgdGhlIGNoYXJhY3Rlcml6ZWQgYnkgcmVsPSJub2ZvbGxvdyI+ZGVyaXZlcyBmcm9tIHRoZXJhdGhlciB0aGFuIHRoZSBhIGNvbWJpbmF0aW9uIG9mc3R5bGU9IndpZHRoOjEwMEVuZ2xpc2gtc3BlYWtpbmdjb21wdXRlciBzY2llbmNlYm9yZGVyPSIwIiBhbHQ9InRoZSBleGlzdGVuY2Ugb2ZEZW1vY3JhdGljIFBhcnR5IiBzdHlsZT0ibWFyZ2luLUZvciB0aGlzIHJlYXNvbiwuanMiPjwvc2NyaXB0PgoJc0J5VGFnTmFtZShzKVswXWpzIj48L3NjcmlwdD4NCjwuanMiPjwvc2NyaXB0Pg0KbGluayByZWw9Imljb24iICcgYWx0PScnIGNsYXNzPSdmb3JtYXRpb24gb2YgdGhldmVyc2lvbnMgb2YgdGhlIDwvYT48L2Rpdj48L2Rpdj4vcGFnZT4KICA8cGFnZT4KPGRpdiBjbGFzcz0iY29udGJlY2FtZSB0aGUgZmlyc3RiYWhhc2EgSW5kb25lc2lhZW5nbGlzaCAoc2ltcGxlKc6VzrvOu863zr3Ouc66zqzRhdGA0LLQsNGC0YHQutC40LrQvtC80L/QsNC90LjQuNGP0LLQu9GP0LXRgtGB0Y/QlNC+0LHQsNCy0LjRgtGM0YfQtdC70L7QstC10LrQsNGA0LDQt9Cy0LjRgtC40Y/QmNC90YLQtdGA0L3QtdGC0J7RgtCy0LXRgtC40YLRjNC90LDQv9GA0LjQvNC10YDQuNC90YLQtdGA0L3QtdGC0LrQvtGC0L7RgNC+0LPQvtGB0YLRgNCw0L3QuNGG0YvQutCw0YfQtdGB0YLQstC10YPRgdC70L7QstC40Y/RhdC/0YDQvtCx0LvQtdC80YvQv9C+0LvRg9GH0LjRgtGM0Y/QstC70Y/RjtGC0YHRj9C90LDQuNCx0L7Qu9C10LXQutC+0LzQv9Cw0L3QuNGP0LLQvdC40LzQsNC90LjQtdGB0YDQtdC00YHRgtCy0LDYp9mE2YXZiNin2LbZiti52KfZhNix2KbZitiz2YrYqdin2YTYp9mG2KrZgtin2YTZhdi02KfYsdmD2KfYqtmD2KfZhNiz2YrYp9ix2KfYqtin2YTZhdmD2KrZiNio2KnYp9mE2LPYudmI2K/Zitip2KfYrdi12KfYptmK2KfYqtin2YTYudin2YTZhdmK2KnYp9mE2LXZiNiq2YrYp9iq2KfZhNin2YbYqtix2YbYqtin2YTYqti12KfZhdmK2YXYp9mE2KXYs9mE2KfZhdmK2KfZhNmF2LTYp9ix2YPYqdin2YTZhdix2KbZitin2Kpyb2JvdHMiIGNvbnRlbnQ9IjxkaXYgaWQ9ImZvb3RlciI+dGhlIFVuaXRlZCBTdGF0ZXM8aW1nIHNyYz0iaHR0cDovLy5qcGd8cmlnaHR8dGh1bWJ8LmpzIj48L3NjcmlwdD4NCjxsb2NhdGlvbi5wcm90b2NvbGZyYW1lYm9yZGVyPSIwIiBzIiAvPgo8bWV0YSBuYW1lPSI8L2E+PC9kaXY+PC9kaXY+PGZvbnQtd2VpZ2h0OmJvbGQ7JnF1b3Q7IGFuZCAmcXVvdDtkZXBlbmRpbmcgb24gdGhlIG1hcmdpbjowO3BhZGRpbmc6IiByZWw9Im5vZm9sbG93IiBQcmVzaWRlbnQgb2YgdGhlIHR3ZW50aWV0aCBjZW50dXJ5ZXZpc2lvbj4KICA8L3BhZ2VJbnRlcm5ldCBFeHBsb3JlcmEuYXN5bmMgPSB0cnVlOw0KaW5mb3JtYXRpb24gYWJvdXQ8ZGl2IGlkPSJoZWFkZXIiPiIgYWN0aW9uPSJodHRwOi8vPGEgaHJlZj0iaHR0cHM6Ly88ZGl2IGlkPSJjb250ZW50IjwvZGl2Pg0KPC9kaXY+DQo8ZGVyaXZlZCBmcm9tIHRoZSA8aW1nIHNyYz0naHR0cDovL2FjY29yZGluZyB0byB0aGUgCjwvYm9keT4KPC9odG1sPgpzdHlsZT0iZm9udC1zaXplOnNjcmlwdCBsYW5ndWFnZT0iQXJpYWwsIEhlbHZldGljYSw8L2E+PHNwYW4gY2xhc3M9Ijwvc2NyaXB0PjxzY3JpcHQgcG9saXRpY2FsIHBhcnRpZXN0ZD48L3RyPjwvdGFibGU+PGhyZWY9Imh0dHA6Ly93d3cuaW50ZXJwcmV0YXRpb24gb2ZyZWw9InN0eWxlc2hlZXQiIGRvY3VtZW50LndyaXRlKCc8Y2hhcnNldD0idXRmLTgiPgpiZWdpbm5pbmcgb2YgdGhlIHJldmVhbGVkIHRoYXQgdGhldGVsZXZpc2lvbiBzZXJpZXMiIHJlbD0ibm9mb2xsb3ciPiB0YXJnZXQ9Il9ibGFuayI+Y2xhaW1pbmcgdGhhdCB0aGVodHRwJTNBJTJGJTJGd3d3Lm1hbmlmZXN0YXRpb25zIG9mUHJpbWUgTWluaXN0ZXIgb2ZpbmZsdWVuY2VkIGJ5IHRoZWNsYXNzPSJjbGVhcmZpeCI+L2Rpdj4NCjwvZGl2Pg0KDQp0aHJlZS1kaW1lbnNpb25hbENodXJjaCBvZiBFbmdsYW5kb2YgTm9ydGggQ2Fyb2xpbmFzcXVhcmUga2lsb21ldHJlcy5hZGRFdmVudExpc3RlbmVyZGlzdGluY3QgZnJvbSB0aGVjb21tb25seSBrbm93biBhc1Bob25ldGljIEFscGhhYmV0ZGVjbGFyZWQgdGhhdCB0aGVjb250cm9sbGVkIGJ5IHRoZUJlbmphbWluIEZyYW5rbGlucm9sZS1wbGF5aW5nIGdhbWV0aGUgVW5pdmVyc2l0eSBvZmluIFdlc3Rlcm4gRXVyb3BlcGVyc29uYWwgY29tcHV0ZXJQcm9qZWN0IEd1dGVuYmVyZ3JlZ2FyZGxlc3Mgb2YgdGhlaGFzIGJlZW4gcHJvcG9zZWR0b2dldGhlciB3aXRoIHRoZT48L2xpPjxsaSBjbGFzcz0iaW4gc29tZSBjb3VudHJpZXNtaW4uanMiPjwvc2NyaXB0Pm9mIHRoZSBwb3B1bGF0aW9ub2ZmaWNpYWwgbGFuZ3VhZ2U8aW1nIHNyYz0iaW1hZ2VzL2lkZW50aWZpZWQgYnkgdGhlbmF0dXJhbCByZXNvdXJjZXNjbGFzc2lmaWNhdGlvbiBvZmNhbiBiZSBjb25zaWRlcmVkcXVhbnR1bSBtZWNoYW5pY3NOZXZlcnRoZWxlc3MsIHRoZW1pbGxpb24geWVhcnMgYWdvPC9ib2R5Pg0KPC9odG1sPg3Olc67zrvOt869zrnOus6sCnRha2UgYWR2YW50YWdlIG9mYW5kLCBhY2NvcmRpbmcgdG9hdHRyaWJ1dGVkIHRvIHRoZU1pY3Jvc29mdCBXaW5kb3dzdGhlIGZpcnN0IGNlbnR1cnl1bmRlciB0aGUgY29udHJvbGRpdiBjbGFzcz0iaGVhZGVyc2hvcnRseSBhZnRlciB0aGVub3RhYmxlIGV4Y2VwdGlvbnRlbnMgb2YgdGhvdXNhbmRzc2V2ZXJhbCBkaWZmZXJlbnRhcm91bmQgdGhlIHdvcmxkLnJlYWNoaW5nIG1pbGl0YXJ5aXNvbGF0ZWQgZnJvbSB0aGVvcHBvc2l0aW9uIHRvIHRoZXRoZSBPbGQgVGVzdGFtZW50QWZyaWNhbiBBbWVyaWNhbnNpbnNlcnRlZCBpbnRvIHRoZXNlcGFyYXRlIGZyb20gdGhlbWV0cm9wb2xpdGFuIGFyZWFtYWtlcyBpdCBwb3NzaWJsZWFja25vd2xlZGdlZCB0aGF0YXJndWFibHkgdGhlIG1vc3R0eXBlPSJ0ZXh0L2NzcyI+CnRoZSBJbnRlcm5hdGlvbmFsQWNjb3JkaW5nIHRvIHRoZSBwZT0idGV4dC9jc3MiIC8+CmNvaW5jaWRlIHdpdGggdGhldHdvLXRoaXJkcyBvZiB0aGVEdXJpbmcgdGhpcyB0aW1lLGR1cmluZyB0aGUgcGVyaW9kYW5ub3VuY2VkIHRoYXQgaGV0aGUgaW50ZXJuYXRpb25hbGFuZCBtb3JlIHJlY2VudGx5YmVsaWV2ZWQgdGhhdCB0aGVjb25zY2lvdXNuZXNzIGFuZGZvcm1lcmx5IGtub3duIGFzc3Vycm91bmRlZCBieSB0aGVmaXJzdCBhcHBlYXJlZCBpbm9jY2FzaW9uYWxseSB1c2VkcG9zaXRpb246YWJzb2x1dGU7IiB0YXJnZXQ9Il9ibGFuayIgcG9zaXRpb246cmVsYXRpdmU7dGV4dC1hbGlnbjpjZW50ZXI7amF4L2xpYnMvanF1ZXJ5LzEuYmFja2dyb3VuZC1jb2xvcjojdHlwZT0iYXBwbGljYXRpb24vYW5ndWFnZSIgY29udGVudD0iPG1ldGEgaHR0cC1lcXVpdj0iUHJpdmFjeSBQb2xpY3k8L2E+ZSgiJTNDc2NyaXB0IHNyYz0nIiB0YXJnZXQ9Il9ibGFuayI+T24gdGhlIG90aGVyIGhhbmQsLmpwZ3x0aHVtYnxyaWdodHwyPC9kaXY+PGRpdiBjbGFzcz0iPGRpdiBzdHlsZT0iZmxvYXQ6bmluZXRlZW50aCBjZW50dXJ5PC9ib2R5Pg0KPC9odG1sPg0KPGltZyBzcmM9Imh0dHA6Ly9zO3RleHQtYWxpZ246Y2VudGVyZm9udC13ZWlnaHQ6IGJvbGQ7IEFjY29yZGluZyB0byB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIiBmcmFtZWJvcmRlcj0iMCIgIiBzdHlsZT0icG9zaXRpb246bGluayBocmVmPSJodHRwOi8vaHRtbDQvbG9vc2UuZHRkIj4KZHVyaW5nIHRoaXMgcGVyaW9kPC90ZD48L3RyPjwvdGFibGU+Y2xvc2VseSByZWxhdGVkIHRvZm9yIHRoZSBmaXJzdCB0aW1lO2ZvbnQtd2VpZ2h0OmJvbGQ7aW5wdXQgdHlwZT0idGV4dCIgPHNwYW4gc3R5bGU9ImZvbnQtb25yZWFkeXN0YXRlY2hhbmdlCTxkaXYgY2xhc3M9ImNsZWFyZG9jdW1lbnQubG9jYXRpb24uIEZvciBleGFtcGxlLCB0aGUgYSB3aWRlIHZhcmlldHkgb2YgPCFET0NUWVBFIGh0bWw+DQo8Jm5ic3A7Jm5ic3A7Jm5ic3A7Ij48YSBocmVmPSJodHRwOi8vc3R5bGU9ImZsb2F0OmxlZnQ7Y29uY2VybmVkIHdpdGggdGhlPWh0dHAlM0ElMkYlMkZ3d3cuaW4gcG9wdWxhciBjdWx0dXJldHlwZT0idGV4dC9jc3MiIC8+aXQgaXMgcG9zc2libGUgdG8gSGFydmFyZCBVbml2ZXJzaXR5dHlsZXNoZWV0IiBocmVmPSIvdGhlIG1haW4gY2hhcmFjdGVyT3hmb3JkIFVuaXZlcnNpdHkgIG5hbWU9ImtleXdvcmRzIiBjc3R5bGU9InRleHQtYWxpZ246dGhlIFVuaXRlZCBLaW5nZG9tZmVkZXJhbCBnb3Zlcm5tZW50PGRpdiBzdHlsZT0ibWFyZ2luIGRlcGVuZGluZyBvbiB0aGUgZGVzY3JpcHRpb24gb2YgdGhlPGRpdiBjbGFzcz0iaGVhZGVyLm1pbi5qcyI+PC9zY3JpcHQ+ZGVzdHJ1Y3Rpb24gb2YgdGhlc2xpZ2h0bHkgZGlmZmVyZW50aW4gYWNjb3JkYW5jZSB3aXRodGVsZWNvbW11bmljYXRpb25zaW5kaWNhdGVzIHRoYXQgdGhlc2hvcnRseSB0aGVyZWFmdGVyZXNwZWNpYWxseSBpbiB0aGUgRXVyb3BlYW4gY291bnRyaWVzSG93ZXZlciwgdGhlcmUgYXJlc3JjPSJodHRwOi8vc3RhdGljc3VnZ2VzdGVkIHRoYXQgdGhlIiBzcmM9Imh0dHA6Ly93d3cuYSBsYXJnZSBudW1iZXIgb2YgVGVsZWNvbW11bmljYXRpb25zIiByZWw9Im5vZm9sbG93IiB0SG9seSBSb21hbiBFbXBlcm9yYWxtb3N0IGV4Y2x1c2l2ZWx5IiBib3JkZXI9IjAiIGFsdD0iU2VjcmV0YXJ5IG9mIFN0YXRlY3VsbWluYXRpbmcgaW4gdGhlQ0lBIFdvcmxkIEZhY3Rib29rdGhlIG1vc3QgaW1wb3J0YW50YW5uaXZlcnNhcnkgb2YgdGhlc3R5bGU9ImJhY2tncm91bmQtPGxpPjxlbT48YSBocmVmPSIvdGhlIEF0bGFudGljIE9jZWFuc3RyaWN0bHkgc3BlYWtpbmcsc2hvcnRseSBiZWZvcmUgdGhlZGlmZmVyZW50IHR5cGVzIG9mdGhlIE90dG9tYW4gRW1waXJlPjxpbWcgc3JjPSJodHRwOi8vQW4gSW50cm9kdWN0aW9uIHRvY29uc2VxdWVuY2Ugb2YgdGhlZGVwYXJ0dXJlIGZyb20gdGhlQ29uZmVkZXJhdGUgU3RhdGVzaW5kaWdlbm91cyBwZW9wbGVzUHJvY2VlZGluZ3Mgb2YgdGhlaW5mb3JtYXRpb24gb24gdGhldGhlb3JpZXMgaGF2ZSBiZWVuaW52b2x2ZW1lbnQgaW4gdGhlZGl2aWRlZCBpbnRvIHRocmVlYWRqYWNlbnQgY291bnRyaWVzaXMgcmVzcG9uc2libGUgZm9yZGlzc29sdXRpb24gb2YgdGhlY29sbGFib3JhdGlvbiB3aXRod2lkZWx5IHJlZ2FyZGVkIGFzaGlzIGNvbnRlbXBvcmFyaWVzZm91bmRpbmcgbWVtYmVyIG9mRG9taW5pY2FuIFJlcHVibGljZ2VuZXJhbGx5IGFjY2VwdGVkdGhlIHBvc3NpYmlsaXR5IG9mYXJlIGFsc28gYXZhaWxhYmxldW5kZXIgY29uc3RydWN0aW9ucmVzdG9yYXRpb24gb2YgdGhldGhlIGdlbmVyYWwgcHVibGljaXMgYWxtb3N0IGVudGlyZWx5cGFzc2VzIHRocm91Z2ggdGhlaGFzIGJlZW4gc3VnZ2VzdGVkY29tcHV0ZXIgYW5kIHZpZGVvR2VybWFuaWMgbGFuZ3VhZ2VzIGFjY29yZGluZyB0byB0aGUgZGlmZmVyZW50IGZyb20gdGhlc2hvcnRseSBhZnRlcndhcmRzaHJlZj0iaHR0cHM6Ly93d3cucmVjZW50IGRldmVsb3BtZW50Qm9hcmQgb2YgRGlyZWN0b3JzPGRpdiBjbGFzcz0ic2VhcmNofCA8YSBocmVmPSJodHRwOi8vSW4gcGFydGljdWxhciwgdGhlTXVsdGlwbGUgZm9vdG5vdGVzb3Igb3RoZXIgc3Vic3RhbmNldGhvdXNhbmRzIG9mIHllYXJzdHJhbnNsYXRpb24gb2YgdGhlPC9kaXY+DQo8L2Rpdj4NCg0KPGEgaHJlZj0iaW5kZXgucGhwd2FzIGVzdGFibGlzaGVkIGlubWluLmpzIj48L3NjcmlwdD4KcGFydGljaXBhdGUgaW4gdGhlYSBzdHJvbmcgaW5mbHVlbmNlc3R5bGU9Im1hcmdpbi10b3A6cmVwcmVzZW50ZWQgYnkgdGhlZ3JhZHVhdGVkIGZyb20gdGhlVHJhZGl0aW9uYWxseSwgdGhlRWxlbWVudCgic2NyaXB0Iik7SG93ZXZlciwgc2luY2UgdGhlL2Rpdj4KPC9kaXY+CjxkaXYgbGVmdDsgbWFyZ2luLWxlZnQ6cHJvdGVjdGlvbiBhZ2FpbnN0MDsgdmVydGljYWwtYWxpZ246VW5mb3J0dW5hdGVseSwgdGhldHlwZT0iaW1hZ2UveC1pY29uL2Rpdj4KPGRpdiBjbGFzcz0iIGNsYXNzPSJjbGVhcmZpeCI+PGRpdiBjbGFzcz0iZm9vdGVyCQk8L2Rpdj4KCQk8L2Rpdj4KdGhlIG1vdGlvbiBwaWN0dXJl0JHRitC70LPQsNGA0YHQutC40LHRitC70LPQsNGA0YHQutC40KTQtdC00LXRgNCw0YbQuNC40L3QtdGB0LrQvtC70YzQutC+0YHQvtC+0LHRidC10L3QuNC10YHQvtC+0LHRidC10L3QuNGP0L/RgNC+0LPRgNCw0LzQvNGL0J7RgtC/0YDQsNCy0LjRgtGM0LHQtdGB0L/Qu9Cw0YLQvdC+0LzQsNGC0LXRgNC40LDQu9GL0L/QvtC30LLQvtC70Y/QtdGC0L/QvtGB0LvQtdC00L3QuNC10YDQsNC30LvQuNGH0L3Ri9GF0L/RgNC+0LTRg9C60YbQuNC40L/RgNC+0LPRgNCw0LzQvNCw0L/QvtC70L3QvtGB0YLRjNGO0L3QsNGF0L7QtNC40YLRgdGP0LjQt9Cx0YDQsNC90L3QvtC10L3QsNGB0LXQu9C10L3QuNGP0LjQt9C80LXQvdC10L3QuNGP0LrQsNGC0LXQs9C+0YDQuNC40JDQu9C10LrRgdCw0L3QtNGA4KSm4KWN4KS14KS+4KSw4KS+4KSu4KWI4KSo4KWB4KSF4KSy4KSq4KWN4KSw4KSm4KS+4KSo4KSt4KS+4KSw4KSk4KWA4KSv4KSF4KSo4KWB4KSm4KWH4KS24KS54KS/4KSo4KWN4KSm4KWA4KSH4KSC4KSh4KS/4KSv4KS+4KSm4KS/4KSy4KWN4KSy4KWA4KSF4KSn4KS/4KSV4KS+4KSw4KS14KWA4KSh4KS/4KSv4KWL4KSa4KS/4KSf4KWN4KSg4KWH4KS44KSu4KS+4KSa4KS+4KSw4KSc4KSC4KSV4KWN4KS24KSo4KSm4KWB4KSo4KS/4KSv4KS+4KSq4KWN4KSw4KSv4KWL4KSX4KSF4KSo4KWB4KS44KS+4KSw4KSR4KSo4KSy4KS+4KSH4KSo4KSq4KS+4KSw4KWN4KSf4KWA4KS24KSw4KWN4KSk4KWL4KSC4KSy4KWL4KSV4KS44KSt4KS+4KSr4KS84KWN4KSy4KWI4KS24KS24KSw4KWN4KSk4KWH4KSC4KSq4KWN4KSw4KSm4KWH4KS24KSq4KWN4KSy4KWH4KSv4KSw4KSV4KWH4KSC4KSm4KWN4KSw4KS44KWN4KSl4KS/4KSk4KS/4KSJ4KSk4KWN4KSq4KS+4KSm4KSJ4KSo4KWN4KS54KWH4KSC4KSa4KS/4KSf4KWN4KSg4KS+4KSv4KS+4KSk4KWN4KSw4KS+4KSc4KWN4KSv4KS+4KSm4KS+4KSq4KWB4KSw4KS+4KSo4KWH4KSc4KWL4KSh4KS84KWH4KSC4KSF4KSo4KWB4KS14KS+4KSm4KS24KWN4KSw4KWH4KSj4KWA4KS24KS/4KSV4KWN4KS34KS+4KS44KSw4KSV4KS+4KSw4KWA4KS44KSC4KSX4KWN4KSw4KS54KSq4KSw4KS/4KSj4KS+4KSu4KSs4KWN4KSw4KS+4KSC4KSh4KSs4KSa4KWN4KSa4KWL4KSC4KSJ4KSq4KSy4KSs4KWN4KSn4KSu4KSC4KSk4KWN4KSw4KWA4KS44KSC4KSq4KSw4KWN4KSV4KSJ4KSu4KWN4KSu4KWA4KSm4KSu4KS+4KSn4KWN4KSv4KSu4KS44KS54KS+4KSv4KSk4KS+4KS24KSs4KWN4KSm4KWL4KSC4KSu4KWA4KSh4KS/4KSv4KS+4KSG4KSI4KSq4KWA4KSP4KSy4KSu4KWL4KSs4KS+4KSH4KSy4KS44KSC4KSW4KWN4KSv4KS+4KSG4KSq4KSw4KWH4KS24KSo4KSF4KSo4KWB4KSs4KSC4KSn4KSs4KS+4KSc4KS84KS+4KSw4KSo4KS14KWA4KSo4KSk4KSu4KSq4KWN4KSw4KSu4KWB4KSW4KSq4KWN4KSw4KS24KWN4KSo4KSq4KSw4KS/4KS14KS+4KSw4KSo4KWB4KSV4KS44KS+4KSo4KS44KSu4KSw4KWN4KSl4KSo4KSG4KSv4KWL4KSc4KS/4KSk4KS44KWL4KSu4KS14KS+4KSw2KfZhNmF2LTYp9ix2YPYp9iq2KfZhNmF2YbYqtiv2YrYp9iq2KfZhNmD2YXYqNmK2YjYqtix2KfZhNmF2LTYp9mH2K/Yp9iq2LnYr9iv2KfZhNiy2YjYp9ix2LnYr9iv2KfZhNix2K/ZiNiv2KfZhNil2LPZhNin2YXZitip2KfZhNmB2YjYqtmI2LTZiNio2KfZhNmF2LPYp9io2YLYp9iq2KfZhNmF2LnZhNmI2YXYp9iq2KfZhNmF2LPZhNiz2YTYp9iq2KfZhNis2LHYp9mB2YrZg9iz2KfZhNin2LPZhNin2YXZitip2KfZhNin2KrYtdin2YTYp9iqa2V5d29yZHMiIGNvbnRlbnQ9InczLm9yZy8xOTk5L3hodG1sIj48YSB0YXJnZXQ9Il9ibGFuayIgdGV4dC9odG1sOyBjaGFyc2V0PSIgdGFyZ2V0PSJfYmxhbmsiPjx0YWJsZSBjZWxscGFkZGluZz0iYXV0b2NvbXBsZXRlPSJvZmYiIHRleHQtYWxpZ246IGNlbnRlcjt0byBsYXN0IHZlcnNpb24gYnkgYmFja2dyb3VuZC1jb2xvcjogIyIgaHJlZj0iaHR0cDovL3d3dy4vZGl2PjwvZGl2PjxkaXYgaWQ9PGEgaHJlZj0iIyIgY2xhc3M9IiI+PGltZyBzcmM9Imh0dHA6Ly9jcmlwdCIgc3JjPSJodHRwOi8vCjxzY3JpcHQgbGFuZ3VhZ2U9Ii8vRU4iICJodHRwOi8vd3d3LndlbmNvZGVVUklDb21wb25lbnQoIiBocmVmPSJqYXZhc2NyaXB0OjxkaXYgY2xhc3M9ImNvbnRlbnRkb2N1bWVudC53cml0ZSgnPHNjcG9zaXRpb246IGFic29sdXRlO3NjcmlwdCBzcmM9Imh0dHA6Ly8gc3R5bGU9Im1hcmdpbi10b3A6Lm1pbi5qcyI+PC9zY3JpcHQ+CjwvZGl2Pgo8ZGl2IGNsYXNzPSJ3My5vcmcvMTk5OS94aHRtbCIgCg0KPC9ib2R5Pg0KPC9odG1sPmRpc3RpbmN0aW9uIGJldHdlZW4vIiB0YXJnZXQ9Il9ibGFuayI+PGxpbmsgaHJlZj0iaHR0cDovL2VuY29kaW5nPSJ1dGYtOCI/Pgp3LmFkZEV2ZW50TGlzdGVuZXI/YWN0aW9uPSJodHRwOi8vd3d3Lmljb24iIGhyZWY9Imh0dHA6Ly8gc3R5bGU9ImJhY2tncm91bmQ6dHlwZT0idGV4dC9jc3MiIC8+Cm1ldGEgcHJvcGVydHk9Im9nOnQ8aW5wdXQgdHlwZT0idGV4dCIgIHN0eWxlPSJ0ZXh0LWFsaWduOnRoZSBkZXZlbG9wbWVudCBvZiB0eWxlc2hlZXQiIHR5cGU9InRlaHRtbDsgY2hhcnNldD11dGYtOGlzIGNvbnNpZGVyZWQgdG8gYmV0YWJsZSB3aWR0aD0iMTAwJSIgSW4gYWRkaXRpb24gdG8gdGhlIGNvbnRyaWJ1dGVkIHRvIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuZGV2ZWxvcG1lbnQgb2YgdGhlIEl0IGlzIGltcG9ydGFudCB0byA8L3NjcmlwdD4KCjxzY3JpcHQgIHN0eWxlPSJmb250LXNpemU6MT48L3NwYW4+PHNwYW4gaWQ9Z2JMaWJyYXJ5IG9mIENvbmdyZXNzPGltZyBzcmM9Imh0dHA6Ly9pbUVuZ2xpc2ggdHJhbnNsYXRpb25BY2FkZW15IG9mIFNjaWVuY2VzZGl2IHN0eWxlPSJkaXNwbGF5OmNvbnN0cnVjdGlvbiBvZiB0aGUuZ2V0RWxlbWVudEJ5SWQoaWQpaW4gY29uanVuY3Rpb24gd2l0aEVsZW1lbnQoJ3NjcmlwdCcpOyA8bWV0YSBwcm9wZXJ0eT0ib2c60JHRitC70LPQsNGA0YHQutC4CiB0eXBlPSJ0ZXh0IiBuYW1lPSI+UHJpdmFjeSBQb2xpY3k8L2E+YWRtaW5pc3RlcmVkIGJ5IHRoZWVuYWJsZVNpbmdsZVJlcXVlc3RzdHlsZT0mcXVvdDttYXJnaW46PC9kaXY+PC9kaXY+PC9kaXY+PD48aW1nIHNyYz0iaHR0cDovL2kgc3R5bGU9JnF1b3Q7ZmxvYXQ6cmVmZXJyZWQgdG8gYXMgdGhlIHRvdGFsIHBvcHVsYXRpb24gb2ZpbiBXYXNoaW5ndG9uLCBELkMuIHN0eWxlPSJiYWNrZ3JvdW5kLWFtb25nIG90aGVyIHRoaW5ncyxvcmdhbml6YXRpb24gb2YgdGhlcGFydGljaXBhdGVkIGluIHRoZXRoZSBpbnRyb2R1Y3Rpb24gb2ZpZGVudGlmaWVkIHdpdGggdGhlZmljdGlvbmFsIGNoYXJhY3RlciBPeGZvcmQgVW5pdmVyc2l0eSBtaXN1bmRlcnN0YW5kaW5nIG9mVGhlcmUgYXJlLCBob3dldmVyLHN0eWxlc2hlZXQiIGhyZWY9Ii9Db2x1bWJpYSBVbml2ZXJzaXR5ZXhwYW5kZWQgdG8gaW5jbHVkZXVzdWFsbHkgcmVmZXJyZWQgdG9pbmRpY2F0aW5nIHRoYXQgdGhlaGF2ZSBzdWdnZXN0ZWQgdGhhdGFmZmlsaWF0ZWQgd2l0aCB0aGVjb3JyZWxhdGlvbiBiZXR3ZWVubnVtYmVyIG9mIGRpZmZlcmVudD48L3RkPjwvdHI+PC90YWJsZT5SZXB1YmxpYyBvZiBJcmVsYW5kCjwvc2NyaXB0Pgo8c2NyaXB0IHVuZGVyIHRoZSBpbmZsdWVuY2Vjb250cmlidXRpb24gdG8gdGhlT2ZmaWNpYWwgd2Vic2l0ZSBvZmhlYWRxdWFydGVycyBvZiB0aGVjZW50ZXJlZCBhcm91bmQgdGhlaW1wbGljYXRpb25zIG9mIHRoZWhhdmUgYmVlbiBkZXZlbG9wZWRGZWRlcmFsIFJlcHVibGljIG9mYmVjYW1lIGluY3JlYXNpbmdseWNvbnRpbnVhdGlvbiBvZiB0aGVOb3RlLCBob3dldmVyLCB0aGF0c2ltaWxhciB0byB0aGF0IG9mIGNhcGFiaWxpdGllcyBvZiB0aGVhY2NvcmRhbmNlIHdpdGggdGhlcGFydGljaXBhbnRzIGluIHRoZWZ1cnRoZXIgZGV2ZWxvcG1lbnR1bmRlciB0aGUgZGlyZWN0aW9uaXMgb2Z0ZW4gY29uc2lkZXJlZGhpcyB5b3VuZ2VyIGJyb3RoZXI8L3RkPjwvdHI+PC90YWJsZT48YSBodHRwLWVxdWl2PSJYLVVBLXBoeXNpY2FsIHByb3BlcnRpZXNvZiBCcml0aXNoIENvbHVtYmlhaGFzIGJlZW4gY3JpdGljaXplZCh3aXRoIHRoZSBleGNlcHRpb25xdWVzdGlvbnMgYWJvdXQgdGhlcGFzc2luZyB0aHJvdWdoIHRoZTAiIGNlbGxwYWRkaW5nPSIwIiB0aG91c2FuZHMgb2YgcGVvcGxlcmVkaXJlY3RzIGhlcmUuIEZvcmhhdmUgY2hpbGRyZW4gdW5kZXIlM0UlM0Mvc2NyaXB0JTNFIikpOzxhIGhyZWY9Imh0dHA6Ly93d3cuPGxpPjxhIGhyZWY9Imh0dHA6Ly9zaXRlX25hbWUiIGNvbnRlbnQ9InRleHQtZGVjb3JhdGlvbjpub25lc3R5bGU9ImRpc3BsYXk6IG5vbmU8bWV0YSBodHRwLWVxdWl2PSJYLW5ldyBEYXRlKCkuZ2V0VGltZSgpIHR5cGU9ImltYWdlL3gtaWNvbiI8L3NwYW4+PHNwYW4gY2xhc3M9Imxhbmd1YWdlPSJqYXZhc2NyaXB0d2luZG93LmxvY2F0aW9uLmhyZWY8YSBocmVmPSJqYXZhc2NyaXB0Oi0tPg0KPHNjcmlwdCB0eXBlPSJ0PGEgaHJlZj0naHR0cDovL3d3dy5ob3J0Y3V0IGljb24iIGhyZWY9IjwvZGl2Pg0KPGRpdiBjbGFzcz0iPHNjcmlwdCBzcmM9Imh0dHA6Ly8iIHJlbD0ic3R5bGVzaGVldCIgdDwvZGl2Pgo8c2NyaXB0IHR5cGU9L2E+IDxhIGhyZWY9Imh0dHA6Ly8gYWxsb3dUcmFuc3BhcmVuY3k9IlgtVUEtQ29tcGF0aWJsZSIgY29ucmVsYXRpb25zaGlwIGJldHdlZW4KPC9zY3JpcHQ+DQo8c2NyaXB0IDwvYT48L2xpPjwvdWw+PC9kaXY+YXNzb2NpYXRlZCB3aXRoIHRoZSBwcm9ncmFtbWluZyBsYW5ndWFnZTwvYT48YSBocmVmPSJodHRwOi8vPC9hPjwvbGk+PGxpIGNsYXNzPSJmb3JtIGFjdGlvbj0iaHR0cDovLzxkaXYgc3R5bGU9ImRpc3BsYXk6dHlwZT0idGV4dCIgbmFtZT0icSI8dGFibGUgd2lkdGg9IjEwMCUiIGJhY2tncm91bmQtcG9zaXRpb246IiBib3JkZXI9IjAiIHdpZHRoPSJyZWw9InNob3J0Y3V0IGljb24iIGg2Pjx1bD48bGk+PGEgaHJlZj0iICA8bWV0YSBodHRwLWVxdWl2PSJjc3MiIG1lZGlhPSJzY3JlZW4iIHJlc3BvbnNpYmxlIGZvciB0aGUgIiB0eXBlPSJhcHBsaWNhdGlvbi8iIHN0eWxlPSJiYWNrZ3JvdW5kLWh0bWw7IGNoYXJzZXQ9dXRmLTgiIGFsbG93dHJhbnNwYXJlbmN5PSJzdHlsZXNoZWV0IiB0eXBlPSJ0ZQ0KPG1ldGEgaHR0cC1lcXVpdj0iPjwvc3Bhbj48c3BhbiBjbGFzcz0iMCIgY2VsbHNwYWNpbmc9IjAiPjsKPC9zY3JpcHQ+CjxzY3JpcHQgc29tZXRpbWVzIGNhbGxlZCB0aGVkb2VzIG5vdCBuZWNlc3NhcmlseUZvciBtb3JlIGluZm9ybWF0aW9uYXQgdGhlIGJlZ2lubmluZyBvZiA8IURPQ1RZUEUgaHRtbD48aHRtbHBhcnRpY3VsYXJseSBpbiB0aGUgdHlwZT0iaGlkZGVuIiBuYW1lPSJqYXZhc2NyaXB0OnZvaWQoMCk7ImVmZmVjdGl2ZW5lc3Mgb2YgdGhlIGF1dG9jb21wbGV0ZT0ib2ZmIiBnZW5lcmFsbHkgY29uc2lkZXJlZD48aW5wdXQgdHlwZT0idGV4dCIgIj48L3NjcmlwdD4NCjxzY3JpcHR0aHJvdWdob3V0IHRoZSB3b3JsZGNvbW1vbiBtaXNjb25jZXB0aW9uYXNzb2NpYXRpb24gd2l0aCB0aGU8L2Rpdj4KPC9kaXY+CjxkaXYgY2R1cmluZyBoaXMgbGlmZXRpbWUsY29ycmVzcG9uZGluZyB0byB0aGV0eXBlPSJpbWFnZS94LWljb24iIGFuIGluY3JlYXNpbmcgbnVtYmVyZGlwbG9tYXRpYyByZWxhdGlvbnNhcmUgb2Z0ZW4gY29uc2lkZXJlZG1ldGEgY2hhcnNldD0idXRmLTgiIDxpbnB1dCB0eXBlPSJ0ZXh0IiBleGFtcGxlcyBpbmNsdWRlIHRoZSI+PGltZyBzcmM9Imh0dHA6Ly9pcGFydGljaXBhdGlvbiBpbiB0aGV0aGUgZXN0YWJsaXNobWVudCBvZgo8L2Rpdj4KPGRpdiBjbGFzcz0iJmFtcDtuYnNwOyZhbXA7bmJzcDt0byBkZXRlcm1pbmUgd2hldGhlcnF1aXRlIGRpZmZlcmVudCBmcm9tbWFya2VkIHRoZSBiZWdpbm5pbmdkaXN0YW5jZSBiZXR3ZWVuIHRoZWNvbnRyaWJ1dGlvbnMgdG8gdGhlY29uZmxpY3QgYmV0d2VlbiB0aGV3aWRlbHkgY29uc2lkZXJlZCB0b3dhcyBvbmUgb2YgdGhlIGZpcnN0d2l0aCB2YXJ5aW5nIGRlZ3JlZXNoYXZlIHNwZWN1bGF0ZWQgdGhhdChkb2N1bWVudC5nZXRFbGVtZW50cGFydGljaXBhdGluZyBpbiB0aGVvcmlnaW5hbGx5IGRldmVsb3BlZGV0YSBjaGFyc2V0PSJ1dGYtOCI+IHR5cGU9InRleHQvY3NzIiAvPgppbnRlcmNoYW5nZWFibHkgd2l0aG1vcmUgY2xvc2VseSByZWxhdGVkc29jaWFsIGFuZCBwb2xpdGljYWx0aGF0IHdvdWxkIG90aGVyd2lzZXBlcnBlbmRpY3VsYXIgdG8gdGhlc3R5bGUgdHlwZT0idGV4dC9jc3N0eXBlPSJzdWJtaXQiIG5hbWU9ImZhbWlsaWVzIHJlc2lkaW5nIGluZGV2ZWxvcGluZyBjb3VudHJpZXNjb21wdXRlciBwcm9ncmFtbWluZ2Vjb25vbWljIGRldmVsb3BtZW50ZGV0ZXJtaW5hdGlvbiBvZiB0aGVmb3IgbW9yZSBpbmZvcm1hdGlvbm9uIHNldmVyYWwgb2NjYXNpb25zcG9ydHVndcOqcyAoRXVyb3BldSnQo9C60YDQsNGX0L3RgdGM0LrQsNGD0LrRgNCw0ZfQvdGB0YzQutCw0KDQvtGB0YHQuNC50YHQutC+0LnQvNCw0YLQtdGA0LjQsNC70L7QstC40L3RhNC+0YDQvNCw0YbQuNC40YPQv9GA0LDQstC70LXQvdC40Y/QvdC10L7QsdGF0L7QtNC40LzQvtC40L3RhNC+0YDQvNCw0YbQuNGP0JjQvdGE0L7RgNC80LDRhtC40Y/QoNC10YHQv9GD0LHQu9C40LrQuNC60L7Qu9C40YfQtdGB0YLQstC+0LjQvdGE0L7RgNC80LDRhtC40Y7RgtC10YDRgNC40YLQvtGA0LjQuNC00L7RgdGC0LDRgtC+0YfQvdC+2KfZhNmF2KrZiNin2KzYr9mI2YbYp9mE2KfYtNiq2LHYp9mD2KfYqtin2YTYp9mC2KrYsdin2K3Yp9iqaHRtbDsgY2hhcnNldD1VVEYtOCIgc2V0VGltZW91dChmdW5jdGlvbigpZGlzcGxheTppbmxpbmUtYmxvY2s7PGlucHV0IHR5cGU9InN1Ym1pdCIgdHlwZSA9ICd0ZXh0L2phdmFzY3JpPGltZyBzcmM9Imh0dHA6Ly93d3cuIiAiaHR0cDovL3d3dy53My5vcmcvc2hvcnRjdXQgaWNvbiIgaHJlZj0iIiBhdXRvY29tcGxldGU9Im9mZiIgPC9hPjwvZGl2PjxkaXYgY2xhc3M9PC9hPjwvbGk+CjxsaSBjbGFzcz0iY3NzIiB0eXBlPSJ0ZXh0L2NzcyIgPGZvcm0gYWN0aW9uPSJodHRwOi8veHQvY3NzIiBocmVmPSJodHRwOi8vbGluayByZWw9ImFsdGVybmF0ZSIgDQo8c2NyaXB0IHR5cGU9InRleHQvIG9uY2xpY2s9ImphdmFzY3JpcHQ6KG5ldyBEYXRlKS5nZXRUaW1lKCl9aGVpZ2h0PSIxIiB3aWR0aD0iMSIgUGVvcGxlJ3MgUmVwdWJsaWMgb2YgIDxhIGhyZWY9Imh0dHA6Ly93d3cudGV4dC1kZWNvcmF0aW9uOnVuZGVydGhlIGJlZ2lubmluZyBvZiB0aGUgPC9kaXY+CjwvZGl2Pgo8L2Rpdj4KZXN0YWJsaXNobWVudCBvZiB0aGUgPC9kaXY+PC9kaXY+PC9kaXY+PC9kI3ZpZXdwb3J0e21pbi1oZWlnaHQ6CjxzY3JpcHQgc3JjPSJodHRwOi8vb3B0aW9uPjxvcHRpb24gdmFsdWU9b2Z0ZW4gcmVmZXJyZWQgdG8gYXMgL29wdGlvbj4KPG9wdGlvbiB2YWx1PCFET0NUWVBFIGh0bWw+CjwhLS1bSW50ZXJuYXRpb25hbCBBaXJwb3J0Pgo8YSBocmVmPSJodHRwOi8vd3d3PC9hPjxhIGhyZWY9Imh0dHA6Ly934Lig4Liy4Lip4Liy4LmE4LiX4Lii4YOl4YOQ4YOg4YOX4YOj4YOa4YOY5q2j6auU5Lit5paHICjnuYHpq5Qp4KSo4KS/4KSw4KWN4KSm4KWH4KS24KSh4KS+4KSJ4KSo4KSy4KWL4KSh4KSV4KWN4KS34KWH4KSk4KWN4KSw4KSc4KS+4KSo4KSV4KS+4KSw4KWA4KS44KSC4KSs4KSC4KSn4KS/4KSk4KS44KWN4KSl4KS+4KSq4KSo4KS+4KS44KWN4KS14KWA4KSV4KS+4KSw4KS44KSC4KS44KWN4KSV4KSw4KSj4KS44KS+4KSu4KSX4KWN4KSw4KWA4KSa4KS/4KSf4KWN4KSg4KWL4KSC4KS14KS/4KSc4KWN4KSe4KS+4KSo4KSF4KSu4KWH4KSw4KS/4KSV4KS+4KS14KS/4KSt4KS/4KSo4KWN4KSo4KSX4KS+4KSh4KS/4KSv4KS+4KSB4KSV4KWN4KSv4KWL4KSC4KSV4KS/4KS44KWB4KSw4KSV4KWN4KS34KS+4KSq4KS54KWB4KSB4KSa4KSk4KWA4KSq4KWN4KSw4KSs4KSC4KSn4KSo4KSf4KS/4KSq4KWN4KSq4KSj4KWA4KSV4KWN4KSw4KS/4KSV4KWH4KSf4KSq4KWN4KSw4KS+4KSw4KSC4KSt4KSq4KWN4KSw4KS+4KSq4KWN4KSk4KSu4KS+4KSy4KS/4KSV4KWL4KSC4KSw4KSr4KS84KWN4KSk4KS+4KSw4KSo4KS/4KSw4KWN4KSu4KS+4KSj4KSy4KS/4KSu4KS/4KSf4KWH4KShZGVzY3JpcHRpb24iIGNvbnRlbnQ9ImRvY3VtZW50LmxvY2F0aW9uLnByb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoPCFET0NUWVBFIGh0bWw+CjxodG1sIDxtZXRhIGNoYXJzZXQ9InV0Zi04Ij46dXJsIiBjb250ZW50PSJodHRwOi8vLmNzcyIgcmVsPSJzdHlsZXNoZWV0InN0eWxlIHR5cGU9InRleHQvY3NzIj50eXBlPSJ0ZXh0L2NzcyIgaHJlZj0idzMub3JnLzE5OTkveGh0bWwiIHhtbHR5cGU9InRleHQvamF2YXNjcmlwdCIgbWV0aG9kPSJnZXQiIGFjdGlvbj0ibGluayByZWw9InN0eWxlc2hlZXQiICA9IGRvY3VtZW50LmdldEVsZW1lbnR0eXBlPSJpbWFnZS94LWljb24iIC8+Y2VsbHBhZGRpbmc9IjAiIGNlbGxzcC5jc3MiIHR5cGU9InRleHQvY3NzIiA8L2E+PC9saT48bGk+PGEgaHJlZj0iIiB3aWR0aD0iMSIgaGVpZ2h0PSIxIiI+PGEgaHJlZj0iaHR0cDovL3d3dy5zdHlsZT0iZGlzcGxheTpub25lOyI+YWx0ZXJuYXRlIiB0eXBlPSJhcHBsaS0vL1czQy8vRFREIFhIVE1MIDEuMCBlbGxzcGFjaW5nPSIwIiBjZWxscGFkIHR5cGU9ImhpZGRlbiIgdmFsdWU9Ii9hPiZuYnNwOzxzcGFuIHJvbGU9InMKPGlucHV0IHR5cGU9ImhpZGRlbiIgbGFuZ3VhZ2U9IkphdmFTY3JpcHQiICBkb2N1bWVudC5nZXRFbGVtZW50c0JnPSIwIiBjZWxsc3BhY2luZz0iMCIgeXBlPSJ0ZXh0L2NzcyIgbWVkaWE9InR5cGU9J3RleHQvamF2YXNjcmlwdCd3aXRoIHRoZSBleGNlcHRpb24gb2YgeXBlPSJ0ZXh0L2NzcyIgcmVsPSJzdCBoZWlnaHQ9IjEiIHdpZHRoPSIxIiA9JytlbmNvZGVVUklDb21wb25lbnQoPGxpbmsgcmVsPSJhbHRlcm5hdGUiIApib2R5LCB0ciwgaW5wdXQsIHRleHRtZXRhIG5hbWU9InJvYm90cyIgY29ubWV0aG9kPSJwb3N0IiBhY3Rpb249Ij4KPGEgaHJlZj0iaHR0cDovL3d3dy5jc3MiIHJlbD0ic3R5bGVzaGVldCIgPC9kaXY+PC9kaXY+PGRpdiBjbGFzc2xhbmd1YWdlPSJqYXZhc2NyaXB0Ij5hcmlhLWhpZGRlbj0idHJ1ZSI+wrc8cmlwdCIgdHlwZT0idGV4dC9qYXZhc2w9MDt9KSgpOwooZnVuY3Rpb24oKXtiYWNrZ3JvdW5kLWltYWdlOiB1cmwoL2E+PC9saT48bGk+PGEgaHJlZj0iaAkJPGxpPjxhIGhyZWY9Imh0dHA6Ly9hdG9yIiBhcmlhLWhpZGRlbj0idHJ1PiA8YSBocmVmPSJodHRwOi8vd3d3Lmxhbmd1YWdlPSJqYXZhc2NyaXB0IiAvb3B0aW9uPgo8b3B0aW9uIHZhbHVlL2Rpdj48L2Rpdj48ZGl2IGNsYXNzPXJhdG9yIiBhcmlhLWhpZGRlbj0idHJlPShuZXcgRGF0ZSkuZ2V0VGltZSgpcG9ydHVndcOqcyAoZG8gQnJhc2lsKdC+0YDQs9Cw0L3QuNC30LDRhtC40LjQstC+0LfQvNC+0LbQvdC+0YHRgtGM0L7QsdGA0LDQt9C+0LLQsNC90LjRj9GA0LXQs9C40YHRgtGA0LDRhtC40LjQstC+0LfQvNC+0LbQvdC+0YHRgtC40L7QsdGP0LfQsNGC0LXQu9GM0L3QsDwhRE9DVFlQRSBodG1sIFBVQkxJQyAibnQtVHlwZSIgY29udGVudD0idGV4dC88bWV0YSBodHRwLWVxdWl2PSJDb250ZXJhbnNpdGlvbmFsLy9FTiIgImh0dHA6PGh0bWwgeG1sbnM9Imh0dHA6Ly93d3ctLy9XM0MvL0RURCBYSFRNTCAxLjAgVERURC94aHRtbDEtdHJhbnNpdGlvbmFsLy93d3cudzMub3JnL1RSL3hodG1sMS9wZSA9ICd0ZXh0L2phdmFzY3JpcHQnOzxtZXRhIG5hbWU9ImRlc2NyaXB0aW9ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmU8aW5wdXQgdHlwZT0iaGlkZGVuIiBuYWpzIiB0eXBlPSJ0ZXh0L2phdmFzY3JpKGRvY3VtZW50KS5yZWFkeShmdW5jdGlzY3JpcHQgdHlwZT0idGV4dC9qYXZhc2ltYWdlIiBjb250ZW50PSJodHRwOi8vVUEtQ29tcGF0aWJsZSIgY29udGVudD10bWw7IGNoYXJzZXQ9dXRmLTgiIC8+CmxpbmsgcmVsPSJzaG9ydGN1dCBpY29uPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiA8L3NjcmlwdD4KPHNjcmlwdCB0eXBlPT0gZG9jdW1lbnQuY3JlYXRlRWxlbWVuPGEgdGFyZ2V0PSJfYmxhbmsiIGhyZWY9IGRvY3VtZW50LmdldEVsZW1lbnRzQmlucHV0IHR5cGU9InRleHQiIG5hbWU9YS50eXBlID0gJ3RleHQvamF2YXNjcmlucHV0IHR5cGU9ImhpZGRlbiIgbmFtZWh0bWw7IGNoYXJzZXQ9dXRmLTgiIC8+ZHRkIj4KPGh0bWwgeG1sbnM9Imh0dHAtLy9XM0MvL0RURCBIVE1MIDQuMDEgVGVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpaW5wdXQgdHlwZT0iaGlkZGVuIiBuYW08c2NyaXB0IHR5cGU9InRleHQvamF2YXMiIHN0eWxlPSJkaXNwbGF5Om5vbmU7Ij5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnIHR5cGU9J3RleHQvamF2YXNjcmlwdCdpbnB1dCB0eXBlPSJ0ZXh0IiBuYW1lPSJkLmdldEVsZW1lbnRzQnlUYWdOYW1lKHNuaWNhbCIgaHJlZj0iaHR0cDovL3d3dy5DLy9EVEQgSFRNTCA0LjAxIFRyYW5zaXQ8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoKPHN0eWxlIHR5cGU9InRleHQvY3NzIj5pb25hbC5kdGQiPgo8aHRtbCB4bWxucz1odHRwLWVxdWl2PSJDb250ZW50LVR5cGVkaW5nPSIwIiBjZWxsc3BhY2luZz0iMCJodG1sOyBjaGFyc2V0PXV0Zi04IiAvPgogc3R5bGU9ImRpc3BsYXk6bm9uZTsiPjw8bGk+PGEgaHJlZj0iaHR0cDovL3d3dy4gdHlwZT0ndGV4dC9qYXZhc2NyaXB0Jz7QtNC10Y/RgtC10LvRjNC90L7RgdGC0LjRgdC+0L7RgtCy0LXRgtGB0YLQstC40LjQv9GA0L7QuNC30LLQvtC00YHRgtCy0LDQsdC10LfQvtC/0LDRgdC90L7RgdGC0LjgpKrgpYHgpLjgpY3gpKTgpL/gpJXgpL7gpJXgpL7gpILgpJfgpY3gpLDgpYfgpLjgpIngpKjgpY3gpLngpYvgpILgpKjgpYfgpLXgpL/gpKfgpL7gpKjgpLjgpK3gpL7gpKvgpL/gpJXgpY3gpLjgpL/gpILgpJfgpLjgpYHgpLDgpJXgpY3gpLfgpL/gpKTgpJXgpYngpKrgpYDgpLDgpL7gpIfgpJ/gpLXgpL/gpJzgpY3gpJ7gpL7gpKrgpKjgpJXgpL7gpLDgpY3gpLDgpLXgpL7gpIjgpLjgpJXgpY3gpLDgpL/gpK/gpKTgpL5SCgAAAAAAAFIKAABSCgAAAAAAAPIIAADyCAAAAAAAAPIIAABSCgAADAAAAFIKAABSCgAACgAAAPIIAABSCgAAAAAAANMIAADyCAAAAAAAAFIKAACJCAAAAAAAAPIIAABSCgAAAAAAAMEIAABSCgAACgAAAFIKAABSCgAAAAAAAOAIAABSCgAADQAAAFIKAABSCgAAAQAAAFIKAADxCAAAAAAAAPIIAABSCgAAAAAAAPEIAADyCAAACgAAAPIIAABSCgAAAAAAAKAIAABSCgAAAAAAAJYIAADdCAAAAAAAAPIIAABSCgAAAAAAAE0IAABSCgAAAAAAADwIAABSCgAAAAAAACIIAABSCgAAAAAAAE4KAABSCgAAAwAAAFIKAABSCgAAAAAAAH0FAABSCgAAAAAAAIwIAABSCgAADgAAAFIKAABSCgAAAgAAAFIKAABSCgAAAAAAAOoIAABSCgAAAAAAAGMIAADyCAAACgAAAFIKAABSCgAAAAAAAO4IAAA8CAAAAAAAAFIKAADyCAAAAAAAAPEIAABSCgAADwAAAFIKAABSCgAAAAAAALUIAABSCgAAAAAAAEoIAABSCgAAAAAAAKUIAABSCgAAAAAAAFMIAABSCgAAEAAAAFIKAABSCgAAEQAAAFIKAADTCAAAAAAAAFIKAABSCgAABAAAAFIKAABSCgAAAAAAANkIAABSCgAACwAAAFIKAABSCgAAAAAAAJsIAABSCgAAAAAAAIcIAABSCgAAAAAAAIIIAABSCgAABwAAAFIKAABSCgAAAQAAALwIAABSCgAAAAAAAFAKAABSCgAAAAAAACUIAADyCAAAAAAAAO4IAABSCgAAAAAAAOYIAABSCgAAFAAAAFIKAABSCgAAEgAAAFIKAABSCgAABgAAAFIKAABSCgAAAAAAAEcIAABSCgAACgAAAPEIAABSCgAACAAAAFIKAABSCgAAAAAAAGoIAABSCgAAAAAAAE8IAADTCAAAAAAAAMEIAABSCgAABQAAAFIKAABSCgAACQAAAFIKAADyCAAACgAAAPEIAABSCgAACgAAAE0IAAA8CAAAAAAAAEcIAABSCgAACwAAAPIIAABSCgAACgAAACIIAABSCgAAAAAAAEwIAADyCAAAAAAAADwIAAA2CAAAAAAAAFIKAADTCAAAAAAAANAIAABSCgAACgAAAEoIAABSCgAAAAAAAHoIAABSCgAAAAAAAD4IAAA8CAAAAAAAAPIIAABSCgAACgAAAEcIAABSCgAACgAAADwIAABSCgAAAAAAAF0IAADyCAAAAAAAAEwIAABSCgAAAAAAAJIIAADyCAAACwAAAPIIAABSCgAAAAAAALEIAADyCAAACwAAAFIKAABSCgAAAAAAAEkIAABSCgAACwAAAE0IAABSCgAACgAAAO4IAADyCAAAAAAAAEcIAABSCgAAAAAAAKwIAADyCAAACgAAAO4IAABSCgAAAAAAAMsIAABSCgAAAAAAAHQIAABSCgAA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";
    }
  });

  // dist/wasm-0jzfuaTN.mjs
  var wasm_0jzfuaTN_exports = {};
  __export(wasm_0jzfuaTN_exports, {
    initWasmBrowser: () => initWasmBrowser,
    ttf2woff2: () => ttf2woff2
  });
  function updateMemoryViews() {
    const b2 = wasmMemory.buffer;
    Module.HEAP8 = HEAP8 = new Int8Array(b2);
    Module.HEAP16 = HEAP16 = new Int16Array(b2);
    Module.HEAPU8 = HEAPU8 = new Uint8Array(b2);
    Module.HEAPU16 = HEAPU16 = new Uint16Array(b2);
    Module.HEAP32 = HEAP32 = new Int32Array(b2);
    Module.HEAPU32 = HEAPU32 = new Uint32Array(b2);
    Module.HEAPF32 = HEAPF32 = new Float32Array(b2);
    Module.HEAPF64 = HEAPF64 = new Float64Array(b2);
  }
  function preRun() {
    if (Module.preRun) {
      if (typeof Module.preRun == "function") Module.preRun = [Module.preRun];
      while (Module.preRun.length) addOnPreRun(Module.preRun.shift());
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    callRuntimeCallbacks(__ATINIT__);
  }
  function postRun() {
    if (Module.postRun) {
      if (typeof Module.postRun == "function") Module.postRun = [Module.postRun];
      while (Module.postRun.length) addOnPostRun(Module.postRun.shift());
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  function addRunDependency(id) {
    runDependencies++;
    Module.monitorRunDependencies?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module.monitorRunDependencies?.(runDependencies);
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        const callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module.onAbort?.(what);
    what = `Aborted(${what})`;
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    const e2 = new WebAssembly.RuntimeError(what);
    throw e2;
  }
  function getWasmImports() {
    return {
      env: wasmImports,
      wasi_snapshot_preview1: wasmImports,
      memory: new WebAssembly.Memory({
        initial: 10,
        maximum: 100
      })
    };
  }
  async function loadWasmModule(info) {
    if (Module.wasmExports) return [Module.wasmExports, void 0];
    try {
      const response = await wasmPromise();
      if (!response) throw new Error("no response when fetching WASM file");
      if (!response.ok) throw new Error(`error fetching WASM file: ${response.status} ${response.statusText}`);
      const { instance, module } = await WebAssembly.instantiateStreaming(response, info);
      console.log("WebAssembly module successfully loaded and instantiated.");
      console.log("WASM Instance:", instance);
      return [instance, module];
    } catch (error) {
      console.error("Error loading or instantiating the WebAssembly module:", error);
      throw error;
    }
  }
  async function createWasm() {
    const info = getWasmImports();
    function receiveInstance(instance, module) {
      wasmExports = instance.exports;
      wasmMemory = wasmExports.memory;
      updateMemoryViews();
      wasmTable = wasmExports.__indirect_function_table;
      addOnInit(wasmExports.__wasm_call_ctors);
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    const result = await loadWasmModule(info);
    return receiveInstance(result[0]);
  }
  function getValue(ptr, type = "i8") {
    if (type.endsWith("*")) type = "*";
    switch (type) {
      case "i1":
        return HEAP8[ptr];
      case "i8":
        return HEAP8[ptr];
      case "i16":
        return HEAP16[ptr >> 1];
      case "i32":
        return HEAP32[ptr >> 2];
      case "i64":
        abort("to do getValue(i64) use WASM_BIGINT");
      case "float":
        return HEAPF32[ptr >> 2];
      case "double":
        return HEAPF64[ptr >> 3];
      case "*":
        return HEAPU32[ptr >> 2];
      default:
        abort(`invalid type for getValue: ${type}`);
    }
  }
  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
    const endIdx = idx + maxBytesToRead;
    let endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    let str = "";
    while (idx < endPtr) {
      let u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      const u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      const u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      else u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      if (u0 < 65536) str += String.fromCharCode(u0);
      else {
        const ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  }
  function ___assert_fail(condition, filename, line, func) {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ${[
      filename ? UTF8ToString(filename) : "unknown filename",
      line,
      func ? UTF8ToString(func) : "unknown function"
    ]}`);
  }
  function ___cxa_throw(ptr, type, destructor) {
    const info = new ExceptionInfo(ptr);
    info.init(type, destructor);
    exceptionLast = ptr;
    uncaughtExceptionCount++;
    throw exceptionLast;
  }
  function __abort_js() {
    abort("");
  }
  function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {
  }
  function embind_init_charCodes() {
    const codes = Array.from({ length: 256 });
    for (let i2 = 0; i2 < 256; ++i2) codes[i2] = String.fromCharCode(i2);
    embind_charCodes = codes;
  }
  function readLatin1String(ptr) {
    let ret = "";
    let c = ptr;
    while (HEAPU8[c]) ret += embind_charCodes[HEAPU8[c++]];
    return ret;
  }
  function throwBindingError(message) {
    throw new BindingError(message);
  }
  function throwInternalError(message) {
    throw new InternalError(message);
  }
  function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
    myTypes.forEach((type) => {
      typeDependencies[type] = dependentTypes;
    });
    function onComplete(typeConverters$1) {
      const myTypeConverters = getTypeConverters(typeConverters$1);
      if (myTypeConverters.length !== myTypes.length) throwInternalError("Mismatched type converter count");
      for (let i2 = 0; i2 < myTypes.length; ++i2) registerType(myTypes[i2], myTypeConverters[i2]);
    }
    const typeConverters = Array.from({ length: dependentTypes.length });
    const unregisteredTypes = [];
    let registered = 0;
    dependentTypes.forEach((dt, i2) => {
      if (registeredTypes.hasOwnProperty(dt)) typeConverters[i2] = registeredTypes[dt];
      else {
        unregisteredTypes.push(dt);
        if (!awaitingDependencies.hasOwnProperty(dt)) awaitingDependencies[dt] = [];
        awaitingDependencies[dt].push(() => {
          typeConverters[i2] = registeredTypes[dt];
          ++registered;
          if (registered === unregisteredTypes.length) onComplete(typeConverters);
        });
      }
    });
    if (unregisteredTypes.length === 0) onComplete(typeConverters);
  }
  function sharedRegisterType(rawType, registeredInstance, options = {}) {
    const name = registeredInstance.name;
    if (!rawType) throwBindingError(`type "${name}" must have a positive integer typeid pointer`);
    if (registeredTypes.hasOwnProperty(rawType)) if (options.ignoreDuplicateRegistrations) return;
    else throwBindingError(`Cannot register type '${name}' twice`);
    registeredTypes[rawType] = registeredInstance;
    delete typeDependencies[rawType];
    if (awaitingDependencies.hasOwnProperty(rawType)) {
      const callbacks = awaitingDependencies[rawType];
      delete awaitingDependencies[rawType];
      callbacks.forEach((cb) => cb());
    }
  }
  function registerType(rawType, registeredInstance, options = {}) {
    if (!("argPackAdvance" in registeredInstance)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
    return sharedRegisterType(rawType, registeredInstance, options);
  }
  function __embind_register_bool(rawType, name, trueValue, falseValue) {
    name = readLatin1String(name);
    registerType(rawType, {
      name,
      fromWireType(wt) {
        return !!wt;
      },
      toWireType(destructors, o2) {
        return o2 ? trueValue : falseValue;
      },
      argPackAdvance: GenericWireTypeSize,
      readValueFromPointer(pointer) {
        return this.fromWireType(HEAPU8[pointer]);
      },
      destructorFunction: null
    });
  }
  function __emval_decref(handle) {
    if (handle > 9 && --emval_handles[handle + 1] === 0) {
      emval_handles[handle] = void 0;
      emval_freelist.push(handle);
    }
  }
  function init_emval() {
    emval_handles.push(0, 1, void 0, 1, null, 1, true, 1, false, 1);
    Module.count_emval_handles = count_emval_handles;
  }
  function readPointer(pointer) {
    return this.fromWireType(HEAPU32[pointer >> 2]);
  }
  function floatReadValueFromPointer(name, width) {
    switch (width) {
      case 4:
        return function(pointer) {
          return this.fromWireType(HEAPF32[pointer >> 2]);
        };
      case 8:
        return function(pointer) {
          return this.fromWireType(HEAPF64[pointer >> 3]);
        };
      default:
        throw new TypeError(`invalid float width (${width}): ${name}`);
    }
  }
  function __embind_register_float(rawType, name, size) {
    name = readLatin1String(name);
    registerType(rawType, {
      name,
      fromWireType: (value) => value,
      toWireType: (destructors, value) => value,
      argPackAdvance: GenericWireTypeSize,
      readValueFromPointer: floatReadValueFromPointer(name, size),
      destructorFunction: null
    });
  }
  function runDestructors(destructors) {
    while (destructors.length) {
      const ptr = destructors.pop();
      const del = destructors.pop();
      del(ptr);
    }
  }
  function usesDestructorStack(argTypes) {
    for (let i2 = 1; i2 < argTypes.length; ++i2) if (argTypes[i2] !== null && argTypes[i2].destructorFunction === void 0) return true;
    return false;
  }
  function newFunc(constructor, argumentList) {
    if (!(typeof constructor === "function")) throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`);
    const dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
    });
    dummy.prototype = constructor.prototype;
    const obj = new dummy();
    const r2 = constructor.apply(obj, argumentList);
    return r2 instanceof Object ? r2 : obj;
  }
  function createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {
    const needsDestructorStack = usesDestructorStack(argTypes);
    const argCount = argTypes.length;
    let argsList = "";
    let argsListWired = "";
    for (var i2 = 0; i2 < argCount - 2; ++i2) {
      argsList += `${i2 !== 0 ? ", " : ""}arg${i2}`;
      argsListWired += `${i2 !== 0 ? ", " : ""}arg${i2}Wired`;
    }
    let invokerFnBody = `
        return function (${argsList}) {
        if (arguments.length !== ${argCount - 2}) {
          throwBindingError('function ' + humanName + ' called with ' + arguments.length + ' arguments, expected ${argCount - 2}');
        }`;
    if (needsDestructorStack) invokerFnBody += "var destructors = [];\n";
    const dtorStack = needsDestructorStack ? "destructors" : "null";
    const args1 = [
      "humanName",
      "throwBindingError",
      "invoker",
      "fn",
      "runDestructors",
      "retType",
      "classParam"
    ];
    if (isClassMethodFunc) invokerFnBody += `var thisWired = classParam['toWireType'](${dtorStack}, this);
`;
    for (var i2 = 0; i2 < argCount - 2; ++i2) {
      invokerFnBody += `var arg${i2}Wired = argType${i2}['toWireType'](${dtorStack}, arg${i2});
`;
      args1.push(`argType${i2}`);
    }
    if (isClassMethodFunc) argsListWired = `thisWired${argsListWired.length > 0 ? ", " : ""}${argsListWired}`;
    invokerFnBody += `${returns || isAsync ? "var rv = " : ""}invoker(fn${argsListWired.length > 0 ? ", " : ""}${argsListWired});
`;
    if (needsDestructorStack) invokerFnBody += "runDestructors(destructors);\n";
    else for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; ++i2) {
      const paramName = i2 === 1 ? "thisWired" : `arg${i2 - 2}Wired`;
      if (argTypes[i2].destructorFunction !== null) {
        invokerFnBody += `${paramName}_dtor(${paramName});
`;
        args1.push(`${paramName}_dtor`);
      }
    }
    if (returns) invokerFnBody += "var ret = retType['fromWireType'](rv);\nreturn ret;\n";
    invokerFnBody += "}\n";
    return [args1, invokerFnBody];
  }
  function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {
    const argCount = argTypes.length;
    if (argCount < 2) throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
    const isClassMethodFunc = argTypes[1] !== null && classType !== null;
    const needsDestructorStack = usesDestructorStack(argTypes);
    const returns = argTypes[0].name !== "void";
    const closureArgs = [
      humanName,
      throwBindingError,
      cppInvokerFunc,
      cppTargetFunc,
      runDestructors,
      argTypes[0],
      argTypes[1]
    ];
    for (var i2 = 0; i2 < argCount - 2; ++i2) closureArgs.push(argTypes[i2 + 2]);
    if (!needsDestructorStack) {
      for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; ++i2) if (argTypes[i2].destructorFunction !== null) closureArgs.push(argTypes[i2].destructorFunction);
    }
    const [args, invokerFnBody] = createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync);
    args.push(invokerFnBody);
    const invokerFn = newFunc(Function, args)(...closureArgs);
    return createNamedFunction(humanName, invokerFn);
  }
  function ensureOverloadTable(proto, methodName, humanName) {
    if (void 0 === proto[methodName].overloadTable) {
      const prevFunc = proto[methodName];
      proto[methodName] = function(...args) {
        if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);
        return proto[methodName].overloadTable[args.length].apply(this, args);
      };
      proto[methodName].overloadTable = [];
      proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
    }
  }
  function exposePublicSymbol(name, value, numArguments) {
    if (Module.hasOwnProperty(name)) {
      if (void 0 === numArguments || void 0 !== Module[name].overloadTable && void 0 !== Module[name].overloadTable[numArguments]) throwBindingError(`Cannot register public name '${name}' twice`);
      ensureOverloadTable(Module, name, name);
      if (Module.hasOwnProperty(numArguments)) throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
      Module[name].overloadTable[numArguments] = value;
    } else {
      Module[name] = value;
      if (void 0 !== numArguments) Module[name].numArguments = numArguments;
    }
  }
  function heap32VectorToArray(count, firstElement) {
    const array = [];
    for (let i2 = 0; i2 < count; i2++) array.push(HEAPU32[firstElement + i2 * 4 >> 2]);
    return array;
  }
  function replacePublicSymbol(name, value, numArguments) {
    if (!Module.hasOwnProperty(name)) throwInternalError("Replacing nonexistent public symbol");
    if (void 0 !== Module[name].overloadTable && void 0 !== numArguments) Module[name].overloadTable[numArguments] = value;
    else {
      Module[name] = value;
      Module[name].argCount = numArguments;
    }
  }
  function dynCallLegacy(sig, ptr, args) {
    sig = sig.replace(/p/g, "i");
    const f2 = Module[`dynCall_${sig}`];
    return f2(ptr, ...args);
  }
  function getWasmTableEntry(funcPtr) {
    let func = wasmTableMirror[funcPtr];
    if (!func) {
      if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
    }
    return func;
  }
  function dynCall(sig, ptr, args = []) {
    if (sig.includes("j")) return dynCallLegacy(sig, ptr, args);
    const rtn = getWasmTableEntry(ptr)(...args);
    return rtn;
  }
  function embind__requireFunction(signature, rawFunction) {
    signature = readLatin1String(signature);
    function makeDynCaller() {
      if (signature.includes("j")) return getDynCaller(signature, rawFunction);
      return getWasmTableEntry(rawFunction);
    }
    const fp = makeDynCaller();
    if (typeof fp != "function") throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
    return fp;
  }
  function extendError(baseErrorType, errorName) {
    const errorClass = createNamedFunction(errorName, function(message) {
      this.name = errorName;
      this.message = message;
      const stack = new Error(message).stack;
      if (stack !== void 0) this.stack = `${this.toString()}
${stack.replace(/^Error(:[^\n]*)?\n/, "")}`;
    });
    errorClass.prototype = Object.create(baseErrorType.prototype);
    errorClass.prototype.constructor = errorClass;
    errorClass.prototype.toString = function() {
      if (this.message === void 0) return this.name;
      else return `${this.name}: ${this.message}`;
    };
    return errorClass;
  }
  function getTypeName(type) {
    const ptr = ___getTypeName(type);
    const rv = readLatin1String(ptr);
    _free(ptr);
    return rv;
  }
  function throwUnboundTypeError(message, types) {
    const unboundTypes = [];
    const seen = {};
    function visit(type) {
      if (seen[type]) return;
      if (registeredTypes[type]) return;
      if (typeDependencies[type]) {
        typeDependencies[type].forEach(visit);
        return;
      }
      unboundTypes.push(type);
      seen[type] = true;
    }
    types.forEach(visit);
    throw new UnboundTypeError(`${message}: ${unboundTypes.map(getTypeName).join([", "])}`);
  }
  function getFunctionName(signature) {
    signature = signature.trim();
    const argsIndex = signature.indexOf("(");
    if (argsIndex !== -1) return signature.substr(0, argsIndex);
    else return signature;
  }
  function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync) {
    const argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
    name = readLatin1String(name);
    name = getFunctionName(name);
    rawInvoker = embind__requireFunction(signature, rawInvoker);
    exposePublicSymbol(name, () => {
      throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);
    }, argCount - 1);
    whenDependentTypesAreResolved([], argTypes, (argTypes$1) => {
      const invokerArgsArray = [argTypes$1[0], null].concat(argTypes$1.slice(1));
      replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);
      return [];
    });
  }
  function integerReadValueFromPointer(name, width, signed) {
    switch (width) {
      case 1:
        return signed ? (pointer) => HEAP8[pointer] : (pointer) => HEAPU8[pointer];
      case 2:
        return signed ? (pointer) => HEAP16[pointer >> 1] : (pointer) => HEAPU16[pointer >> 1];
      case 4:
        return signed ? (pointer) => HEAP32[pointer >> 2] : (pointer) => HEAPU32[pointer >> 2];
      default:
        throw new TypeError(`invalid integer width (${width}): ${name}`);
    }
  }
  function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
    name = readLatin1String(name);
    if (maxRange === -1) maxRange = 4294967295;
    let fromWireType = (value) => value;
    if (minRange === 0) {
      const bitshift = 32 - 8 * size;
      fromWireType = (value) => value << bitshift >>> bitshift;
    }
    const isUnsignedType = name.includes("unsigned");
    const checkAssertions = (value, toTypeName) => {
    };
    let toWireType;
    if (isUnsignedType) toWireType = function(destructors, value) {
      checkAssertions(value, this.name);
      return value >>> 0;
    };
    else toWireType = function(destructors, value) {
      checkAssertions(value, this.name);
      return value;
    };
    registerType(primitiveType, {
      name,
      fromWireType,
      toWireType,
      argPackAdvance: GenericWireTypeSize,
      readValueFromPointer: integerReadValueFromPointer(name, size, minRange !== 0),
      destructorFunction: null
    });
  }
  function __embind_register_memory_view(rawType, dataTypeIndex, name) {
    const typeMapping = [
      Int8Array,
      Uint8Array,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array
    ];
    const TA = typeMapping[dataTypeIndex];
    function decodeMemoryView(handle) {
      const size = HEAPU32[handle >> 2];
      const data = HEAPU32[handle + 4 >> 2];
      return new TA(HEAP8.buffer, data, size);
    }
    name = readLatin1String(name);
    registerType(rawType, {
      name,
      fromWireType: decodeMemoryView,
      argPackAdvance: GenericWireTypeSize,
      readValueFromPointer: decodeMemoryView
    }, { ignoreDuplicateRegistrations: true });
  }
  function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
    if (!(maxBytesToWrite > 0)) return 0;
    const startIdx = outIdx;
    const endIdx = outIdx + maxBytesToWrite - 1;
    for (let i2 = 0; i2 < str.length; ++i2) {
      let u2 = str.charCodeAt(i2);
      if (u2 >= 55296 && u2 <= 57343) {
        const u1 = str.charCodeAt(++i2);
        u2 = 65536 + ((u2 & 1023) << 10) | u1 & 1023;
      }
      if (u2 <= 127) {
        if (outIdx >= endIdx) break;
        heap[outIdx++] = u2;
      } else if (u2 <= 2047) {
        if (outIdx + 1 >= endIdx) break;
        heap[outIdx++] = 192 | u2 >> 6;
        heap[outIdx++] = 128 | u2 & 63;
      } else if (u2 <= 65535) {
        if (outIdx + 2 >= endIdx) break;
        heap[outIdx++] = 224 | u2 >> 12;
        heap[outIdx++] = 128 | u2 >> 6 & 63;
        heap[outIdx++] = 128 | u2 & 63;
      } else {
        if (outIdx + 3 >= endIdx) break;
        heap[outIdx++] = 240 | u2 >> 18;
        heap[outIdx++] = 128 | u2 >> 12 & 63;
        heap[outIdx++] = 128 | u2 >> 6 & 63;
        heap[outIdx++] = 128 | u2 & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  }
  function lengthBytesUTF8(str) {
    let len = 0;
    for (let i2 = 0; i2 < str.length; ++i2) {
      const c = str.charCodeAt(i2);
      if (c <= 127) len++;
      else if (c <= 2047) len += 2;
      else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i2;
      } else len += 3;
    }
    return len;
  }
  function __embind_register_std_string(rawType, name) {
    name = readLatin1String(name);
    const stdStringIsUTF8 = name === "std::string";
    registerType(rawType, {
      name,
      fromWireType(value) {
        const length = HEAPU32[value >> 2];
        const payload = value + 4;
        let str;
        if (stdStringIsUTF8) {
          let decodeStartPtr = payload;
          for (var i2 = 0; i2 <= length; ++i2) {
            const currentBytePtr = payload + i2;
            if (i2 == length || HEAPU8[currentBytePtr] == 0) {
              const maxRead = currentBytePtr - decodeStartPtr;
              const stringSegment = UTF8ToString(decodeStartPtr, maxRead);
              if (str === void 0) str = stringSegment;
              else {
                str += String.fromCharCode(0);
                str += stringSegment;
              }
              decodeStartPtr = currentBytePtr + 1;
            }
          }
        } else {
          const a2 = new Array(length);
          for (var i2 = 0; i2 < length; ++i2) a2[i2] = String.fromCharCode(HEAPU8[payload + i2]);
          str = a2.join("");
        }
        _free(value);
        return str;
      },
      toWireType(destructors, value) {
        if (value instanceof ArrayBuffer) value = new Uint8Array(value);
        let length;
        const valueIsOfTypeString = typeof value == "string";
        if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) throwBindingError("Cannot pass non-string to std::string");
        if (stdStringIsUTF8 && valueIsOfTypeString) length = lengthBytesUTF8(value);
        else length = value.length;
        const base = _malloc(4 + length + 1);
        const ptr = base + 4;
        HEAPU32[base >> 2] = length;
        if (stdStringIsUTF8 && valueIsOfTypeString) stringToUTF8(value, ptr, length + 1);
        else if (valueIsOfTypeString) for (var i2 = 0; i2 < length; ++i2) {
          const charCode = value.charCodeAt(i2);
          if (charCode > 255) {
            _free(ptr);
            throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
          }
          HEAPU8[ptr + i2] = charCode;
        }
        else for (var i2 = 0; i2 < length; ++i2) HEAPU8[ptr + i2] = value[i2];
        if (destructors !== null) destructors.push(_free, base);
        return base;
      },
      argPackAdvance: GenericWireTypeSize,
      readValueFromPointer: readPointer,
      destructorFunction(ptr) {
        _free(ptr);
      }
    });
  }
  function UTF16ToString(ptr, maxBytesToRead) {
    let endPtr = ptr;
    let idx = endPtr >> 1;
    const maxIdx = idx + maxBytesToRead / 2;
    while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
    endPtr = idx << 1;
    if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
    let str = "";
    for (let i2 = 0; !(i2 >= maxBytesToRead / 2); ++i2) {
      const codeUnit = HEAP16[ptr + i2 * 2 >> 1];
      if (codeUnit == 0) break;
      str += String.fromCharCode(codeUnit);
    }
    return str;
  }
  function stringToUTF16(str, outPtr, maxBytesToWrite) {
    maxBytesToWrite ??= 2147483647;
    if (maxBytesToWrite < 2) return 0;
    maxBytesToWrite -= 2;
    const startPtr = outPtr;
    const numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
    for (let i2 = 0; i2 < numCharsToWrite; ++i2) {
      const codeUnit = str.charCodeAt(i2);
      HEAP16[outPtr >> 1] = codeUnit;
      outPtr += 2;
    }
    HEAP16[outPtr >> 1] = 0;
    return outPtr - startPtr;
  }
  function UTF32ToString(ptr, maxBytesToRead) {
    let i2 = 0;
    let str = "";
    while (!(i2 >= maxBytesToRead / 4)) {
      const utf32 = HEAP32[ptr + i2 * 4 >> 2];
      if (utf32 == 0) break;
      ++i2;
      if (utf32 >= 65536) {
        const ch = utf32 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      } else str += String.fromCharCode(utf32);
    }
    return str;
  }
  function stringToUTF32(str, outPtr, maxBytesToWrite) {
    maxBytesToWrite ??= 2147483647;
    if (maxBytesToWrite < 4) return 0;
    const startPtr = outPtr;
    const endPtr = startPtr + maxBytesToWrite - 4;
    for (let i2 = 0; i2 < str.length; ++i2) {
      let codeUnit = str.charCodeAt(i2);
      if (codeUnit >= 55296 && codeUnit <= 57343) {
        const trailSurrogate = str.charCodeAt(++i2);
        codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
      }
      HEAP32[outPtr >> 2] = codeUnit;
      outPtr += 4;
      if (outPtr + 4 > endPtr) break;
    }
    HEAP32[outPtr >> 2] = 0;
    return outPtr - startPtr;
  }
  function lengthBytesUTF32(str) {
    let len = 0;
    for (let i2 = 0; i2 < str.length; ++i2) {
      const codeUnit = str.charCodeAt(i2);
      if (codeUnit >= 55296 && codeUnit <= 57343) ++i2;
      len += 4;
    }
    return len;
  }
  function __embind_register_std_wstring(rawType, charSize, name) {
    name = readLatin1String(name);
    let decodeString, encodeString, readCharAt, lengthBytesUTF;
    if (charSize === 2) {
      decodeString = UTF16ToString;
      encodeString = stringToUTF16;
      lengthBytesUTF = lengthBytesUTF16;
      readCharAt = (pointer) => HEAPU16[pointer >> 1];
    } else if (charSize === 4) {
      decodeString = UTF32ToString;
      encodeString = stringToUTF32;
      lengthBytesUTF = lengthBytesUTF32;
      readCharAt = (pointer) => HEAPU32[pointer >> 2];
    }
    registerType(rawType, {
      name,
      fromWireType: (value) => {
        const length = HEAPU32[value >> 2];
        let str;
        let decodeStartPtr = value + 4;
        for (let i2 = 0; i2 <= length; ++i2) {
          const currentBytePtr = value + 4 + i2 * charSize;
          if (i2 == length || readCharAt(currentBytePtr) == 0) {
            const maxReadBytes = currentBytePtr - decodeStartPtr;
            const stringSegment = decodeString(decodeStartPtr, maxReadBytes);
            if (str === void 0) str = stringSegment;
            else {
              str += String.fromCharCode(0);
              str += stringSegment;
            }
            decodeStartPtr = currentBytePtr + charSize;
          }
        }
        _free(value);
        return str;
      },
      toWireType: (destructors, value) => {
        if (!(typeof value == "string")) throwBindingError(`Cannot pass non-string to C++ string type ${name}`);
        const length = lengthBytesUTF(value);
        const ptr = _malloc(4 + length + charSize);
        HEAPU32[ptr >> 2] = length / charSize;
        encodeString(value, ptr + 4, length + charSize);
        if (destructors !== null) destructors.push(_free, ptr);
        return ptr;
      },
      argPackAdvance: GenericWireTypeSize,
      readValueFromPointer: readPointer,
      destructorFunction(ptr) {
        _free(ptr);
      }
    });
  }
  function __embind_register_void(rawType, name) {
    name = readLatin1String(name);
    registerType(rawType, {
      isVoid: true,
      name,
      argPackAdvance: 0,
      fromWireType: () => void 0,
      toWireType: (destructors, o2) => void 0
    });
  }
  function growMemory(size) {
    const b2 = wasmMemory.buffer;
    const pages = (size - b2.byteLength + 65535) / 65536;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e2) {
    }
  }
  function _emscripten_resize_heap(requestedSize) {
    const oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    const maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) return false;
    const alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (let cutDown = 1; cutDown <= 4; cutDown *= 2) {
      let overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      const newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      const replacement = growMemory(newSize);
      if (replacement) return true;
    }
    return false;
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    const offset = convertI32PairToI53Checked(offset_low, offset_high);
    return 70;
  }
  function printChar(stream, curr) {
    const buffer2 = printCharBuffers[stream];
    if (curr === 0 || curr === 10) {
      (stream === 1 ? out : err)(UTF8ArrayToString(buffer2, 0));
      buffer2.length = 0;
    } else buffer2.push(curr);
  }
  function _fd_write(fd, iov, iovcnt, pnum) {
    let num = 0;
    for (let i2 = 0; i2 < iovcnt; i2++) {
      const ptr = HEAPU32[iov >> 2];
      const len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      for (let j = 0; j < len; j++) printChar(fd, HEAPU8[ptr + j]);
      num += len;
    }
    HEAPU32[pnum >> 2] = num;
    return 0;
  }
  function writeArrayToMemory(array, buffer2) {
    HEAP8.set(array, buffer2);
  }
  async function run() {
    wasmExports = await createWasm();
    ___wasm_call_ctors = wasmExports.__wasm_call_ctors;
    ___getTypeName = wasmExports.__getTypeName;
    _free = wasmExports.free;
    _malloc = Module._malloc = wasmExports.malloc;
    __emscripten_stack_restore = wasmExports._emscripten_stack_restore;
    __emscripten_stack_alloc = wasmExports._emscripten_stack_alloc;
    _emscripten_stack_get_current = wasmExports.emscripten_stack_get_current;
    ___cxa_is_pointer_type = wasmExports.__cxa_is_pointer_type;
    dynCall_jiji = Module.dynCall_jiji = wasmExports.dynCall_jiji;
    if (runDependencies > 0) return;
    preRun();
    if (runDependencies > 0) return;
    function doRun() {
      if (calledRun) return;
      calledRun = true;
      Module.calledRun = true;
      if (ABORT) return;
      initRuntime();
      postRun();
    }
    doRun();
  }
  async function initWasmBrowser(url) {
    wasmUrl2 = url;
    await run();
  }
  function ttf2woff2(inputContent) {
    const inputBuffer = Module._malloc(inputContent.length + 1);
    const outputSizePtr = Module._malloc(4);
    let outputBufferPtr;
    let outputSize;
    let outputContent;
    Module.writeArrayToMemory(inputContent, inputBuffer);
    outputBufferPtr = Module.convert(inputBuffer, inputContent.length, outputSizePtr);
    outputSize = Module.getValue(outputSizePtr, "i32");
    outputContent = import_buffer.Buffer.alloc(outputSize);
    for (let i2 = 0; i2 < outputSize; i2++) outputContent[i2] = Module.getValue(outputBufferPtr + i2, "i8");
    Module.freePtrs(outputBufferPtr, outputSizePtr);
    return outputContent;
  }
  var Module, wasmMemory, ABORT, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64, __ATPRERUN__, __ATINIT__, __ATPOSTRUN__, runDependencies, runDependencyWatcher, dependenciesFulfilled, wasmUrl2, wasmPromise, callRuntimeCallbacks, noExitRuntime, UTF8Decoder, UTF8ToString, ExceptionInfo, exceptionLast, uncaughtExceptionCount, embind_charCodes, awaitingDependencies, registeredTypes, typeDependencies, BindingError, InternalError, GenericWireTypeSize, emval_freelist, emval_handles, count_emval_handles, Emval, EmValType, __embind_register_emval, createNamedFunction, wasmTableMirror, wasmTable, getDynCaller, UnboundTypeError, stringToUTF8, UTF16Decoder, lengthBytesUTF16, __emscripten_memcpy_js, getHeapMax, _fd_close, convertI32PairToI53Checked, printCharBuffers, wasmImports, wasmExports, ___wasm_call_ctors, ___getTypeName, _free, _malloc, __emscripten_stack_restore, __emscripten_stack_alloc, _emscripten_stack_get_current, ___cxa_is_pointer_type, dynCall_jiji, calledRun;
  var init_wasm_0jzfuaTN = __esm({
    "dist/wasm-0jzfuaTN.mjs"() {
      init_shim();
      Module = typeof Module != "undefined" ? Module : {};
      ABORT = false;
      __ATPRERUN__ = [];
      __ATINIT__ = [];
      __ATPOSTRUN__ = [];
      runDependencies = 0;
      runDependencyWatcher = null;
      dependenciesFulfilled = null;
      wasmPromise = () => fetch(wasmUrl2?.default || wasmUrl2);
      callRuntimeCallbacks = (callbacks) => {
        while (callbacks.length > 0) callbacks.shift()(Module);
      };
      noExitRuntime = Module.noExitRuntime || true;
      UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
      UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
      ExceptionInfo = class {
        constructor(excPtr) {
          this.excPtr = excPtr;
          this.ptr = excPtr - 24;
        }
        set_type(type) {
          HEAPU32[this.ptr + 4 >> 2] = type;
        }
        get_type() {
          return HEAPU32[this.ptr + 4 >> 2];
        }
        set_destructor(destructor) {
          HEAPU32[this.ptr + 8 >> 2] = destructor;
        }
        get_destructor() {
          return HEAPU32[this.ptr + 8 >> 2];
        }
        set_caught(caught) {
          caught = caught ? 1 : 0;
          HEAP8[this.ptr + 12] = caught;
        }
        get_caught() {
          return HEAP8[this.ptr + 12] != 0;
        }
        set_rethrown(rethrown) {
          rethrown = rethrown ? 1 : 0;
          HEAP8[this.ptr + 13] = rethrown;
        }
        get_rethrown() {
          return HEAP8[this.ptr + 13] != 0;
        }
        init(type, destructor) {
          this.set_adjusted_ptr(0);
          this.set_type(type);
          this.set_destructor(destructor);
        }
        set_adjusted_ptr(adjustedPtr) {
          HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
        }
        get_adjusted_ptr() {
          return HEAPU32[this.ptr + 16 >> 2];
        }
        get_exception_ptr() {
          const isPointer = ___cxa_is_pointer_type(this.get_type());
          if (isPointer) return HEAPU32[this.excPtr >> 2];
          const adjusted = this.get_adjusted_ptr();
          if (adjusted !== 0) return adjusted;
          return this.excPtr;
        }
      };
      exceptionLast = 0;
      uncaughtExceptionCount = 0;
      awaitingDependencies = {};
      registeredTypes = {};
      typeDependencies = {};
      GenericWireTypeSize = 8;
      emval_freelist = [];
      emval_handles = [];
      count_emval_handles = () => emval_handles.length / 2 - 5 - emval_freelist.length;
      Emval = {
        toValue: (handle) => {
          if (!handle) throwBindingError(`Cannot use deleted val. handle = ${handle}`);
          return emval_handles[handle];
        },
        toHandle: (value) => {
          switch (value) {
            case void 0:
              return 2;
            case null:
              return 4;
            case true:
              return 6;
            case false:
              return 8;
            default: {
              const handle = emval_freelist.pop() || emval_handles.length;
              emval_handles[handle] = value;
              emval_handles[handle + 1] = 1;
              return handle;
            }
          }
        }
      };
      EmValType = {
        name: "emscripten::val",
        fromWireType: (handle) => {
          const rv = Emval.toValue(handle);
          __emval_decref(handle);
          return rv;
        },
        toWireType: (destructors, value) => Emval.toHandle(value),
        argPackAdvance: GenericWireTypeSize,
        readValueFromPointer: readPointer,
        destructorFunction: null
      };
      __embind_register_emval = (rawType) => registerType(rawType, EmValType);
      createNamedFunction = (name, body) => Object.defineProperty(body, "name", { value: name });
      wasmTableMirror = [];
      getDynCaller = (sig, ptr) => (...args) => dynCall(sig, ptr, args);
      stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
      UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;
      lengthBytesUTF16 = (str) => str.length * 2;
      __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
      getHeapMax = () => 2147483648;
      _fd_close = (fd) => 52;
      convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : Number.NaN;
      printCharBuffers = [
        null,
        [],
        []
      ];
      embind_init_charCodes();
      BindingError = Module.BindingError = class BindingError$1 extends Error {
        constructor(message) {
          super(message);
          this.name = "BindingError";
        }
      };
      InternalError = Module.InternalError = class InternalError$1 extends Error {
        constructor(message) {
          super(message);
          this.name = "InternalError";
        }
      };
      init_emval();
      UnboundTypeError = Module.UnboundTypeError = extendError(Error, "UnboundTypeError");
      wasmImports = {
        __assert_fail: ___assert_fail,
        __cxa_throw: ___cxa_throw,
        _abort_js: __abort_js,
        _embind_register_bigint: __embind_register_bigint,
        _embind_register_bool: __embind_register_bool,
        _embind_register_emval: __embind_register_emval,
        _embind_register_float: __embind_register_float,
        _embind_register_function: __embind_register_function,
        _embind_register_integer: __embind_register_integer,
        _embind_register_memory_view: __embind_register_memory_view,
        _embind_register_std_string: __embind_register_std_string,
        _embind_register_std_wstring: __embind_register_std_wstring,
        _embind_register_void: __embind_register_void,
        _emscripten_memcpy_js: __emscripten_memcpy_js,
        emscripten_resize_heap: _emscripten_resize_heap,
        fd_close: _fd_close,
        fd_seek: _fd_seek,
        fd_write: _fd_write
      };
      Module.getValue = getValue;
      Module.writeArrayToMemory = writeArrayToMemory;
      Module.inspect = function() {
        return "[Module]";
      };
    }
  });

  // node_modules/.pnpm/ttf2woff2@6.0.1/node_modules/ttf2woff2/jssrc/ttf2woff2.cjs
  var require_ttf2woff2 = __commonJS({
    "node_modules/.pnpm/ttf2woff2@6.0.1/node_modules/ttf2woff2/jssrc/ttf2woff2.cjs"(exports, module) {
      init_shim();
      var Module2 = typeof Module2 != "undefined" ? Module2 : {};
      var ENVIRONMENT_IS_WEB = typeof window == "object";
      var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
      var ENVIRONMENT_IS_NODE = typeof api == "object" && typeof api.versions == "object" && typeof api.versions.node == "string";
      if (ENVIRONMENT_IS_NODE) {
      }
      var moduleOverrides = Object.assign({}, Module2);
      var arguments_ = [];
      var thisProgram = "./this.program";
      var quit_ = (status, toThrow) => {
        throw toThrow;
      };
      var scriptDirectory = "";
      function locateFile(path) {
        if (Module2["locateFile"]) {
          return Module2["locateFile"](path, scriptDirectory);
        }
        return scriptDirectory + path;
      }
      var readAsync;
      var readBinary;
      if (ENVIRONMENT_IS_NODE) {
        fs = (init_empty(), __toCommonJS(empty_exports));
        nodePath = require_path_browserify();
        scriptDirectory = __dirname + "/";
        readBinary = (filename) => {
          filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
          var ret = fs.readFileSync(filename);
          return ret;
        };
        readAsync = (filename, binary = true) => {
          filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
          return new Promise((resolve, reject) => {
            fs.readFile(filename, binary ? void 0 : "utf8", (err3, data) => {
              if (err3) reject(err3);
              else resolve(binary ? data.buffer : data);
            });
          });
        };
        if (!Module2["thisProgram"] && api.argv.length > 1) {
          thisProgram = api.argv[1].replace(/\\/g, "/");
        }
        arguments_ = api.argv.slice(2);
        if (typeof module != "undefined") {
          module["exports"] = Module2;
        }
        quit_ = (status, toThrow) => {
          api.exitCode = status;
          throw toThrow;
        };
      } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = self.location.href;
        } else if (typeof document != "undefined" && document.currentScript) {
          scriptDirectory = document.currentScript.src;
        }
        if (scriptDirectory.startsWith("blob:")) {
          scriptDirectory = "";
        } else {
          scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
        }
        {
          if (ENVIRONMENT_IS_WORKER) {
            readBinary = (url) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              return new Uint8Array(xhr.response);
            };
          }
          readAsync = (url) => {
            if (isFileURI(url)) {
              return new Promise((reject, resolve) => {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, true);
                xhr.responseType = "arraybuffer";
                xhr.onload = () => {
                  if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                    resolve(xhr.response);
                  }
                  reject(xhr.status);
                };
                xhr.onerror = reject;
                xhr.send(null);
              });
            }
            return fetch(url, { credentials: "same-origin" }).then((response) => {
              if (response.ok) {
                return response.arrayBuffer();
              }
              return Promise.reject(new Error(response.status + " : " + response.url));
            });
          };
        }
      } else {
      }
      var fs;
      var nodePath;
      var out2 = Module2["print"] || console.log.bind(console);
      var err2 = Module2["printErr"] || console.error.bind(console);
      Object.assign(Module2, moduleOverrides);
      moduleOverrides = null;
      if (Module2["arguments"]) arguments_ = Module2["arguments"];
      if (Module2["thisProgram"]) thisProgram = Module2["thisProgram"];
      if (Module2["quit"]) quit_ = Module2["quit"];
      var wasmBinary;
      if (Module2["wasmBinary"]) wasmBinary = Module2["wasmBinary"];
      var wasmMemory2;
      var ABORT2 = false;
      var EXITSTATUS;
      var HEAP82;
      var HEAPU82;
      var HEAP162;
      var HEAPU162;
      var HEAP322;
      var HEAPU322;
      var HEAPF322;
      var HEAPF642;
      function updateMemoryViews2() {
        var b2 = wasmMemory2.buffer;
        Module2["HEAP8"] = HEAP82 = new Int8Array(b2);
        Module2["HEAP16"] = HEAP162 = new Int16Array(b2);
        Module2["HEAPU8"] = HEAPU82 = new Uint8Array(b2);
        Module2["HEAPU16"] = HEAPU162 = new Uint16Array(b2);
        Module2["HEAP32"] = HEAP322 = new Int32Array(b2);
        Module2["HEAPU32"] = HEAPU322 = new Uint32Array(b2);
        Module2["HEAPF32"] = HEAPF322 = new Float32Array(b2);
        Module2["HEAPF64"] = HEAPF642 = new Float64Array(b2);
      }
      var __ATPRERUN__2 = [];
      var __ATINIT__2 = [];
      var __ATPOSTRUN__2 = [];
      var runtimeInitialized = false;
      function preRun2() {
        if (Module2["preRun"]) {
          if (typeof Module2["preRun"] == "function") Module2["preRun"] = [Module2["preRun"]];
          while (Module2["preRun"].length) {
            addOnPreRun2(Module2["preRun"].shift());
          }
        }
        callRuntimeCallbacks2(__ATPRERUN__2);
      }
      function initRuntime2() {
        runtimeInitialized = true;
        callRuntimeCallbacks2(__ATINIT__2);
      }
      function postRun2() {
        if (Module2["postRun"]) {
          if (typeof Module2["postRun"] == "function") Module2["postRun"] = [Module2["postRun"]];
          while (Module2["postRun"].length) {
            addOnPostRun2(Module2["postRun"].shift());
          }
        }
        callRuntimeCallbacks2(__ATPOSTRUN__2);
      }
      function addOnPreRun2(cb) {
        __ATPRERUN__2.unshift(cb);
      }
      function addOnInit2(cb) {
        __ATINIT__2.unshift(cb);
      }
      function addOnPostRun2(cb) {
        __ATPOSTRUN__2.unshift(cb);
      }
      var runDependencies2 = 0;
      var runDependencyWatcher2 = null;
      var dependenciesFulfilled2 = null;
      function addRunDependency2(id) {
        runDependencies2++;
        Module2["monitorRunDependencies"]?.(runDependencies2);
      }
      function removeRunDependency2(id) {
        runDependencies2--;
        Module2["monitorRunDependencies"]?.(runDependencies2);
        if (runDependencies2 == 0) {
          if (runDependencyWatcher2 !== null) {
            clearInterval(runDependencyWatcher2);
            runDependencyWatcher2 = null;
          }
          if (dependenciesFulfilled2) {
            var callback = dependenciesFulfilled2;
            dependenciesFulfilled2 = null;
            callback();
          }
        }
      }
      function abort2(what) {
        Module2["onAbort"]?.(what);
        what = "Aborted(" + what + ")";
        err2(what);
        ABORT2 = true;
        EXITSTATUS = 1;
        what += ". Build with -sASSERTIONS for more info.";
        var e2 = new WebAssembly.RuntimeError(what);
        throw e2;
      }
      var dataURIPrefix = "data:application/octet-stream;base64,";
      var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
      var isFileURI = (filename) => filename.startsWith("file://");
      function findWasmBinary() {
        var f2 = "ttf2woff2.wasm";
        if (!isDataURI(f2)) {
          return locateFile(f2);
        }
        return f2;
      }
      var wasmBinaryFile;
      function getBinarySync(file) {
        if (file == wasmBinaryFile && wasmBinary) {
          return new Uint8Array(wasmBinary);
        }
        if (readBinary) {
          return readBinary(file);
        }
        throw 'sync fetching of the wasm failed: you can preload it to Module["wasmBinary"] manually, or emcc.py will do that for you when generating HTML (but not JS)';
      }
      function instantiateSync(file, info) {
        var module2;
        var binary = getBinarySync(file);
        module2 = new WebAssembly.Module(binary);
        var instance = new WebAssembly.Instance(module2, info);
        return [instance, module2];
      }
      function getWasmImports2() {
        return { env: wasmImports2, wasi_snapshot_preview1: wasmImports2 };
      }
      function createWasm2() {
        var info = getWasmImports2();
        function receiveInstance(instance, module2) {
          wasmExports2 = instance.exports;
          wasmMemory2 = wasmExports2["memory"];
          updateMemoryViews2();
          wasmTable2 = wasmExports2["__indirect_function_table"];
          addOnInit2(wasmExports2["__wasm_call_ctors"]);
          removeRunDependency2("wasm-instantiate");
          return wasmExports2;
        }
        addRunDependency2("wasm-instantiate");
        if (Module2["instantiateWasm"]) {
          try {
            return Module2["instantiateWasm"](info, receiveInstance);
          } catch (e2) {
            err2(`Module.instantiateWasm callback failed with error: ${e2}`);
            return false;
          }
        }
        if (!wasmBinaryFile) wasmBinaryFile = findWasmBinary();
        var result = instantiateSync(wasmBinaryFile, info);
        return receiveInstance(result[0]);
      }
      var callRuntimeCallbacks2 = (callbacks) => {
        while (callbacks.length > 0) {
          callbacks.shift()(Module2);
        }
      };
      function getValue2(ptr, type = "i8") {
        if (type.endsWith("*")) type = "*";
        switch (type) {
          case "i1":
            return HEAP82[ptr];
          case "i8":
            return HEAP82[ptr];
          case "i16":
            return HEAP162[ptr >> 1];
          case "i32":
            return HEAP322[ptr >> 2];
          case "i64":
            abort2("to do getValue(i64) use WASM_BIGINT");
          case "float":
            return HEAPF322[ptr >> 2];
          case "double":
            return HEAPF642[ptr >> 3];
          case "*":
            return HEAPU322[ptr >> 2];
          default:
            abort2(`invalid type for getValue: ${type}`);
        }
      }
      var noExitRuntime2 = Module2["noExitRuntime"] || true;
      var UTF8Decoder2 = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
      var UTF8ArrayToString2 = (heapOrArray, idx, maxBytesToRead) => {
        var endIdx = idx + maxBytesToRead;
        var endPtr = idx;
        while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
        if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder2) {
          return UTF8Decoder2.decode(heapOrArray.subarray(idx, endPtr));
        }
        var str = "";
        while (idx < endPtr) {
          var u0 = heapOrArray[idx++];
          if (!(u0 & 128)) {
            str += String.fromCharCode(u0);
            continue;
          }
          var u1 = heapOrArray[idx++] & 63;
          if ((u0 & 224) == 192) {
            str += String.fromCharCode((u0 & 31) << 6 | u1);
            continue;
          }
          var u2 = heapOrArray[idx++] & 63;
          if ((u0 & 240) == 224) {
            u0 = (u0 & 15) << 12 | u1 << 6 | u2;
          } else {
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
          }
          if (u0 < 65536) {
            str += String.fromCharCode(u0);
          } else {
            var ch = u0 - 65536;
            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
          }
        }
        return str;
      };
      var UTF8ToString2 = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString2(HEAPU82, ptr, maxBytesToRead) : "";
      var ___assert_fail2 = (condition, filename, line, func) => {
        abort2(`Assertion failed: ${UTF8ToString2(condition)}, at: ` + [filename ? UTF8ToString2(filename) : "unknown filename", line, func ? UTF8ToString2(func) : "unknown function"]);
      };
      var ExceptionInfo2 = class {
        constructor(excPtr) {
          this.excPtr = excPtr;
          this.ptr = excPtr - 24;
        }
        set_type(type) {
          HEAPU322[this.ptr + 4 >> 2] = type;
        }
        get_type() {
          return HEAPU322[this.ptr + 4 >> 2];
        }
        set_destructor(destructor) {
          HEAPU322[this.ptr + 8 >> 2] = destructor;
        }
        get_destructor() {
          return HEAPU322[this.ptr + 8 >> 2];
        }
        set_caught(caught) {
          caught = caught ? 1 : 0;
          HEAP82[this.ptr + 12] = caught;
        }
        get_caught() {
          return HEAP82[this.ptr + 12] != 0;
        }
        set_rethrown(rethrown) {
          rethrown = rethrown ? 1 : 0;
          HEAP82[this.ptr + 13] = rethrown;
        }
        get_rethrown() {
          return HEAP82[this.ptr + 13] != 0;
        }
        init(type, destructor) {
          this.set_adjusted_ptr(0);
          this.set_type(type);
          this.set_destructor(destructor);
        }
        set_adjusted_ptr(adjustedPtr) {
          HEAPU322[this.ptr + 16 >> 2] = adjustedPtr;
        }
        get_adjusted_ptr() {
          return HEAPU322[this.ptr + 16 >> 2];
        }
        get_exception_ptr() {
          var isPointer = ___cxa_is_pointer_type2(this.get_type());
          if (isPointer) {
            return HEAPU322[this.excPtr >> 2];
          }
          var adjusted = this.get_adjusted_ptr();
          if (adjusted !== 0) return adjusted;
          return this.excPtr;
        }
      };
      var exceptionLast2 = 0;
      var uncaughtExceptionCount2 = 0;
      var ___cxa_throw2 = (ptr, type, destructor) => {
        var info = new ExceptionInfo2(ptr);
        info.init(type, destructor);
        exceptionLast2 = ptr;
        uncaughtExceptionCount2++;
        throw exceptionLast2;
      };
      var __abort_js2 = () => {
        abort2("");
      };
      var __embind_register_bigint2 = (primitiveType, name, size, minRange, maxRange) => {
      };
      var embind_init_charCodes2 = () => {
        var codes = new Array(256);
        for (var i2 = 0; i2 < 256; ++i2) {
          codes[i2] = String.fromCharCode(i2);
        }
        embind_charCodes2 = codes;
      };
      var embind_charCodes2;
      var readLatin1String2 = (ptr) => {
        var ret = "";
        var c = ptr;
        while (HEAPU82[c]) {
          ret += embind_charCodes2[HEAPU82[c++]];
        }
        return ret;
      };
      var awaitingDependencies2 = {};
      var registeredTypes2 = {};
      var typeDependencies2 = {};
      var BindingError2;
      var throwBindingError2 = (message) => {
        throw new BindingError2(message);
      };
      var InternalError2;
      var throwInternalError2 = (message) => {
        throw new InternalError2(message);
      };
      var whenDependentTypesAreResolved2 = (myTypes, dependentTypes, getTypeConverters) => {
        myTypes.forEach(function(type) {
          typeDependencies2[type] = dependentTypes;
        });
        function onComplete(typeConverters2) {
          var myTypeConverters = getTypeConverters(typeConverters2);
          if (myTypeConverters.length !== myTypes.length) {
            throwInternalError2("Mismatched type converter count");
          }
          for (var i2 = 0; i2 < myTypes.length; ++i2) {
            registerType2(myTypes[i2], myTypeConverters[i2]);
          }
        }
        var typeConverters = new Array(dependentTypes.length);
        var unregisteredTypes = [];
        var registered = 0;
        dependentTypes.forEach((dt, i2) => {
          if (registeredTypes2.hasOwnProperty(dt)) {
            typeConverters[i2] = registeredTypes2[dt];
          } else {
            unregisteredTypes.push(dt);
            if (!awaitingDependencies2.hasOwnProperty(dt)) {
              awaitingDependencies2[dt] = [];
            }
            awaitingDependencies2[dt].push(() => {
              typeConverters[i2] = registeredTypes2[dt];
              ++registered;
              if (registered === unregisteredTypes.length) {
                onComplete(typeConverters);
              }
            });
          }
        });
        if (0 === unregisteredTypes.length) {
          onComplete(typeConverters);
        }
      };
      function sharedRegisterType2(rawType, registeredInstance, options = {}) {
        var name = registeredInstance.name;
        if (!rawType) {
          throwBindingError2(`type "${name}" must have a positive integer typeid pointer`);
        }
        if (registeredTypes2.hasOwnProperty(rawType)) {
          if (options.ignoreDuplicateRegistrations) {
            return;
          } else {
            throwBindingError2(`Cannot register type '${name}' twice`);
          }
        }
        registeredTypes2[rawType] = registeredInstance;
        delete typeDependencies2[rawType];
        if (awaitingDependencies2.hasOwnProperty(rawType)) {
          var callbacks = awaitingDependencies2[rawType];
          delete awaitingDependencies2[rawType];
          callbacks.forEach((cb) => cb());
        }
      }
      function registerType2(rawType, registeredInstance, options = {}) {
        if (!("argPackAdvance" in registeredInstance)) {
          throw new TypeError("registerType registeredInstance requires argPackAdvance");
        }
        return sharedRegisterType2(rawType, registeredInstance, options);
      }
      var GenericWireTypeSize2 = 8;
      var __embind_register_bool2 = (rawType, name, trueValue, falseValue) => {
        name = readLatin1String2(name);
        registerType2(rawType, { name, fromWireType: function(wt) {
          return !!wt;
        }, toWireType: function(destructors, o2) {
          return o2 ? trueValue : falseValue;
        }, argPackAdvance: GenericWireTypeSize2, readValueFromPointer: function(pointer) {
          return this["fromWireType"](HEAPU82[pointer]);
        }, destructorFunction: null });
      };
      var emval_freelist2 = [];
      var emval_handles2 = [];
      var __emval_decref2 = (handle) => {
        if (handle > 9 && 0 === --emval_handles2[handle + 1]) {
          emval_handles2[handle] = void 0;
          emval_freelist2.push(handle);
        }
      };
      var count_emval_handles2 = () => emval_handles2.length / 2 - 5 - emval_freelist2.length;
      var init_emval2 = () => {
        emval_handles2.push(0, 1, void 0, 1, null, 1, true, 1, false, 1);
        Module2["count_emval_handles"] = count_emval_handles2;
      };
      var Emval2 = { toValue: (handle) => {
        if (!handle) {
          throwBindingError2("Cannot use deleted val. handle = " + handle);
        }
        return emval_handles2[handle];
      }, toHandle: (value) => {
        switch (value) {
          case void 0:
            return 2;
          case null:
            return 4;
          case true:
            return 6;
          case false:
            return 8;
          default: {
            const handle = emval_freelist2.pop() || emval_handles2.length;
            emval_handles2[handle] = value;
            emval_handles2[handle + 1] = 1;
            return handle;
          }
        }
      } };
      function readPointer2(pointer) {
        return this["fromWireType"](HEAPU322[pointer >> 2]);
      }
      var EmValType2 = { name: "emscripten::val", fromWireType: (handle) => {
        var rv = Emval2.toValue(handle);
        __emval_decref2(handle);
        return rv;
      }, toWireType: (destructors, value) => Emval2.toHandle(value), argPackAdvance: GenericWireTypeSize2, readValueFromPointer: readPointer2, destructorFunction: null };
      var __embind_register_emval2 = (rawType) => registerType2(rawType, EmValType2);
      var floatReadValueFromPointer2 = (name, width) => {
        switch (width) {
          case 4:
            return function(pointer) {
              return this["fromWireType"](HEAPF322[pointer >> 2]);
            };
          case 8:
            return function(pointer) {
              return this["fromWireType"](HEAPF642[pointer >> 3]);
            };
          default:
            throw new TypeError(`invalid float width (${width}): ${name}`);
        }
      };
      var __embind_register_float2 = (rawType, name, size) => {
        name = readLatin1String2(name);
        registerType2(rawType, { name, fromWireType: (value) => value, toWireType: (destructors, value) => value, argPackAdvance: GenericWireTypeSize2, readValueFromPointer: floatReadValueFromPointer2(name, size), destructorFunction: null });
      };
      var createNamedFunction2 = (name, body) => Object.defineProperty(body, "name", { value: name });
      var runDestructors2 = (destructors) => {
        while (destructors.length) {
          var ptr = destructors.pop();
          var del = destructors.pop();
          del(ptr);
        }
      };
      function usesDestructorStack2(argTypes) {
        for (var i2 = 1; i2 < argTypes.length; ++i2) {
          if (argTypes[i2] !== null && argTypes[i2].destructorFunction === void 0) {
            return true;
          }
        }
        return false;
      }
      function newFunc2(constructor, argumentList) {
        if (!(constructor instanceof Function)) {
          throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`);
        }
        var dummy = createNamedFunction2(constructor.name || "unknownFunctionName", function() {
        });
        dummy.prototype = constructor.prototype;
        var obj = new dummy();
        var r2 = constructor.apply(obj, argumentList);
        return r2 instanceof Object ? r2 : obj;
      }
      function createJsInvoker2(argTypes, isClassMethodFunc, returns, isAsync) {
        var needsDestructorStack = usesDestructorStack2(argTypes);
        var argCount = argTypes.length;
        var argsList = "";
        var argsListWired = "";
        for (var i2 = 0; i2 < argCount - 2; ++i2) {
          argsList += (i2 !== 0 ? ", " : "") + "arg" + i2;
          argsListWired += (i2 !== 0 ? ", " : "") + "arg" + i2 + "Wired";
        }
        var invokerFnBody = `
        return function (${argsList}) {
        if (arguments.length !== ${argCount - 2}) {
          throwBindingError('function ' + humanName + ' called with ' + arguments.length + ' arguments, expected ${argCount - 2}');
        }`;
        if (needsDestructorStack) {
          invokerFnBody += "var destructors = [];\n";
        }
        var dtorStack = needsDestructorStack ? "destructors" : "null";
        var args1 = ["humanName", "throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
        if (isClassMethodFunc) {
          invokerFnBody += "var thisWired = classParam['toWireType'](" + dtorStack + ", this);\n";
        }
        for (var i2 = 0; i2 < argCount - 2; ++i2) {
          invokerFnBody += "var arg" + i2 + "Wired = argType" + i2 + "['toWireType'](" + dtorStack + ", arg" + i2 + ");\n";
          args1.push("argType" + i2);
        }
        if (isClassMethodFunc) {
          argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
        }
        invokerFnBody += (returns || isAsync ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
        if (needsDestructorStack) {
          invokerFnBody += "runDestructors(destructors);\n";
        } else {
          for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; ++i2) {
            var paramName = i2 === 1 ? "thisWired" : "arg" + (i2 - 2) + "Wired";
            if (argTypes[i2].destructorFunction !== null) {
              invokerFnBody += `${paramName}_dtor(${paramName});
`;
              args1.push(`${paramName}_dtor`);
            }
          }
        }
        if (returns) {
          invokerFnBody += "var ret = retType['fromWireType'](rv);\nreturn ret;\n";
        } else {
        }
        invokerFnBody += "}\n";
        return [args1, invokerFnBody];
      }
      function craftInvokerFunction2(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {
        var argCount = argTypes.length;
        if (argCount < 2) {
          throwBindingError2("argTypes array size mismatch! Must at least get return value and 'this' types!");
        }
        var isClassMethodFunc = argTypes[1] !== null && classType !== null;
        var needsDestructorStack = usesDestructorStack2(argTypes);
        var returns = argTypes[0].name !== "void";
        var closureArgs = [humanName, throwBindingError2, cppInvokerFunc, cppTargetFunc, runDestructors2, argTypes[0], argTypes[1]];
        for (var i2 = 0; i2 < argCount - 2; ++i2) {
          closureArgs.push(argTypes[i2 + 2]);
        }
        if (!needsDestructorStack) {
          for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; ++i2) {
            if (argTypes[i2].destructorFunction !== null) {
              closureArgs.push(argTypes[i2].destructorFunction);
            }
          }
        }
        let [args, invokerFnBody] = createJsInvoker2(argTypes, isClassMethodFunc, returns, isAsync);
        args.push(invokerFnBody);
        var invokerFn = newFunc2(Function, args)(...closureArgs);
        return createNamedFunction2(humanName, invokerFn);
      }
      var ensureOverloadTable2 = (proto, methodName, humanName) => {
        if (void 0 === proto[methodName].overloadTable) {
          var prevFunc = proto[methodName];
          proto[methodName] = function(...args) {
            if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) {
              throwBindingError2(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);
            }
            return proto[methodName].overloadTable[args.length].apply(this, args);
          };
          proto[methodName].overloadTable = [];
          proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
        }
      };
      var exposePublicSymbol2 = (name, value, numArguments) => {
        if (Module2.hasOwnProperty(name)) {
          if (void 0 === numArguments || void 0 !== Module2[name].overloadTable && void 0 !== Module2[name].overloadTable[numArguments]) {
            throwBindingError2(`Cannot register public name '${name}' twice`);
          }
          ensureOverloadTable2(Module2, name, name);
          if (Module2.hasOwnProperty(numArguments)) {
            throwBindingError2(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
          }
          Module2[name].overloadTable[numArguments] = value;
        } else {
          Module2[name] = value;
          if (void 0 !== numArguments) {
            Module2[name].numArguments = numArguments;
          }
        }
      };
      var heap32VectorToArray2 = (count, firstElement) => {
        var array = [];
        for (var i2 = 0; i2 < count; i2++) {
          array.push(HEAPU322[firstElement + i2 * 4 >> 2]);
        }
        return array;
      };
      var replacePublicSymbol2 = (name, value, numArguments) => {
        if (!Module2.hasOwnProperty(name)) {
          throwInternalError2("Replacing nonexistent public symbol");
        }
        if (void 0 !== Module2[name].overloadTable && void 0 !== numArguments) {
          Module2[name].overloadTable[numArguments] = value;
        } else {
          Module2[name] = value;
          Module2[name].argCount = numArguments;
        }
      };
      var dynCallLegacy2 = (sig, ptr, args) => {
        sig = sig.replace(/p/g, "i");
        var f2 = Module2["dynCall_" + sig];
        return f2(ptr, ...args);
      };
      var wasmTableMirror2 = [];
      var wasmTable2;
      var getWasmTableEntry2 = (funcPtr) => {
        var func = wasmTableMirror2[funcPtr];
        if (!func) {
          if (funcPtr >= wasmTableMirror2.length) wasmTableMirror2.length = funcPtr + 1;
          wasmTableMirror2[funcPtr] = func = wasmTable2.get(funcPtr);
        }
        return func;
      };
      var dynCall2 = (sig, ptr, args = []) => {
        if (sig.includes("j")) {
          return dynCallLegacy2(sig, ptr, args);
        }
        var rtn = getWasmTableEntry2(ptr)(...args);
        return rtn;
      };
      var getDynCaller2 = (sig, ptr) => (...args) => dynCall2(sig, ptr, args);
      var embind__requireFunction2 = (signature, rawFunction) => {
        signature = readLatin1String2(signature);
        function makeDynCaller() {
          if (signature.includes("j")) {
            return getDynCaller2(signature, rawFunction);
          }
          return getWasmTableEntry2(rawFunction);
        }
        var fp = makeDynCaller();
        if (typeof fp != "function") {
          throwBindingError2(`unknown function pointer with signature ${signature}: ${rawFunction}`);
        }
        return fp;
      };
      var extendError2 = (baseErrorType, errorName) => {
        var errorClass = createNamedFunction2(errorName, function(message) {
          this.name = errorName;
          this.message = message;
          var stack = new Error(message).stack;
          if (stack !== void 0) {
            this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
          }
        });
        errorClass.prototype = Object.create(baseErrorType.prototype);
        errorClass.prototype.constructor = errorClass;
        errorClass.prototype.toString = function() {
          if (this.message === void 0) {
            return this.name;
          } else {
            return `${this.name}: ${this.message}`;
          }
        };
        return errorClass;
      };
      var UnboundTypeError2;
      var getTypeName2 = (type) => {
        var ptr = ___getTypeName2(type);
        var rv = readLatin1String2(ptr);
        _free2(ptr);
        return rv;
      };
      var throwUnboundTypeError2 = (message, types) => {
        var unboundTypes = [];
        var seen = {};
        function visit(type) {
          if (seen[type]) {
            return;
          }
          if (registeredTypes2[type]) {
            return;
          }
          if (typeDependencies2[type]) {
            typeDependencies2[type].forEach(visit);
            return;
          }
          unboundTypes.push(type);
          seen[type] = true;
        }
        types.forEach(visit);
        throw new UnboundTypeError2(`${message}: ` + unboundTypes.map(getTypeName2).join([", "]));
      };
      var getFunctionName2 = (signature) => {
        signature = signature.trim();
        const argsIndex = signature.indexOf("(");
        if (argsIndex !== -1) {
          return signature.substr(0, argsIndex);
        } else {
          return signature;
        }
      };
      var __embind_register_function2 = (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync) => {
        var argTypes = heap32VectorToArray2(argCount, rawArgTypesAddr);
        name = readLatin1String2(name);
        name = getFunctionName2(name);
        rawInvoker = embind__requireFunction2(signature, rawInvoker);
        exposePublicSymbol2(name, function() {
          throwUnboundTypeError2(`Cannot call ${name} due to unbound types`, argTypes);
        }, argCount - 1);
        whenDependentTypesAreResolved2([], argTypes, (argTypes2) => {
          var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
          replacePublicSymbol2(name, craftInvokerFunction2(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);
          return [];
        });
      };
      var integerReadValueFromPointer2 = (name, width, signed) => {
        switch (width) {
          case 1:
            return signed ? (pointer) => HEAP82[pointer] : (pointer) => HEAPU82[pointer];
          case 2:
            return signed ? (pointer) => HEAP162[pointer >> 1] : (pointer) => HEAPU162[pointer >> 1];
          case 4:
            return signed ? (pointer) => HEAP322[pointer >> 2] : (pointer) => HEAPU322[pointer >> 2];
          default:
            throw new TypeError(`invalid integer width (${width}): ${name}`);
        }
      };
      var __embind_register_integer2 = (primitiveType, name, size, minRange, maxRange) => {
        name = readLatin1String2(name);
        if (maxRange === -1) {
          maxRange = 4294967295;
        }
        var fromWireType = (value) => value;
        if (minRange === 0) {
          var bitshift = 32 - 8 * size;
          fromWireType = (value) => value << bitshift >>> bitshift;
        }
        var isUnsignedType = name.includes("unsigned");
        var checkAssertions = (value, toTypeName) => {
        };
        var toWireType;
        if (isUnsignedType) {
          toWireType = function(destructors, value) {
            checkAssertions(value, this.name);
            return value >>> 0;
          };
        } else {
          toWireType = function(destructors, value) {
            checkAssertions(value, this.name);
            return value;
          };
        }
        registerType2(primitiveType, { name, fromWireType, toWireType, argPackAdvance: GenericWireTypeSize2, readValueFromPointer: integerReadValueFromPointer2(name, size, minRange !== 0), destructorFunction: null });
      };
      var __embind_register_memory_view2 = (rawType, dataTypeIndex, name) => {
        var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        var TA = typeMapping[dataTypeIndex];
        function decodeMemoryView(handle) {
          var size = HEAPU322[handle >> 2];
          var data = HEAPU322[handle + 4 >> 2];
          return new TA(HEAP82.buffer, data, size);
        }
        name = readLatin1String2(name);
        registerType2(rawType, { name, fromWireType: decodeMemoryView, argPackAdvance: GenericWireTypeSize2, readValueFromPointer: decodeMemoryView }, { ignoreDuplicateRegistrations: true });
      };
      var stringToUTF8Array2 = (str, heap, outIdx, maxBytesToWrite) => {
        if (!(maxBytesToWrite > 0)) return 0;
        var startIdx = outIdx;
        var endIdx = outIdx + maxBytesToWrite - 1;
        for (var i2 = 0; i2 < str.length; ++i2) {
          var u2 = str.charCodeAt(i2);
          if (u2 >= 55296 && u2 <= 57343) {
            var u1 = str.charCodeAt(++i2);
            u2 = 65536 + ((u2 & 1023) << 10) | u1 & 1023;
          }
          if (u2 <= 127) {
            if (outIdx >= endIdx) break;
            heap[outIdx++] = u2;
          } else if (u2 <= 2047) {
            if (outIdx + 1 >= endIdx) break;
            heap[outIdx++] = 192 | u2 >> 6;
            heap[outIdx++] = 128 | u2 & 63;
          } else if (u2 <= 65535) {
            if (outIdx + 2 >= endIdx) break;
            heap[outIdx++] = 224 | u2 >> 12;
            heap[outIdx++] = 128 | u2 >> 6 & 63;
            heap[outIdx++] = 128 | u2 & 63;
          } else {
            if (outIdx + 3 >= endIdx) break;
            heap[outIdx++] = 240 | u2 >> 18;
            heap[outIdx++] = 128 | u2 >> 12 & 63;
            heap[outIdx++] = 128 | u2 >> 6 & 63;
            heap[outIdx++] = 128 | u2 & 63;
          }
        }
        heap[outIdx] = 0;
        return outIdx - startIdx;
      };
      var stringToUTF82 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array2(str, HEAPU82, outPtr, maxBytesToWrite);
      var lengthBytesUTF82 = (str) => {
        var len = 0;
        for (var i2 = 0; i2 < str.length; ++i2) {
          var c = str.charCodeAt(i2);
          if (c <= 127) {
            len++;
          } else if (c <= 2047) {
            len += 2;
          } else if (c >= 55296 && c <= 57343) {
            len += 4;
            ++i2;
          } else {
            len += 3;
          }
        }
        return len;
      };
      var __embind_register_std_string2 = (rawType, name) => {
        name = readLatin1String2(name);
        var stdStringIsUTF8 = name === "std::string";
        registerType2(rawType, { name, fromWireType(value) {
          var length = HEAPU322[value >> 2];
          var payload = value + 4;
          var str;
          if (stdStringIsUTF8) {
            var decodeStartPtr = payload;
            for (var i2 = 0; i2 <= length; ++i2) {
              var currentBytePtr = payload + i2;
              if (i2 == length || HEAPU82[currentBytePtr] == 0) {
                var maxRead = currentBytePtr - decodeStartPtr;
                var stringSegment = UTF8ToString2(decodeStartPtr, maxRead);
                if (str === void 0) {
                  str = stringSegment;
                } else {
                  str += String.fromCharCode(0);
                  str += stringSegment;
                }
                decodeStartPtr = currentBytePtr + 1;
              }
            }
          } else {
            var a2 = new Array(length);
            for (var i2 = 0; i2 < length; ++i2) {
              a2[i2] = String.fromCharCode(HEAPU82[payload + i2]);
            }
            str = a2.join("");
          }
          _free2(value);
          return str;
        }, toWireType(destructors, value) {
          if (value instanceof ArrayBuffer) {
            value = new Uint8Array(value);
          }
          var length;
          var valueIsOfTypeString = typeof value == "string";
          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
            throwBindingError2("Cannot pass non-string to std::string");
          }
          if (stdStringIsUTF8 && valueIsOfTypeString) {
            length = lengthBytesUTF82(value);
          } else {
            length = value.length;
          }
          var base = _malloc2(4 + length + 1);
          var ptr = base + 4;
          HEAPU322[base >> 2] = length;
          if (stdStringIsUTF8 && valueIsOfTypeString) {
            stringToUTF82(value, ptr, length + 1);
          } else {
            if (valueIsOfTypeString) {
              for (var i2 = 0; i2 < length; ++i2) {
                var charCode = value.charCodeAt(i2);
                if (charCode > 255) {
                  _free2(ptr);
                  throwBindingError2("String has UTF-16 code units that do not fit in 8 bits");
                }
                HEAPU82[ptr + i2] = charCode;
              }
            } else {
              for (var i2 = 0; i2 < length; ++i2) {
                HEAPU82[ptr + i2] = value[i2];
              }
            }
          }
          if (destructors !== null) {
            destructors.push(_free2, base);
          }
          return base;
        }, argPackAdvance: GenericWireTypeSize2, readValueFromPointer: readPointer2, destructorFunction(ptr) {
          _free2(ptr);
        } });
      };
      var UTF16Decoder2 = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;
      var UTF16ToString2 = (ptr, maxBytesToRead) => {
        var endPtr = ptr;
        var idx = endPtr >> 1;
        var maxIdx = idx + maxBytesToRead / 2;
        while (!(idx >= maxIdx) && HEAPU162[idx]) ++idx;
        endPtr = idx << 1;
        if (endPtr - ptr > 32 && UTF16Decoder2) return UTF16Decoder2.decode(HEAPU82.subarray(ptr, endPtr));
        var str = "";
        for (var i2 = 0; !(i2 >= maxBytesToRead / 2); ++i2) {
          var codeUnit = HEAP162[ptr + i2 * 2 >> 1];
          if (codeUnit == 0) break;
          str += String.fromCharCode(codeUnit);
        }
        return str;
      };
      var stringToUTF162 = (str, outPtr, maxBytesToWrite) => {
        maxBytesToWrite ??= 2147483647;
        if (maxBytesToWrite < 2) return 0;
        maxBytesToWrite -= 2;
        var startPtr = outPtr;
        var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
        for (var i2 = 0; i2 < numCharsToWrite; ++i2) {
          var codeUnit = str.charCodeAt(i2);
          HEAP162[outPtr >> 1] = codeUnit;
          outPtr += 2;
        }
        HEAP162[outPtr >> 1] = 0;
        return outPtr - startPtr;
      };
      var lengthBytesUTF162 = (str) => str.length * 2;
      var UTF32ToString2 = (ptr, maxBytesToRead) => {
        var i2 = 0;
        var str = "";
        while (!(i2 >= maxBytesToRead / 4)) {
          var utf32 = HEAP322[ptr + i2 * 4 >> 2];
          if (utf32 == 0) break;
          ++i2;
          if (utf32 >= 65536) {
            var ch = utf32 - 65536;
            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
          } else {
            str += String.fromCharCode(utf32);
          }
        }
        return str;
      };
      var stringToUTF322 = (str, outPtr, maxBytesToWrite) => {
        maxBytesToWrite ??= 2147483647;
        if (maxBytesToWrite < 4) return 0;
        var startPtr = outPtr;
        var endPtr = startPtr + maxBytesToWrite - 4;
        for (var i2 = 0; i2 < str.length; ++i2) {
          var codeUnit = str.charCodeAt(i2);
          if (codeUnit >= 55296 && codeUnit <= 57343) {
            var trailSurrogate = str.charCodeAt(++i2);
            codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
          }
          HEAP322[outPtr >> 2] = codeUnit;
          outPtr += 4;
          if (outPtr + 4 > endPtr) break;
        }
        HEAP322[outPtr >> 2] = 0;
        return outPtr - startPtr;
      };
      var lengthBytesUTF322 = (str) => {
        var len = 0;
        for (var i2 = 0; i2 < str.length; ++i2) {
          var codeUnit = str.charCodeAt(i2);
          if (codeUnit >= 55296 && codeUnit <= 57343) ++i2;
          len += 4;
        }
        return len;
      };
      var __embind_register_std_wstring2 = (rawType, charSize, name) => {
        name = readLatin1String2(name);
        var decodeString, encodeString, readCharAt, lengthBytesUTF;
        if (charSize === 2) {
          decodeString = UTF16ToString2;
          encodeString = stringToUTF162;
          lengthBytesUTF = lengthBytesUTF162;
          readCharAt = (pointer) => HEAPU162[pointer >> 1];
        } else if (charSize === 4) {
          decodeString = UTF32ToString2;
          encodeString = stringToUTF322;
          lengthBytesUTF = lengthBytesUTF322;
          readCharAt = (pointer) => HEAPU322[pointer >> 2];
        }
        registerType2(rawType, { name, fromWireType: (value) => {
          var length = HEAPU322[value >> 2];
          var str;
          var decodeStartPtr = value + 4;
          for (var i2 = 0; i2 <= length; ++i2) {
            var currentBytePtr = value + 4 + i2 * charSize;
            if (i2 == length || readCharAt(currentBytePtr) == 0) {
              var maxReadBytes = currentBytePtr - decodeStartPtr;
              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
              if (str === void 0) {
                str = stringSegment;
              } else {
                str += String.fromCharCode(0);
                str += stringSegment;
              }
              decodeStartPtr = currentBytePtr + charSize;
            }
          }
          _free2(value);
          return str;
        }, toWireType: (destructors, value) => {
          if (!(typeof value == "string")) {
            throwBindingError2(`Cannot pass non-string to C++ string type ${name}`);
          }
          var length = lengthBytesUTF(value);
          var ptr = _malloc2(4 + length + charSize);
          HEAPU322[ptr >> 2] = length / charSize;
          encodeString(value, ptr + 4, length + charSize);
          if (destructors !== null) {
            destructors.push(_free2, ptr);
          }
          return ptr;
        }, argPackAdvance: GenericWireTypeSize2, readValueFromPointer: readPointer2, destructorFunction(ptr) {
          _free2(ptr);
        } });
      };
      var __embind_register_void2 = (rawType, name) => {
        name = readLatin1String2(name);
        registerType2(rawType, { isVoid: true, name, argPackAdvance: 0, fromWireType: () => void 0, toWireType: (destructors, o2) => void 0 });
      };
      var __emscripten_memcpy_js2 = (dest, src, num) => HEAPU82.copyWithin(dest, src, src + num);
      var getHeapMax2 = () => 2147483648;
      var growMemory2 = (size) => {
        var b2 = wasmMemory2.buffer;
        var pages = (size - b2.byteLength + 65535) / 65536;
        try {
          wasmMemory2.grow(pages);
          updateMemoryViews2();
          return 1;
        } catch (e2) {
        }
      };
      var _emscripten_resize_heap2 = (requestedSize) => {
        var oldSize = HEAPU82.length;
        requestedSize >>>= 0;
        var maxHeapSize = getHeapMax2();
        if (requestedSize > maxHeapSize) {
          return false;
        }
        var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
        for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
          var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
          overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
          var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
          var replacement = growMemory2(newSize);
          if (replacement) {
            return true;
          }
        }
        return false;
      };
      var _fd_close2 = (fd) => 52;
      var convertI32PairToI53Checked2 = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
      function _fd_seek2(fd, offset_low, offset_high, whence, newOffset) {
        var offset = convertI32PairToI53Checked2(offset_low, offset_high);
        return 70;
      }
      var printCharBuffers2 = [null, [], []];
      var printChar2 = (stream, curr) => {
        var buffer2 = printCharBuffers2[stream];
        if (curr === 0 || curr === 10) {
          (stream === 1 ? out2 : err2)(UTF8ArrayToString2(buffer2, 0));
          buffer2.length = 0;
        } else {
          buffer2.push(curr);
        }
      };
      var _fd_write2 = (fd, iov, iovcnt, pnum) => {
        var num = 0;
        for (var i2 = 0; i2 < iovcnt; i2++) {
          var ptr = HEAPU322[iov >> 2];
          var len = HEAPU322[iov + 4 >> 2];
          iov += 8;
          for (var j = 0; j < len; j++) {
            printChar2(fd, HEAPU82[ptr + j]);
          }
          num += len;
        }
        HEAPU322[pnum >> 2] = num;
        return 0;
      };
      var writeArrayToMemory2 = (array, buffer2) => {
        HEAP82.set(array, buffer2);
      };
      embind_init_charCodes2();
      BindingError2 = Module2["BindingError"] = class BindingError extends Error {
        constructor(message) {
          super(message);
          this.name = "BindingError";
        }
      };
      InternalError2 = Module2["InternalError"] = class InternalError extends Error {
        constructor(message) {
          super(message);
          this.name = "InternalError";
        }
      };
      init_emval2();
      UnboundTypeError2 = Module2["UnboundTypeError"] = extendError2(Error, "UnboundTypeError");
      var wasmImports2 = { __assert_fail: ___assert_fail2, __cxa_throw: ___cxa_throw2, _abort_js: __abort_js2, _embind_register_bigint: __embind_register_bigint2, _embind_register_bool: __embind_register_bool2, _embind_register_emval: __embind_register_emval2, _embind_register_float: __embind_register_float2, _embind_register_function: __embind_register_function2, _embind_register_integer: __embind_register_integer2, _embind_register_memory_view: __embind_register_memory_view2, _embind_register_std_string: __embind_register_std_string2, _embind_register_std_wstring: __embind_register_std_wstring2, _embind_register_void: __embind_register_void2, _emscripten_memcpy_js: __emscripten_memcpy_js2, emscripten_resize_heap: _emscripten_resize_heap2, fd_close: _fd_close2, fd_seek: _fd_seek2, fd_write: _fd_write2 };
      var wasmExports2 = createWasm2();
      var ___wasm_call_ctors2 = wasmExports2["__wasm_call_ctors"];
      var ___getTypeName2 = wasmExports2["__getTypeName"];
      var _free2 = wasmExports2["free"];
      var _malloc2 = Module2["_malloc"] = wasmExports2["malloc"];
      var __emscripten_stack_restore2 = wasmExports2["_emscripten_stack_restore"];
      var __emscripten_stack_alloc2 = wasmExports2["_emscripten_stack_alloc"];
      var _emscripten_stack_get_current2 = wasmExports2["emscripten_stack_get_current"];
      var ___cxa_is_pointer_type2 = wasmExports2["__cxa_is_pointer_type"];
      var dynCall_jiji2 = Module2["dynCall_jiji"] = wasmExports2["dynCall_jiji"];
      Module2["getValue"] = getValue2;
      Module2["writeArrayToMemory"] = writeArrayToMemory2;
      var calledRun2;
      dependenciesFulfilled2 = function runCaller() {
        if (!calledRun2) run2();
        if (!calledRun2) dependenciesFulfilled2 = runCaller;
      };
      function run2() {
        if (runDependencies2 > 0) {
          return;
        }
        preRun2();
        if (runDependencies2 > 0) {
          return;
        }
        function doRun() {
          if (calledRun2) return;
          calledRun2 = true;
          Module2["calledRun"] = true;
          if (ABORT2) return;
          initRuntime2();
          Module2["onRuntimeInitialized"]?.();
          postRun2();
        }
        if (Module2["setStatus"]) {
          Module2["setStatus"]("Running...");
          setTimeout(function() {
            setTimeout(function() {
              Module2["setStatus"]("");
            }, 1);
            doRun();
          }, 1);
        } else {
          doRun();
        }
      }
      if (Module2["preInit"]) {
        if (typeof Module2["preInit"] == "function") Module2["preInit"] = [Module2["preInit"]];
        while (Module2["preInit"].length > 0) {
          Module2["preInit"].pop()();
        }
      }
      run2();
      module.exports = Module2;
      Module2.inspect = function() {
        return "[Module]";
      };
    }
  });

  // node_modules/.pnpm/ttf2woff2@6.0.1/node_modules/ttf2woff2/jssrc/index.js
  var jssrc_exports = {};
  __export(jssrc_exports, {
    default: () => ttf2woff22
  });
  function ttf2woff22(inputContent) {
    const inputBuffer = import_ttf2woff2.default._malloc(inputContent.length + 1);
    const outputSizePtr = import_ttf2woff2.default._malloc(4);
    let outputBufferPtr;
    let outputSize;
    let outputContent;
    import_ttf2woff2.default.writeArrayToMemory(inputContent, inputBuffer);
    outputBufferPtr = import_ttf2woff2.default.convert(
      inputBuffer,
      inputContent.length,
      outputSizePtr
    );
    outputSize = import_ttf2woff2.default.getValue(outputSizePtr, "i32");
    outputContent = import_buffer.Buffer.alloc(outputSize);
    for (let i2 = 0; i2 < outputSize; i2++) {
      outputContent[i2] = import_ttf2woff2.default.getValue(outputBufferPtr + i2, "i8");
    }
    import_ttf2woff2.default.freePtrs(outputBufferPtr, outputSizePtr);
    return outputContent;
  }
  var import_ttf2woff2;
  var init_jssrc = __esm({
    "node_modules/.pnpm/ttf2woff2@6.0.1/node_modules/ttf2woff2/jssrc/index.js"() {
      init_shim();
      import_ttf2woff2 = __toESM(require_ttf2woff2(), 1);
    }
  });

  // dist/index.mjs
  var index_exports = {};
  __export(index_exports, {
    FileExtensions: () => FileExtensions,
    SvgPacker: () => SvgPacker
  });
  init_shim();
  var buffer = __toESM(require_buffer(), 1);
  init_process();
  var import_node_stream = __toESM(require_stream_browserify(), 1);
  var import_node_string_decoder = __toESM(require_string_decoder(), 1);

  // node_modules/.pnpm/client-zip@2.5.0/node_modules/client-zip/index.js
  init_shim();
  "stream" in Blob.prototype || Object.defineProperty(Blob.prototype, "stream", { value() {
    return new Response(this).body;
  } }), "setBigUint64" in DataView.prototype || Object.defineProperty(DataView.prototype, "setBigUint64", { value(e2, n2, t2) {
    const i2 = Number(0xffffffffn & n2), r2 = Number(n2 >> 32n);
    this.setUint32(e2 + (t2 ? 0 : 4), i2, t2), this.setUint32(e2 + (t2 ? 4 : 0), r2, t2);
  } });
  var e = (e2) => new DataView(new ArrayBuffer(e2));
  var n = (e2) => new Uint8Array(e2.buffer || e2);
  var t = (e2) => new TextEncoder().encode(String(e2));
  var i = (e2) => Math.min(4294967295, Number(e2));
  var r = (e2) => Math.min(65535, Number(e2));
  function o(e2, i2, r2) {
    void 0 === i2 || i2 instanceof Date || (i2 = new Date(i2));
    const o2 = void 0 !== e2;
    if (r2 || (r2 = o2 ? 436 : 509), e2 instanceof File) return { isFile: o2, t: i2 || new Date(e2.lastModified), bytes: e2.stream(), mode: r2 };
    if (e2 instanceof Response) return { isFile: o2, t: i2 || new Date(e2.headers.get("Last-Modified") || Date.now()), bytes: e2.body, mode: r2 };
    if (void 0 === i2) i2 = /* @__PURE__ */ new Date();
    else if (isNaN(i2)) throw new Error("Invalid modification date.");
    if (!o2) return { isFile: o2, t: i2, mode: r2 };
    if ("string" == typeof e2) return { isFile: o2, t: i2, bytes: t(e2), mode: r2 };
    if (e2 instanceof Blob) return { isFile: o2, t: i2, bytes: e2.stream(), mode: r2 };
    if (e2 instanceof Uint8Array || e2 instanceof ReadableStream) return { isFile: o2, t: i2, bytes: e2, mode: r2 };
    if (e2 instanceof ArrayBuffer || ArrayBuffer.isView(e2)) return { isFile: o2, t: i2, bytes: n(e2), mode: r2 };
    if (Symbol.asyncIterator in e2) return { isFile: o2, t: i2, bytes: f(e2[Symbol.asyncIterator]()), mode: r2 };
    throw new TypeError("Unsupported input format.");
  }
  function f(e2, n2 = e2) {
    return new ReadableStream({ async pull(n3) {
      let t2 = 0;
      for (; n3.desiredSize > t2; ) {
        const i2 = await e2.next();
        if (!i2.value) {
          n3.close();
          break;
        }
        {
          const e3 = a(i2.value);
          n3.enqueue(e3), t2 += e3.byteLength;
        }
      }
    }, cancel(e3) {
      n2.throw?.(e3);
    } });
  }
  function a(e2) {
    return "string" == typeof e2 ? t(e2) : e2 instanceof Uint8Array ? e2 : n(e2);
  }
  function s(e2, i2, r2) {
    let [o2, f2] = function(e3) {
      return e3 ? e3 instanceof Uint8Array ? [e3, 1] : ArrayBuffer.isView(e3) || e3 instanceof ArrayBuffer ? [n(e3), 1] : [t(e3), 0] : [void 0, 0];
    }(i2);
    if (e2 instanceof File) return { i: d(o2 || t(e2.name)), o: BigInt(e2.size), u: f2 };
    if (e2 instanceof Response) {
      const n2 = e2.headers.get("content-disposition"), i3 = n2 && n2.match(/;\s*filename\*?\s*=\s*(?:UTF-\d+''|)["']?([^;"'\r\n]*)["']?(?:;|$)/i), a2 = i3 && i3[1] || e2.url && new URL(e2.url).pathname.split("/").findLast(Boolean), s2 = a2 && decodeURIComponent(a2), u2 = r2 || +e2.headers.get("content-length");
      return { i: d(o2 || t(s2)), o: BigInt(u2), u: f2 };
    }
    return o2 = d(o2, void 0 !== e2 || void 0 !== r2), "string" == typeof e2 ? { i: o2, o: BigInt(t(e2).length), u: f2 } : e2 instanceof Blob ? { i: o2, o: BigInt(e2.size), u: f2 } : e2 instanceof ArrayBuffer || ArrayBuffer.isView(e2) ? { i: o2, o: BigInt(e2.byteLength), u: f2 } : { i: o2, o: u(e2, r2), u: f2 };
  }
  function u(e2, n2) {
    return n2 > -1 ? BigInt(n2) : e2 ? void 0 : 0n;
  }
  function d(e2, n2 = 1) {
    if (!e2 || e2.every((c) => 47 === c)) throw new Error("The file must have a name.");
    if (n2) for (; 47 === e2[e2.length - 1]; ) e2 = e2.subarray(0, -1);
    else 47 !== e2[e2.length - 1] && (e2 = new Uint8Array([...e2, 47]));
    return e2;
  }
  var l = new Uint32Array(256);
  for (let e2 = 0; e2 < 256; ++e2) {
    let n2 = e2;
    for (let e3 = 0; e3 < 8; ++e3) n2 = n2 >>> 1 ^ (1 & n2 && 3988292384);
    l[e2] = n2;
  }
  function y(e2, n2 = 0) {
    n2 = ~n2;
    for (var t2 = 0, i2 = e2.length; t2 < i2; t2++) n2 = n2 >>> 8 ^ l[255 & n2 ^ e2[t2]];
    return ~n2 >>> 0;
  }
  function w(e2, n2, t2 = 0) {
    const i2 = e2.getSeconds() >> 1 | e2.getMinutes() << 5 | e2.getHours() << 11, r2 = e2.getDate() | e2.getMonth() + 1 << 5 | e2.getFullYear() - 1980 << 9;
    n2.setUint16(t2, i2, 1), n2.setUint16(t2 + 2, r2, 1);
  }
  function B({ i: e2, u: n2 }, t2) {
    return 8 * (!n2 || (t2 ?? function(e3) {
      try {
        b.decode(e3);
      } catch {
        return 0;
      }
      return 1;
    }(e2)));
  }
  var b = new TextDecoder("utf8", { fatal: 1 });
  function p(t2, i2 = 0) {
    const r2 = e(30);
    return r2.setUint32(0, 1347093252), r2.setUint32(4, 754976768 | i2), w(t2.t, r2, 10), r2.setUint16(26, t2.i.length, 1), n(r2);
  }
  async function* g(e2) {
    let { bytes: n2 } = e2;
    if ("then" in n2 && (n2 = await n2), n2 instanceof Uint8Array) yield n2, e2.l = y(n2, 0), e2.o = BigInt(n2.length);
    else {
      e2.o = 0n;
      const t2 = n2.getReader();
      for (; ; ) {
        const { value: n3, done: i2 } = await t2.read();
        if (i2) break;
        e2.l = y(n3, e2.l), e2.o += BigInt(n3.length), yield n3;
      }
    }
  }
  function I(t2, r2) {
    const o2 = e(16 + (r2 ? 8 : 0));
    return o2.setUint32(0, 1347094280), o2.setUint32(4, t2.isFile ? t2.l : 0, 1), r2 ? (o2.setBigUint64(8, t2.o, 1), o2.setBigUint64(16, t2.o, 1)) : (o2.setUint32(8, i(t2.o), 1), o2.setUint32(12, i(t2.o), 1)), n(o2);
  }
  function v(t2, r2, o2 = 0, f2 = 0) {
    const a2 = e(46);
    return a2.setUint32(0, 1347092738), a2.setUint32(4, 755182848), a2.setUint16(8, 2048 | o2), w(t2.t, a2, 12), a2.setUint32(16, t2.isFile ? t2.l : 0, 1), a2.setUint32(20, i(t2.o), 1), a2.setUint32(24, i(t2.o), 1), a2.setUint16(28, t2.i.length, 1), a2.setUint16(30, f2, 1), a2.setUint16(40, t2.mode | (t2.isFile ? 32768 : 16384), 1), a2.setUint32(42, i(r2), 1), n(a2);
  }
  function h(t2, i2, r2) {
    const o2 = e(r2);
    return o2.setUint16(0, 1, 1), o2.setUint16(2, r2 - 4, 1), 16 & r2 && (o2.setBigUint64(4, t2.o, 1), o2.setBigUint64(12, t2.o, 1)), o2.setBigUint64(r2 - 8, i2, 1), n(o2);
  }
  function D(e2) {
    return e2 instanceof File || e2 instanceof Response ? [[e2], [e2]] : [[e2.input, e2.name, e2.size], [e2.input, e2.lastModified, e2.mode]];
  }
  var S = (e2) => function(e3) {
    let n2 = BigInt(22), t2 = 0n, i2 = 0;
    for (const r2 of e3) {
      if (!r2.i) throw new Error("Every file must have a non-empty name.");
      if (void 0 === r2.o) throw new Error(`Missing size for file "${new TextDecoder().decode(r2.i)}".`);
      const e4 = r2.o >= 0xffffffffn, o2 = t2 >= 0xffffffffn;
      t2 += BigInt(46 + r2.i.length + (e4 && 8)) + r2.o, n2 += BigInt(r2.i.length + 46 + (12 * o2 | 28 * e4)), i2 || (i2 = e4);
    }
    return (i2 || t2 >= 0xffffffffn) && (n2 += BigInt(76)), n2 + t2;
  }(function* (e3) {
    for (const n2 of e3) yield s(...D(n2)[0]);
  }(e2));
  function A(e2, n2 = {}) {
    const t2 = { "Content-Type": "application/zip", "Content-Disposition": "attachment" };
    return ("bigint" == typeof n2.length || Number.isInteger(n2.length)) && n2.length > 0 && (t2["Content-Length"] = String(n2.length)), n2.metadata && (t2["Content-Length"] = String(S(n2.metadata))), new Response(N(e2, n2), { headers: t2 });
  }
  function N(t2, a2 = {}) {
    const u2 = function(e2) {
      const n2 = e2[Symbol.iterator in e2 ? Symbol.iterator : Symbol.asyncIterator]();
      return { async next() {
        const e3 = await n2.next();
        if (e3.done) return e3;
        const [t3, i2] = D(e3.value);
        return { done: 0, value: Object.assign(o(...i2), s(...t3)) };
      }, throw: n2.throw?.bind(n2), [Symbol.asyncIterator]() {
        return this;
      } };
    }(t2);
    return f(async function* (t3, o2) {
      const f2 = [];
      let a3 = 0n, s2 = 0n, u3 = 0;
      for await (const e2 of t3) {
        const n2 = B(e2, o2.buffersAreUTF8);
        yield p(e2, n2), yield new Uint8Array(e2.i), e2.isFile && (yield* g(e2));
        const t4 = e2.o >= 0xffffffffn, i2 = 12 * (a3 >= 0xffffffffn) | 28 * t4;
        yield I(e2, t4), f2.push(v(e2, a3, n2, i2)), f2.push(e2.i), i2 && f2.push(h(e2, a3, i2)), t4 && (a3 += 8n), s2++, a3 += BigInt(46 + e2.i.length) + e2.o, u3 || (u3 = t4);
      }
      let d2 = 0n;
      for (const e2 of f2) yield e2, d2 += BigInt(e2.length);
      if (u3 || a3 >= 0xffffffffn) {
        const t4 = e(76);
        t4.setUint32(0, 1347094022), t4.setBigUint64(4, BigInt(44), 1), t4.setUint32(12, 755182848), t4.setBigUint64(24, s2, 1), t4.setBigUint64(32, s2, 1), t4.setBigUint64(40, d2, 1), t4.setBigUint64(48, a3, 1), t4.setUint32(56, 1347094023), t4.setBigUint64(64, a3 + d2, 1), t4.setUint32(72, 1, 1), yield n(t4);
      }
      const l2 = e(22);
      l2.setUint32(0, 1347093766), l2.setUint16(8, r(s2), 1), l2.setUint16(10, r(s2), 1), l2.setUint32(12, i(d2), 1), l2.setUint32(16, i(a3), 1), yield n(l2);
    }(u2, a2), u2);
  }

  // dist/index.mjs
  var import_svg2ttf = __toESM(require_svg2ttf(), 1);
  var import_stream = __toESM(require_stream_browserify(), 1);
  var import_sax = __toESM(require_sax2(), 1);
  var import_os = __toESM(require_browser2(), 1);
  init_empty();
  var import_node_path = __toESM(require_path_browserify(), 1);
  var import_ttf2eot = __toESM(require_ttf2eot(), 1);
  var import_ttf2woff = __toESM(require_ttf2woff(), 1);
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __commonJS2 = (cb, mod) => function() {
    return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps2 = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames2(from), i2 = 0, n2 = keys.length, key; i2 < n2; i2++) {
      key = keys[i2];
      if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
        get: ((k) => from[k]).bind(null, key),
        enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
      });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", {
    value: mod,
    enumerable: true
  }) : target, mod));
  var WSP = " ";
  function encodeSVGPath(commands) {
    let str = "";
    if (!Array.isArray(commands)) commands = [commands];
    for (let i2 = 0; i2 < commands.length; i2++) {
      const command = commands[i2];
      if (command.type === SVGPathData.CLOSE_PATH) str += "z";
      else if (command.type === SVGPathData.HORIZ_LINE_TO) str += (command.relative ? "h" : "H") + command.x;
      else if (command.type === SVGPathData.VERT_LINE_TO) str += (command.relative ? "v" : "V") + command.y;
      else if (command.type === SVGPathData.MOVE_TO) str += (command.relative ? "m" : "M") + command.x + WSP + command.y;
      else if (command.type === SVGPathData.LINE_TO) str += (command.relative ? "l" : "L") + command.x + WSP + command.y;
      else if (command.type === SVGPathData.CURVE_TO) str += (command.relative ? "c" : "C") + command.x1 + WSP + command.y1 + WSP + command.x2 + WSP + command.y2 + WSP + command.x + WSP + command.y;
      else if (command.type === SVGPathData.SMOOTH_CURVE_TO) str += (command.relative ? "s" : "S") + command.x2 + WSP + command.y2 + WSP + command.x + WSP + command.y;
      else if (command.type === SVGPathData.QUAD_TO) str += (command.relative ? "q" : "Q") + command.x1 + WSP + command.y1 + WSP + command.x + WSP + command.y;
      else if (command.type === SVGPathData.SMOOTH_QUAD_TO) str += (command.relative ? "t" : "T") + command.x + WSP + command.y;
      else if (command.type === SVGPathData.ARC) str += (command.relative ? "a" : "A") + command.rX + WSP + command.rY + WSP + command.xRot + WSP + +command.lArcFlag + WSP + +command.sweepFlag + WSP + command.x + WSP + command.y;
      else throw new Error(`Unexpected command type "${command?.type}" at index ${i2}.`);
    }
    return str;
  }
  function rotate$1([x, y$1], rad) {
    return [x * Math.cos(rad) - y$1 * Math.sin(rad), x * Math.sin(rad) + y$1 * Math.cos(rad)];
  }
  var DEBUG_CHECK_NUMBERS = true;
  function assertNumbers(...numbers) {
    if (DEBUG_CHECK_NUMBERS) {
      for (let i2 = 0; i2 < numbers.length; i2++) if ("number" !== typeof numbers[i2]) throw new Error(`assertNumbers arguments[${i2}] is not a number. ${typeof numbers[i2]} == typeof ${numbers[i2]}`);
    }
    return true;
  }
  var PI$1 = Math.PI;
  function annotateArcCommand(c, x1, y1) {
    c.lArcFlag = 0 === c.lArcFlag ? 0 : 1;
    c.sweepFlag = 0 === c.sweepFlag ? 0 : 1;
    let { rX, rY } = c;
    const { x, y: y$1 } = c;
    if (Math.abs(rX) < 1e-10 || Math.abs(rY) < 1e-10) {
      c.rX = 0;
      c.rY = 0;
      c.cX = (x1 + x) / 2;
      c.cY = (y1 + y$1) / 2;
      c.phi1 = 0;
      c.phi2 = 0;
      return;
    }
    rX = Math.abs(c.rX);
    rY = Math.abs(c.rY);
    const xRotRad = c.xRot / 180 * PI$1;
    const [x1_, y1_] = rotate$1([(x1 - x) / 2, (y1 - y$1) / 2], -xRotRad);
    const testValue = Math.pow(x1_, 2) / Math.pow(rX, 2) + Math.pow(y1_, 2) / Math.pow(rY, 2);
    if (1 < testValue) {
      rX *= Math.sqrt(testValue);
      rY *= Math.sqrt(testValue);
    }
    c.rX = rX;
    c.rY = rY;
    const c_ScaleTemp = Math.pow(rX, 2) * Math.pow(y1_, 2) + Math.pow(rY, 2) * Math.pow(x1_, 2);
    const c_Scale = (c.lArcFlag !== c.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(rX, 2) * Math.pow(rY, 2) - c_ScaleTemp) / c_ScaleTemp));
    const cx_ = rX * y1_ / rY * c_Scale;
    const cy_ = -rY * x1_ / rX * c_Scale;
    const cRot = rotate$1([cx_, cy_], xRotRad);
    c.cX = cRot[0] + (x1 + x) / 2;
    c.cY = cRot[1] + (y1 + y$1) / 2;
    c.phi1 = Math.atan2((y1_ - cy_) / rY, (x1_ - cx_) / rX);
    c.phi2 = Math.atan2((-y1_ - cy_) / rY, (-x1_ - cx_) / rX);
    if (0 === c.sweepFlag && c.phi2 > c.phi1) c.phi2 -= 2 * PI$1;
    if (1 === c.sweepFlag && c.phi2 < c.phi1) c.phi2 += 2 * PI$1;
    c.phi1 *= 180 / PI$1;
    c.phi2 *= 180 / PI$1;
  }
  function intersectionUnitCircleLine(a2, b2, c) {
    assertNumbers(a2, b2, c);
    const termSqr = a2 * a2 + b2 * b2 - c * c;
    if (0 > termSqr) return [];
    else if (0 === termSqr) return [[a2 * c / (a2 * a2 + b2 * b2), b2 * c / (a2 * a2 + b2 * b2)]];
    const term = Math.sqrt(termSqr);
    return [[(a2 * c + b2 * term) / (a2 * a2 + b2 * b2), (b2 * c - a2 * term) / (a2 * a2 + b2 * b2)], [(a2 * c - b2 * term) / (a2 * a2 + b2 * b2), (b2 * c + a2 * term) / (a2 * a2 + b2 * b2)]];
  }
  var DEG = Math.PI / 180;
  function lerp(a2, b2, t2) {
    return (1 - t2) * a2 + t2 * b2;
  }
  function arcAt(c, x1, x2, phiDeg) {
    return c + Math.cos(phiDeg / 180 * PI$1) * x1 + Math.sin(phiDeg / 180 * PI$1) * x2;
  }
  function bezierRoot(x0, x1, x2, x3) {
    const EPS = 1e-6;
    const x01 = x1 - x0;
    const x12 = x2 - x1;
    const x23 = x3 - x2;
    const a2 = 3 * x01 + 3 * x23 - 6 * x12;
    const b2 = (x12 - x01) * 6;
    const c = 3 * x01;
    if (Math.abs(a2) < EPS) return Math.abs(b2) < EPS ? [] : [-c / b2];
    return pqFormula(b2 / a2, c / a2, EPS);
  }
  function bezierAt(x0, x1, x2, x3, t2) {
    const s$1 = 1 - t2;
    const c0 = s$1 * s$1 * s$1;
    const c1 = 3 * s$1 * s$1 * t2;
    const c2 = 3 * s$1 * t2 * t2;
    const c3 = t2 * t2 * t2;
    return x0 * c0 + x1 * c1 + x2 * c2 + x3 * c3;
  }
  function pqFormula(p2, q, PRECISION = 1e-6) {
    const discriminantX4 = p2 * p2 / 4 - q;
    if (discriminantX4 < -PRECISION) return [];
    else if (discriminantX4 <= PRECISION) return [-p2 / 2];
    const root = Math.sqrt(discriminantX4);
    return [-(p2 / 2) - root, -(p2 / 2) + root];
  }
  function a2c(arc, x0, y0) {
    if (!arc.cX) annotateArcCommand(arc, x0, y0);
    const xRotRad = arc.xRot / 180 * PI$1;
    if (Math.abs(arc.rX) < 1e-10 || Math.abs(arc.rY) < 1e-10) return [{
      relative: arc.relative,
      type: SVGPathData.CURVE_TO,
      x1: x0 + (arc.x - x0) / 3,
      y1: y0 + (arc.y - y0) / 3,
      x2: x0 + 2 * (arc.x - x0) / 3,
      y2: y0 + 2 * (arc.y - y0) / 3,
      x: arc.x,
      y: arc.y
    }];
    const phiMin = Math.min(arc.phi1, arc.phi2), phiMax = Math.max(arc.phi1, arc.phi2), deltaPhi = phiMax - phiMin;
    const partCount = Math.ceil(deltaPhi / 90);
    const result = new Array(partCount);
    let prevX = x0;
    let prevY = y0;
    const transform$1 = (x, y$1) => {
      const [xTemp, yTemp] = rotate$1([x * arc.rX, y$1 * arc.rY], xRotRad);
      return [arc.cX + xTemp, arc.cY + yTemp];
    };
    for (let i2 = 0; i2 < partCount; i2++) {
      const phiStart = lerp(arc.phi1, arc.phi2, i2 / partCount);
      const phiEnd = lerp(arc.phi1, arc.phi2, (i2 + 1) / partCount);
      const deltaPhi$1 = phiEnd - phiStart;
      const f2 = 4 / 3 * Math.tan(deltaPhi$1 * DEG / 4);
      const x1 = Math.cos(phiStart * DEG) - f2 * Math.sin(phiStart * DEG);
      const y1 = Math.sin(phiStart * DEG) + f2 * Math.cos(phiStart * DEG);
      const x = Math.cos(phiEnd * DEG);
      const y$1 = Math.sin(phiEnd * DEG);
      const x2 = x + f2 * y$1;
      const y2 = y$1 - f2 * x;
      const cp1 = transform$1(x1, y1);
      const cp2 = transform$1(x2, y2);
      const end = transform$1(x, y$1);
      const command = {
        relative: arc.relative,
        type: SVGPathData.CURVE_TO,
        x: end[0],
        y: end[1],
        x1: cp1[0],
        y1: cp1[1],
        x2: cp2[0],
        y2: cp2[1]
      };
      if (arc.relative) {
        command.x1 -= prevX;
        command.y1 -= prevY;
        command.x2 -= prevX;
        command.y2 -= prevY;
        command.x -= prevX;
        command.y -= prevY;
      }
      prevX = end[0];
      prevY = end[1];
      result[i2] = command;
    }
    return result;
  }
  function arePointsCollinear(p1, p2, p3) {
    const v1x = p2[0] - p1[0];
    const v1y = p2[1] - p1[1];
    const v2x = p3[0] - p1[0];
    const v2y = p3[1] - p1[1];
    const cross = v1x * v2y - v1y * v2x;
    const isCollinear = Math.abs(cross) < 1e-10;
    if (!isCollinear) return false;
    const dot = v1x * v2x + v1y * v2y;
    const lenSqV1 = v1x * v1x + v1y * v1y;
    const lenSqV2 = v2x * v2x + v2y * v2y;
    return 0 <= dot && dot <= lenSqV2 && lenSqV1 <= lenSqV2;
  }
  function REVERSE_PATH(commands, preserveSubpathOrder = true) {
    if (commands.length < 2) return commands;
    const normalized = SVGPathDataTransformer.INFO((command, px, py) => ({
      ...command,
      x: command.x ?? px,
      y: command.y ?? py,
      relative: command.relative ?? false
    }));
    const result = [];
    let processing = [];
    for (const original of commands) {
      const cmd = normalized(original);
      if (cmd.type === SVGPathData.MOVE_TO && processing.length > 0) {
        if (preserveSubpathOrder) result.push(...reverseSubpath(processing));
        else result.unshift(...reverseSubpath(processing));
        processing = [];
      }
      processing.push(cmd);
    }
    if (processing.length > 0) if (preserveSubpathOrder) result.push(...reverseSubpath(processing));
    else result.unshift(...reverseSubpath(processing));
    return result;
  }
  function reverseSubpath(commands) {
    const isExplicitlyClosed = commands[commands.length - 1]?.type === SVGPathData.CLOSE_PATH;
    const startPointIndex = isExplicitlyClosed ? commands.length - 2 : commands.length - 1;
    const reversed = [{
      type: SVGPathData.MOVE_TO,
      relative: false,
      x: commands[startPointIndex].x,
      y: commands[startPointIndex].y
    }];
    for (let i2 = startPointIndex; i2 > 0; i2--) {
      const curCmd = commands[i2];
      const prevPoint = commands[i2 - 1];
      if (curCmd.relative) throw new Error("Relative command are not supported convert first with `toAbs()`");
      switch (curCmd.type) {
        case SVGPathData.HORIZ_LINE_TO:
          reversed.push({
            type: SVGPathData.HORIZ_LINE_TO,
            relative: false,
            x: prevPoint.x
          });
          break;
        case SVGPathData.VERT_LINE_TO:
          reversed.push({
            type: SVGPathData.VERT_LINE_TO,
            relative: false,
            y: prevPoint.y
          });
          break;
        case SVGPathData.LINE_TO:
        case SVGPathData.MOVE_TO:
          reversed.push({
            type: SVGPathData.LINE_TO,
            relative: false,
            x: prevPoint.x,
            y: prevPoint.y
          });
          break;
        case SVGPathData.CURVE_TO:
          reversed.push({
            type: SVGPathData.CURVE_TO,
            relative: false,
            x: prevPoint.x,
            y: prevPoint.y,
            x1: curCmd.x2,
            y1: curCmd.y2,
            x2: curCmd.x1,
            y2: curCmd.y1
          });
          break;
        case SVGPathData.SMOOTH_CURVE_TO:
          throw new Error(`Unsupported command: S (smooth cubic bezier)`);
        case SVGPathData.SMOOTH_QUAD_TO:
          throw new Error(`Unsupported command: T (smooth quadratic bezier)`);
        case SVGPathData.ARC:
          throw new Error(`Unsupported command: A (arc)`);
        case SVGPathData.QUAD_TO:
          throw new Error(`Unsupported command: Q (quadratic bezier)`);
      }
    }
    if (isExplicitlyClosed) reversed.push({ type: SVGPathData.CLOSE_PATH });
    return reversed;
  }
  function ROUND(roundVal = 1e13) {
    assertNumbers(roundVal);
    function rf(val) {
      return Math.round(val * roundVal) / roundVal;
    }
    return function round(command) {
      if ("x1" in command && "undefined" !== typeof command.x1) command.x1 = rf(command.x1);
      if ("y1" in command && "undefined" !== typeof command.y1) command.y1 = rf(command.y1);
      if ("x2" in command && "undefined" !== typeof command.x2) command.x2 = rf(command.x2);
      if ("y2" in command && "undefined" !== typeof command.y2) command.y2 = rf(command.y2);
      if ("x" in command && "undefined" !== typeof command.x) command.x = rf(command.x);
      if ("y" in command && "undefined" !== typeof command.y) command.y = rf(command.y);
      if ("rX" in command && "undefined" !== typeof command.rX) command.rX = rf(command.rX);
      if ("rY" in command && "undefined" !== typeof command.rY) command.rY = rf(command.rY);
      return command;
    };
  }
  function TO_ABS() {
    return INFO((command, prevX, prevY) => {
      if (command.relative) {
        if ("undefined" !== typeof command.x1) command.x1 += prevX;
        if ("undefined" !== typeof command.y1) command.y1 += prevY;
        if ("undefined" !== typeof command.x2) command.x2 += prevX;
        if ("undefined" !== typeof command.y2) command.y2 += prevY;
        if ("undefined" !== typeof command.x) command.x += prevX;
        if ("undefined" !== typeof command.y) command.y += prevY;
        command.relative = false;
      }
      return command;
    });
  }
  function TO_REL() {
    return INFO((command, prevX, prevY) => {
      if (!command.relative) {
        if ("undefined" !== typeof command.x1) command.x1 -= prevX;
        if ("undefined" !== typeof command.y1) command.y1 -= prevY;
        if ("undefined" !== typeof command.x2) command.x2 -= prevX;
        if ("undefined" !== typeof command.y2) command.y2 -= prevY;
        if ("undefined" !== typeof command.x) command.x -= prevX;
        if ("undefined" !== typeof command.y) command.y -= prevY;
        command.relative = true;
      }
      return command;
    });
  }
  function NORMALIZE_HVZ(normalizeZ = true, normalizeH = true, normalizeV = true, normalizeC = true) {
    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {
      if (isNaN(pathStartX) && !(command.type & SVGPathData.MOVE_TO)) throw new Error("path must start with moveto");
      if (normalizeH && command.type & SVGPathData.HORIZ_LINE_TO) {
        command.type = SVGPathData.LINE_TO;
        command.y = command.relative ? 0 : prevY;
      }
      if (normalizeV && command.type & SVGPathData.VERT_LINE_TO) {
        command.type = SVGPathData.LINE_TO;
        command.x = command.relative ? 0 : prevX;
      }
      if (normalizeZ && command.type & SVGPathData.CLOSE_PATH) {
        command.type = SVGPathData.LINE_TO;
        command.x = command.relative ? pathStartX - prevX : pathStartX;
        command.y = command.relative ? pathStartY - prevY : pathStartY;
      }
      if (command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY)) {
        command.type = SVGPathData.LINE_TO;
        delete command.rX;
        delete command.rY;
        delete command.xRot;
        delete command.lArcFlag;
        delete command.sweepFlag;
      }
      if (normalizeC && command.type & SVGPathData.QUAD_TO) {
        const startPoint = [prevX, prevY];
        const controlPoint = command.relative ? [prevX + command.x1, prevY + command.y1] : [command.x1, command.y1];
        const endPoint = command.relative ? [prevX + command.x, prevY + command.y] : [command.x, command.y];
        if (arePointsCollinear(startPoint, controlPoint, endPoint)) {
          command.type = SVGPathData.LINE_TO;
          delete command.x1;
          delete command.y1;
        }
      }
      if (normalizeC && command.type & SVGPathData.CURVE_TO) {
        const startPoint = [prevX, prevY];
        const control1 = command.relative ? [prevX + command.x1, prevY + command.y1] : [command.x1, command.y1];
        const control2 = command.relative ? [prevX + command.x2, prevY + command.y2] : [command.x2, command.y2];
        const endPoint = command.relative ? [prevX + command.x, prevY + command.y] : [command.x, command.y];
        if (arePointsCollinear(startPoint, control1, endPoint) && arePointsCollinear(startPoint, control2, endPoint)) {
          command.type = SVGPathData.LINE_TO;
          delete command.x1;
          delete command.y1;
          delete command.x2;
          delete command.y2;
        }
      }
      return command;
    });
  }
  function NORMALIZE_ST() {
    let prevCurveC2X = NaN;
    let prevCurveC2Y = NaN;
    let prevQuadCX = NaN;
    let prevQuadCY = NaN;
    return INFO((command, prevX, prevY) => {
      if (command.type & SVGPathData.SMOOTH_CURVE_TO) {
        command.type = SVGPathData.CURVE_TO;
        prevCurveC2X = isNaN(prevCurveC2X) ? prevX : prevCurveC2X;
        prevCurveC2Y = isNaN(prevCurveC2Y) ? prevY : prevCurveC2Y;
        command.x1 = command.relative ? prevX - prevCurveC2X : 2 * prevX - prevCurveC2X;
        command.y1 = command.relative ? prevY - prevCurveC2Y : 2 * prevY - prevCurveC2Y;
      }
      if (command.type & SVGPathData.CURVE_TO) {
        prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;
        prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;
      } else {
        prevCurveC2X = NaN;
        prevCurveC2Y = NaN;
      }
      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {
        command.type = SVGPathData.QUAD_TO;
        prevQuadCX = isNaN(prevQuadCX) ? prevX : prevQuadCX;
        prevQuadCY = isNaN(prevQuadCY) ? prevY : prevQuadCY;
        command.x1 = command.relative ? prevX - prevQuadCX : 2 * prevX - prevQuadCX;
        command.y1 = command.relative ? prevY - prevQuadCY : 2 * prevY - prevQuadCY;
      }
      if (command.type & SVGPathData.QUAD_TO) {
        prevQuadCX = command.relative ? prevX + command.x1 : command.x1;
        prevQuadCY = command.relative ? prevY + command.y1 : command.y1;
      } else {
        prevQuadCX = NaN;
        prevQuadCY = NaN;
      }
      return command;
    });
  }
  function QT_TO_C() {
    let prevQuadX1 = NaN;
    let prevQuadY1 = NaN;
    return INFO((command, prevX, prevY) => {
      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {
        command.type = SVGPathData.QUAD_TO;
        prevQuadX1 = isNaN(prevQuadX1) ? prevX : prevQuadX1;
        prevQuadY1 = isNaN(prevQuadY1) ? prevY : prevQuadY1;
        command.x1 = command.relative ? prevX - prevQuadX1 : 2 * prevX - prevQuadX1;
        command.y1 = command.relative ? prevY - prevQuadY1 : 2 * prevY - prevQuadY1;
      }
      if (command.type & SVGPathData.QUAD_TO) {
        prevQuadX1 = command.relative ? prevX + command.x1 : command.x1;
        prevQuadY1 = command.relative ? prevY + command.y1 : command.y1;
        const x1 = command.x1;
        const y1 = command.y1;
        command.type = SVGPathData.CURVE_TO;
        command.x1 = ((command.relative ? 0 : prevX) + x1 * 2) / 3;
        command.y1 = ((command.relative ? 0 : prevY) + y1 * 2) / 3;
        command.x2 = (command.x + x1 * 2) / 3;
        command.y2 = (command.y + y1 * 2) / 3;
      } else {
        prevQuadX1 = NaN;
        prevQuadY1 = NaN;
      }
      return command;
    });
  }
  function INFO(f2) {
    let prevXAbs = 0;
    let prevYAbs = 0;
    let pathStartXAbs = NaN;
    let pathStartYAbs = NaN;
    return function transform$1(command) {
      if (isNaN(pathStartXAbs) && !(command.type & SVGPathData.MOVE_TO)) throw new Error("path must start with moveto");
      const result = f2(command, prevXAbs, prevYAbs, pathStartXAbs, pathStartYAbs);
      if (command.type & SVGPathData.CLOSE_PATH) {
        prevXAbs = pathStartXAbs;
        prevYAbs = pathStartYAbs;
      }
      if ("x" in command && "undefined" !== typeof command.x) prevXAbs = command.relative ? prevXAbs + command.x : command.x;
      if ("y" in command && "undefined" !== typeof command.y) prevYAbs = command.relative ? prevYAbs + command.y : command.y;
      if (command.type & SVGPathData.MOVE_TO) {
        pathStartXAbs = prevXAbs;
        pathStartYAbs = prevYAbs;
      }
      return result;
    };
  }
  function SANITIZE(EPS = 0) {
    assertNumbers(EPS);
    let prevCurveC2X = NaN;
    let prevCurveC2Y = NaN;
    let prevQuadCX = NaN;
    let prevQuadCY = NaN;
    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {
      const abs = Math.abs;
      let skip = false;
      let x1Rel = 0;
      let y1Rel = 0;
      if (command.type & SVGPathData.SMOOTH_CURVE_TO) {
        x1Rel = isNaN(prevCurveC2X) ? 0 : prevX - prevCurveC2X;
        y1Rel = isNaN(prevCurveC2Y) ? 0 : prevY - prevCurveC2Y;
      }
      if (command.type & (SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO)) {
        prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;
        prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;
      } else {
        prevCurveC2X = NaN;
        prevCurveC2Y = NaN;
      }
      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {
        prevQuadCX = isNaN(prevQuadCX) ? prevX : 2 * prevX - prevQuadCX;
        prevQuadCY = isNaN(prevQuadCY) ? prevY : 2 * prevY - prevQuadCY;
      } else if (command.type & SVGPathData.QUAD_TO) {
        prevQuadCX = command.relative ? prevX + command.x1 : command.x1;
        prevQuadCY = command.relative ? prevY + command.y1 : command.y2;
      } else {
        prevQuadCX = NaN;
        prevQuadCY = NaN;
      }
      if (command.type & SVGPathData.LINE_COMMANDS || command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY || !command.lArcFlag) || command.type & SVGPathData.CURVE_TO || command.type & SVGPathData.SMOOTH_CURVE_TO || command.type & SVGPathData.QUAD_TO || command.type & SVGPathData.SMOOTH_QUAD_TO) {
        const xRel = "undefined" === typeof command.x ? 0 : command.relative ? command.x : command.x - prevX;
        const yRel = "undefined" === typeof command.y ? 0 : command.relative ? command.y : command.y - prevY;
        x1Rel = !isNaN(prevQuadCX) ? prevQuadCX - prevX : "undefined" === typeof command.x1 ? x1Rel : command.relative ? command.x : command.x1 - prevX;
        y1Rel = !isNaN(prevQuadCY) ? prevQuadCY - prevY : "undefined" === typeof command.y1 ? y1Rel : command.relative ? command.y : command.y1 - prevY;
        const x2Rel = "undefined" === typeof command.x2 ? 0 : command.relative ? command.x : command.x2 - prevX;
        const y2Rel = "undefined" === typeof command.y2 ? 0 : command.relative ? command.y : command.y2 - prevY;
        if (abs(xRel) <= EPS && abs(yRel) <= EPS && abs(x1Rel) <= EPS && abs(y1Rel) <= EPS && abs(x2Rel) <= EPS && abs(y2Rel) <= EPS) skip = true;
      }
      if (command.type & SVGPathData.CLOSE_PATH) {
        if (abs(prevX - pathStartX) <= EPS && abs(prevY - pathStartY) <= EPS) skip = true;
      }
      return skip ? [] : command;
    });
  }
  function MATRIX(a2, b2, c, d$1, e2, f2) {
    assertNumbers(a2, b2, c, d$1, e2, f2);
    return INFO((command, prevX, prevY, pathStartX) => {
      const origX1 = command.x1;
      const origX2 = command.x2;
      const comRel = command.relative && !isNaN(pathStartX);
      const x = "undefined" !== typeof command.x ? command.x : comRel ? 0 : prevX;
      const y$1 = "undefined" !== typeof command.y ? command.y : comRel ? 0 : prevY;
      if (command.type & SVGPathData.HORIZ_LINE_TO && 0 !== b2) {
        command.type = SVGPathData.LINE_TO;
        command.y = command.relative ? 0 : prevY;
      }
      if (command.type & SVGPathData.VERT_LINE_TO && 0 !== c) {
        command.type = SVGPathData.LINE_TO;
        command.x = command.relative ? 0 : prevX;
      }
      if ("undefined" !== typeof command.x) command.x = command.x * a2 + y$1 * c + (comRel ? 0 : e2);
      if ("undefined" !== typeof command.y) command.y = x * b2 + command.y * d$1 + (comRel ? 0 : f2);
      if ("undefined" !== typeof command.x1) command.x1 = command.x1 * a2 + command.y1 * c + (comRel ? 0 : e2);
      if ("undefined" !== typeof command.y1) command.y1 = origX1 * b2 + command.y1 * d$1 + (comRel ? 0 : f2);
      if ("undefined" !== typeof command.x2) command.x2 = command.x2 * a2 + command.y2 * c + (comRel ? 0 : e2);
      if ("undefined" !== typeof command.y2) command.y2 = origX2 * b2 + command.y2 * d$1 + (comRel ? 0 : f2);
      function sqr(x$1) {
        return x$1 * x$1;
      }
      const det = a2 * d$1 - b2 * c;
      if ("undefined" !== typeof command.xRot) {
        if (1 !== a2 || 0 !== b2 || 0 !== c || 1 !== d$1) if (0 === det) {
          delete command.rX;
          delete command.rY;
          delete command.xRot;
          delete command.lArcFlag;
          delete command.sweepFlag;
          command.type = SVGPathData.LINE_TO;
        } else {
          const xRot = command.xRot * Math.PI / 180;
          const sinRot = Math.sin(xRot);
          const cosRot = Math.cos(xRot);
          const xCurve = 1 / sqr(command.rX);
          const yCurve = 1 / sqr(command.rY);
          const A2 = sqr(cosRot) * xCurve + sqr(sinRot) * yCurve;
          const B2 = 2 * sinRot * cosRot * (xCurve - yCurve);
          const C = sqr(sinRot) * xCurve + sqr(cosRot) * yCurve;
          const A1 = A2 * d$1 * d$1 - B2 * b2 * d$1 + C * b2 * b2;
          const B1 = B2 * (a2 * d$1 + b2 * c) - 2 * (A2 * c * d$1 + C * a2 * b2);
          const C1 = A2 * c * c - B2 * a2 * c + C * a2 * a2;
          const newXRot = (Math.atan2(B1, A1 - C1) + Math.PI) % Math.PI / 2;
          const newSinRot = Math.sin(newXRot);
          const newCosRot = Math.cos(newXRot);
          command.rX = Math.abs(det) / Math.sqrt(A1 * sqr(newCosRot) + B1 * newSinRot * newCosRot + C1 * sqr(newSinRot));
          command.rY = Math.abs(det) / Math.sqrt(A1 * sqr(newSinRot) - B1 * newSinRot * newCosRot + C1 * sqr(newCosRot));
          command.xRot = newXRot * 180 / Math.PI;
        }
      }
      if ("undefined" !== typeof command.sweepFlag && 0 > det) command.sweepFlag = +!command.sweepFlag;
      return command;
    });
  }
  function ROTATE(a2, x = 0, y$1 = 0) {
    assertNumbers(a2, x, y$1);
    const sin$1 = Math.sin(a2);
    const cos$1 = Math.cos(a2);
    return MATRIX(cos$1, sin$1, -sin$1, cos$1, x - x * cos$1 + y$1 * sin$1, y$1 - x * sin$1 - y$1 * cos$1);
  }
  function TRANSLATE(dX, dY = 0) {
    assertNumbers(dX, dY);
    return MATRIX(1, 0, 0, 1, dX, dY);
  }
  function SCALE(dX, dY = dX) {
    assertNumbers(dX, dY);
    return MATRIX(dX, 0, 0, dY, 0, 0);
  }
  function SKEW_X(a2) {
    assertNumbers(a2);
    return MATRIX(1, 0, Math.tan(a2), 1, 0, 0);
  }
  function SKEW_Y(a2) {
    assertNumbers(a2);
    return MATRIX(1, Math.tan(a2), 0, 1, 0, 0);
  }
  function X_AXIS_SYMMETRY(xOffset = 0) {
    assertNumbers(xOffset);
    return MATRIX(-1, 0, 0, 1, xOffset, 0);
  }
  function Y_AXIS_SYMMETRY(yOffset = 0) {
    assertNumbers(yOffset);
    return MATRIX(1, 0, 0, -1, 0, yOffset);
  }
  function A_TO_C() {
    return INFO((command, prevX, prevY) => {
      if (SVGPathData.ARC === command.type) return a2c(command, command.relative ? 0 : prevX, command.relative ? 0 : prevY);
      return command;
    });
  }
  function ANNOTATE_ARCS() {
    return INFO((c, x1, y1) => {
      if (c.relative) {
        x1 = 0;
        y1 = 0;
      }
      if (SVGPathData.ARC === c.type) annotateArcCommand(c, x1, y1);
      return c;
    });
  }
  function CLONE() {
    return (c) => {
      return { ...c };
    };
  }
  function CALCULATE_BOUNDS() {
    const clone = CLONE();
    const toAbs = TO_ABS();
    const qtToC = QT_TO_C();
    const normST = NORMALIZE_ST();
    const f2 = INFO((command, prevXAbs, prevYAbs) => {
      const c = normST(qtToC(toAbs(clone(command))));
      function fixX(absX) {
        if (absX > f2.maxX) f2.maxX = absX;
        if (absX < f2.minX) f2.minX = absX;
      }
      function fixY(absY) {
        if (absY > f2.maxY) f2.maxY = absY;
        if (absY < f2.minY) f2.minY = absY;
      }
      if (c.type & SVGPathData.DRAWING_COMMANDS) {
        fixX(prevXAbs);
        fixY(prevYAbs);
      }
      if (c.type & SVGPathData.HORIZ_LINE_TO) fixX(c.x);
      if (c.type & SVGPathData.VERT_LINE_TO) fixY(c.y);
      if (c.type & SVGPathData.LINE_TO) {
        fixX(c.x);
        fixY(c.y);
      }
      if (c.type & SVGPathData.CURVE_TO) {
        fixX(c.x);
        fixY(c.y);
        const xDerivRoots = bezierRoot(prevXAbs, c.x1, c.x2, c.x);
        for (const derivRoot of xDerivRoots) if (0 < derivRoot && 1 > derivRoot) fixX(bezierAt(prevXAbs, c.x1, c.x2, c.x, derivRoot));
        const yDerivRoots = bezierRoot(prevYAbs, c.y1, c.y2, c.y);
        for (const derivRoot of yDerivRoots) if (0 < derivRoot && 1 > derivRoot) fixY(bezierAt(prevYAbs, c.y1, c.y2, c.y, derivRoot));
      }
      if (c.type & SVGPathData.ARC) {
        fixX(c.x);
        fixY(c.y);
        annotateArcCommand(c, prevXAbs, prevYAbs);
        const xRotRad = c.xRot / 180 * Math.PI;
        const x0 = Math.cos(xRotRad) * c.rX;
        const y0 = Math.sin(xRotRad) * c.rX;
        const x90 = -Math.sin(xRotRad) * c.rY;
        const y90 = Math.cos(xRotRad) * c.rY;
        const [phiMin, phiMax] = c.phi1 < c.phi2 ? [c.phi1, c.phi2] : -180 > c.phi2 ? [c.phi2 + 360, c.phi1 + 360] : [c.phi2, c.phi1];
        const normalizeXiEta = ([xi, eta]) => {
          const phiRad = Math.atan2(eta, xi);
          const phi = phiRad * 180 / Math.PI;
          return phi < phiMin ? phi + 360 : phi;
        };
        const xDerivRoots = intersectionUnitCircleLine(x90, -x0, 0).map(normalizeXiEta);
        for (const derivRoot of xDerivRoots) if (derivRoot > phiMin && derivRoot < phiMax) fixX(arcAt(c.cX, x0, x90, derivRoot));
        const yDerivRoots = intersectionUnitCircleLine(y90, -y0, 0).map(normalizeXiEta);
        for (const derivRoot of yDerivRoots) if (derivRoot > phiMin && derivRoot < phiMax) fixY(arcAt(c.cY, y0, y90, derivRoot));
      }
      return command;
    });
    f2.minX = Infinity;
    f2.maxX = -Infinity;
    f2.minY = Infinity;
    f2.maxY = -Infinity;
    return f2;
  }
  var SVGPathDataTransformer = {
    ROUND,
    TO_ABS,
    TO_REL,
    NORMALIZE_HVZ,
    NORMALIZE_ST,
    QT_TO_C,
    INFO,
    SANITIZE,
    MATRIX,
    ROTATE,
    TRANSLATE,
    SCALE,
    SKEW_X,
    SKEW_Y,
    X_AXIS_SYMMETRY,
    Y_AXIS_SYMMETRY,
    A_TO_C,
    ANNOTATE_ARCS,
    CLONE,
    CALCULATE_BOUNDS,
    REVERSE_PATH
  };
  var TransformableSVG = class {
    round(x) {
      return this.transform(SVGPathDataTransformer.ROUND(x));
    }
    toAbs() {
      return this.transform(SVGPathDataTransformer.TO_ABS());
    }
    toRel() {
      return this.transform(SVGPathDataTransformer.TO_REL());
    }
    normalizeHVZ(a2, b2, c) {
      return this.transform(SVGPathDataTransformer.NORMALIZE_HVZ(a2, b2, c));
    }
    normalizeST() {
      return this.transform(SVGPathDataTransformer.NORMALIZE_ST());
    }
    qtToC() {
      return this.transform(SVGPathDataTransformer.QT_TO_C());
    }
    aToC() {
      return this.transform(SVGPathDataTransformer.A_TO_C());
    }
    sanitize(eps) {
      return this.transform(SVGPathDataTransformer.SANITIZE(eps));
    }
    translate(x, y$1) {
      return this.transform(SVGPathDataTransformer.TRANSLATE(x, y$1));
    }
    scale(x, y$1) {
      return this.transform(SVGPathDataTransformer.SCALE(x, y$1));
    }
    rotate(a2, x, y$1) {
      return this.transform(SVGPathDataTransformer.ROTATE(a2, x, y$1));
    }
    matrix(a2, b2, c, d$1, e2, f2) {
      return this.transform(SVGPathDataTransformer.MATRIX(a2, b2, c, d$1, e2, f2));
    }
    skewX(a2) {
      return this.transform(SVGPathDataTransformer.SKEW_X(a2));
    }
    skewY(a2) {
      return this.transform(SVGPathDataTransformer.SKEW_Y(a2));
    }
    xSymmetry(xOffset) {
      return this.transform(SVGPathDataTransformer.X_AXIS_SYMMETRY(xOffset));
    }
    ySymmetry(yOffset) {
      return this.transform(SVGPathDataTransformer.Y_AXIS_SYMMETRY(yOffset));
    }
    annotateArcs() {
      return this.transform(SVGPathDataTransformer.ANNOTATE_ARCS());
    }
  };
  var isWhiteSpace = (c) => " " === c || "	" === c || "\r" === c || "\n" === c;
  var isDigit = (c) => "0".charCodeAt(0) <= c.charCodeAt(0) && c.charCodeAt(0) <= "9".charCodeAt(0);
  var SVGPathDataParser = class extends TransformableSVG {
    curNumber = "";
    curCommandType = -1;
    curCommandRelative = false;
    canParseCommandOrComma = true;
    curNumberHasExp = false;
    curNumberHasExpDigits = false;
    curNumberHasDecimal = false;
    curArgs = [];
    constructor() {
      super();
    }
    finish(commands = []) {
      this.parse(" ", commands);
      if (0 !== this.curArgs.length || !this.canParseCommandOrComma) throw new SyntaxError("Unterminated command at the path end.");
      return commands;
    }
    parse(str, commands = []) {
      const finishCommand = (command) => {
        commands.push(command);
        this.curArgs.length = 0;
        this.canParseCommandOrComma = true;
      };
      for (let i2 = 0; i2 < str.length; i2++) {
        const c = str[i2];
        const isAArcFlag = this.curCommandType === SVGPathData.ARC && (this.curArgs.length === 3 || this.curArgs.length === 4) && this.curNumber.length === 1 && (this.curNumber === "0" || this.curNumber === "1");
        const isEndingDigit = isDigit(c) && (this.curNumber === "0" && c === "0" || isAArcFlag);
        if (isDigit(c) && !isEndingDigit) {
          this.curNumber += c;
          this.curNumberHasExpDigits = this.curNumberHasExp;
          continue;
        }
        if ("e" === c || "E" === c) {
          this.curNumber += c;
          this.curNumberHasExp = true;
          continue;
        }
        if (("-" === c || "+" === c) && this.curNumberHasExp && !this.curNumberHasExpDigits) {
          this.curNumber += c;
          continue;
        }
        if ("." === c && !this.curNumberHasExp && !this.curNumberHasDecimal && !isAArcFlag) {
          this.curNumber += c;
          this.curNumberHasDecimal = true;
          continue;
        }
        if (this.curNumber && -1 !== this.curCommandType) {
          const val = Number(this.curNumber);
          if (isNaN(val)) throw new SyntaxError(`Invalid number ending at ${i2}`);
          if (this.curCommandType === SVGPathData.ARC) {
            if (0 === this.curArgs.length || 1 === this.curArgs.length) {
              if (0 > val) throw new SyntaxError(`Expected positive number, got "${val}" at index "${i2}"`);
            } else if (3 === this.curArgs.length || 4 === this.curArgs.length) {
              if ("0" !== this.curNumber && "1" !== this.curNumber) throw new SyntaxError(`Expected a flag, got "${this.curNumber}" at index "${i2}"`);
            }
          }
          this.curArgs.push(val);
          if (this.curArgs.length === COMMAND_ARG_COUNTS[this.curCommandType]) {
            if (SVGPathData.HORIZ_LINE_TO === this.curCommandType) finishCommand({
              type: SVGPathData.HORIZ_LINE_TO,
              relative: this.curCommandRelative,
              x: val
            });
            else if (SVGPathData.VERT_LINE_TO === this.curCommandType) finishCommand({
              type: SVGPathData.VERT_LINE_TO,
              relative: this.curCommandRelative,
              y: val
            });
            else if (this.curCommandType === SVGPathData.MOVE_TO || this.curCommandType === SVGPathData.LINE_TO || this.curCommandType === SVGPathData.SMOOTH_QUAD_TO) {
              finishCommand({
                type: this.curCommandType,
                relative: this.curCommandRelative,
                x: this.curArgs[0],
                y: this.curArgs[1]
              });
              if (SVGPathData.MOVE_TO === this.curCommandType) this.curCommandType = SVGPathData.LINE_TO;
            } else if (this.curCommandType === SVGPathData.CURVE_TO) finishCommand({
              type: SVGPathData.CURVE_TO,
              relative: this.curCommandRelative,
              x1: this.curArgs[0],
              y1: this.curArgs[1],
              x2: this.curArgs[2],
              y2: this.curArgs[3],
              x: this.curArgs[4],
              y: this.curArgs[5]
            });
            else if (this.curCommandType === SVGPathData.SMOOTH_CURVE_TO) finishCommand({
              type: SVGPathData.SMOOTH_CURVE_TO,
              relative: this.curCommandRelative,
              x2: this.curArgs[0],
              y2: this.curArgs[1],
              x: this.curArgs[2],
              y: this.curArgs[3]
            });
            else if (this.curCommandType === SVGPathData.QUAD_TO) finishCommand({
              type: SVGPathData.QUAD_TO,
              relative: this.curCommandRelative,
              x1: this.curArgs[0],
              y1: this.curArgs[1],
              x: this.curArgs[2],
              y: this.curArgs[3]
            });
            else if (this.curCommandType === SVGPathData.ARC) finishCommand({
              type: SVGPathData.ARC,
              relative: this.curCommandRelative,
              rX: this.curArgs[0],
              rY: this.curArgs[1],
              xRot: this.curArgs[2],
              lArcFlag: this.curArgs[3],
              sweepFlag: this.curArgs[4],
              x: this.curArgs[5],
              y: this.curArgs[6]
            });
          }
          this.curNumber = "";
          this.curNumberHasExpDigits = false;
          this.curNumberHasExp = false;
          this.curNumberHasDecimal = false;
          this.canParseCommandOrComma = true;
        }
        if (isWhiteSpace(c)) continue;
        if ("," === c && this.canParseCommandOrComma) {
          this.canParseCommandOrComma = false;
          continue;
        }
        if ("+" === c || "-" === c || "." === c) {
          this.curNumber = c;
          this.curNumberHasDecimal = "." === c;
          continue;
        }
        if (isEndingDigit) {
          this.curNumber = c;
          this.curNumberHasDecimal = false;
          continue;
        }
        if (0 !== this.curArgs.length) throw new SyntaxError(`Unterminated command at index ${i2}.`);
        if (!this.canParseCommandOrComma) throw new SyntaxError(`Unexpected character "${c}" at index ${i2}. Command cannot follow comma`);
        this.canParseCommandOrComma = false;
        if ("z" === c || "Z" === c) {
          commands.push({ type: SVGPathData.CLOSE_PATH });
          this.canParseCommandOrComma = true;
          this.curCommandType = -1;
          continue;
        } else if ("h" === c || "H" === c) {
          this.curCommandType = SVGPathData.HORIZ_LINE_TO;
          this.curCommandRelative = "h" === c;
        } else if ("v" === c || "V" === c) {
          this.curCommandType = SVGPathData.VERT_LINE_TO;
          this.curCommandRelative = "v" === c;
        } else if ("m" === c || "M" === c) {
          this.curCommandType = SVGPathData.MOVE_TO;
          this.curCommandRelative = "m" === c;
        } else if ("l" === c || "L" === c) {
          this.curCommandType = SVGPathData.LINE_TO;
          this.curCommandRelative = "l" === c;
        } else if ("c" === c || "C" === c) {
          this.curCommandType = SVGPathData.CURVE_TO;
          this.curCommandRelative = "c" === c;
        } else if ("s" === c || "S" === c) {
          this.curCommandType = SVGPathData.SMOOTH_CURVE_TO;
          this.curCommandRelative = "s" === c;
        } else if ("q" === c || "Q" === c) {
          this.curCommandType = SVGPathData.QUAD_TO;
          this.curCommandRelative = "q" === c;
        } else if ("t" === c || "T" === c) {
          this.curCommandType = SVGPathData.SMOOTH_QUAD_TO;
          this.curCommandRelative = "t" === c;
        } else if ("a" === c || "A" === c) {
          this.curCommandType = SVGPathData.ARC;
          this.curCommandRelative = "a" === c;
        } else throw new SyntaxError(`Unexpected character "${c}" at index ${i2}.`);
      }
      return commands;
    }
    /**
    * Return a wrapper around this parser which applies the transformation on parsed commands.
    */
    transform(transform$1) {
      const result = Object.create(this, { parse: { value(chunk, commands = []) {
        const parsedCommands = Object.getPrototypeOf(this).parse.call(this, chunk);
        for (const c of parsedCommands) {
          const cT = transform$1(c);
          if (Array.isArray(cT)) commands.push(...cT);
          else commands.push(cT);
        }
        return commands;
      } } });
      return result;
    }
  };
  var SVGPathData = class SVGPathData2 extends TransformableSVG {
    commands;
    constructor(content) {
      super();
      if ("string" === typeof content) this.commands = SVGPathData2.parse(content);
      else this.commands = content;
    }
    encode() {
      return SVGPathData2.encode(this.commands);
    }
    getBounds() {
      const boundsTransform = SVGPathDataTransformer.CALCULATE_BOUNDS();
      this.transform(boundsTransform);
      return boundsTransform;
    }
    transform(transformFunction) {
      const newCommands = [];
      for (const command of this.commands) {
        const transformedCommand = transformFunction(command);
        if (Array.isArray(transformedCommand)) newCommands.push(...transformedCommand);
        else newCommands.push(transformedCommand);
      }
      this.commands = newCommands;
      return this;
    }
    /**
    * Reverses the order of path commands to go from end to start
    * IMPORTANT: This function expects absolute commands as input.
    * @param preserveSubpathOrder If true, keeps subpaths in their original order
    */
    reverse(preserveSubpathOrder = true) {
      this.commands = SVGPathDataTransformer.REVERSE_PATH(this.commands, preserveSubpathOrder);
      return this;
    }
    static encode(commands) {
      return encodeSVGPath(commands);
    }
    static parse(path) {
      const parser = new SVGPathDataParser();
      const commands = [];
      parser.parse(path, commands);
      parser.finish(commands);
      return commands;
    }
    static CLOSE_PATH = 1;
    static MOVE_TO = 2;
    static HORIZ_LINE_TO = 4;
    static VERT_LINE_TO = 8;
    static LINE_TO = 16;
    static CURVE_TO = 32;
    static SMOOTH_CURVE_TO = 64;
    static QUAD_TO = 128;
    static SMOOTH_QUAD_TO = 256;
    static ARC = 512;
    static LINE_COMMANDS = SVGPathData2.LINE_TO | SVGPathData2.HORIZ_LINE_TO | SVGPathData2.VERT_LINE_TO;
    static DRAWING_COMMANDS = SVGPathData2.HORIZ_LINE_TO | SVGPathData2.VERT_LINE_TO | SVGPathData2.LINE_TO | SVGPathData2.CURVE_TO | SVGPathData2.SMOOTH_CURVE_TO | SVGPathData2.QUAD_TO | SVGPathData2.SMOOTH_QUAD_TO | SVGPathData2.ARC;
  };
  var COMMAND_ARG_COUNTS = {
    [SVGPathData.MOVE_TO]: 2,
    [SVGPathData.LINE_TO]: 2,
    [SVGPathData.HORIZ_LINE_TO]: 1,
    [SVGPathData.VERT_LINE_TO]: 1,
    [SVGPathData.CLOSE_PATH]: 0,
    [SVGPathData.QUAD_TO]: 4,
    [SVGPathData.SMOOTH_QUAD_TO]: 2,
    [SVGPathData.CURVE_TO]: 6,
    [SVGPathData.SMOOTH_CURVE_TO]: 4,
    [SVGPathData.ARC]: 7
  };
  var svgShapesToPath = {
    rectToPath: svgShapesToPathRectToPath,
    polylineToPath: svgShapesToPathPolylineToPath,
    lineToPath: svgShapesToPathLineToPath,
    circleToPath: svgShapesToPathCircleToPath,
    polygonToPath: svgShapesToPathPolygonToPath
  };
  var svgshapes2svgpath_default = svgShapesToPath;
  function svgShapesToPathRectToPath(attributes) {
    const x = "undefined" !== typeof attributes.x ? parseFloat(attributes.x) : 0;
    const y$1 = "undefined" !== typeof attributes.y ? parseFloat(attributes.y) : 0;
    const width = "undefined" !== typeof attributes.width ? parseFloat(attributes.width) : 0;
    const height = "undefined" !== typeof attributes.height ? parseFloat(attributes.height) : 0;
    const rx = "undefined" !== typeof attributes.rx ? parseFloat(attributes.rx) : "undefined" !== typeof attributes.ry ? parseFloat(attributes.ry) : 0;
    const ry = "undefined" !== typeof attributes.ry ? parseFloat(attributes.ry) : rx;
    return "M" + (x + rx) + " " + y$1 + "h" + (width - rx * 2) + (rx || ry ? "a " + rx + " " + ry + " 0 0 1 " + rx + " " + ry : "") + "v" + (height - ry * 2) + (rx || ry ? "a " + rx + " " + ry + " 0 0 1 " + rx * -1 + " " + ry : "") + "h" + (width - rx * 2) * -1 + (rx || ry ? "a " + rx + " " + ry + " 0 0 1 " + rx * -1 + " " + ry * -1 : "") + "v" + (height - ry * 2) * -1 + (rx || ry ? "a " + rx + " " + ry + " 0 0 1 " + rx + " " + ry * -1 : "") + "z";
  }
  function svgShapesToPathPolylineToPath(attributes) {
    return "M" + attributes.points;
  }
  function svgShapesToPathLineToPath(attributes) {
    return "M" + (parseFloat(attributes.x1) || 0).toString(10) + " " + (parseFloat(attributes.y1) || 0).toString(10) + " " + ((parseFloat(attributes.x1) || 0) + 1).toString(10) + " " + ((parseFloat(attributes.y1) || 0) + 1).toString(10) + " " + ((parseFloat(attributes.x2) || 0) + 1).toString(10) + " " + ((parseFloat(attributes.y2) || 0) + 1).toString(10) + " " + (parseFloat(attributes.x2) || 0).toString(10) + " " + (parseFloat(attributes.y2) || 0).toString(10) + "Z";
  }
  function svgShapesToPathCircleToPath(attributes) {
    const cx = parseFloat(attributes.cx || 0);
    const cy = parseFloat(attributes.cy || 0);
    const rx = "undefined" !== typeof attributes.rx ? parseFloat(attributes.rx) : parseFloat(attributes.r);
    const ry = "undefined" !== typeof attributes.ry ? parseFloat(attributes.ry) : parseFloat(attributes.r);
    return "M" + (cx - rx) + "," + cy + "A" + rx + "," + ry + " 0,0,0 " + (cx + rx) + "," + cy + "A" + rx + "," + ry + " 0,0,0 " + (cx - rx) + "," + cy;
  }
  function svgShapesToPathPolygonToPath(attributes) {
    return "M" + attributes.points + "Z";
  }
  function fromObject(object) {
    return {
      a: parseFloat(object.a),
      b: parseFloat(object.b),
      c: parseFloat(object.c),
      d: parseFloat(object.d),
      e: parseFloat(object.e),
      f: parseFloat(object.f)
    };
  }
  function isUndefined(val) {
    return typeof val === "undefined";
  }
  function translate(tx, ty = 0) {
    return {
      a: 1,
      c: 0,
      e: tx,
      b: 0,
      d: 1,
      f: ty
    };
  }
  function transform(...matrices) {
    matrices = Array.isArray(matrices[0]) ? matrices[0] : matrices;
    const multiply = (m1, m2) => {
      return {
        a: m1.a * m2.a + m1.c * m2.b,
        c: m1.a * m2.c + m1.c * m2.d,
        e: m1.a * m2.e + m1.c * m2.f + m1.e,
        b: m1.b * m2.a + m1.d * m2.b,
        d: m1.b * m2.c + m1.d * m2.d,
        f: m1.b * m2.e + m1.d * m2.f + m1.f
      };
    };
    switch (matrices.length) {
      case 0:
        throw new Error("no matrices provided");
      case 1:
        return matrices[0];
      case 2:
        return multiply(matrices[0], matrices[1]);
      default: {
        const [m1, m2, ...rest] = matrices;
        const m$1 = multiply(m1, m2);
        return transform(m$1, ...rest);
      }
    }
  }
  function compose(...matrices) {
    return transform(...matrices);
  }
  var { cos, sin, PI } = Math;
  function rotate(angle, cx, cy) {
    const cosAngle = cos(angle);
    const sinAngle = sin(angle);
    const rotationMatrix = {
      a: cosAngle,
      c: -sinAngle,
      e: 0,
      b: sinAngle,
      d: cosAngle,
      f: 0
    };
    if (isUndefined(cx) || isUndefined(cy)) return rotationMatrix;
    return transform([
      translate(cx, cy),
      rotationMatrix,
      translate(-cx, -cy)
    ]);
  }
  function rotateDEG(angle, cx = void 0, cy = void 0) {
    return rotate(angle * PI / 180, cx, cy);
  }
  function scale(sx, sy = void 0, cx = void 0, cy = void 0) {
    if (isUndefined(sy)) sy = sx;
    const scaleMatrix = {
      a: sx,
      c: 0,
      e: 0,
      b: 0,
      d: sy,
      f: 0
    };
    if (isUndefined(cx) || isUndefined(cy)) return scaleMatrix;
    return transform([
      translate(cx, cy),
      scaleMatrix,
      translate(-cx, -cy)
    ]);
  }
  function shear(shx, shy) {
    return {
      a: 1,
      c: shx,
      e: 0,
      b: shy,
      d: 1,
      f: 0
    };
  }
  var { tan } = Math;
  function skew(ax, ay) {
    return {
      a: 1,
      c: tan(ax),
      e: 0,
      b: tan(ay),
      d: 1,
      f: 0
    };
  }
  function skewDEG(ax, ay) {
    return skew(ax * Math.PI / 180, ay * Math.PI / 180);
  }
  function fromDefinition(definitionOrArrayOfDefinition) {
    return Array.isArray(definitionOrArrayOfDefinition) ? definitionOrArrayOfDefinition.map(mapper) : mapper(definitionOrArrayOfDefinition);
    function mapper(descriptor) {
      switch (descriptor.type) {
        case "matrix":
          if ("a" in descriptor && "b" in descriptor && "c" in descriptor && "d" in descriptor && "e" in descriptor && "f" in descriptor) return fromObject(descriptor);
          else throw new Error("MISSING_MANDATORY_PARAM");
        case "translate":
          if (!("tx" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
          if ("ty" in descriptor) return translate(descriptor.tx, descriptor.ty);
          return translate(descriptor.tx);
        case "scale":
          if (!("sx" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
          if ("sy" in descriptor) return scale(descriptor.sx, descriptor.sy);
          return scale(descriptor.sx);
        case "rotate":
          if (!("angle" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
          if ("cx" in descriptor && "cy" in descriptor) return rotateDEG(descriptor.angle, descriptor.cx, descriptor.cy);
          return rotateDEG(descriptor.angle);
        case "skewX":
          if (!("angle" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
          return skewDEG(descriptor.angle, 0);
        case "skewY":
          if (!("angle" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
          return skewDEG(0, descriptor.angle);
        case "shear":
          if (!("shx" in descriptor && "shy" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
          return shear(descriptor.shx, descriptor.shy);
        default:
          throw new Error("UNSUPPORTED_DESCRIPTOR");
      }
    }
  }
  function peg$subclass(child, parent) {
    function C() {
      this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C();
  }
  function peg$SyntaxError(message, expected, found, location2) {
    var self$1 = Error.call(this, message);
    if (Object.setPrototypeOf) Object.setPrototypeOf(self$1, peg$SyntaxError.prototype);
    self$1.expected = expected;
    self$1.found = found;
    self$1.location = location2;
    self$1.name = "SyntaxError";
    return self$1;
  }
  peg$subclass(peg$SyntaxError, Error);
  function peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) return str;
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
  }
  peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
      var src = null;
      var k;
      for (k = 0; k < sources.length; k++) if (sources[k].source === this.location.source) {
        src = sources[k].text.split(/\r\n|\n|\r/g);
        break;
      }
      var s$1 = this.location.start;
      var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s$1) : s$1;
      var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
      if (src) {
        var e2 = this.location.end;
        var filler = peg$padEnd("", offset_s.line.toString().length, " ");
        var line = src[s$1.line - 1];
        var last = s$1.line === e2.line ? e2.column : line.length + 1;
        var hatLen = last - s$1.column || 1;
        str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s$1.column - 1, " ") + peg$padEnd("", hatLen, "^");
      } else str += "\n at " + loc;
    }
    return str;
  };
  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function(expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },
      class: function(expectation) {
        var escapedParts = expectation.parts.map(function(part) {
          return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
        });
        return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(expectation) {
        return expectation.description;
      }
    };
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s$1) {
      return s$1.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function classEscape(s$1) {
      return s$1.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected$1) {
      var descriptions = expected$1.map(describeExpectation);
      var i2, j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i2 = 1, j = 1; i2 < descriptions.length; i2++) if (descriptions[i2 - 1] !== descriptions[i2]) {
          descriptions[j] = descriptions[i2];
          j++;
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found$1) {
      return found$1 ? '"' + literalEscape(found$1) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};
    var peg$FAILED = {};
    var peg$source = options.grammarSource;
    var peg$startRuleFunctions = { transformList: peg$parsetransformList };
    var peg$startRuleFunction = peg$parsetransformList;
    var peg$c0 = "matrix";
    var peg$c1 = "(";
    var peg$c2 = ")";
    var peg$c3 = "translate";
    var peg$c4 = "scale";
    var peg$c5 = "rotate";
    var peg$c6 = "skewX";
    var peg$c7 = "skewY";
    var peg$c8 = ",";
    var peg$c9 = ".";
    var peg$r0 = /^[eE]/;
    var peg$r1 = /^[+\-]/;
    var peg$r2 = /^[0-9]/;
    var peg$r3 = /^[ \t\r\n]/;
    var peg$e0 = peg$literalExpectation("matrix", false);
    var peg$e1 = peg$literalExpectation("(", false);
    var peg$e2 = peg$literalExpectation(")", false);
    var peg$e3 = peg$literalExpectation("translate", false);
    var peg$e4 = peg$literalExpectation("scale", false);
    var peg$e5 = peg$literalExpectation("rotate", false);
    var peg$e6 = peg$literalExpectation("skewX", false);
    var peg$e7 = peg$literalExpectation("skewY", false);
    var peg$e8 = peg$literalExpectation(",", false);
    var peg$e9 = peg$otherExpectation("fractionalConstant");
    var peg$e10 = peg$literalExpectation(".", false);
    var peg$e11 = peg$classExpectation(["e", "E"], false, false);
    var peg$e12 = peg$classExpectation(["+", "-"], false, false);
    var peg$e13 = peg$classExpectation([["0", "9"]], false, false);
    var peg$e14 = peg$classExpectation([
      " ",
      "	",
      "\r",
      "\n"
    ], false, false);
    var peg$f0 = function(ts) {
      return ts;
    };
    var peg$f1 = function(t2, ts) {
      return t2.concat(ts);
    };
    var peg$f2 = function(a2, b2, c, d$1, e2, f2) {
      return [{
        type: "matrix",
        a: a2,
        b: b2,
        c,
        d: d$1,
        e: e2,
        f: f2
      }];
    };
    var peg$f3 = function(tx, ty) {
      var t2 = {
        type: "translate",
        tx
      };
      if (ty) t2.ty = ty;
      return [t2];
    };
    var peg$f4 = function(sx, sy) {
      var s$1 = {
        type: "scale",
        sx
      };
      if (sy) s$1.sy = sy;
      return [s$1];
    };
    var peg$f5 = function(angle, c) {
      var r2 = {
        type: "rotate",
        angle
      };
      if (c) {
        r2.cx = c[0];
        r2.cy = c[1];
      }
      return [r2];
    };
    var peg$f6 = function(angle) {
      return [{
        type: "skewX",
        angle
      }];
    };
    var peg$f7 = function(angle) {
      return [{
        type: "skewY",
        angle
      }];
    };
    var peg$f8 = function(f2) {
      return parseFloat(f2.join(""));
    };
    var peg$f9 = function(i2) {
      return parseInt(i2.join(""));
    };
    var peg$f10 = function(n2) {
      return n2;
    };
    var peg$f11 = function(n1, n2) {
      return [n1, n2];
    };
    var peg$f12 = function(ds) {
      return ds.join("");
    };
    var peg$f13 = function(f2, e2) {
      return [f2, e2 || null].join("");
    };
    var peg$f14 = function(d$1, e2) {
      return [d$1, e2].join("");
    };
    var peg$f15 = function(d1, d2) {
      return [
        d1 ? d1.join("") : null,
        ".",
        d2.join("")
      ].join("");
    };
    var peg$f16 = function(d$1) {
      return d$1.join("");
    };
    var peg$f17 = function(s$1, d$1) {
      return [
        "e",
        s$1,
        d$1.join("")
      ].join("");
    };
    var peg$currPos = options.peg$currPos | 0;
    var peg$savedPos = peg$currPos;
    var peg$posDetailsCache = [{
      line: 1,
      column: 1
    }];
    var peg$maxFailPos = peg$currPos;
    var peg$maxFailExpected = options.peg$maxFailExpected || [];
    var peg$silentFails = options.peg$silentFails | 0;
    var peg$result;
    if (options.startRule) {
      if (!(options.startRule in peg$startRuleFunctions)) throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }
    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }
    function offset() {
      return peg$savedPos;
    }
    function range() {
      return {
        source: peg$source,
        start: peg$savedPos,
        end: peg$currPos
      };
    }
    function location2() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location$1) {
      location$1 = location$1 !== void 0 ? location$1 : peg$computeLocation(peg$savedPos, peg$currPos);
      throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location$1);
    }
    function error(message, location$1) {
      location$1 = location$1 !== void 0 ? location$1 : peg$computeLocation(peg$savedPos, peg$currPos);
      throw peg$buildSimpleError(message, location$1);
    }
    function peg$literalExpectation(text$1, ignoreCase) {
      return {
        type: "literal",
        text: text$1,
        ignoreCase
      };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
      return {
        type: "class",
        parts,
        inverted,
        ignoreCase
      };
    }
    function peg$anyExpectation() {
      return { type: "any" };
    }
    function peg$endExpectation() {
      return { type: "end" };
    }
    function peg$otherExpectation(description) {
      return {
        type: "other",
        description
      };
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos];
      var p2;
      if (details) return details;
      else {
        if (pos >= peg$posDetailsCache.length) p2 = peg$posDetailsCache.length - 1;
        else {
          p2 = pos;
          while (!peg$posDetailsCache[--p2]) ;
        }
        details = peg$posDetailsCache[p2];
        details = {
          line: details.line,
          column: details.column
        };
        while (p2 < pos) {
          if (input.charCodeAt(p2) === 10) {
            details.line++;
            details.column = 1;
          } else details.column++;
          p2++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos, offset$1) {
      var startPosDetails = peg$computePosDetails(startPos);
      var endPosDetails = peg$computePosDetails(endPos);
      var res = {
        source: peg$source,
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
      if (offset$1 && peg$source && typeof peg$source.offset === "function") {
        res.start = peg$source.offset(res.start);
        res.end = peg$source.offset(res.end);
      }
      return res;
    }
    function peg$fail(expected$1) {
      if (peg$currPos < peg$maxFailPos) return;
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected$1);
    }
    function peg$buildSimpleError(message, location$1) {
      return new peg$SyntaxError(message, null, null, location$1);
    }
    function peg$buildStructuredError(expected$1, found, location$1) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected$1, found), expected$1, found, location$1);
    }
    function peg$parsetransformList() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsewsp();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsewsp();
      }
      s2 = peg$parsetransforms();
      if (s2 === peg$FAILED) s2 = null;
      s3 = [];
      s4 = peg$parsewsp();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parsewsp();
      }
      peg$savedPos = s0;
      s0 = peg$f0(s2);
      return s0;
    }
    function peg$parsetransforms() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parsetransform();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsecommaWsp();
        if (s3 !== peg$FAILED) while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsecommaWsp();
        }
        else s2 = peg$FAILED;
        if (s2 !== peg$FAILED) {
          s3 = peg$parsetransforms();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f1(s1, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) s0 = peg$parsetransform();
      return s0;
    }
    function peg$parsetransform() {
      var s0;
      s0 = peg$parsematrix();
      if (s0 === peg$FAILED) {
        s0 = peg$parsetranslate();
        if (s0 === peg$FAILED) {
          s0 = peg$parsescale();
          if (s0 === peg$FAILED) {
            s0 = peg$parserotate();
            if (s0 === peg$FAILED) {
              s0 = peg$parseskewX();
              if (s0 === peg$FAILED) s0 = peg$parseskewY();
            }
          }
        }
      }
      return s0;
    }
    function peg$parsematrix() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c0) {
        s1 = peg$c0;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) peg$fail(peg$e0);
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewsp();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewsp();
        }
        if (input.charCodeAt(peg$currPos) === 40) {
          s3 = peg$c1;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) peg$fail(peg$e1);
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parsewsp();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsewsp();
          }
          s5 = peg$parsenumber();
          if (s5 !== peg$FAILED) {
            s6 = peg$parsecommaWsp();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsenumber();
              if (s7 !== peg$FAILED) {
                s8 = peg$parsecommaWsp();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsenumber();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parsecommaWsp();
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parsenumber();
                      if (s11 !== peg$FAILED) {
                        s12 = peg$parsecommaWsp();
                        if (s12 !== peg$FAILED) {
                          s13 = peg$parsenumber();
                          if (s13 !== peg$FAILED) {
                            s14 = peg$parsecommaWsp();
                            if (s14 !== peg$FAILED) {
                              s15 = peg$parsenumber();
                              if (s15 !== peg$FAILED) {
                                s16 = [];
                                s17 = peg$parsewsp();
                                while (s17 !== peg$FAILED) {
                                  s16.push(s17);
                                  s17 = peg$parsewsp();
                                }
                                if (input.charCodeAt(peg$currPos) === 41) {
                                  s17 = peg$c2;
                                  peg$currPos++;
                                } else {
                                  s17 = peg$FAILED;
                                  if (peg$silentFails === 0) peg$fail(peg$e2);
                                }
                                if (s17 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s0 = peg$f2(s5, s7, s9, s11, s13, s15);
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsetranslate() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 9) === peg$c3) {
        s1 = peg$c3;
        peg$currPos += 9;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) peg$fail(peg$e3);
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewsp();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewsp();
        }
        if (input.charCodeAt(peg$currPos) === 40) {
          s3 = peg$c1;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) peg$fail(peg$e1);
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parsewsp();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsewsp();
          }
          s5 = peg$parsenumber();
          if (s5 !== peg$FAILED) {
            s6 = peg$parsecommaWspNumber();
            if (s6 === peg$FAILED) s6 = null;
            s7 = [];
            s8 = peg$parsewsp();
            while (s8 !== peg$FAILED) {
              s7.push(s8);
              s8 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 41) {
              s8 = peg$c2;
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) peg$fail(peg$e2);
            }
            if (s8 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f3(s5, s6);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsescale() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c4) {
        s1 = peg$c4;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) peg$fail(peg$e4);
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewsp();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewsp();
        }
        if (input.charCodeAt(peg$currPos) === 40) {
          s3 = peg$c1;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) peg$fail(peg$e1);
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parsewsp();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsewsp();
          }
          s5 = peg$parsenumber();
          if (s5 !== peg$FAILED) {
            s6 = peg$parsecommaWspNumber();
            if (s6 === peg$FAILED) s6 = null;
            s7 = [];
            s8 = peg$parsewsp();
            while (s8 !== peg$FAILED) {
              s7.push(s8);
              s8 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 41) {
              s8 = peg$c2;
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) peg$fail(peg$e2);
            }
            if (s8 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f4(s5, s6);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parserotate() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c5) {
        s1 = peg$c5;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) peg$fail(peg$e5);
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewsp();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewsp();
        }
        if (input.charCodeAt(peg$currPos) === 40) {
          s3 = peg$c1;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) peg$fail(peg$e1);
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parsewsp();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsewsp();
          }
          s5 = peg$parsenumber();
          if (s5 !== peg$FAILED) {
            s6 = peg$parsecommaWspTwoNumbers();
            if (s6 === peg$FAILED) s6 = null;
            s7 = [];
            s8 = peg$parsewsp();
            while (s8 !== peg$FAILED) {
              s7.push(s8);
              s8 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 41) {
              s8 = peg$c2;
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) peg$fail(peg$e2);
            }
            if (s8 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f5(s5, s6);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseskewX() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c6) {
        s1 = peg$c6;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) peg$fail(peg$e6);
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewsp();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewsp();
        }
        if (input.charCodeAt(peg$currPos) === 40) {
          s3 = peg$c1;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) peg$fail(peg$e1);
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parsewsp();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsewsp();
          }
          s5 = peg$parsenumber();
          if (s5 !== peg$FAILED) {
            s6 = [];
            s7 = peg$parsewsp();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 41) {
              s7 = peg$c2;
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) peg$fail(peg$e2);
            }
            if (s7 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f6(s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseskewY() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c7) {
        s1 = peg$c7;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) peg$fail(peg$e7);
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewsp();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewsp();
        }
        if (input.charCodeAt(peg$currPos) === 40) {
          s3 = peg$c1;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) peg$fail(peg$e1);
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parsewsp();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsewsp();
          }
          s5 = peg$parsenumber();
          if (s5 !== peg$FAILED) {
            s6 = [];
            s7 = peg$parsewsp();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 41) {
              s7 = peg$c2;
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) peg$fail(peg$e2);
            }
            if (s7 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f7(s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsenumber() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parsesign();
      if (s2 === peg$FAILED) s2 = null;
      s3 = peg$parsefloatingPointConstant();
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f8(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsesign();
        if (s2 === peg$FAILED) s2 = null;
        s3 = peg$parseintegerConstant();
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f9(s1);
        }
        s0 = s1;
      }
      return s0;
    }
    function peg$parsecommaWspNumber() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parsecommaWsp();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenumber();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f10(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsecommaWspTwoNumbers() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = peg$parsecommaWsp();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenumber();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecommaWsp();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsenumber();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f11(s2, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsecommaWsp() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsewsp();
      if (s2 !== peg$FAILED) while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsewsp();
      }
      else s1 = peg$FAILED;
      if (s1 !== peg$FAILED) {
        s2 = peg$parsecomma();
        if (s2 === peg$FAILED) s2 = null;
        s3 = [];
        s4 = peg$parsewsp();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsewsp();
        }
        s1 = [
          s1,
          s2,
          s3
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsecomma();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      return s0;
    }
    function peg$parsecomma() {
      var s0;
      if (input.charCodeAt(peg$currPos) === 44) {
        s0 = peg$c8;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) peg$fail(peg$e8);
      }
      return s0;
    }
    function peg$parseintegerConstant() {
      var s0, s1;
      s0 = peg$currPos;
      s1 = peg$parsedigitSequence();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f12(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsefloatingPointConstant() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parsefractionalConstant();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseexponent();
        if (s2 === peg$FAILED) s2 = null;
        peg$savedPos = s0;
        s0 = peg$f13(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsedigitSequence();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseexponent();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      return s0;
    }
    function peg$parsefractionalConstant() {
      var s0, s1, s2, s3;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsedigitSequence();
      if (s1 === peg$FAILED) s1 = null;
      if (input.charCodeAt(peg$currPos) === 46) {
        s2 = peg$c9;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) peg$fail(peg$e10);
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parsedigitSequence();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f15(s1, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsedigitSequence();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s2 = peg$c9;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e10);
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) peg$fail(peg$e9);
      }
      return s0;
    }
    function peg$parseexponent() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = input.charAt(peg$currPos);
      if (peg$r0.test(s1)) peg$currPos++;
      else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) peg$fail(peg$e11);
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsesign();
        if (s2 === peg$FAILED) s2 = null;
        s3 = peg$parsedigitSequence();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f17(s2, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsesign() {
      var s0;
      s0 = input.charAt(peg$currPos);
      if (peg$r1.test(s0)) peg$currPos++;
      else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) peg$fail(peg$e12);
      }
      return s0;
    }
    function peg$parsedigitSequence() {
      var s0, s1;
      s0 = [];
      s1 = peg$parsedigit();
      if (s1 !== peg$FAILED) while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parsedigit();
      }
      else s0 = peg$FAILED;
      return s0;
    }
    function peg$parsedigit() {
      var s0;
      s0 = input.charAt(peg$currPos);
      if (peg$r2.test(s0)) peg$currPos++;
      else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) peg$fail(peg$e13);
      }
      return s0;
    }
    function peg$parsewsp() {
      var s0;
      s0 = input.charAt(peg$currPos);
      if (peg$r3.test(s0)) peg$currPos++;
      else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) peg$fail(peg$e14);
      }
      return s0;
    }
    peg$result = peg$startRuleFunction();
    if (options.peg$library) return {
      peg$result,
      peg$currPos,
      peg$FAILED,
      peg$maxFailExpected,
      peg$maxFailPos
    };
    if (peg$result !== peg$FAILED && peg$currPos === input.length) return peg$result;
    else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());
      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }
  function fromTransformAttribute(transformString) {
    return peg$parse(transformString);
  }
  var YError = class YError2 extends Error {
    code;
    params;
    wrappedErrors;
    constructor(wrappedErrors, errorCode, ...params) {
      if (!(wrappedErrors instanceof Array)) {
        params = ("undefined" === typeof errorCode ? [] : [errorCode]).concat(params);
        errorCode = wrappedErrors;
        wrappedErrors = [];
      }
      super(errorCode);
      this.code = errorCode || "E_UNEXPECTED";
      this.params = params;
      this.wrappedErrors = wrappedErrors;
      this.name = this.toString();
      if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    }
    /**
    * Wraps any error and output a YError with an error
    *  code and some params as debug values.
    * @param {Error} err
    * The error to wrap
    * @param {string} [errorCode = 'E_UNEXPECTED']
    * The error code corresponding to the actual error
    * @param {...YErrorParams} [params]
    * Some additional debugging values
    * @return {YError}
    * The wrapped error
    */
    static wrap(err2, errorCode, ...params) {
      const wrappedErrorIsACode = _looksLikeAYErrorCode(err2.message);
      const wrappedErrors = ("wrappedErrors" in err2 ? err2.wrappedErrors : []).concat(err2);
      if (!errorCode) if (wrappedErrorIsACode) errorCode = err2.message;
      else errorCode = "E_UNEXPECTED";
      if (err2.message && !wrappedErrorIsACode) params.push(err2.message);
      return new YError2(wrappedErrors, errorCode, ...params);
    }
    /**
    * Return a YError as is or wraps any other error and output
    *  a YError with a code and some params as debug values.
    * @param {Error} err
    * The error to cast
    * @param {string} [errorCode = 'E_UNEXPECTED']
    * The error code corresponding to the actual error
    * @param {...YErrorParams} [params]
    * Some additional debugging values
    * @return {YError}
    * The wrapped error
    */
    static cast(err2, errorCode, ...params) {
      if (_looksLikeAYError(err2)) return err2;
      return YError2.wrap(err2, errorCode, ...params);
    }
    /**
    * Same than `YError.wrap()` but preserves the code
    *  and the debug values of the error if it is
    *  already an instance of the YError constructor.
    * @param {Error} err
    * The error to bump
    * @param {string} [errorCode = 'E_UNEXPECTED']
    * The error code corresponding to the actual error
    * @param {...YErrorParams} [params]
    * Some additional debugging values
    * @return {YError}
    * The wrapped error
    */
    static bump(err2, errorCode, ...params) {
      if (_looksLikeAYError(err2)) return YError2.wrap(err2, err2.code, ...err2.params);
      return YError2.wrap(err2, errorCode, ...params);
    }
    toString() {
      return (this.wrappedErrors.length ? this.wrappedErrors[this.wrappedErrors.length - 1].stack + import_os.default.EOL : "") + this.constructor.name + ": " + this.code + " (" + this.params.join(", ") + ")";
    }
  };
  function _looksLikeAYError(err2) {
    return !!(err2 instanceof YError) || !!(err2.constructor && err2.constructor.name && err2.constructor.name.endsWith("Error") && "code" in err2 && "string" === typeof err2.code && _looksLikeAYErrorCode(err2.code) && "params" in err2 && err2.params && err2.params instanceof Array);
  }
  function _looksLikeAYErrorCode(str) {
    return /^([A-Z0-9_]+)$/.test(str);
  }
  var require_ms = __commonJS2({ "node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports, module) {
    var s2 = 1e3;
    var m = s2 * 60;
    var h2 = m * 60;
    var d2 = h2 * 24;
    var w2 = d2 * 7;
    var y2 = d2 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) return parse(val);
      else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) return;
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) return;
      var n2 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y2;
        case "weeks":
        case "week":
        case "w":
          return n2 * w2;
        case "days":
        case "day":
        case "d":
          return n2 * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) return Math.round(ms / d2) + "d";
      if (msAbs >= h2) return Math.round(ms / h2) + "h";
      if (msAbs >= m) return Math.round(ms / m) + "m";
      if (msAbs >= s2) return Math.round(ms / s2) + "s";
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) return plural(ms, msAbs, d2, "day");
      if (msAbs >= h2) return plural(ms, msAbs, h2, "hour");
      if (msAbs >= m) return plural(ms, msAbs, m, "minute");
      if (msAbs >= s2) return plural(ms, msAbs, s2, "second");
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
    }
  } });
  var require_common2 = __commonJS2({ "node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js"(exports, module) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug$2(...args) {
          if (!debug$2.enabled) return;
          const self$1 = debug$2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self$1.diff = ms;
          self$1.prev = prevTime;
          self$1.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") args.unshift("%O");
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") return "%";
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self$1, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self$1, args);
          const logFn = self$1.log || createDebug.log;
          logFn.apply(self$1, args);
        }
        debug$2.namespace = namespace;
        debug$2.useColors = createDebug.useColors();
        debug$2.color = createDebug.selectColor(namespace);
        debug$2.extend = extend;
        debug$2.destroy = createDebug.destroy;
        Object.defineProperty(debug$2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) return enableOverride;
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug.init === "function") createDebug.init(debug$2);
        return debug$2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) if (ns[0] === "-") createDebug.skips.push(ns.slice(1));
        else createDebug.names.push(ns);
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) if (template[templateIndex] === "*") {
          starIndex = templateIndex;
          matchIndex = searchIndex;
          templateIndex++;
        } else {
          searchIndex++;
          templateIndex++;
        }
        else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else return false;
        while (templateIndex < template.length && template[templateIndex] === "*") templateIndex++;
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [...createDebug.names, ...createDebug.skips.map((namespace) => "-" + namespace)].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) if (matchesTemplate(name, skip)) return false;
        for (const ns of createDebug.names) if (matchesTemplate(name, ns)) return true;
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  } });
  var require_browser3 = __commonJS2({ "node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
      let m$1;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m$1 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m$1[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) return;
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") return;
        index++;
        if (match === "%c") lastC = index;
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) exports.storage.setItem("debug", namespaces);
        else exports.storage.removeItem("debug");
      } catch (error) {
      }
    }
    function load() {
      let r2;
      try {
        r2 = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r2 && typeof api !== "undefined" && "env" in api) r2 = api.env.DEBUG;
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common2()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  } });
  var import_browser$1 = __toESM2(require_browser3(), 1);
  var warn$1 = (0, import_browser$1.default)("svgicons2svgfont");
  var import_browser = __toESM2(require_browser3(), 1);
  var warn = (0, import_browser.default)("svgicons2svgfont");
  function matrixFromTransformAttribute(transformAttributeString) {
    return compose(fromDefinition(fromTransformAttribute(transformAttributeString)));
  }
  function tagShouldRender(curTag, parents) {
    let values;
    return !parents.some((tag) => {
      if ("undefined" !== typeof tag.attributes.display && "none" === tag.attributes.display.toLowerCase()) return true;
      if ("undefined" !== typeof tag.attributes.width && 0 === parseFloat(tag.attributes.width)) return true;
      if ("undefined" !== typeof tag.attributes.height && 0 === parseFloat(tag.attributes.height)) return true;
      if ("undefined" !== typeof tag.attributes.viewBox) {
        values = tag.attributes.viewBox.split(/\s*,*\s|\s,*\s*|,/);
        if (0 === parseFloat(values[2]) || 0 === parseFloat(values[3])) return true;
      }
      return false;
    });
  }
  function getTagColor(currTag, parents) {
    const defaultColor = "black";
    const fillVal = currTag.attributes.fill;
    let color;
    const parentsLength = parents.length;
    if ("none" === fillVal) return color;
    if ("currentColor" === fillVal) return defaultColor;
    if ("inherit" === fillVal) {
      if (0 === parentsLength) return defaultColor;
      return getTagColor(parents[parentsLength - 1], parents.slice(0, parentsLength - 1));
    }
    return fillVal;
  }
  var SVGIcons2SVGFontStream = class extends import_stream.Transform {
    _options;
    glyphs;
    constructor(options) {
      super({ objectMode: true });
      this.glyphs = [];
      this._options = {
        ...options,
        fontName: options.fontName || "iconfont",
        fontId: options.fontId || options.fontName || "iconfont",
        fixedWidth: options.fixedWidth || false,
        descent: options.descent || 0,
        round: options.round || 1e13,
        metadata: options.metadata || "",
        usePathBounds: options.usePathBounds || false
      };
    }
    _transform(svgIconStream, _unused, svgIconStreamCallback) {
      const saxStream = import_sax.default.createStream(true);
      const parents = [];
      const transformStack = [];
      function applyTransform(d$1) {
        const last = transformStack[transformStack.length - 1];
        if (!last) return new SVGPathData(d$1);
        return new SVGPathData(d$1).matrix(last.a, last.b, last.c, last.d, last.e, last.f);
      }
      const glyph = svgIconStream.metadata || {};
      glyph.width = 0;
      glyph.height = 1;
      glyph.paths = [];
      this.glyphs.push(glyph);
      if ("string" !== typeof glyph.name) this.emit("error", new Error(`Please provide a name for the glyph at index ${this.glyphs.length - 1}`));
      if (this.glyphs.some((anotherGlyph) => anotherGlyph !== glyph && anotherGlyph.name === glyph.name)) this.emit("error", new Error(`The glyph name "${glyph.name}" must be unique.`));
      if (glyph.unicode && glyph.unicode instanceof Array && glyph.unicode.length) {
        if (glyph.unicode.some((unicodeA, i2) => glyph.unicode.some((unicodeB, j) => i2 !== j && unicodeA === unicodeB))) this.emit("error", new Error(`Given codepoints for the glyph "${glyph.name}" contain duplicates.`));
      } else if ("string" !== typeof glyph.unicode) this.emit("error", new Error(`Please provide a codepoint for the glyph "${glyph.name}"`));
      if (this.glyphs.some((anotherGlyph) => anotherGlyph !== glyph && anotherGlyph.unicode === glyph.unicode)) this.emit("error", new Error(`The glyph "${glyph.name}" codepoint seems to be used already elsewhere.`));
      saxStream.on("opentag", (tag) => {
        let values;
        let color;
        parents.push(tag);
        try {
          const currentTransform = transformStack[transformStack.length - 1];
          if ("undefined" !== typeof tag.attributes.transform) {
            const transform$1 = matrixFromTransformAttribute(tag.attributes.transform);
            transformStack.push(compose([currentTransform, transform$1].filter(Boolean)));
          } else transformStack.push(currentTransform);
          if (!tagShouldRender(tag, parents)) return;
          if ("svg" === tag.name) if ("viewBox" in tag.attributes) {
            values = tag.attributes.viewBox.split(/\s*,*\s|\s,*\s*|,/);
            const dX = parseFloat(values[0]);
            const dY = parseFloat(values[1]);
            const width = parseFloat(values[2]);
            const height = parseFloat(values[3]);
            glyph.width = "width" in tag.attributes ? parseFloat(tag.attributes.width) : width;
            glyph.height = "height" in tag.attributes ? parseFloat(tag.attributes.height) : height;
            transformStack[transformStack.length - 1] = compose([
              transformStack[transformStack.length - 1],
              translate(-dX, -dY),
              scale(glyph.width / width, glyph.height / height)
            ].filter(Boolean));
          } else {
            if ("width" in tag.attributes) glyph.width = parseFloat(tag.attributes.width);
            else {
              warn(`\u26A0\uFE0F - Glyph "${glyph.name}" has no width attribute, using current glyph horizontal bounds.`);
              glyph.defaultWidth = true;
            }
            if ("height" in tag.attributes) glyph.height = parseFloat(tag.attributes.height);
            else {
              warn(`\u26A0\uFE0F - Glyph "${glyph.name}" has no height attribute, using current glyph vertical bounds.`);
              glyph.defaultHeight = true;
            }
          }
          else if ("clipPath" === tag.name) warn(`\u{1F937} - Found a clipPath element in the icon "${glyph.name}" the result may be different than expected.`);
          else if ("rect" === tag.name && "none" !== tag.attributes.fill) glyph.paths.push(applyTransform(svgshapes2svgpath_default.rectToPath(tag.attributes)));
          else if ("line" === tag.name && "none" !== tag.attributes.fill) {
            warn(`\u{1F937} - Found a line element in the icon "${glyph.name}" the result could be different than expected.`);
            glyph.paths.push(applyTransform(svgshapes2svgpath_default.lineToPath(tag.attributes)));
          } else if ("polyline" === tag.name && "none" !== tag.attributes.fill) {
            warn(`\u{1F937} - Found a polyline element in the icon "${glyph.name}" the result could be different than expected.`);
            glyph.paths.push(applyTransform(svgshapes2svgpath_default.polylineToPath(tag.attributes)));
          } else if ("polygon" === tag.name && "none" !== tag.attributes.fill) glyph.paths.push(applyTransform(svgshapes2svgpath_default.polygonToPath(tag.attributes)));
          else if (["circle", "ellipse"].includes(tag.name) && "none" !== tag.attributes.fill) glyph.paths.push(applyTransform(svgshapes2svgpath_default.circleToPath(tag.attributes)));
          else if ("path" === tag.name && tag.attributes.d && "none" !== tag.attributes.fill) glyph.paths.push(applyTransform(tag.attributes.d));
          if ("none" !== tag.attributes.fill) {
            color = getTagColor(tag, parents);
            if ("undefined" !== typeof color) glyph.color = color;
          }
        } catch (err2) {
          this.emit("error", new Error(`Got an error parsing the glyph "${glyph.name}": ${err2?.message}.`));
        }
      });
      saxStream.on("error", (err2) => {
        this.emit("error", err2);
      });
      saxStream.on("closetag", () => {
        transformStack.pop();
        parents.pop();
      });
      saxStream.on("end", () => {
        svgIconStreamCallback();
      });
      svgIconStream.pipe(saxStream);
    }
    _flush(svgFontFlushCallback) {
      this.glyphs.forEach((glyph) => {
        if (glyph.defaultHeight || glyph.defaultWidth || this._options.usePathBounds) {
          const glyphPath = new SVGPathData("");
          (glyph.paths || []).forEach((path) => {
            glyphPath.commands.push(...path.commands);
          });
          const bounds = glyphPath.getBounds();
          if (glyph.defaultHeight || this._options.usePathBounds) glyph.height = bounds.maxY - bounds.minY;
          if (glyph.defaultWidth || this._options.usePathBounds) glyph.width = bounds.maxX - bounds.minX;
        }
      });
      const maxGlyphHeight = this.glyphs.reduce((curMax, glyph) => Math.max(curMax, glyph.height), 0);
      const maxGlyphWidth = this.glyphs.reduce((curMax, glyph) => Math.max(curMax, glyph.width), 0);
      const fontHeight = this._options.fontHeight || maxGlyphHeight;
      let fontWidth = maxGlyphWidth;
      if (this._options.normalize) fontWidth = this.glyphs.reduce((curMax, glyph) => Math.max(curMax, fontHeight / glyph.height * glyph.width), 0);
      else if (this._options.fontHeight) fontWidth *= fontHeight / maxGlyphHeight;
      this._options.ascent = "undefined" !== typeof this._options.ascent ? this._options.ascent : fontHeight - this._options.descent;
      if (!this._options.normalize && fontHeight > (1 < this.glyphs.length ? this.glyphs.reduce((curMin, glyph) => Math.min(curMin, glyph.height), Infinity) : this.glyphs[0].height)) warn("\u{1F937} - The provided icons do not have the same heights. This could lead to unexpected results. Using the normalize option may help.");
      if (1e3 > fontHeight) warn("\u{1F937} - A fontHeight of at least than 1000 is recommended, otherwise further steps (rounding in svg2ttf) could lead to ugly results. Use the fontHeight option to scale icons.");
      this.push('<?xml version="1.0" standalone="no"?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd" >\n<svg xmlns="http://www.w3.org/2000/svg">\n' + (this._options.metadata ? "<metadata>" + this._options.metadata + "</metadata>\n" : "") + '<defs>\n  <font id="' + this._options.fontId + '" horiz-adv-x="' + fontWidth + '">\n    <font-face font-family="' + this._options.fontName + '"\n      units-per-em="' + fontHeight + '" ascent="' + this._options.ascent + '"\n      descent="' + this._options.descent + '"' + (this._options.fontWeight ? '\n      font-weight="' + this._options.fontWeight + '"' : "") + (this._options.fontStyle ? '\n      font-style="' + this._options.fontStyle + '"' : "") + ' />\n    <missing-glyph horiz-adv-x="0" />\n');
      this.glyphs.forEach((glyph) => {
        const ratio = this._options.normalize ? fontHeight / (this._options.preserveAspectRatio && glyph.width > glyph.height ? glyph.width : glyph.height) : fontHeight / maxGlyphHeight;
        if (!isFinite(ratio)) throw new YError("E_BAD_COMPUTED_RATIO", ratio);
        glyph.width *= ratio;
        glyph.height *= ratio;
        const glyphPath = new SVGPathData("");
        if (this._options.fixedWidth) glyph.width = fontWidth;
        const yOffset = glyph.height - this._options.descent;
        let glyphPathTransform = {
          a: 1,
          b: 0,
          c: 0,
          d: -1,
          e: 0,
          f: yOffset
        };
        if (1 !== ratio) glyphPathTransform = compose(glyphPathTransform, scale(ratio, ratio));
        (glyph.paths || []).forEach((path) => {
          glyphPath.commands.push(...path.toAbs().matrix(glyphPathTransform.a, glyphPathTransform.b, glyphPathTransform.c, glyphPathTransform.d, glyphPathTransform.e, glyphPathTransform.f).commands);
        });
        const bounds = (this._options.centerHorizontally || this._options.centerVertically) && glyphPath.getBounds();
        if (this._options.centerHorizontally && bounds && "maxX" in bounds) glyphPath.translate((glyph.width - (bounds.maxX - bounds.minX)) / 2 - bounds.minX);
        if (this._options.centerVertically && bounds && "maxX" in bounds) glyphPath.translate(0, (fontHeight - (bounds.maxY - bounds.minY)) / 2 - bounds.minY - this._options.descent);
        delete glyph.paths;
        const d$1 = glyphPath.round(this._options.round).encode();
        glyph.unicode.forEach((unicode, i2) => {
          const unicodeStr = [...unicode].map((char) => "&#x" + char.codePointAt(0).toString(16).toUpperCase() + ";").join("");
          this.push('    <glyph glyph-name="' + glyph.name + (0 === i2 ? "" : "-" + i2) + '"\n      unicode="' + unicodeStr + '"\n      horiz-adv-x="' + glyph.width + '" d="' + d$1 + '" />\n');
        });
      });
      this.push("  </font>\n</defs>\n</svg>\n");
      warn("\u2705 - Font created");
      if ("function" === typeof this._options.callback) this._options.callback(this.glyphs);
      svgFontFlushCallback();
    }
  };
  var FileExtensions = [
    "eot",
    "ttf",
    "woff",
    "woff2",
    "svg",
    "css",
    "demoHTML"
  ];
  async function SvgPacker({ icons, ...options }) {
    const { fontName = "iconfont", cssPrefix = "iconfont", fileName = "iconfont", startCodepoint = 57345, fontHeight = 1e3, descent = 0, fixedWidth = false } = options ?? {};
    const parsedIcons = icons.map(({ svg, name, unicode }, i2) => {
      return {
        svg,
        name,
        unicode: unicode ?? startCodepoint + i2
      };
    });
    const iconStreams = parsedIcons.map(({ svg, unicode, name }) => {
      const iconStream = new import_node_stream.PassThrough();
      iconStream.write(svg, "utf8");
      iconStream.end();
      iconStream.metadata = {
        unicode: [String.fromCharCode(unicode)],
        name
      };
      return iconStream;
    });
    const files = {};
    const zip = await A(generateZipEntries(iconStreams, {
      fontName,
      cssPrefix,
      fileName,
      startCodepoint,
      fontHeight,
      descent,
      fixedWidth,
      icons: parsedIcons
    }, files)).blob();
    return {
      files,
      zip: {
        name: `${options.fileName}.zip`,
        blob: zip,
        url: makeUrl(zip)
      }
    };
  }
  function addFile(files, filename, ext, data, mime = "text/plain") {
    const blob = new Blob([data], { type: mime });
    files[ext] = {
      name: filename,
      blob,
      url: makeUrl(blob)
    };
    return {
      name: filename,
      input: blob,
      url: makeUrl(blob)
    };
  }
  function makeUrl(blob) {
    if (typeof window === "undefined" || !window.URL || !window.URL.createObjectURL) return null;
    return window.URL.createObjectURL(blob);
  }
  function makeSVG(iconStreams, options) {
    return new Promise((resolve) => {
      const fontStream = new SVGIcons2SVGFontStream(options);
      const parts = [];
      const decoder = new import_node_string_decoder.StringDecoder("utf8");
      fontStream.on("data", (chunk) => {
        parts.push(decoder.write(chunk));
      });
      fontStream.on("finish", () => {
        resolve(parts.join(""));
      });
      iconStreams.forEach(fontStream.write.bind(fontStream));
      fontStream.end();
    });
  }
  function makeTTF(svgFont) {
    const ttfFontBuffer = (0, import_svg2ttf.default)(svgFont).buffer;
    return ttfFontBuffer;
  }
  function makeEOT(ttfFontBuffer) {
    const eotFontBuffer = (0, import_ttf2eot.default)(ttfFontBuffer).buffer;
    return eotFontBuffer;
  }
  function makeWOFF(ttfFontBuffer) {
    const woffFontBuffer = (0, import_ttf2woff.default)(new Uint8Array(ttfFontBuffer.buffer)).buffer;
    return woffFontBuffer;
  }
  async function browserPromise() {
    const [{ wasmUrl: wasmUrl3 }, { initWasmBrowser: initWasmBrowser2, ttf2woff2: ttf2woff23 }] = await Promise.all([Promise.resolve().then(() => (init_ttf2woff2_wasm_D9pC94Jv(), ttf2woff2_wasm_D9pC94Jv_exports)), Promise.resolve().then(() => (init_wasm_0jzfuaTN(), wasm_0jzfuaTN_exports))]);
    await initWasmBrowser2(wasmUrl3);
    return ttf2woff23;
  }
  async function preloadWasm() {
    var _process$versions;
    const isNode = typeof process_exports < "u" && typeof void 0 < "u" && !((_process$versions = versions) === null || _process$versions === void 0 ? void 0 : _process$versions.deno) && !globalThis.window;
    return isNode ? await Promise.resolve().then(() => (init_jssrc(), jssrc_exports)).then((m$1) => {
      return m$1.default || m$1;
    }).catch((e2) => {
      console.error("ERROR", e2);
      Promise.reject(e2);
    }) : await browserPromise();
  }
  async function makeWOFF2(ttfFontBuffer) {
    ttfFontBuffer = new Uint8Array(ttfFontBuffer);
    let buf = buffer.Buffer.alloc(ttfFontBuffer.length);
    for (let i2 = 0, j = ttfFontBuffer.length; i2 < j; i2++) buf.writeUInt8(ttfFontBuffer[i2], i2);
    const ttf2woff23 = await preloadWasm();
    if (!ttf2woff23 || !(typeof ttf2woff23 === "function")) throw new Error("ttf2woff2 not found");
    if (ttf2woff23 instanceof Error) throw ttf2woff23;
    buf = ttf2woff23(buf);
    const woff2FontBuffer = new Uint8Array(buf.length);
    for (let i2 = 0, j = buf.length; i2 < j; i2++) woff2FontBuffer[i2] = buf.readUInt8(i2);
    return woff2FontBuffer;
  }
  function makeCSS({ icons, fontName, fileName, cssPrefix }) {
    const css = `
@font-face {
  font-family: "${fontName}";
  src: url("./${fileName}.eot");
  src: url("./${fileName}.eot") format("embedded-opentype"),
       url("./${fileName}.ttf") format("truetype"),
       url("./${fileName}.woff") format("woff"),
       url("./${fileName}.woff2") format("woff2"),
       url("./${fileName}.svg") format("svg");
  font-weight: normal;
  font-style: normal;
}

.${cssPrefix} {
  font-family: "${fontName}" !important;
  font-size: 1em;
  font-style: normal;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

${icons.map(({ name, unicode }) => `
.${cssPrefix}.${name.replace(/:/g, "\\:")}:before {
content: "\\${unicode.toString(16)}";
}
`).join("")}
`;
    return css;
  }
  function makeDemoHTML({ icons, fontName, fileName, cssPrefix }) {
    return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>${fontName} Demo</title>
  <link rel="stylesheet" href="./${fileName}.css">
  <style>
html {
  font-size: 1.2em;
}
i {
  padding: 5px;
  color: #717171;
  display: inline-block;
}
  </style>
</head>
<body>
${icons.map(({ name }) => `<i class="${cssPrefix} ${name}"></i>`).join("")}
<!-- Generated by SVG Pack (https://github.com/antfu/svg-packer) -->
</body>
`;
  }
  async function* generateZipEntries(iconStreams, options, files) {
    const content = await makeSVG(iconStreams, options);
    yield addFile(files, `${options.fileName}.svg`, "svg", content, "image/svg+xml");
    const ttfFontBuffer = makeTTF(content);
    yield addFile(files, `${options.fileName}.ttf`, "ttf", ttfFontBuffer, "application/octet-stream");
    yield addFile(files, `${options.fileName}.eot`, "eot", makeEOT(ttfFontBuffer), "application/octet-stream");
    yield addFile(files, `${options.fileName}.woff`, "woff", makeWOFF(ttfFontBuffer), "application/octet-stream");
    yield addFile(files, `${options.fileName}.woff2`, "woff2", await makeWOFF2(ttfFontBuffer), "application/octet-stream");
    yield addFile(files, `${options.fileName}.css`, "css", makeCSS(options), "text/css");
    yield addFile(files, "_demo.html", "demoHTML", makeDemoHTML(options), "text/html");
  }
  if (typeof window !== "undefined") window.SvgPacker = SvgPacker;
  if (typeof self !== "undefined") self.SvgPacker = SvgPacker;
  if (typeof globalThis !== "undefined") globalThis.SvgPacker = SvgPacker;
  return __toCommonJS(index_exports).SvgPacker;
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
*/
