import * as buffer from "node:buffer";
import * as process$1 from "node:process";
import { PassThrough } from "node:stream";
import { StringDecoder } from "node:string_decoder";
import { downloadZip } from "client-zip";
import svg2ttf from "svg2ttf";
import { Transform } from "stream";
import Sax from "sax";
import os from "os";
import "node:fs";
import "node:path";
import ttf2eot from "ttf2eot";
import ttf2woff from "ttf2woff";

//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
//#region node_modules/.pnpm/svg-pathdata@7.2.0/node_modules/svg-pathdata/dist/SVGPathDataEncoder.js
const WSP = " ";
function encodeSVGPath(commands) {
	let str = "";
	if (!Array.isArray(commands)) commands = [commands];
	for (let i = 0; i < commands.length; i++) {
		const command = commands[i];
		if (command.type === SVGPathData.CLOSE_PATH) str += "z";
		else if (command.type === SVGPathData.HORIZ_LINE_TO) str += (command.relative ? "h" : "H") + command.x;
		else if (command.type === SVGPathData.VERT_LINE_TO) str += (command.relative ? "v" : "V") + command.y;
		else if (command.type === SVGPathData.MOVE_TO) str += (command.relative ? "m" : "M") + command.x + WSP + command.y;
		else if (command.type === SVGPathData.LINE_TO) str += (command.relative ? "l" : "L") + command.x + WSP + command.y;
		else if (command.type === SVGPathData.CURVE_TO) str += (command.relative ? "c" : "C") + command.x1 + WSP + command.y1 + WSP + command.x2 + WSP + command.y2 + WSP + command.x + WSP + command.y;
		else if (command.type === SVGPathData.SMOOTH_CURVE_TO) str += (command.relative ? "s" : "S") + command.x2 + WSP + command.y2 + WSP + command.x + WSP + command.y;
		else if (command.type === SVGPathData.QUAD_TO) str += (command.relative ? "q" : "Q") + command.x1 + WSP + command.y1 + WSP + command.x + WSP + command.y;
		else if (command.type === SVGPathData.SMOOTH_QUAD_TO) str += (command.relative ? "t" : "T") + command.x + WSP + command.y;
		else if (command.type === SVGPathData.ARC) str += (command.relative ? "a" : "A") + command.rX + WSP + command.rY + WSP + command.xRot + WSP + +command.lArcFlag + WSP + +command.sweepFlag + WSP + command.x + WSP + command.y;
		else throw new Error(`Unexpected command type "${command?.type}" at index ${i}.`);
	}
	return str;
}

//#endregion
//#region node_modules/.pnpm/svg-pathdata@7.2.0/node_modules/svg-pathdata/dist/mathUtils.js
function rotate$1([x, y$1], rad) {
	return [x * Math.cos(rad) - y$1 * Math.sin(rad), x * Math.sin(rad) + y$1 * Math.cos(rad)];
}
const DEBUG_CHECK_NUMBERS = true;
function assertNumbers(...numbers) {
	if (DEBUG_CHECK_NUMBERS) {
		for (let i = 0; i < numbers.length; i++) if ("number" !== typeof numbers[i]) throw new Error(`assertNumbers arguments[${i}] is not a number. ${typeof numbers[i]} == typeof ${numbers[i]}`);
	}
	return true;
}
const PI$1 = Math.PI;
/**
* https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
* Fixes rX and rY.
* Ensures lArcFlag and sweepFlag are 0 or 1
* Adds center coordinates: command.cX, command.cY (relative or absolute, depending on command.relative)
* Adds start and end arc parameters (in degrees): command.phi1, command.phi2; phi1 < phi2 iff. c.sweepFlag == true
*/
function annotateArcCommand(c, x1, y1) {
	c.lArcFlag = 0 === c.lArcFlag ? 0 : 1;
	c.sweepFlag = 0 === c.sweepFlag ? 0 : 1;
	let { rX, rY } = c;
	const { x, y: y$1 } = c;
	if (Math.abs(rX) < 1e-10 || Math.abs(rY) < 1e-10) {
		c.rX = 0;
		c.rY = 0;
		c.cX = (x1 + x) / 2;
		c.cY = (y1 + y$1) / 2;
		c.phi1 = 0;
		c.phi2 = 0;
		return;
	}
	rX = Math.abs(c.rX);
	rY = Math.abs(c.rY);
	const xRotRad = c.xRot / 180 * PI$1;
	const [x1_, y1_] = rotate$1([(x1 - x) / 2, (y1 - y$1) / 2], -xRotRad);
	const testValue = Math.pow(x1_, 2) / Math.pow(rX, 2) + Math.pow(y1_, 2) / Math.pow(rY, 2);
	if (1 < testValue) {
		rX *= Math.sqrt(testValue);
		rY *= Math.sqrt(testValue);
	}
	c.rX = rX;
	c.rY = rY;
	const c_ScaleTemp = Math.pow(rX, 2) * Math.pow(y1_, 2) + Math.pow(rY, 2) * Math.pow(x1_, 2);
	const c_Scale = (c.lArcFlag !== c.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(rX, 2) * Math.pow(rY, 2) - c_ScaleTemp) / c_ScaleTemp));
	const cx_ = rX * y1_ / rY * c_Scale;
	const cy_ = -rY * x1_ / rX * c_Scale;
	const cRot = rotate$1([cx_, cy_], xRotRad);
	c.cX = cRot[0] + (x1 + x) / 2;
	c.cY = cRot[1] + (y1 + y$1) / 2;
	c.phi1 = Math.atan2((y1_ - cy_) / rY, (x1_ - cx_) / rX);
	c.phi2 = Math.atan2((-y1_ - cy_) / rY, (-x1_ - cx_) / rX);
	if (0 === c.sweepFlag && c.phi2 > c.phi1) c.phi2 -= 2 * PI$1;
	if (1 === c.sweepFlag && c.phi2 < c.phi1) c.phi2 += 2 * PI$1;
	c.phi1 *= 180 / PI$1;
	c.phi2 *= 180 / PI$1;
}
/**
* Solves a quadratic system of equations of the form
*      a * x + b * y = c
*      x² + y² = 1
* This can be understood as the intersection of the unit circle with a line.
*      => y = (c - a x) / b
*      => x² + (c - a x)² / b² = 1
*      => x² b² + c² - 2 c a x + a² x² = b²
*      => (a² + b²) x² - 2 a c x + (c² - b²) = 0
*/
function intersectionUnitCircleLine(a, b, c) {
	assertNumbers(a, b, c);
	const termSqr = a * a + b * b - c * c;
	if (0 > termSqr) return [];
	else if (0 === termSqr) return [[a * c / (a * a + b * b), b * c / (a * a + b * b)]];
	const term = Math.sqrt(termSqr);
	return [[(a * c + b * term) / (a * a + b * b), (b * c - a * term) / (a * a + b * b)], [(a * c - b * term) / (a * a + b * b), (b * c + a * term) / (a * a + b * b)]];
}
const DEG = Math.PI / 180;
function lerp(a, b, t) {
	return (1 - t) * a + t * b;
}
function arcAt(c, x1, x2, phiDeg) {
	return c + Math.cos(phiDeg / 180 * PI$1) * x1 + Math.sin(phiDeg / 180 * PI$1) * x2;
}
function bezierRoot(x0, x1, x2, x3) {
	const EPS = 1e-6;
	const x01 = x1 - x0;
	const x12 = x2 - x1;
	const x23 = x3 - x2;
	const a = 3 * x01 + 3 * x23 - 6 * x12;
	const b = (x12 - x01) * 6;
	const c = 3 * x01;
	if (Math.abs(a) < EPS) return Math.abs(b) < EPS ? [] : [-c / b];
	return pqFormula(b / a, c / a, EPS);
}
function bezierAt(x0, x1, x2, x3, t) {
	const s$1 = 1 - t;
	const c0 = s$1 * s$1 * s$1;
	const c1 = 3 * s$1 * s$1 * t;
	const c2 = 3 * s$1 * t * t;
	const c3 = t * t * t;
	return x0 * c0 + x1 * c1 + x2 * c2 + x3 * c3;
}
function pqFormula(p, q, PRECISION = 1e-6) {
	const discriminantX4 = p * p / 4 - q;
	if (discriminantX4 < -PRECISION) return [];
	else if (discriminantX4 <= PRECISION) return [-p / 2];
	const root = Math.sqrt(discriminantX4);
	return [-(p / 2) - root, -(p / 2) + root];
}
function a2c(arc, x0, y0) {
	if (!arc.cX) annotateArcCommand(arc, x0, y0);
	const xRotRad = arc.xRot / 180 * PI$1;
	if (Math.abs(arc.rX) < 1e-10 || Math.abs(arc.rY) < 1e-10) return [{
		relative: arc.relative,
		type: SVGPathData.CURVE_TO,
		x1: x0 + (arc.x - x0) / 3,
		y1: y0 + (arc.y - y0) / 3,
		x2: x0 + 2 * (arc.x - x0) / 3,
		y2: y0 + 2 * (arc.y - y0) / 3,
		x: arc.x,
		y: arc.y
	}];
	const phiMin = Math.min(arc.phi1, arc.phi2), phiMax = Math.max(arc.phi1, arc.phi2), deltaPhi = phiMax - phiMin;
	const partCount = Math.ceil(deltaPhi / 90);
	const result = new Array(partCount);
	let prevX = x0;
	let prevY = y0;
	const transform$1 = (x, y$1) => {
		const [xTemp, yTemp] = rotate$1([x * arc.rX, y$1 * arc.rY], xRotRad);
		return [arc.cX + xTemp, arc.cY + yTemp];
	};
	for (let i = 0; i < partCount; i++) {
		const phiStart = lerp(arc.phi1, arc.phi2, i / partCount);
		const phiEnd = lerp(arc.phi1, arc.phi2, (i + 1) / partCount);
		const deltaPhi$1 = phiEnd - phiStart;
		const f = 4 / 3 * Math.tan(deltaPhi$1 * DEG / 4);
		const x1 = Math.cos(phiStart * DEG) - f * Math.sin(phiStart * DEG);
		const y1 = Math.sin(phiStart * DEG) + f * Math.cos(phiStart * DEG);
		const x = Math.cos(phiEnd * DEG);
		const y$1 = Math.sin(phiEnd * DEG);
		const x2 = x + f * y$1;
		const y2 = y$1 - f * x;
		const cp1 = transform$1(x1, y1);
		const cp2 = transform$1(x2, y2);
		const end = transform$1(x, y$1);
		const command = {
			relative: arc.relative,
			type: SVGPathData.CURVE_TO,
			x: end[0],
			y: end[1],
			x1: cp1[0],
			y1: cp1[1],
			x2: cp2[0],
			y2: cp2[1]
		};
		if (arc.relative) {
			command.x1 -= prevX;
			command.y1 -= prevY;
			command.x2 -= prevX;
			command.y2 -= prevY;
			command.x -= prevX;
			command.y -= prevY;
		}
		prevX = end[0];
		prevY = end[1];
		result[i] = command;
	}
	return result;
}
/**
* Determines if three points are collinear (lie on the same straight line)
* and the middle point is on the line segment between the first and third points
*
* @param p1 First point [x, y]
* @param p2 Middle point that might be removed
* @param p3 Last point [x, y]
* @returns true if the points are collinear and p2 is on the segment p1-p3
*/
function arePointsCollinear(p1, p2, p3) {
	const v1x = p2[0] - p1[0];
	const v1y = p2[1] - p1[1];
	const v2x = p3[0] - p1[0];
	const v2y = p3[1] - p1[1];
	const cross = v1x * v2y - v1y * v2x;
	const isCollinear = Math.abs(cross) < 1e-10;
	if (!isCollinear) return false;
	const dot = v1x * v2x + v1y * v2y;
	const lenSqV1 = v1x * v1x + v1y * v1y;
	const lenSqV2 = v2x * v2x + v2y * v2y;
	return 0 <= dot && dot <= lenSqV2 && lenSqV1 <= lenSqV2;
}

//#endregion
//#region node_modules/.pnpm/svg-pathdata@7.2.0/node_modules/svg-pathdata/dist/transformers/reverse_path.js
/**
* Reverses the order of path commands to go from end to start
* IMPORTANT: This function expects absolute commands as input.
* It doesn't convert relative to absolute - use SVGPathDataTransformer.TO_ABS() first if needed.
* @param commands SVG path commands in absolute form to reverse
* @param preserveSubpathOrder If true, keeps subpaths in their original order
* @returns New SVG commands in reverse order with absolute coordinates
*/
function REVERSE_PATH(commands, preserveSubpathOrder = true) {
	if (commands.length < 2) return commands;
	const normalized = SVGPathDataTransformer.INFO((command, px, py) => ({
		...command,
		x: command.x ?? px,
		y: command.y ?? py,
		relative: command.relative ?? false
	}));
	const result = [];
	let processing = [];
	for (const original of commands) {
		const cmd = normalized(original);
		if (cmd.type === SVGPathData.MOVE_TO && processing.length > 0) {
			if (preserveSubpathOrder) result.push(...reverseSubpath(processing));
			else result.unshift(...reverseSubpath(processing));
			processing = [];
		}
		processing.push(cmd);
	}
	if (processing.length > 0) if (preserveSubpathOrder) result.push(...reverseSubpath(processing));
	else result.unshift(...reverseSubpath(processing));
	return result;
}
function reverseSubpath(commands) {
	const isExplicitlyClosed = commands[commands.length - 1]?.type === SVGPathData.CLOSE_PATH;
	const startPointIndex = isExplicitlyClosed ? commands.length - 2 : commands.length - 1;
	const reversed = [{
		type: SVGPathData.MOVE_TO,
		relative: false,
		x: commands[startPointIndex].x,
		y: commands[startPointIndex].y
	}];
	for (let i = startPointIndex; i > 0; i--) {
		const curCmd = commands[i];
		const prevPoint = commands[i - 1];
		if (curCmd.relative) throw new Error("Relative command are not supported convert first with `toAbs()`");
		switch (curCmd.type) {
			case SVGPathData.HORIZ_LINE_TO:
				reversed.push({
					type: SVGPathData.HORIZ_LINE_TO,
					relative: false,
					x: prevPoint.x
				});
				break;
			case SVGPathData.VERT_LINE_TO:
				reversed.push({
					type: SVGPathData.VERT_LINE_TO,
					relative: false,
					y: prevPoint.y
				});
				break;
			case SVGPathData.LINE_TO:
			case SVGPathData.MOVE_TO:
				reversed.push({
					type: SVGPathData.LINE_TO,
					relative: false,
					x: prevPoint.x,
					y: prevPoint.y
				});
				break;
			case SVGPathData.CURVE_TO:
				reversed.push({
					type: SVGPathData.CURVE_TO,
					relative: false,
					x: prevPoint.x,
					y: prevPoint.y,
					x1: curCmd.x2,
					y1: curCmd.y2,
					x2: curCmd.x1,
					y2: curCmd.y1
				});
				break;
			case SVGPathData.SMOOTH_CURVE_TO: throw new Error(`Unsupported command: S (smooth cubic bezier)`);
			case SVGPathData.SMOOTH_QUAD_TO: throw new Error(`Unsupported command: T (smooth quadratic bezier)`);
			case SVGPathData.ARC: throw new Error(`Unsupported command: A (arc)`);
			case SVGPathData.QUAD_TO: throw new Error(`Unsupported command: Q (quadratic bezier)`);
		}
	}
	if (isExplicitlyClosed) reversed.push({ type: SVGPathData.CLOSE_PATH });
	return reversed;
}

//#endregion
//#region node_modules/.pnpm/svg-pathdata@7.2.0/node_modules/svg-pathdata/dist/SVGPathDataTransformer.js
function ROUND(roundVal = 1e13) {
	assertNumbers(roundVal);
	function rf(val) {
		return Math.round(val * roundVal) / roundVal;
	}
	return function round(command) {
		if ("x1" in command && "undefined" !== typeof command.x1) command.x1 = rf(command.x1);
		if ("y1" in command && "undefined" !== typeof command.y1) command.y1 = rf(command.y1);
		if ("x2" in command && "undefined" !== typeof command.x2) command.x2 = rf(command.x2);
		if ("y2" in command && "undefined" !== typeof command.y2) command.y2 = rf(command.y2);
		if ("x" in command && "undefined" !== typeof command.x) command.x = rf(command.x);
		if ("y" in command && "undefined" !== typeof command.y) command.y = rf(command.y);
		if ("rX" in command && "undefined" !== typeof command.rX) command.rX = rf(command.rX);
		if ("rY" in command && "undefined" !== typeof command.rY) command.rY = rf(command.rY);
		return command;
	};
}
function TO_ABS() {
	return INFO((command, prevX, prevY) => {
		if (command.relative) {
			if ("undefined" !== typeof command.x1) command.x1 += prevX;
			if ("undefined" !== typeof command.y1) command.y1 += prevY;
			if ("undefined" !== typeof command.x2) command.x2 += prevX;
			if ("undefined" !== typeof command.y2) command.y2 += prevY;
			if ("undefined" !== typeof command.x) command.x += prevX;
			if ("undefined" !== typeof command.y) command.y += prevY;
			command.relative = false;
		}
		return command;
	});
}
function TO_REL() {
	return INFO((command, prevX, prevY) => {
		if (!command.relative) {
			if ("undefined" !== typeof command.x1) command.x1 -= prevX;
			if ("undefined" !== typeof command.y1) command.y1 -= prevY;
			if ("undefined" !== typeof command.x2) command.x2 -= prevX;
			if ("undefined" !== typeof command.y2) command.y2 -= prevY;
			if ("undefined" !== typeof command.x) command.x -= prevX;
			if ("undefined" !== typeof command.y) command.y -= prevY;
			command.relative = true;
		}
		return command;
	});
}
function NORMALIZE_HVZ(normalizeZ = true, normalizeH = true, normalizeV = true, normalizeC = true) {
	return INFO((command, prevX, prevY, pathStartX, pathStartY) => {
		if (isNaN(pathStartX) && !(command.type & SVGPathData.MOVE_TO)) throw new Error("path must start with moveto");
		if (normalizeH && command.type & SVGPathData.HORIZ_LINE_TO) {
			command.type = SVGPathData.LINE_TO;
			command.y = command.relative ? 0 : prevY;
		}
		if (normalizeV && command.type & SVGPathData.VERT_LINE_TO) {
			command.type = SVGPathData.LINE_TO;
			command.x = command.relative ? 0 : prevX;
		}
		if (normalizeZ && command.type & SVGPathData.CLOSE_PATH) {
			command.type = SVGPathData.LINE_TO;
			command.x = command.relative ? pathStartX - prevX : pathStartX;
			command.y = command.relative ? pathStartY - prevY : pathStartY;
		}
		if (command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY)) {
			command.type = SVGPathData.LINE_TO;
			delete command.rX;
			delete command.rY;
			delete command.xRot;
			delete command.lArcFlag;
			delete command.sweepFlag;
		}
		if (normalizeC && command.type & SVGPathData.QUAD_TO) {
			const startPoint = [prevX, prevY];
			const controlPoint = command.relative ? [prevX + command.x1, prevY + command.y1] : [command.x1, command.y1];
			const endPoint = command.relative ? [prevX + command.x, prevY + command.y] : [command.x, command.y];
			if (arePointsCollinear(startPoint, controlPoint, endPoint)) {
				command.type = SVGPathData.LINE_TO;
				delete command.x1;
				delete command.y1;
			}
		}
		if (normalizeC && command.type & SVGPathData.CURVE_TO) {
			const startPoint = [prevX, prevY];
			const control1 = command.relative ? [prevX + command.x1, prevY + command.y1] : [command.x1, command.y1];
			const control2 = command.relative ? [prevX + command.x2, prevY + command.y2] : [command.x2, command.y2];
			const endPoint = command.relative ? [prevX + command.x, prevY + command.y] : [command.x, command.y];
			if (arePointsCollinear(startPoint, control1, endPoint) && arePointsCollinear(startPoint, control2, endPoint)) {
				command.type = SVGPathData.LINE_TO;
				delete command.x1;
				delete command.y1;
				delete command.x2;
				delete command.y2;
			}
		}
		return command;
	});
}
function NORMALIZE_ST() {
	let prevCurveC2X = NaN;
	let prevCurveC2Y = NaN;
	let prevQuadCX = NaN;
	let prevQuadCY = NaN;
	return INFO((command, prevX, prevY) => {
		if (command.type & SVGPathData.SMOOTH_CURVE_TO) {
			command.type = SVGPathData.CURVE_TO;
			prevCurveC2X = isNaN(prevCurveC2X) ? prevX : prevCurveC2X;
			prevCurveC2Y = isNaN(prevCurveC2Y) ? prevY : prevCurveC2Y;
			command.x1 = command.relative ? prevX - prevCurveC2X : 2 * prevX - prevCurveC2X;
			command.y1 = command.relative ? prevY - prevCurveC2Y : 2 * prevY - prevCurveC2Y;
		}
		if (command.type & SVGPathData.CURVE_TO) {
			prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;
			prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;
		} else {
			prevCurveC2X = NaN;
			prevCurveC2Y = NaN;
		}
		if (command.type & SVGPathData.SMOOTH_QUAD_TO) {
			command.type = SVGPathData.QUAD_TO;
			prevQuadCX = isNaN(prevQuadCX) ? prevX : prevQuadCX;
			prevQuadCY = isNaN(prevQuadCY) ? prevY : prevQuadCY;
			command.x1 = command.relative ? prevX - prevQuadCX : 2 * prevX - prevQuadCX;
			command.y1 = command.relative ? prevY - prevQuadCY : 2 * prevY - prevQuadCY;
		}
		if (command.type & SVGPathData.QUAD_TO) {
			prevQuadCX = command.relative ? prevX + command.x1 : command.x1;
			prevQuadCY = command.relative ? prevY + command.y1 : command.y1;
		} else {
			prevQuadCX = NaN;
			prevQuadCY = NaN;
		}
		return command;
	});
}
function QT_TO_C() {
	let prevQuadX1 = NaN;
	let prevQuadY1 = NaN;
	return INFO((command, prevX, prevY) => {
		if (command.type & SVGPathData.SMOOTH_QUAD_TO) {
			command.type = SVGPathData.QUAD_TO;
			prevQuadX1 = isNaN(prevQuadX1) ? prevX : prevQuadX1;
			prevQuadY1 = isNaN(prevQuadY1) ? prevY : prevQuadY1;
			command.x1 = command.relative ? prevX - prevQuadX1 : 2 * prevX - prevQuadX1;
			command.y1 = command.relative ? prevY - prevQuadY1 : 2 * prevY - prevQuadY1;
		}
		if (command.type & SVGPathData.QUAD_TO) {
			prevQuadX1 = command.relative ? prevX + command.x1 : command.x1;
			prevQuadY1 = command.relative ? prevY + command.y1 : command.y1;
			const x1 = command.x1;
			const y1 = command.y1;
			command.type = SVGPathData.CURVE_TO;
			command.x1 = ((command.relative ? 0 : prevX) + x1 * 2) / 3;
			command.y1 = ((command.relative ? 0 : prevY) + y1 * 2) / 3;
			command.x2 = (command.x + x1 * 2) / 3;
			command.y2 = (command.y + y1 * 2) / 3;
		} else {
			prevQuadX1 = NaN;
			prevQuadY1 = NaN;
		}
		return command;
	});
}
function INFO(f) {
	let prevXAbs = 0;
	let prevYAbs = 0;
	let pathStartXAbs = NaN;
	let pathStartYAbs = NaN;
	return function transform$1(command) {
		if (isNaN(pathStartXAbs) && !(command.type & SVGPathData.MOVE_TO)) throw new Error("path must start with moveto");
		const result = f(command, prevXAbs, prevYAbs, pathStartXAbs, pathStartYAbs);
		if (command.type & SVGPathData.CLOSE_PATH) {
			prevXAbs = pathStartXAbs;
			prevYAbs = pathStartYAbs;
		}
		if ("x" in command && "undefined" !== typeof command.x) prevXAbs = command.relative ? prevXAbs + command.x : command.x;
		if ("y" in command && "undefined" !== typeof command.y) prevYAbs = command.relative ? prevYAbs + command.y : command.y;
		if (command.type & SVGPathData.MOVE_TO) {
			pathStartXAbs = prevXAbs;
			pathStartYAbs = prevYAbs;
		}
		return result;
	};
}
function SANITIZE(EPS = 0) {
	assertNumbers(EPS);
	let prevCurveC2X = NaN;
	let prevCurveC2Y = NaN;
	let prevQuadCX = NaN;
	let prevQuadCY = NaN;
	return INFO((command, prevX, prevY, pathStartX, pathStartY) => {
		const abs = Math.abs;
		let skip = false;
		let x1Rel = 0;
		let y1Rel = 0;
		if (command.type & SVGPathData.SMOOTH_CURVE_TO) {
			x1Rel = isNaN(prevCurveC2X) ? 0 : prevX - prevCurveC2X;
			y1Rel = isNaN(prevCurveC2Y) ? 0 : prevY - prevCurveC2Y;
		}
		if (command.type & (SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO)) {
			prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;
			prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;
		} else {
			prevCurveC2X = NaN;
			prevCurveC2Y = NaN;
		}
		if (command.type & SVGPathData.SMOOTH_QUAD_TO) {
			prevQuadCX = isNaN(prevQuadCX) ? prevX : 2 * prevX - prevQuadCX;
			prevQuadCY = isNaN(prevQuadCY) ? prevY : 2 * prevY - prevQuadCY;
		} else if (command.type & SVGPathData.QUAD_TO) {
			prevQuadCX = command.relative ? prevX + command.x1 : command.x1;
			prevQuadCY = command.relative ? prevY + command.y1 : command.y2;
		} else {
			prevQuadCX = NaN;
			prevQuadCY = NaN;
		}
		if (command.type & SVGPathData.LINE_COMMANDS || command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY || !command.lArcFlag) || command.type & SVGPathData.CURVE_TO || command.type & SVGPathData.SMOOTH_CURVE_TO || command.type & SVGPathData.QUAD_TO || command.type & SVGPathData.SMOOTH_QUAD_TO) {
			const xRel = "undefined" === typeof command.x ? 0 : command.relative ? command.x : command.x - prevX;
			const yRel = "undefined" === typeof command.y ? 0 : command.relative ? command.y : command.y - prevY;
			x1Rel = !isNaN(prevQuadCX) ? prevQuadCX - prevX : "undefined" === typeof command.x1 ? x1Rel : command.relative ? command.x : command.x1 - prevX;
			y1Rel = !isNaN(prevQuadCY) ? prevQuadCY - prevY : "undefined" === typeof command.y1 ? y1Rel : command.relative ? command.y : command.y1 - prevY;
			const x2Rel = "undefined" === typeof command.x2 ? 0 : command.relative ? command.x : command.x2 - prevX;
			const y2Rel = "undefined" === typeof command.y2 ? 0 : command.relative ? command.y : command.y2 - prevY;
			if (abs(xRel) <= EPS && abs(yRel) <= EPS && abs(x1Rel) <= EPS && abs(y1Rel) <= EPS && abs(x2Rel) <= EPS && abs(y2Rel) <= EPS) skip = true;
		}
		if (command.type & SVGPathData.CLOSE_PATH) {
			if (abs(prevX - pathStartX) <= EPS && abs(prevY - pathStartY) <= EPS) skip = true;
		}
		return skip ? [] : command;
	});
}
function MATRIX(a, b, c, d$1, e, f) {
	assertNumbers(a, b, c, d$1, e, f);
	return INFO((command, prevX, prevY, pathStartX) => {
		const origX1 = command.x1;
		const origX2 = command.x2;
		const comRel = command.relative && !isNaN(pathStartX);
		const x = "undefined" !== typeof command.x ? command.x : comRel ? 0 : prevX;
		const y$1 = "undefined" !== typeof command.y ? command.y : comRel ? 0 : prevY;
		if (command.type & SVGPathData.HORIZ_LINE_TO && 0 !== b) {
			command.type = SVGPathData.LINE_TO;
			command.y = command.relative ? 0 : prevY;
		}
		if (command.type & SVGPathData.VERT_LINE_TO && 0 !== c) {
			command.type = SVGPathData.LINE_TO;
			command.x = command.relative ? 0 : prevX;
		}
		if ("undefined" !== typeof command.x) command.x = command.x * a + y$1 * c + (comRel ? 0 : e);
		if ("undefined" !== typeof command.y) command.y = x * b + command.y * d$1 + (comRel ? 0 : f);
		if ("undefined" !== typeof command.x1) command.x1 = command.x1 * a + command.y1 * c + (comRel ? 0 : e);
		if ("undefined" !== typeof command.y1) command.y1 = origX1 * b + command.y1 * d$1 + (comRel ? 0 : f);
		if ("undefined" !== typeof command.x2) command.x2 = command.x2 * a + command.y2 * c + (comRel ? 0 : e);
		if ("undefined" !== typeof command.y2) command.y2 = origX2 * b + command.y2 * d$1 + (comRel ? 0 : f);
		function sqr(x$1) {
			return x$1 * x$1;
		}
		const det = a * d$1 - b * c;
		if ("undefined" !== typeof command.xRot) {
			if (1 !== a || 0 !== b || 0 !== c || 1 !== d$1) if (0 === det) {
				delete command.rX;
				delete command.rY;
				delete command.xRot;
				delete command.lArcFlag;
				delete command.sweepFlag;
				command.type = SVGPathData.LINE_TO;
			} else {
				const xRot = command.xRot * Math.PI / 180;
				const sinRot = Math.sin(xRot);
				const cosRot = Math.cos(xRot);
				const xCurve = 1 / sqr(command.rX);
				const yCurve = 1 / sqr(command.rY);
				const A = sqr(cosRot) * xCurve + sqr(sinRot) * yCurve;
				const B = 2 * sinRot * cosRot * (xCurve - yCurve);
				const C = sqr(sinRot) * xCurve + sqr(cosRot) * yCurve;
				const A1 = A * d$1 * d$1 - B * b * d$1 + C * b * b;
				const B1 = B * (a * d$1 + b * c) - 2 * (A * c * d$1 + C * a * b);
				const C1 = A * c * c - B * a * c + C * a * a;
				const newXRot = (Math.atan2(B1, A1 - C1) + Math.PI) % Math.PI / 2;
				const newSinRot = Math.sin(newXRot);
				const newCosRot = Math.cos(newXRot);
				command.rX = Math.abs(det) / Math.sqrt(A1 * sqr(newCosRot) + B1 * newSinRot * newCosRot + C1 * sqr(newSinRot));
				command.rY = Math.abs(det) / Math.sqrt(A1 * sqr(newSinRot) - B1 * newSinRot * newCosRot + C1 * sqr(newCosRot));
				command.xRot = newXRot * 180 / Math.PI;
			}
		}
		if ("undefined" !== typeof command.sweepFlag && 0 > det) command.sweepFlag = +!command.sweepFlag;
		return command;
	});
}
function ROTATE(a, x = 0, y$1 = 0) {
	assertNumbers(a, x, y$1);
	const sin$1 = Math.sin(a);
	const cos$1 = Math.cos(a);
	return MATRIX(cos$1, sin$1, -sin$1, cos$1, x - x * cos$1 + y$1 * sin$1, y$1 - x * sin$1 - y$1 * cos$1);
}
function TRANSLATE(dX, dY = 0) {
	assertNumbers(dX, dY);
	return MATRIX(1, 0, 0, 1, dX, dY);
}
function SCALE(dX, dY = dX) {
	assertNumbers(dX, dY);
	return MATRIX(dX, 0, 0, dY, 0, 0);
}
function SKEW_X(a) {
	assertNumbers(a);
	return MATRIX(1, 0, Math.tan(a), 1, 0, 0);
}
function SKEW_Y(a) {
	assertNumbers(a);
	return MATRIX(1, Math.tan(a), 0, 1, 0, 0);
}
function X_AXIS_SYMMETRY(xOffset = 0) {
	assertNumbers(xOffset);
	return MATRIX(-1, 0, 0, 1, xOffset, 0);
}
function Y_AXIS_SYMMETRY(yOffset = 0) {
	assertNumbers(yOffset);
	return MATRIX(1, 0, 0, -1, 0, yOffset);
}
function A_TO_C() {
	return INFO((command, prevX, prevY) => {
		if (SVGPathData.ARC === command.type) return a2c(command, command.relative ? 0 : prevX, command.relative ? 0 : prevY);
		return command;
	});
}
function ANNOTATE_ARCS() {
	return INFO((c, x1, y1) => {
		if (c.relative) {
			x1 = 0;
			y1 = 0;
		}
		if (SVGPathData.ARC === c.type) annotateArcCommand(c, x1, y1);
		return c;
	});
}
function CLONE() {
	return (c) => {
		return { ...c };
	};
}
function CALCULATE_BOUNDS() {
	const clone = CLONE();
	const toAbs = TO_ABS();
	const qtToC = QT_TO_C();
	const normST = NORMALIZE_ST();
	const f = INFO((command, prevXAbs, prevYAbs) => {
		const c = normST(qtToC(toAbs(clone(command))));
		function fixX(absX) {
			if (absX > f.maxX) f.maxX = absX;
			if (absX < f.minX) f.minX = absX;
		}
		function fixY(absY) {
			if (absY > f.maxY) f.maxY = absY;
			if (absY < f.minY) f.minY = absY;
		}
		if (c.type & SVGPathData.DRAWING_COMMANDS) {
			fixX(prevXAbs);
			fixY(prevYAbs);
		}
		if (c.type & SVGPathData.HORIZ_LINE_TO) fixX(c.x);
		if (c.type & SVGPathData.VERT_LINE_TO) fixY(c.y);
		if (c.type & SVGPathData.LINE_TO) {
			fixX(c.x);
			fixY(c.y);
		}
		if (c.type & SVGPathData.CURVE_TO) {
			fixX(c.x);
			fixY(c.y);
			const xDerivRoots = bezierRoot(prevXAbs, c.x1, c.x2, c.x);
			for (const derivRoot of xDerivRoots) if (0 < derivRoot && 1 > derivRoot) fixX(bezierAt(prevXAbs, c.x1, c.x2, c.x, derivRoot));
			const yDerivRoots = bezierRoot(prevYAbs, c.y1, c.y2, c.y);
			for (const derivRoot of yDerivRoots) if (0 < derivRoot && 1 > derivRoot) fixY(bezierAt(prevYAbs, c.y1, c.y2, c.y, derivRoot));
		}
		if (c.type & SVGPathData.ARC) {
			fixX(c.x);
			fixY(c.y);
			annotateArcCommand(c, prevXAbs, prevYAbs);
			const xRotRad = c.xRot / 180 * Math.PI;
			const x0 = Math.cos(xRotRad) * c.rX;
			const y0 = Math.sin(xRotRad) * c.rX;
			const x90 = -Math.sin(xRotRad) * c.rY;
			const y90 = Math.cos(xRotRad) * c.rY;
			const [phiMin, phiMax] = c.phi1 < c.phi2 ? [c.phi1, c.phi2] : -180 > c.phi2 ? [c.phi2 + 360, c.phi1 + 360] : [c.phi2, c.phi1];
			const normalizeXiEta = ([xi, eta]) => {
				const phiRad = Math.atan2(eta, xi);
				const phi = phiRad * 180 / Math.PI;
				return phi < phiMin ? phi + 360 : phi;
			};
			const xDerivRoots = intersectionUnitCircleLine(x90, -x0, 0).map(normalizeXiEta);
			for (const derivRoot of xDerivRoots) if (derivRoot > phiMin && derivRoot < phiMax) fixX(arcAt(c.cX, x0, x90, derivRoot));
			const yDerivRoots = intersectionUnitCircleLine(y90, -y0, 0).map(normalizeXiEta);
			for (const derivRoot of yDerivRoots) if (derivRoot > phiMin && derivRoot < phiMax) fixY(arcAt(c.cY, y0, y90, derivRoot));
		}
		return command;
	});
	f.minX = Infinity;
	f.maxX = -Infinity;
	f.minY = Infinity;
	f.maxY = -Infinity;
	return f;
}
const SVGPathDataTransformer = {
	ROUND,
	TO_ABS,
	TO_REL,
	NORMALIZE_HVZ,
	NORMALIZE_ST,
	QT_TO_C,
	INFO,
	SANITIZE,
	MATRIX,
	ROTATE,
	TRANSLATE,
	SCALE,
	SKEW_X,
	SKEW_Y,
	X_AXIS_SYMMETRY,
	Y_AXIS_SYMMETRY,
	A_TO_C,
	ANNOTATE_ARCS,
	CLONE,
	CALCULATE_BOUNDS,
	REVERSE_PATH
};

//#endregion
//#region node_modules/.pnpm/svg-pathdata@7.2.0/node_modules/svg-pathdata/dist/TransformableSVG.js
var TransformableSVG = class {
	round(x) {
		return this.transform(SVGPathDataTransformer.ROUND(x));
	}
	toAbs() {
		return this.transform(SVGPathDataTransformer.TO_ABS());
	}
	toRel() {
		return this.transform(SVGPathDataTransformer.TO_REL());
	}
	normalizeHVZ(a, b, c) {
		return this.transform(SVGPathDataTransformer.NORMALIZE_HVZ(a, b, c));
	}
	normalizeST() {
		return this.transform(SVGPathDataTransformer.NORMALIZE_ST());
	}
	qtToC() {
		return this.transform(SVGPathDataTransformer.QT_TO_C());
	}
	aToC() {
		return this.transform(SVGPathDataTransformer.A_TO_C());
	}
	sanitize(eps) {
		return this.transform(SVGPathDataTransformer.SANITIZE(eps));
	}
	translate(x, y$1) {
		return this.transform(SVGPathDataTransformer.TRANSLATE(x, y$1));
	}
	scale(x, y$1) {
		return this.transform(SVGPathDataTransformer.SCALE(x, y$1));
	}
	rotate(a, x, y$1) {
		return this.transform(SVGPathDataTransformer.ROTATE(a, x, y$1));
	}
	matrix(a, b, c, d$1, e, f) {
		return this.transform(SVGPathDataTransformer.MATRIX(a, b, c, d$1, e, f));
	}
	skewX(a) {
		return this.transform(SVGPathDataTransformer.SKEW_X(a));
	}
	skewY(a) {
		return this.transform(SVGPathDataTransformer.SKEW_Y(a));
	}
	xSymmetry(xOffset) {
		return this.transform(SVGPathDataTransformer.X_AXIS_SYMMETRY(xOffset));
	}
	ySymmetry(yOffset) {
		return this.transform(SVGPathDataTransformer.Y_AXIS_SYMMETRY(yOffset));
	}
	annotateArcs() {
		return this.transform(SVGPathDataTransformer.ANNOTATE_ARCS());
	}
};

//#endregion
//#region node_modules/.pnpm/svg-pathdata@7.2.0/node_modules/svg-pathdata/dist/SVGPathDataParser.js
const isWhiteSpace = (c) => " " === c || "	" === c || "\r" === c || "\n" === c;
const isDigit = (c) => "0".charCodeAt(0) <= c.charCodeAt(0) && c.charCodeAt(0) <= "9".charCodeAt(0);
var SVGPathDataParser = class extends TransformableSVG {
	curNumber = "";
	curCommandType = -1;
	curCommandRelative = false;
	canParseCommandOrComma = true;
	curNumberHasExp = false;
	curNumberHasExpDigits = false;
	curNumberHasDecimal = false;
	curArgs = [];
	constructor() {
		super();
	}
	finish(commands = []) {
		this.parse(" ", commands);
		if (0 !== this.curArgs.length || !this.canParseCommandOrComma) throw new SyntaxError("Unterminated command at the path end.");
		return commands;
	}
	parse(str, commands = []) {
		const finishCommand = (command) => {
			commands.push(command);
			this.curArgs.length = 0;
			this.canParseCommandOrComma = true;
		};
		for (let i = 0; i < str.length; i++) {
			const c = str[i];
			const isAArcFlag = this.curCommandType === SVGPathData.ARC && (this.curArgs.length === 3 || this.curArgs.length === 4) && this.curNumber.length === 1 && (this.curNumber === "0" || this.curNumber === "1");
			const isEndingDigit = isDigit(c) && (this.curNumber === "0" && c === "0" || isAArcFlag);
			if (isDigit(c) && !isEndingDigit) {
				this.curNumber += c;
				this.curNumberHasExpDigits = this.curNumberHasExp;
				continue;
			}
			if ("e" === c || "E" === c) {
				this.curNumber += c;
				this.curNumberHasExp = true;
				continue;
			}
			if (("-" === c || "+" === c) && this.curNumberHasExp && !this.curNumberHasExpDigits) {
				this.curNumber += c;
				continue;
			}
			if ("." === c && !this.curNumberHasExp && !this.curNumberHasDecimal && !isAArcFlag) {
				this.curNumber += c;
				this.curNumberHasDecimal = true;
				continue;
			}
			if (this.curNumber && -1 !== this.curCommandType) {
				const val = Number(this.curNumber);
				if (isNaN(val)) throw new SyntaxError(`Invalid number ending at ${i}`);
				if (this.curCommandType === SVGPathData.ARC) {
					if (0 === this.curArgs.length || 1 === this.curArgs.length) {
						if (0 > val) throw new SyntaxError(`Expected positive number, got "${val}" at index "${i}"`);
					} else if (3 === this.curArgs.length || 4 === this.curArgs.length) {
						if ("0" !== this.curNumber && "1" !== this.curNumber) throw new SyntaxError(`Expected a flag, got "${this.curNumber}" at index "${i}"`);
					}
				}
				this.curArgs.push(val);
				if (this.curArgs.length === COMMAND_ARG_COUNTS[this.curCommandType]) {
					if (SVGPathData.HORIZ_LINE_TO === this.curCommandType) finishCommand({
						type: SVGPathData.HORIZ_LINE_TO,
						relative: this.curCommandRelative,
						x: val
					});
					else if (SVGPathData.VERT_LINE_TO === this.curCommandType) finishCommand({
						type: SVGPathData.VERT_LINE_TO,
						relative: this.curCommandRelative,
						y: val
					});
					else if (this.curCommandType === SVGPathData.MOVE_TO || this.curCommandType === SVGPathData.LINE_TO || this.curCommandType === SVGPathData.SMOOTH_QUAD_TO) {
						finishCommand({
							type: this.curCommandType,
							relative: this.curCommandRelative,
							x: this.curArgs[0],
							y: this.curArgs[1]
						});
						if (SVGPathData.MOVE_TO === this.curCommandType) this.curCommandType = SVGPathData.LINE_TO;
					} else if (this.curCommandType === SVGPathData.CURVE_TO) finishCommand({
						type: SVGPathData.CURVE_TO,
						relative: this.curCommandRelative,
						x1: this.curArgs[0],
						y1: this.curArgs[1],
						x2: this.curArgs[2],
						y2: this.curArgs[3],
						x: this.curArgs[4],
						y: this.curArgs[5]
					});
					else if (this.curCommandType === SVGPathData.SMOOTH_CURVE_TO) finishCommand({
						type: SVGPathData.SMOOTH_CURVE_TO,
						relative: this.curCommandRelative,
						x2: this.curArgs[0],
						y2: this.curArgs[1],
						x: this.curArgs[2],
						y: this.curArgs[3]
					});
					else if (this.curCommandType === SVGPathData.QUAD_TO) finishCommand({
						type: SVGPathData.QUAD_TO,
						relative: this.curCommandRelative,
						x1: this.curArgs[0],
						y1: this.curArgs[1],
						x: this.curArgs[2],
						y: this.curArgs[3]
					});
					else if (this.curCommandType === SVGPathData.ARC) finishCommand({
						type: SVGPathData.ARC,
						relative: this.curCommandRelative,
						rX: this.curArgs[0],
						rY: this.curArgs[1],
						xRot: this.curArgs[2],
						lArcFlag: this.curArgs[3],
						sweepFlag: this.curArgs[4],
						x: this.curArgs[5],
						y: this.curArgs[6]
					});
				}
				this.curNumber = "";
				this.curNumberHasExpDigits = false;
				this.curNumberHasExp = false;
				this.curNumberHasDecimal = false;
				this.canParseCommandOrComma = true;
			}
			if (isWhiteSpace(c)) continue;
			if ("," === c && this.canParseCommandOrComma) {
				this.canParseCommandOrComma = false;
				continue;
			}
			if ("+" === c || "-" === c || "." === c) {
				this.curNumber = c;
				this.curNumberHasDecimal = "." === c;
				continue;
			}
			if (isEndingDigit) {
				this.curNumber = c;
				this.curNumberHasDecimal = false;
				continue;
			}
			if (0 !== this.curArgs.length) throw new SyntaxError(`Unterminated command at index ${i}.`);
			if (!this.canParseCommandOrComma) throw new SyntaxError(`Unexpected character "${c}" at index ${i}. Command cannot follow comma`);
			this.canParseCommandOrComma = false;
			if ("z" === c || "Z" === c) {
				commands.push({ type: SVGPathData.CLOSE_PATH });
				this.canParseCommandOrComma = true;
				this.curCommandType = -1;
				continue;
			} else if ("h" === c || "H" === c) {
				this.curCommandType = SVGPathData.HORIZ_LINE_TO;
				this.curCommandRelative = "h" === c;
			} else if ("v" === c || "V" === c) {
				this.curCommandType = SVGPathData.VERT_LINE_TO;
				this.curCommandRelative = "v" === c;
			} else if ("m" === c || "M" === c) {
				this.curCommandType = SVGPathData.MOVE_TO;
				this.curCommandRelative = "m" === c;
			} else if ("l" === c || "L" === c) {
				this.curCommandType = SVGPathData.LINE_TO;
				this.curCommandRelative = "l" === c;
			} else if ("c" === c || "C" === c) {
				this.curCommandType = SVGPathData.CURVE_TO;
				this.curCommandRelative = "c" === c;
			} else if ("s" === c || "S" === c) {
				this.curCommandType = SVGPathData.SMOOTH_CURVE_TO;
				this.curCommandRelative = "s" === c;
			} else if ("q" === c || "Q" === c) {
				this.curCommandType = SVGPathData.QUAD_TO;
				this.curCommandRelative = "q" === c;
			} else if ("t" === c || "T" === c) {
				this.curCommandType = SVGPathData.SMOOTH_QUAD_TO;
				this.curCommandRelative = "t" === c;
			} else if ("a" === c || "A" === c) {
				this.curCommandType = SVGPathData.ARC;
				this.curCommandRelative = "a" === c;
			} else throw new SyntaxError(`Unexpected character "${c}" at index ${i}.`);
		}
		return commands;
	}
	/**
	* Return a wrapper around this parser which applies the transformation on parsed commands.
	*/
	transform(transform$1) {
		const result = Object.create(this, { parse: { value(chunk, commands = []) {
			const parsedCommands = Object.getPrototypeOf(this).parse.call(this, chunk);
			for (const c of parsedCommands) {
				const cT = transform$1(c);
				if (Array.isArray(cT)) commands.push(...cT);
				else commands.push(cT);
			}
			return commands;
		} } });
		return result;
	}
};

//#endregion
//#region node_modules/.pnpm/svg-pathdata@7.2.0/node_modules/svg-pathdata/dist/SVGPathData.js
var SVGPathData = class SVGPathData extends TransformableSVG {
	commands;
	constructor(content) {
		super();
		if ("string" === typeof content) this.commands = SVGPathData.parse(content);
		else this.commands = content;
	}
	encode() {
		return SVGPathData.encode(this.commands);
	}
	getBounds() {
		const boundsTransform = SVGPathDataTransformer.CALCULATE_BOUNDS();
		this.transform(boundsTransform);
		return boundsTransform;
	}
	transform(transformFunction) {
		const newCommands = [];
		for (const command of this.commands) {
			const transformedCommand = transformFunction(command);
			if (Array.isArray(transformedCommand)) newCommands.push(...transformedCommand);
			else newCommands.push(transformedCommand);
		}
		this.commands = newCommands;
		return this;
	}
	/**
	* Reverses the order of path commands to go from end to start
	* IMPORTANT: This function expects absolute commands as input.
	* @param preserveSubpathOrder If true, keeps subpaths in their original order
	*/
	reverse(preserveSubpathOrder = true) {
		this.commands = SVGPathDataTransformer.REVERSE_PATH(this.commands, preserveSubpathOrder);
		return this;
	}
	static encode(commands) {
		return encodeSVGPath(commands);
	}
	static parse(path) {
		const parser = new SVGPathDataParser();
		const commands = [];
		parser.parse(path, commands);
		parser.finish(commands);
		return commands;
	}
	static CLOSE_PATH = 1;
	static MOVE_TO = 2;
	static HORIZ_LINE_TO = 4;
	static VERT_LINE_TO = 8;
	static LINE_TO = 16;
	static CURVE_TO = 32;
	static SMOOTH_CURVE_TO = 64;
	static QUAD_TO = 128;
	static SMOOTH_QUAD_TO = 256;
	static ARC = 512;
	static LINE_COMMANDS = SVGPathData.LINE_TO | SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO;
	static DRAWING_COMMANDS = SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO | SVGPathData.LINE_TO | SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO | SVGPathData.QUAD_TO | SVGPathData.SMOOTH_QUAD_TO | SVGPathData.ARC;
};
const COMMAND_ARG_COUNTS = {
	[SVGPathData.MOVE_TO]: 2,
	[SVGPathData.LINE_TO]: 2,
	[SVGPathData.HORIZ_LINE_TO]: 1,
	[SVGPathData.VERT_LINE_TO]: 1,
	[SVGPathData.CLOSE_PATH]: 0,
	[SVGPathData.QUAD_TO]: 4,
	[SVGPathData.SMOOTH_QUAD_TO]: 2,
	[SVGPathData.CURVE_TO]: 6,
	[SVGPathData.SMOOTH_CURVE_TO]: 4,
	[SVGPathData.ARC]: 7
};

//#endregion
//#region node_modules/.pnpm/svgicons2svgfont@15.0.1/node_modules/svgicons2svgfont/dist/svgshapes2svgpath.js
const svgShapesToPath = {
	rectToPath: svgShapesToPathRectToPath,
	polylineToPath: svgShapesToPathPolylineToPath,
	lineToPath: svgShapesToPathLineToPath,
	circleToPath: svgShapesToPathCircleToPath,
	polygonToPath: svgShapesToPathPolygonToPath
};
var svgshapes2svgpath_default = svgShapesToPath;
function svgShapesToPathRectToPath(attributes) {
	const x = "undefined" !== typeof attributes.x ? parseFloat(attributes.x) : 0;
	const y$1 = "undefined" !== typeof attributes.y ? parseFloat(attributes.y) : 0;
	const width = "undefined" !== typeof attributes.width ? parseFloat(attributes.width) : 0;
	const height = "undefined" !== typeof attributes.height ? parseFloat(attributes.height) : 0;
	const rx = "undefined" !== typeof attributes.rx ? parseFloat(attributes.rx) : "undefined" !== typeof attributes.ry ? parseFloat(attributes.ry) : 0;
	const ry = "undefined" !== typeof attributes.ry ? parseFloat(attributes.ry) : rx;
	return "M" + (x + rx) + " " + y$1 + "h" + (width - rx * 2) + (rx || ry ? "a " + rx + " " + ry + " 0 0 1 " + rx + " " + ry : "") + "v" + (height - ry * 2) + (rx || ry ? "a " + rx + " " + ry + " 0 0 1 " + rx * -1 + " " + ry : "") + "h" + (width - rx * 2) * -1 + (rx || ry ? "a " + rx + " " + ry + " 0 0 1 " + rx * -1 + " " + ry * -1 : "") + "v" + (height - ry * 2) * -1 + (rx || ry ? "a " + rx + " " + ry + " 0 0 1 " + rx + " " + ry * -1 : "") + "z";
}
function svgShapesToPathPolylineToPath(attributes) {
	return "M" + attributes.points;
}
function svgShapesToPathLineToPath(attributes) {
	return "M" + (parseFloat(attributes.x1) || 0).toString(10) + " " + (parseFloat(attributes.y1) || 0).toString(10) + " " + ((parseFloat(attributes.x1) || 0) + 1).toString(10) + " " + ((parseFloat(attributes.y1) || 0) + 1).toString(10) + " " + ((parseFloat(attributes.x2) || 0) + 1).toString(10) + " " + ((parseFloat(attributes.y2) || 0) + 1).toString(10) + " " + (parseFloat(attributes.x2) || 0).toString(10) + " " + (parseFloat(attributes.y2) || 0).toString(10) + "Z";
}
function svgShapesToPathCircleToPath(attributes) {
	const cx = parseFloat(attributes.cx || 0);
	const cy = parseFloat(attributes.cy || 0);
	const rx = "undefined" !== typeof attributes.rx ? parseFloat(attributes.rx) : parseFloat(attributes.r);
	const ry = "undefined" !== typeof attributes.ry ? parseFloat(attributes.ry) : parseFloat(attributes.r);
	return "M" + (cx - rx) + "," + cy + "A" + rx + "," + ry + " 0,0,0 " + (cx + rx) + "," + cy + "A" + rx + "," + ry + " 0,0,0 " + (cx - rx) + "," + cy;
}
function svgShapesToPathPolygonToPath(attributes) {
	return "M" + attributes.points + "Z";
}

//#endregion
//#region node_modules/.pnpm/transformation-matrix@3.0.0/node_modules/transformation-matrix/src/fromObject.js
/**
* Extract an affine matrix from an object that contains a,b,c,d,e,f keys
* Any value could be a float or a string that contains a float
* @param object {Object} Object that contains a,b,c,d,e,f keys
* @return {Matrix} Affine Matrix
*/
function fromObject(object) {
	return {
		a: parseFloat(object.a),
		b: parseFloat(object.b),
		c: parseFloat(object.c),
		d: parseFloat(object.d),
		e: parseFloat(object.e),
		f: parseFloat(object.f)
	};
}

//#endregion
//#region node_modules/.pnpm/transformation-matrix@3.0.0/node_modules/transformation-matrix/src/utils.js
function isUndefined(val) {
	return typeof val === "undefined";
}

//#endregion
//#region node_modules/.pnpm/transformation-matrix@3.0.0/node_modules/transformation-matrix/src/translate.js
/**
* Calculate a translate matrix
* @param tx {number} Translation on axis x
* @param [ty = 0] {number} Translation on axis y
* @returns {Matrix} Affine Matrix
*/
function translate(tx, ty = 0) {
	return {
		a: 1,
		c: 0,
		e: tx,
		b: 0,
		d: 1,
		f: ty
	};
}

//#endregion
//#region node_modules/.pnpm/transformation-matrix@3.0.0/node_modules/transformation-matrix/src/transform.js
/**
* Merge multiple matrices into one
* @param matrices {...Matrix | Matrix[]} Matrices listed as separate parameters or in an array
* @returns {Matrix} Affine Matrix
*/
function transform(...matrices) {
	matrices = Array.isArray(matrices[0]) ? matrices[0] : matrices;
	const multiply = (m1, m2) => {
		return {
			a: m1.a * m2.a + m1.c * m2.b,
			c: m1.a * m2.c + m1.c * m2.d,
			e: m1.a * m2.e + m1.c * m2.f + m1.e,
			b: m1.b * m2.a + m1.d * m2.b,
			d: m1.b * m2.c + m1.d * m2.d,
			f: m1.b * m2.e + m1.d * m2.f + m1.f
		};
	};
	switch (matrices.length) {
		case 0: throw new Error("no matrices provided");
		case 1: return matrices[0];
		case 2: return multiply(matrices[0], matrices[1]);
		default: {
			const [m1, m2, ...rest] = matrices;
			const m$1 = multiply(m1, m2);
			return transform(m$1, ...rest);
		}
	}
}
/**
* Merge multiple matrices into one
* @param matrices {...Matrix | Matrix[]} Matrices listed as separate parameters or in an array
* @returns {Matrix} Affine Matrix
*/
function compose(...matrices) {
	return transform(...matrices);
}

//#endregion
//#region node_modules/.pnpm/transformation-matrix@3.0.0/node_modules/transformation-matrix/src/rotate.js
const { cos, sin, PI } = Math;
/**
* Calculate a rotation matrix
* @param angle {number} Angle in radians
* @param [cx] {number} If (cx,cy) are supplied the rotate is about this point
* @param [cy] {number} If (cx,cy) are supplied the rotate is about this point
* @returns {Matrix} Affine Matrix
*/
function rotate(angle, cx, cy) {
	const cosAngle = cos(angle);
	const sinAngle = sin(angle);
	const rotationMatrix = {
		a: cosAngle,
		c: -sinAngle,
		e: 0,
		b: sinAngle,
		d: cosAngle,
		f: 0
	};
	if (isUndefined(cx) || isUndefined(cy)) return rotationMatrix;
	return transform([
		translate(cx, cy),
		rotationMatrix,
		translate(-cx, -cy)
	]);
}
/**
* Calculate a rotation matrix with a DEG angle
* @param angle {number} Angle in degree
* @param [cx] {number} If (cx,cy) are supplied the rotate is about this point
* @param [cy] {number} If (cx,cy) are supplied the rotate is about this point
* @returns {Matrix} Affine Matrix
*/
function rotateDEG(angle, cx = void 0, cy = void 0) {
	return rotate(angle * PI / 180, cx, cy);
}

//#endregion
//#region node_modules/.pnpm/transformation-matrix@3.0.0/node_modules/transformation-matrix/src/scale.js
/**
* Calculate a scaling matrix
* @param sx {number} Scaling on axis x
* @param [sy = sx] {number} Scaling on axis y (default sx)
* @param [cx] {number} If (cx,cy) are supplied the scaling is about this point
* @param [cy] {number} If (cx,cy) are supplied the scaling is about this point
* @returns {Matrix} Affine Matrix
*/
function scale(sx, sy = void 0, cx = void 0, cy = void 0) {
	if (isUndefined(sy)) sy = sx;
	const scaleMatrix = {
		a: sx,
		c: 0,
		e: 0,
		b: 0,
		d: sy,
		f: 0
	};
	if (isUndefined(cx) || isUndefined(cy)) return scaleMatrix;
	return transform([
		translate(cx, cy),
		scaleMatrix,
		translate(-cx, -cy)
	]);
}

//#endregion
//#region node_modules/.pnpm/transformation-matrix@3.0.0/node_modules/transformation-matrix/src/shear.js
/**
* Calculate a shear matrix
* @param shx {number} Shear on axis x
* @param shy {number} Shear on axis y
* @returns {Matrix} Affine Matrix
*/
function shear(shx, shy) {
	return {
		a: 1,
		c: shx,
		e: 0,
		b: shy,
		d: 1,
		f: 0
	};
}

//#endregion
//#region node_modules/.pnpm/transformation-matrix@3.0.0/node_modules/transformation-matrix/src/skew.js
const { tan } = Math;
/**
* Calculate a skew matrix
* @param ax {number} Skew on axis x
* @param ay {number} Skew on axis y
* @returns {Matrix} Affine Matrix
*/
function skew(ax, ay) {
	return {
		a: 1,
		c: tan(ax),
		e: 0,
		b: tan(ay),
		d: 1,
		f: 0
	};
}
/**
* Calculate a skew matrix using DEG angles
* @param ax {number} Skew on axis x
* @param ay {number} Skew on axis y
* @returns {Matrix} Affine Matrix
*/
function skewDEG(ax, ay) {
	return skew(ax * Math.PI / 180, ay * Math.PI / 180);
}

//#endregion
//#region node_modules/.pnpm/transformation-matrix@3.0.0/node_modules/transformation-matrix/src/fromDefinition.js
/**
* Converts array of matrix descriptor to array of matrix
* @param definitionOrArrayOfDefinition {Object[]} Array of object describing the matrix
* @returns {Matrix[]} Array of matrix
*
* @example
* > fromDefinition([
*  { type: 'matrix', a:1, b:2, c:3, d:4, e:5, f:6 },
*  { type: 'translate', tx: 10, ty: 20 },
*  { type: 'scale', sx: 2, sy: 4 },
*  { type: 'rotate', angle: 90, cx: 50, cy: 25 },
*  { type: 'skewX', angle: 45 },
*  { type: 'skewY',  angle: 45 },
*  { type: 'shear', shx: 10, shy: 20}
* ])
*
* [
*  { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6 },
*  { a: 1, c: 0, e: 10, b: 0, d: 1, f: 20 },
*  { a: 2, c: 0, e: 0, b: 0, d: 4, f: 0 },
*  { a: 6.123, c: -1, e: 0, b: 1, d: 6.123, f: 0 },
*  { a: 1, c: 0.99.., e: 0, b: 0, d: 1, f: 0 },
*  { a: 1, c: 0, e: 0, b: 0.99, d: 1, f: 0 },
*  { a: 1, c: 10, e: 0, b: 20, d: 1, f: 0 }
* ]
**/
function fromDefinition(definitionOrArrayOfDefinition) {
	return Array.isArray(definitionOrArrayOfDefinition) ? definitionOrArrayOfDefinition.map(mapper) : mapper(definitionOrArrayOfDefinition);
	function mapper(descriptor) {
		switch (descriptor.type) {
			case "matrix": if ("a" in descriptor && "b" in descriptor && "c" in descriptor && "d" in descriptor && "e" in descriptor && "f" in descriptor) return fromObject(descriptor);
			else throw new Error("MISSING_MANDATORY_PARAM");
			case "translate":
				if (!("tx" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
				if ("ty" in descriptor) return translate(descriptor.tx, descriptor.ty);
				return translate(descriptor.tx);
			case "scale":
				if (!("sx" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
				if ("sy" in descriptor) return scale(descriptor.sx, descriptor.sy);
				return scale(descriptor.sx);
			case "rotate":
				if (!("angle" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
				if ("cx" in descriptor && "cy" in descriptor) return rotateDEG(descriptor.angle, descriptor.cx, descriptor.cy);
				return rotateDEG(descriptor.angle);
			case "skewX":
				if (!("angle" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
				return skewDEG(descriptor.angle, 0);
			case "skewY":
				if (!("angle" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
				return skewDEG(0, descriptor.angle);
			case "shear":
				if (!("shx" in descriptor && "shy" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
				return shear(descriptor.shx, descriptor.shy);
			default: throw new Error("UNSUPPORTED_DESCRIPTOR");
		}
	}
}

//#endregion
//#region node_modules/.pnpm/transformation-matrix@3.0.0/node_modules/transformation-matrix/src/fromTransformAttribute.autogenerated.js
function peg$subclass(child, parent) {
	function C() {
		this.constructor = child;
	}
	C.prototype = parent.prototype;
	child.prototype = new C();
}
function peg$SyntaxError(message, expected, found, location) {
	var self$1 = Error.call(this, message);
	// istanbul ignore next Check is a necessary evil to support older environments
	if (Object.setPrototypeOf) Object.setPrototypeOf(self$1, peg$SyntaxError.prototype);
	self$1.expected = expected;
	self$1.found = found;
	self$1.location = location;
	self$1.name = "SyntaxError";
	return self$1;
}
peg$subclass(peg$SyntaxError, Error);
function peg$padEnd(str, targetLength, padString) {
	padString = padString || " ";
	if (str.length > targetLength) return str;
	targetLength -= str.length;
	padString += padString.repeat(targetLength);
	return str + padString.slice(0, targetLength);
}
peg$SyntaxError.prototype.format = function(sources) {
	var str = "Error: " + this.message;
	if (this.location) {
		var src = null;
		var k;
		for (k = 0; k < sources.length; k++) if (sources[k].source === this.location.source) {
			src = sources[k].text.split(/\r\n|\n|\r/g);
			break;
		}
		var s$1 = this.location.start;
		var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s$1) : s$1;
		var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
		if (src) {
			var e = this.location.end;
			var filler = peg$padEnd("", offset_s.line.toString().length, " ");
			var line = src[s$1.line - 1];
			var last = s$1.line === e.line ? e.column : line.length + 1;
			var hatLen = last - s$1.column || 1;
			str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s$1.column - 1, " ") + peg$padEnd("", hatLen, "^");
		} else str += "\n at " + loc;
	}
	return str;
};
peg$SyntaxError.buildMessage = function(expected, found) {
	var DESCRIBE_EXPECTATION_FNS = {
		literal: function(expectation) {
			return "\"" + literalEscape(expectation.text) + "\"";
		},
		class: function(expectation) {
			var escapedParts = expectation.parts.map(function(part) {
				return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
			});
			return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
		},
		any: function() {
			return "any character";
		},
		end: function() {
			return "end of input";
		},
		other: function(expectation) {
			return expectation.description;
		}
	};
	function hex(ch) {
		return ch.charCodeAt(0).toString(16).toUpperCase();
	}
	function literalEscape(s$1) {
		return s$1.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
			return "\\x0" + hex(ch);
		}).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
			return "\\x" + hex(ch);
		});
	}
	function classEscape(s$1) {
		return s$1.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
			return "\\x0" + hex(ch);
		}).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
			return "\\x" + hex(ch);
		});
	}
	function describeExpectation(expectation) {
		return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
	}
	function describeExpected(expected$1) {
		var descriptions = expected$1.map(describeExpectation);
		var i, j;
		descriptions.sort();
		if (descriptions.length > 0) {
			for (i = 1, j = 1; i < descriptions.length; i++) if (descriptions[i - 1] !== descriptions[i]) {
				descriptions[j] = descriptions[i];
				j++;
			}
			descriptions.length = j;
		}
		switch (descriptions.length) {
			case 1: return descriptions[0];
			case 2: return descriptions[0] + " or " + descriptions[1];
			default: return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
		}
	}
	function describeFound(found$1) {
		return found$1 ? "\"" + literalEscape(found$1) + "\"" : "end of input";
	}
	return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};
function peg$parse(input, options) {
	options = options !== void 0 ? options : {};
	var peg$FAILED = {};
	var peg$source = options.grammarSource;
	var peg$startRuleFunctions = { transformList: peg$parsetransformList };
	var peg$startRuleFunction = peg$parsetransformList;
	var peg$c0 = "matrix";
	var peg$c1 = "(";
	var peg$c2 = ")";
	var peg$c3 = "translate";
	var peg$c4 = "scale";
	var peg$c5 = "rotate";
	var peg$c6 = "skewX";
	var peg$c7 = "skewY";
	var peg$c8 = ",";
	var peg$c9 = ".";
	var peg$r0 = /^[eE]/;
	var peg$r1 = /^[+\-]/;
	var peg$r2 = /^[0-9]/;
	var peg$r3 = /^[ \t\r\n]/;
	var peg$e0 = peg$literalExpectation("matrix", false);
	var peg$e1 = peg$literalExpectation("(", false);
	var peg$e2 = peg$literalExpectation(")", false);
	var peg$e3 = peg$literalExpectation("translate", false);
	var peg$e4 = peg$literalExpectation("scale", false);
	var peg$e5 = peg$literalExpectation("rotate", false);
	var peg$e6 = peg$literalExpectation("skewX", false);
	var peg$e7 = peg$literalExpectation("skewY", false);
	var peg$e8 = peg$literalExpectation(",", false);
	var peg$e9 = peg$otherExpectation("fractionalConstant");
	var peg$e10 = peg$literalExpectation(".", false);
	var peg$e11 = peg$classExpectation(["e", "E"], false, false);
	var peg$e12 = peg$classExpectation(["+", "-"], false, false);
	var peg$e13 = peg$classExpectation([["0", "9"]], false, false);
	var peg$e14 = peg$classExpectation([
		" ",
		"	",
		"\r",
		"\n"
	], false, false);
	var peg$f0 = function(ts) {
		return ts;
	};
	var peg$f1 = function(t, ts) {
		return t.concat(ts);
	};
	var peg$f2 = function(a, b, c, d$1, e, f) {
		return [{
			type: "matrix",
			a,
			b,
			c,
			d: d$1,
			e,
			f
		}];
	};
	var peg$f3 = function(tx, ty) {
		var t = {
			type: "translate",
			tx
		};
		if (ty) t.ty = ty;
		return [t];
	};
	var peg$f4 = function(sx, sy) {
		var s$1 = {
			type: "scale",
			sx
		};
		if (sy) s$1.sy = sy;
		return [s$1];
	};
	var peg$f5 = function(angle, c) {
		var r = {
			type: "rotate",
			angle
		};
		if (c) {
			r.cx = c[0];
			r.cy = c[1];
		}
		return [r];
	};
	var peg$f6 = function(angle) {
		return [{
			type: "skewX",
			angle
		}];
	};
	var peg$f7 = function(angle) {
		return [{
			type: "skewY",
			angle
		}];
	};
	var peg$f8 = function(f) {
		return parseFloat(f.join(""));
	};
	var peg$f9 = function(i) {
		return parseInt(i.join(""));
	};
	var peg$f10 = function(n) {
		return n;
	};
	var peg$f11 = function(n1, n2) {
		return [n1, n2];
	};
	var peg$f12 = function(ds) {
		return ds.join("");
	};
	var peg$f13 = function(f, e) {
		return [f, e || null].join("");
	};
	var peg$f14 = function(d$1, e) {
		return [d$1, e].join("");
	};
	var peg$f15 = function(d1, d2) {
		return [
			d1 ? d1.join("") : null,
			".",
			d2.join("")
		].join("");
	};
	var peg$f16 = function(d$1) {
		return d$1.join("");
	};
	var peg$f17 = function(s$1, d$1) {
		return [
			"e",
			s$1,
			d$1.join("")
		].join("");
	};
	var peg$currPos = options.peg$currPos | 0;
	var peg$savedPos = peg$currPos;
	var peg$posDetailsCache = [{
		line: 1,
		column: 1
	}];
	var peg$maxFailPos = peg$currPos;
	var peg$maxFailExpected = options.peg$maxFailExpected || [];
	var peg$silentFails = options.peg$silentFails | 0;
	var peg$result;
	if (options.startRule) {
		if (!(options.startRule in peg$startRuleFunctions)) throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
		peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	}
	function text() {
		return input.substring(peg$savedPos, peg$currPos);
	}
	function offset() {
		return peg$savedPos;
	}
	function range() {
		return {
			source: peg$source,
			start: peg$savedPos,
			end: peg$currPos
		};
	}
	function location() {
		return peg$computeLocation(peg$savedPos, peg$currPos);
	}
	function expected(description, location$1) {
		location$1 = location$1 !== void 0 ? location$1 : peg$computeLocation(peg$savedPos, peg$currPos);
		throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location$1);
	}
	function error(message, location$1) {
		location$1 = location$1 !== void 0 ? location$1 : peg$computeLocation(peg$savedPos, peg$currPos);
		throw peg$buildSimpleError(message, location$1);
	}
	function peg$literalExpectation(text$1, ignoreCase) {
		return {
			type: "literal",
			text: text$1,
			ignoreCase
		};
	}
	function peg$classExpectation(parts, inverted, ignoreCase) {
		return {
			type: "class",
			parts,
			inverted,
			ignoreCase
		};
	}
	function peg$anyExpectation() {
		return { type: "any" };
	}
	function peg$endExpectation() {
		return { type: "end" };
	}
	function peg$otherExpectation(description) {
		return {
			type: "other",
			description
		};
	}
	function peg$computePosDetails(pos) {
		var details = peg$posDetailsCache[pos];
		var p;
		if (details) return details;
		else {
			if (pos >= peg$posDetailsCache.length) p = peg$posDetailsCache.length - 1;
			else {
				p = pos;
				while (!peg$posDetailsCache[--p]);
			}
			details = peg$posDetailsCache[p];
			details = {
				line: details.line,
				column: details.column
			};
			while (p < pos) {
				if (input.charCodeAt(p) === 10) {
					details.line++;
					details.column = 1;
				} else details.column++;
				p++;
			}
			peg$posDetailsCache[pos] = details;
			return details;
		}
	}
	function peg$computeLocation(startPos, endPos, offset$1) {
		var startPosDetails = peg$computePosDetails(startPos);
		var endPosDetails = peg$computePosDetails(endPos);
		var res = {
			source: peg$source,
			start: {
				offset: startPos,
				line: startPosDetails.line,
				column: startPosDetails.column
			},
			end: {
				offset: endPos,
				line: endPosDetails.line,
				column: endPosDetails.column
			}
		};
		if (offset$1 && peg$source && typeof peg$source.offset === "function") {
			res.start = peg$source.offset(res.start);
			res.end = peg$source.offset(res.end);
		}
		return res;
	}
	function peg$fail(expected$1) {
		if (peg$currPos < peg$maxFailPos) return;
		if (peg$currPos > peg$maxFailPos) {
			peg$maxFailPos = peg$currPos;
			peg$maxFailExpected = [];
		}
		peg$maxFailExpected.push(expected$1);
	}
	function peg$buildSimpleError(message, location$1) {
		return new peg$SyntaxError(message, null, null, location$1);
	}
	function peg$buildStructuredError(expected$1, found, location$1) {
		return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected$1, found), expected$1, found, location$1);
	}
	function peg$parsetransformList() {
		var s0, s1, s2, s3, s4;
		s0 = peg$currPos;
		s1 = [];
		s2 = peg$parsewsp();
		while (s2 !== peg$FAILED) {
			s1.push(s2);
			s2 = peg$parsewsp();
		}
		s2 = peg$parsetransforms();
		if (s2 === peg$FAILED) s2 = null;
		s3 = [];
		s4 = peg$parsewsp();
		while (s4 !== peg$FAILED) {
			s3.push(s4);
			s4 = peg$parsewsp();
		}
		peg$savedPos = s0;
		s0 = peg$f0(s2);
		return s0;
	}
	function peg$parsetransforms() {
		var s0, s1, s2, s3;
		s0 = peg$currPos;
		s1 = peg$parsetransform();
		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$parsecommaWsp();
			if (s3 !== peg$FAILED) while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$parsecommaWsp();
			}
			else s2 = peg$FAILED;
			if (s2 !== peg$FAILED) {
				s3 = peg$parsetransforms();
				if (s3 !== peg$FAILED) {
					peg$savedPos = s0;
					s0 = peg$f1(s1, s3);
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		if (s0 === peg$FAILED) s0 = peg$parsetransform();
		return s0;
	}
	function peg$parsetransform() {
		var s0;
		s0 = peg$parsematrix();
		if (s0 === peg$FAILED) {
			s0 = peg$parsetranslate();
			if (s0 === peg$FAILED) {
				s0 = peg$parsescale();
				if (s0 === peg$FAILED) {
					s0 = peg$parserotate();
					if (s0 === peg$FAILED) {
						s0 = peg$parseskewX();
						if (s0 === peg$FAILED) s0 = peg$parseskewY();
					}
				}
			}
		}
		return s0;
	}
	function peg$parsematrix() {
		var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;
		s0 = peg$currPos;
		if (input.substr(peg$currPos, 6) === peg$c0) {
			s1 = peg$c0;
			peg$currPos += 6;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) peg$fail(peg$e0);
		}
		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$parsewsp();
			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$parsewsp();
			}
			if (input.charCodeAt(peg$currPos) === 40) {
				s3 = peg$c1;
				peg$currPos++;
			} else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) peg$fail(peg$e1);
			}
			if (s3 !== peg$FAILED) {
				s4 = [];
				s5 = peg$parsewsp();
				while (s5 !== peg$FAILED) {
					s4.push(s5);
					s5 = peg$parsewsp();
				}
				s5 = peg$parsenumber();
				if (s5 !== peg$FAILED) {
					s6 = peg$parsecommaWsp();
					if (s6 !== peg$FAILED) {
						s7 = peg$parsenumber();
						if (s7 !== peg$FAILED) {
							s8 = peg$parsecommaWsp();
							if (s8 !== peg$FAILED) {
								s9 = peg$parsenumber();
								if (s9 !== peg$FAILED) {
									s10 = peg$parsecommaWsp();
									if (s10 !== peg$FAILED) {
										s11 = peg$parsenumber();
										if (s11 !== peg$FAILED) {
											s12 = peg$parsecommaWsp();
											if (s12 !== peg$FAILED) {
												s13 = peg$parsenumber();
												if (s13 !== peg$FAILED) {
													s14 = peg$parsecommaWsp();
													if (s14 !== peg$FAILED) {
														s15 = peg$parsenumber();
														if (s15 !== peg$FAILED) {
															s16 = [];
															s17 = peg$parsewsp();
															while (s17 !== peg$FAILED) {
																s16.push(s17);
																s17 = peg$parsewsp();
															}
															if (input.charCodeAt(peg$currPos) === 41) {
																s17 = peg$c2;
																peg$currPos++;
															} else {
																s17 = peg$FAILED;
																if (peg$silentFails === 0) peg$fail(peg$e2);
															}
															if (s17 !== peg$FAILED) {
																peg$savedPos = s0;
																s0 = peg$f2(s5, s7, s9, s11, s13, s15);
															} else {
																peg$currPos = s0;
																s0 = peg$FAILED;
															}
														} else {
															peg$currPos = s0;
															s0 = peg$FAILED;
														}
													} else {
														peg$currPos = s0;
														s0 = peg$FAILED;
													}
												} else {
													peg$currPos = s0;
													s0 = peg$FAILED;
												}
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		return s0;
	}
	function peg$parsetranslate() {
		var s0, s1, s2, s3, s4, s5, s6, s7, s8;
		s0 = peg$currPos;
		if (input.substr(peg$currPos, 9) === peg$c3) {
			s1 = peg$c3;
			peg$currPos += 9;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) peg$fail(peg$e3);
		}
		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$parsewsp();
			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$parsewsp();
			}
			if (input.charCodeAt(peg$currPos) === 40) {
				s3 = peg$c1;
				peg$currPos++;
			} else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) peg$fail(peg$e1);
			}
			if (s3 !== peg$FAILED) {
				s4 = [];
				s5 = peg$parsewsp();
				while (s5 !== peg$FAILED) {
					s4.push(s5);
					s5 = peg$parsewsp();
				}
				s5 = peg$parsenumber();
				if (s5 !== peg$FAILED) {
					s6 = peg$parsecommaWspNumber();
					if (s6 === peg$FAILED) s6 = null;
					s7 = [];
					s8 = peg$parsewsp();
					while (s8 !== peg$FAILED) {
						s7.push(s8);
						s8 = peg$parsewsp();
					}
					if (input.charCodeAt(peg$currPos) === 41) {
						s8 = peg$c2;
						peg$currPos++;
					} else {
						s8 = peg$FAILED;
						if (peg$silentFails === 0) peg$fail(peg$e2);
					}
					if (s8 !== peg$FAILED) {
						peg$savedPos = s0;
						s0 = peg$f3(s5, s6);
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		return s0;
	}
	function peg$parsescale() {
		var s0, s1, s2, s3, s4, s5, s6, s7, s8;
		s0 = peg$currPos;
		if (input.substr(peg$currPos, 5) === peg$c4) {
			s1 = peg$c4;
			peg$currPos += 5;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) peg$fail(peg$e4);
		}
		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$parsewsp();
			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$parsewsp();
			}
			if (input.charCodeAt(peg$currPos) === 40) {
				s3 = peg$c1;
				peg$currPos++;
			} else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) peg$fail(peg$e1);
			}
			if (s3 !== peg$FAILED) {
				s4 = [];
				s5 = peg$parsewsp();
				while (s5 !== peg$FAILED) {
					s4.push(s5);
					s5 = peg$parsewsp();
				}
				s5 = peg$parsenumber();
				if (s5 !== peg$FAILED) {
					s6 = peg$parsecommaWspNumber();
					if (s6 === peg$FAILED) s6 = null;
					s7 = [];
					s8 = peg$parsewsp();
					while (s8 !== peg$FAILED) {
						s7.push(s8);
						s8 = peg$parsewsp();
					}
					if (input.charCodeAt(peg$currPos) === 41) {
						s8 = peg$c2;
						peg$currPos++;
					} else {
						s8 = peg$FAILED;
						if (peg$silentFails === 0) peg$fail(peg$e2);
					}
					if (s8 !== peg$FAILED) {
						peg$savedPos = s0;
						s0 = peg$f4(s5, s6);
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		return s0;
	}
	function peg$parserotate() {
		var s0, s1, s2, s3, s4, s5, s6, s7, s8;
		s0 = peg$currPos;
		if (input.substr(peg$currPos, 6) === peg$c5) {
			s1 = peg$c5;
			peg$currPos += 6;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) peg$fail(peg$e5);
		}
		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$parsewsp();
			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$parsewsp();
			}
			if (input.charCodeAt(peg$currPos) === 40) {
				s3 = peg$c1;
				peg$currPos++;
			} else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) peg$fail(peg$e1);
			}
			if (s3 !== peg$FAILED) {
				s4 = [];
				s5 = peg$parsewsp();
				while (s5 !== peg$FAILED) {
					s4.push(s5);
					s5 = peg$parsewsp();
				}
				s5 = peg$parsenumber();
				if (s5 !== peg$FAILED) {
					s6 = peg$parsecommaWspTwoNumbers();
					if (s6 === peg$FAILED) s6 = null;
					s7 = [];
					s8 = peg$parsewsp();
					while (s8 !== peg$FAILED) {
						s7.push(s8);
						s8 = peg$parsewsp();
					}
					if (input.charCodeAt(peg$currPos) === 41) {
						s8 = peg$c2;
						peg$currPos++;
					} else {
						s8 = peg$FAILED;
						if (peg$silentFails === 0) peg$fail(peg$e2);
					}
					if (s8 !== peg$FAILED) {
						peg$savedPos = s0;
						s0 = peg$f5(s5, s6);
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		return s0;
	}
	function peg$parseskewX() {
		var s0, s1, s2, s3, s4, s5, s6, s7;
		s0 = peg$currPos;
		if (input.substr(peg$currPos, 5) === peg$c6) {
			s1 = peg$c6;
			peg$currPos += 5;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) peg$fail(peg$e6);
		}
		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$parsewsp();
			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$parsewsp();
			}
			if (input.charCodeAt(peg$currPos) === 40) {
				s3 = peg$c1;
				peg$currPos++;
			} else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) peg$fail(peg$e1);
			}
			if (s3 !== peg$FAILED) {
				s4 = [];
				s5 = peg$parsewsp();
				while (s5 !== peg$FAILED) {
					s4.push(s5);
					s5 = peg$parsewsp();
				}
				s5 = peg$parsenumber();
				if (s5 !== peg$FAILED) {
					s6 = [];
					s7 = peg$parsewsp();
					while (s7 !== peg$FAILED) {
						s6.push(s7);
						s7 = peg$parsewsp();
					}
					if (input.charCodeAt(peg$currPos) === 41) {
						s7 = peg$c2;
						peg$currPos++;
					} else {
						s7 = peg$FAILED;
						if (peg$silentFails === 0) peg$fail(peg$e2);
					}
					if (s7 !== peg$FAILED) {
						peg$savedPos = s0;
						s0 = peg$f6(s5);
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		return s0;
	}
	function peg$parseskewY() {
		var s0, s1, s2, s3, s4, s5, s6, s7;
		s0 = peg$currPos;
		if (input.substr(peg$currPos, 5) === peg$c7) {
			s1 = peg$c7;
			peg$currPos += 5;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) peg$fail(peg$e7);
		}
		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$parsewsp();
			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$parsewsp();
			}
			if (input.charCodeAt(peg$currPos) === 40) {
				s3 = peg$c1;
				peg$currPos++;
			} else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) peg$fail(peg$e1);
			}
			if (s3 !== peg$FAILED) {
				s4 = [];
				s5 = peg$parsewsp();
				while (s5 !== peg$FAILED) {
					s4.push(s5);
					s5 = peg$parsewsp();
				}
				s5 = peg$parsenumber();
				if (s5 !== peg$FAILED) {
					s6 = [];
					s7 = peg$parsewsp();
					while (s7 !== peg$FAILED) {
						s6.push(s7);
						s7 = peg$parsewsp();
					}
					if (input.charCodeAt(peg$currPos) === 41) {
						s7 = peg$c2;
						peg$currPos++;
					} else {
						s7 = peg$FAILED;
						if (peg$silentFails === 0) peg$fail(peg$e2);
					}
					if (s7 !== peg$FAILED) {
						peg$savedPos = s0;
						s0 = peg$f7(s5);
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		return s0;
	}
	function peg$parsenumber() {
		var s0, s1, s2, s3;
		s0 = peg$currPos;
		s1 = peg$currPos;
		s2 = peg$parsesign();
		if (s2 === peg$FAILED) s2 = null;
		s3 = peg$parsefloatingPointConstant();
		if (s3 !== peg$FAILED) {
			s2 = [s2, s3];
			s1 = s2;
		} else {
			peg$currPos = s1;
			s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$f8(s1);
		}
		s0 = s1;
		if (s0 === peg$FAILED) {
			s0 = peg$currPos;
			s1 = peg$currPos;
			s2 = peg$parsesign();
			if (s2 === peg$FAILED) s2 = null;
			s3 = peg$parseintegerConstant();
			if (s3 !== peg$FAILED) {
				s2 = [s2, s3];
				s1 = s2;
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$f9(s1);
			}
			s0 = s1;
		}
		return s0;
	}
	function peg$parsecommaWspNumber() {
		var s0, s1, s2;
		s0 = peg$currPos;
		s1 = peg$parsecommaWsp();
		if (s1 !== peg$FAILED) {
			s2 = peg$parsenumber();
			if (s2 !== peg$FAILED) {
				peg$savedPos = s0;
				s0 = peg$f10(s2);
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		return s0;
	}
	function peg$parsecommaWspTwoNumbers() {
		var s0, s1, s2, s3, s4;
		s0 = peg$currPos;
		s1 = peg$parsecommaWsp();
		if (s1 !== peg$FAILED) {
			s2 = peg$parsenumber();
			if (s2 !== peg$FAILED) {
				s3 = peg$parsecommaWsp();
				if (s3 !== peg$FAILED) {
					s4 = peg$parsenumber();
					if (s4 !== peg$FAILED) {
						peg$savedPos = s0;
						s0 = peg$f11(s2, s4);
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		return s0;
	}
	function peg$parsecommaWsp() {
		var s0, s1, s2, s3, s4;
		s0 = peg$currPos;
		s1 = [];
		s2 = peg$parsewsp();
		if (s2 !== peg$FAILED) while (s2 !== peg$FAILED) {
			s1.push(s2);
			s2 = peg$parsewsp();
		}
		else s1 = peg$FAILED;
		if (s1 !== peg$FAILED) {
			s2 = peg$parsecomma();
			if (s2 === peg$FAILED) s2 = null;
			s3 = [];
			s4 = peg$parsewsp();
			while (s4 !== peg$FAILED) {
				s3.push(s4);
				s4 = peg$parsewsp();
			}
			s1 = [
				s1,
				s2,
				s3
			];
			s0 = s1;
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		if (s0 === peg$FAILED) {
			s0 = peg$currPos;
			s1 = peg$parsecomma();
			if (s1 !== peg$FAILED) {
				s2 = [];
				s3 = peg$parsewsp();
				while (s3 !== peg$FAILED) {
					s2.push(s3);
					s3 = peg$parsewsp();
				}
				s1 = [s1, s2];
				s0 = s1;
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		}
		return s0;
	}
	function peg$parsecomma() {
		var s0;
		if (input.charCodeAt(peg$currPos) === 44) {
			s0 = peg$c8;
			peg$currPos++;
		} else {
			s0 = peg$FAILED;
			if (peg$silentFails === 0) peg$fail(peg$e8);
		}
		return s0;
	}
	function peg$parseintegerConstant() {
		var s0, s1;
		s0 = peg$currPos;
		s1 = peg$parsedigitSequence();
		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$f12(s1);
		}
		s0 = s1;
		return s0;
	}
	function peg$parsefloatingPointConstant() {
		var s0, s1, s2;
		s0 = peg$currPos;
		s1 = peg$parsefractionalConstant();
		if (s1 !== peg$FAILED) {
			s2 = peg$parseexponent();
			if (s2 === peg$FAILED) s2 = null;
			peg$savedPos = s0;
			s0 = peg$f13(s1, s2);
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		if (s0 === peg$FAILED) {
			s0 = peg$currPos;
			s1 = peg$parsedigitSequence();
			if (s1 !== peg$FAILED) {
				s2 = peg$parseexponent();
				if (s2 !== peg$FAILED) {
					peg$savedPos = s0;
					s0 = peg$f14(s1, s2);
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		}
		return s0;
	}
	function peg$parsefractionalConstant() {
		var s0, s1, s2, s3;
		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parsedigitSequence();
		if (s1 === peg$FAILED) s1 = null;
		if (input.charCodeAt(peg$currPos) === 46) {
			s2 = peg$c9;
			peg$currPos++;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) peg$fail(peg$e10);
		}
		if (s2 !== peg$FAILED) {
			s3 = peg$parsedigitSequence();
			if (s3 !== peg$FAILED) {
				peg$savedPos = s0;
				s0 = peg$f15(s1, s3);
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		if (s0 === peg$FAILED) {
			s0 = peg$currPos;
			s1 = peg$parsedigitSequence();
			if (s1 !== peg$FAILED) {
				if (input.charCodeAt(peg$currPos) === 46) {
					s2 = peg$c9;
					peg$currPos++;
				} else {
					s2 = peg$FAILED;
					if (peg$silentFails === 0) peg$fail(peg$e10);
				}
				if (s2 !== peg$FAILED) {
					peg$savedPos = s0;
					s0 = peg$f16(s1);
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) peg$fail(peg$e9);
		}
		return s0;
	}
	function peg$parseexponent() {
		var s0, s1, s2, s3;
		s0 = peg$currPos;
		s1 = input.charAt(peg$currPos);
		if (peg$r0.test(s1)) peg$currPos++;
		else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) peg$fail(peg$e11);
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$parsesign();
			if (s2 === peg$FAILED) s2 = null;
			s3 = peg$parsedigitSequence();
			if (s3 !== peg$FAILED) {
				peg$savedPos = s0;
				s0 = peg$f17(s2, s3);
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		return s0;
	}
	function peg$parsesign() {
		var s0;
		s0 = input.charAt(peg$currPos);
		if (peg$r1.test(s0)) peg$currPos++;
		else {
			s0 = peg$FAILED;
			if (peg$silentFails === 0) peg$fail(peg$e12);
		}
		return s0;
	}
	function peg$parsedigitSequence() {
		var s0, s1;
		s0 = [];
		s1 = peg$parsedigit();
		if (s1 !== peg$FAILED) while (s1 !== peg$FAILED) {
			s0.push(s1);
			s1 = peg$parsedigit();
		}
		else s0 = peg$FAILED;
		return s0;
	}
	function peg$parsedigit() {
		var s0;
		s0 = input.charAt(peg$currPos);
		if (peg$r2.test(s0)) peg$currPos++;
		else {
			s0 = peg$FAILED;
			if (peg$silentFails === 0) peg$fail(peg$e13);
		}
		return s0;
	}
	function peg$parsewsp() {
		var s0;
		s0 = input.charAt(peg$currPos);
		if (peg$r3.test(s0)) peg$currPos++;
		else {
			s0 = peg$FAILED;
			if (peg$silentFails === 0) peg$fail(peg$e14);
		}
		return s0;
	}
	peg$result = peg$startRuleFunction();
	if (options.peg$library) return {
		peg$result,
		peg$currPos,
		peg$FAILED,
		peg$maxFailExpected,
		peg$maxFailPos
	};
	if (peg$result !== peg$FAILED && peg$currPos === input.length) return peg$result;
	else {
		if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());
		throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
	}
}

//#endregion
//#region node_modules/.pnpm/transformation-matrix@3.0.0/node_modules/transformation-matrix/src/fromTransformAttribute.js
/**
* Parser for SVG Trasform Attribute http://www.w3.org/TR/SVG/coords.html#TransformAttribute
* @param transformString {string} Transform string as defined by w3 Consortium
* @returns {MatrixDescriptor[]} Array of MatrixDescriptor
*
* @example
* > fromTransformAttribute('translate(-10,-10) scale(2,2) translate(10,10)')
* [
*  { type: 'translate', tx: -10, ty: -10},
*  { type: 'scale', sx: 2, sy: 2 },
*  { type: 'translate', tx: 10, ty: 10}
* ]
*
* > compose(fromDefinition(fromTransformAttribute('translate(-10, -10) scale(10, 10)')))
* { a: 10, c: 0, e: -10, b: 0, d: 10, f: -10 }
*/
function fromTransformAttribute(transformString) {
	return peg$parse(transformString);
}

//#endregion
//#region node_modules/.pnpm/yerror@8.0.0/node_modules/yerror/dist/index.js
/**
* A YError class able to contain some params and
*  print better stack traces
* @extends Error
*/
var YError = class YError extends Error {
	code;
	params;
	wrappedErrors;
	constructor(wrappedErrors, errorCode, ...params) {
		if (!(wrappedErrors instanceof Array)) {
			params = ("undefined" === typeof errorCode ? [] : [errorCode]).concat(params);
			errorCode = wrappedErrors;
			wrappedErrors = [];
		}
		super(errorCode);
		this.code = errorCode || "E_UNEXPECTED";
		this.params = params;
		this.wrappedErrors = wrappedErrors;
		this.name = this.toString();
		if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
	}
	/**
	* Wraps any error and output a YError with an error
	*  code and some params as debug values.
	* @param {Error} err
	* The error to wrap
	* @param {string} [errorCode = 'E_UNEXPECTED']
	* The error code corresponding to the actual error
	* @param {...YErrorParams} [params]
	* Some additional debugging values
	* @return {YError}
	* The wrapped error
	*/
	static wrap(err, errorCode, ...params) {
		const wrappedErrorIsACode = _looksLikeAYErrorCode(err.message);
		const wrappedErrors = ("wrappedErrors" in err ? err.wrappedErrors : []).concat(err);
		if (!errorCode) if (wrappedErrorIsACode) errorCode = err.message;
		else errorCode = "E_UNEXPECTED";
		if (err.message && !wrappedErrorIsACode) params.push(err.message);
		return new YError(wrappedErrors, errorCode, ...params);
	}
	/**
	* Return a YError as is or wraps any other error and output
	*  a YError with a code and some params as debug values.
	* @param {Error} err
	* The error to cast
	* @param {string} [errorCode = 'E_UNEXPECTED']
	* The error code corresponding to the actual error
	* @param {...YErrorParams} [params]
	* Some additional debugging values
	* @return {YError}
	* The wrapped error
	*/
	static cast(err, errorCode, ...params) {
		if (_looksLikeAYError(err)) return err;
		return YError.wrap(err, errorCode, ...params);
	}
	/**
	* Same than `YError.wrap()` but preserves the code
	*  and the debug values of the error if it is
	*  already an instance of the YError constructor.
	* @param {Error} err
	* The error to bump
	* @param {string} [errorCode = 'E_UNEXPECTED']
	* The error code corresponding to the actual error
	* @param {...YErrorParams} [params]
	* Some additional debugging values
	* @return {YError}
	* The wrapped error
	*/
	static bump(err, errorCode, ...params) {
		if (_looksLikeAYError(err)) return YError.wrap(err, err.code, ...err.params);
		return YError.wrap(err, errorCode, ...params);
	}
	toString() {
		return (this.wrappedErrors.length ? this.wrappedErrors[this.wrappedErrors.length - 1].stack + os.EOL : "") + this.constructor.name + ": " + this.code + " (" + this.params.join(", ") + ")";
	}
};
function _looksLikeAYError(err) {
	return !!(err instanceof YError) || !!(err.constructor && err.constructor.name && err.constructor.name.endsWith("Error") && "code" in err && "string" === typeof err.code && _looksLikeAYErrorCode(err.code) && "params" in err && err.params && err.params instanceof Array);
}
function _looksLikeAYErrorCode(str) {
	return /^([A-Z0-9_]+)$/.test(str);
}

//#endregion
//#region node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({ "node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports, module) {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse(val);
		else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n = parseFloat(match[1]);
		var type = (match[2] || "ms").toLowerCase();
		switch (type) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y;
			case "weeks":
			case "week":
			case "w": return n * w;
			case "days":
			case "day":
			case "d": return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return void 0;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return Math.round(ms / d) + "d";
		if (msAbs >= h) return Math.round(ms / h) + "h";
		if (msAbs >= m) return Math.round(ms / m) + "m";
		if (msAbs >= s) return Math.round(ms / s) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return plural(ms, msAbs, d, "day");
		if (msAbs >= h) return plural(ms, msAbs, h, "hour");
		if (msAbs >= m) return plural(ms, msAbs, m, "minute");
		if (msAbs >= s) return plural(ms, msAbs, s, "second");
		return ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms, msAbs, n, name) {
		var isPlural = msAbs >= n * 1.5;
		return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
	}
} });

//#endregion
//#region node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js
var require_common = __commonJS({ "node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js"(exports, module) {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*/
	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = require_ms();
		createDebug.destroy = destroy;
		Object.keys(env).forEach((key) => {
			createDebug[key] = env[key];
		});
		/**
		* The currently active debug mode names, and names to skip.
		*/
		createDebug.names = [];
		createDebug.skips = [];
		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};
		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;
			for (let i = 0; i < namespace.length; i++) {
				hash = (hash << 5) - hash + namespace.charCodeAt(i);
				hash |= 0;
			}
			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;
			function debug$2(...args) {
				if (!debug$2.enabled) return;
				const self$1 = debug$2;
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self$1.diff = ms;
				self$1.prev = prevTime;
				self$1.curr = curr;
				prevTime = curr;
				args[0] = createDebug.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					if (match === "%%") return "%";
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === "function") {
						const val = args[index];
						match = formatter.call(self$1, val);
						args.splice(index, 1);
						index--;
					}
					return match;
				});
				createDebug.formatArgs.call(self$1, args);
				const logFn = self$1.log || createDebug.log;
				logFn.apply(self$1, args);
			}
			debug$2.namespace = namespace;
			debug$2.useColors = createDebug.useColors();
			debug$2.color = createDebug.selectColor(namespace);
			debug$2.extend = extend;
			debug$2.destroy = createDebug.destroy;
			Object.defineProperty(debug$2, "enabled", {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) return enableOverride;
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}
					return enabledCache;
				},
				set: (v) => {
					enableOverride = v;
				}
			});
			if (typeof createDebug.init === "function") createDebug.init(debug$2);
			return debug$2;
		}
		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;
			createDebug.names = [];
			createDebug.skips = [];
			const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
			for (const ns of split) if (ns[0] === "-") createDebug.skips.push(ns.slice(1));
			else createDebug.names.push(ns);
		}
		/**
		* Checks if the given string matches a namespace template, honoring
		* asterisks as wildcards.
		*
		* @param {String} search
		* @param {String} template
		* @return {Boolean}
		*/
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;
			while (searchIndex < search.length) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) if (template[templateIndex] === "*") {
				starIndex = templateIndex;
				matchIndex = searchIndex;
				templateIndex++;
			} else {
				searchIndex++;
				templateIndex++;
			}
			else if (starIndex !== -1) {
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else return false;
			while (templateIndex < template.length && template[templateIndex] === "*") templateIndex++;
			return templateIndex === template.length;
		}
		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [...createDebug.names, ...createDebug.skips.map((namespace) => "-" + namespace)].join(",");
			createDebug.enable("");
			return namespaces;
		}
		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			for (const skip of createDebug.skips) if (matchesTemplate(name, skip)) return false;
			for (const ns of createDebug.names) if (matchesTemplate(name, ns)) return true;
			return false;
		}
		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		}
		createDebug.enable(createDebug.load());
		return createDebug;
	}
	module.exports = setup;
} });

//#endregion
//#region node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/browser.js
var require_browser = __commonJS({ "node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/browser.js"(exports, module) {
	/**
	* This is the web browser implementation of `debug()`.
	*/
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = localstorage();
	exports.destroy = (() => {
		let warned = false;
		return () => {
			if (!warned) {
				warned = true;
				console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
			}
		};
	})();
	/**
	* Colors.
	*/
	exports.colors = [
		"#0000CC",
		"#0000FF",
		"#0033CC",
		"#0033FF",
		"#0066CC",
		"#0066FF",
		"#0099CC",
		"#0099FF",
		"#00CC00",
		"#00CC33",
		"#00CC66",
		"#00CC99",
		"#00CCCC",
		"#00CCFF",
		"#3300CC",
		"#3300FF",
		"#3333CC",
		"#3333FF",
		"#3366CC",
		"#3366FF",
		"#3399CC",
		"#3399FF",
		"#33CC00",
		"#33CC33",
		"#33CC66",
		"#33CC99",
		"#33CCCC",
		"#33CCFF",
		"#6600CC",
		"#6600FF",
		"#6633CC",
		"#6633FF",
		"#66CC00",
		"#66CC33",
		"#9900CC",
		"#9900FF",
		"#9933CC",
		"#9933FF",
		"#99CC00",
		"#99CC33",
		"#CC0000",
		"#CC0033",
		"#CC0066",
		"#CC0099",
		"#CC00CC",
		"#CC00FF",
		"#CC3300",
		"#CC3333",
		"#CC3366",
		"#CC3399",
		"#CC33CC",
		"#CC33FF",
		"#CC6600",
		"#CC6633",
		"#CC9900",
		"#CC9933",
		"#CCCC00",
		"#CCCC33",
		"#FF0000",
		"#FF0033",
		"#FF0066",
		"#FF0099",
		"#FF00CC",
		"#FF00FF",
		"#FF3300",
		"#FF3333",
		"#FF3366",
		"#FF3399",
		"#FF33CC",
		"#FF33FF",
		"#FF6600",
		"#FF6633",
		"#FF9900",
		"#FF9933",
		"#FFCC00",
		"#FFCC33"
	];
	/**
	* Currently only WebKit-based Web Inspectors, Firefox >= v31,
	* and the Firebug extension (any Firefox version) are known
	* to support "%c" CSS customizations.
	*
	* TODO: add a `localStorage` variable to explicitly enable/disable colors
	*/
	function useColors() {
		if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
		if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
		let m$1;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m$1 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m$1[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	/**
	* Colorize log arguments if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
		if (!this.useColors) return;
		const c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		let index = 0;
		let lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, (match) => {
			if (match === "%%") return;
			index++;
			if (match === "%c") lastC = index;
		});
		args.splice(lastC, 0, c);
	}
	/**
	* Invokes `console.debug()` when available.
	* No-op when `console.debug` is not a "function".
	* If `console.debug` is not available, falls back
	* to `console.log`.
	*
	* @api public
	*/
	exports.log = console.debug || console.log || (() => {});
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		try {
			if (namespaces) exports.storage.setItem("debug", namespaces);
			else exports.storage.removeItem("debug");
		} catch (error) {}
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		let r;
		try {
			r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
		} catch (error) {}
		if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
		return r;
	}
	/**
	* Localstorage attempts to return the localstorage.
	*
	* This is necessary because safari throws
	* when a user disables cookies/localstorage
	* and you attempt to access it.
	*
	* @return {LocalStorage}
	* @api private
	*/
	function localstorage() {
		try {
			return localStorage;
		} catch (error) {}
	}
	module.exports = require_common()(exports);
	const { formatters } = module.exports;
	/**
	* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	*/
	formatters.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (error) {
			return "[UnexpectedJSONParseError]: " + error.message;
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/svgicons2svgfont@15.0.1/node_modules/svgicons2svgfont/dist/iconsdir.js
var import_browser$1 = __toESM(require_browser(), 1);
const warn$1 = (0, import_browser$1.default)("svgicons2svgfont");

//#endregion
//#region node_modules/.pnpm/svgicons2svgfont@15.0.1/node_modules/svgicons2svgfont/dist/index.js
var import_browser = __toESM(require_browser(), 1);
const warn = (0, import_browser.default)("svgicons2svgfont");
function matrixFromTransformAttribute(transformAttributeString) {
	return compose(fromDefinition(fromTransformAttribute(transformAttributeString)));
}
function tagShouldRender(curTag, parents) {
	let values;
	return !parents.some((tag) => {
		if ("undefined" !== typeof tag.attributes.display && "none" === tag.attributes.display.toLowerCase()) return true;
		if ("undefined" !== typeof tag.attributes.width && 0 === parseFloat(tag.attributes.width)) return true;
		if ("undefined" !== typeof tag.attributes.height && 0 === parseFloat(tag.attributes.height)) return true;
		if ("undefined" !== typeof tag.attributes.viewBox) {
			values = tag.attributes.viewBox.split(/\s*,*\s|\s,*\s*|,/);
			if (0 === parseFloat(values[2]) || 0 === parseFloat(values[3])) return true;
		}
		return false;
	});
}
function getTagColor(currTag, parents) {
	const defaultColor = "black";
	const fillVal = currTag.attributes.fill;
	let color;
	const parentsLength = parents.length;
	if ("none" === fillVal) return color;
	if ("currentColor" === fillVal) return defaultColor;
	if ("inherit" === fillVal) {
		if (0 === parentsLength) return defaultColor;
		return getTagColor(parents[parentsLength - 1], parents.slice(0, parentsLength - 1));
	}
	return fillVal;
}
var SVGIcons2SVGFontStream = class extends Transform {
	_options;
	glyphs;
	constructor(options) {
		super({ objectMode: true });
		this.glyphs = [];
		this._options = {
			...options,
			fontName: options.fontName || "iconfont",
			fontId: options.fontId || options.fontName || "iconfont",
			fixedWidth: options.fixedWidth || false,
			descent: options.descent || 0,
			round: options.round || 1e13,
			metadata: options.metadata || "",
			usePathBounds: options.usePathBounds || false
		};
	}
	_transform(svgIconStream, _unused, svgIconStreamCallback) {
		const saxStream = Sax.createStream(true);
		const parents = [];
		const transformStack = [];
		function applyTransform(d$1) {
			const last = transformStack[transformStack.length - 1];
			if (!last) return new SVGPathData(d$1);
			return new SVGPathData(d$1).matrix(last.a, last.b, last.c, last.d, last.e, last.f);
		}
		const glyph = svgIconStream.metadata || {};
		glyph.width = 0;
		glyph.height = 1;
		glyph.paths = [];
		this.glyphs.push(glyph);
		if ("string" !== typeof glyph.name) this.emit("error", new Error(`Please provide a name for the glyph at index ${this.glyphs.length - 1}`));
		if (this.glyphs.some((anotherGlyph) => anotherGlyph !== glyph && anotherGlyph.name === glyph.name)) this.emit("error", new Error(`The glyph name "${glyph.name}" must be unique.`));
		if (glyph.unicode && glyph.unicode instanceof Array && glyph.unicode.length) {
			if (glyph.unicode.some((unicodeA, i) => glyph.unicode.some((unicodeB, j) => i !== j && unicodeA === unicodeB))) this.emit("error", new Error(`Given codepoints for the glyph "${glyph.name}" contain duplicates.`));
		} else if ("string" !== typeof glyph.unicode) this.emit("error", new Error(`Please provide a codepoint for the glyph "${glyph.name}"`));
		if (this.glyphs.some((anotherGlyph) => anotherGlyph !== glyph && anotherGlyph.unicode === glyph.unicode)) this.emit("error", new Error(`The glyph "${glyph.name}" codepoint seems to be used already elsewhere.`));
		saxStream.on("opentag", (tag) => {
			let values;
			let color;
			parents.push(tag);
			try {
				const currentTransform = transformStack[transformStack.length - 1];
				if ("undefined" !== typeof tag.attributes.transform) {
					const transform$1 = matrixFromTransformAttribute(tag.attributes.transform);
					transformStack.push(compose([currentTransform, transform$1].filter(Boolean)));
				} else transformStack.push(currentTransform);
				if (!tagShouldRender(tag, parents)) return;
				if ("svg" === tag.name) if ("viewBox" in tag.attributes) {
					values = tag.attributes.viewBox.split(/\s*,*\s|\s,*\s*|,/);
					const dX = parseFloat(values[0]);
					const dY = parseFloat(values[1]);
					const width = parseFloat(values[2]);
					const height = parseFloat(values[3]);
					glyph.width = "width" in tag.attributes ? parseFloat(tag.attributes.width) : width;
					glyph.height = "height" in tag.attributes ? parseFloat(tag.attributes.height) : height;
					transformStack[transformStack.length - 1] = compose([
						transformStack[transformStack.length - 1],
						translate(-dX, -dY),
						scale(glyph.width / width, glyph.height / height)
					].filter(Boolean));
				} else {
					if ("width" in tag.attributes) glyph.width = parseFloat(tag.attributes.width);
					else {
						warn(`⚠️ - Glyph "${glyph.name}" has no width attribute, using current glyph horizontal bounds.`);
						glyph.defaultWidth = true;
					}
					if ("height" in tag.attributes) glyph.height = parseFloat(tag.attributes.height);
					else {
						warn(`⚠️ - Glyph "${glyph.name}" has no height attribute, using current glyph vertical bounds.`);
						glyph.defaultHeight = true;
					}
				}
				else if ("clipPath" === tag.name) warn(`🤷 - Found a clipPath element in the icon "${glyph.name}" the result may be different than expected.`);
				else if ("rect" === tag.name && "none" !== tag.attributes.fill) glyph.paths.push(applyTransform(svgshapes2svgpath_default.rectToPath(tag.attributes)));
				else if ("line" === tag.name && "none" !== tag.attributes.fill) {
					warn(`🤷 - Found a line element in the icon "${glyph.name}" the result could be different than expected.`);
					glyph.paths.push(applyTransform(svgshapes2svgpath_default.lineToPath(tag.attributes)));
				} else if ("polyline" === tag.name && "none" !== tag.attributes.fill) {
					warn(`🤷 - Found a polyline element in the icon "${glyph.name}" the result could be different than expected.`);
					glyph.paths.push(applyTransform(svgshapes2svgpath_default.polylineToPath(tag.attributes)));
				} else if ("polygon" === tag.name && "none" !== tag.attributes.fill) glyph.paths.push(applyTransform(svgshapes2svgpath_default.polygonToPath(tag.attributes)));
				else if (["circle", "ellipse"].includes(tag.name) && "none" !== tag.attributes.fill) glyph.paths.push(applyTransform(svgshapes2svgpath_default.circleToPath(tag.attributes)));
				else if ("path" === tag.name && tag.attributes.d && "none" !== tag.attributes.fill) glyph.paths.push(applyTransform(tag.attributes.d));
				if ("none" !== tag.attributes.fill) {
					color = getTagColor(tag, parents);
					if ("undefined" !== typeof color) glyph.color = color;
				}
			} catch (err) {
				this.emit("error", new Error(`Got an error parsing the glyph "${glyph.name}": ${err?.message}.`));
			}
		});
		saxStream.on("error", (err) => {
			this.emit("error", err);
		});
		saxStream.on("closetag", () => {
			transformStack.pop();
			parents.pop();
		});
		saxStream.on("end", () => {
			svgIconStreamCallback();
		});
		svgIconStream.pipe(saxStream);
	}
	_flush(svgFontFlushCallback) {
		this.glyphs.forEach((glyph) => {
			if (glyph.defaultHeight || glyph.defaultWidth || this._options.usePathBounds) {
				const glyphPath = new SVGPathData("");
				(glyph.paths || []).forEach((path) => {
					glyphPath.commands.push(...path.commands);
				});
				const bounds = glyphPath.getBounds();
				if (glyph.defaultHeight || this._options.usePathBounds) glyph.height = bounds.maxY - bounds.minY;
				if (glyph.defaultWidth || this._options.usePathBounds) glyph.width = bounds.maxX - bounds.minX;
			}
		});
		const maxGlyphHeight = this.glyphs.reduce((curMax, glyph) => Math.max(curMax, glyph.height), 0);
		const maxGlyphWidth = this.glyphs.reduce((curMax, glyph) => Math.max(curMax, glyph.width), 0);
		const fontHeight = this._options.fontHeight || maxGlyphHeight;
		let fontWidth = maxGlyphWidth;
		if (this._options.normalize) fontWidth = this.glyphs.reduce((curMax, glyph) => Math.max(curMax, fontHeight / glyph.height * glyph.width), 0);
		else if (this._options.fontHeight) fontWidth *= fontHeight / maxGlyphHeight;
		this._options.ascent = "undefined" !== typeof this._options.ascent ? this._options.ascent : fontHeight - this._options.descent;
		if (!this._options.normalize && fontHeight > (1 < this.glyphs.length ? this.glyphs.reduce((curMin, glyph) => Math.min(curMin, glyph.height), Infinity) : this.glyphs[0].height)) warn("🤷 - The provided icons do not have the same heights. This could lead to unexpected results. Using the normalize option may help.");
		if (1e3 > fontHeight) warn("🤷 - A fontHeight of at least than 1000 is recommended, otherwise further steps (rounding in svg2ttf) could lead to ugly results. Use the fontHeight option to scale icons.");
		this.push("<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\" >\n<svg xmlns=\"http://www.w3.org/2000/svg\">\n" + (this._options.metadata ? "<metadata>" + this._options.metadata + "</metadata>\n" : "") + "<defs>\n  <font id=\"" + this._options.fontId + "\" horiz-adv-x=\"" + fontWidth + "\">\n    <font-face font-family=\"" + this._options.fontName + "\"\n      units-per-em=\"" + fontHeight + "\" ascent=\"" + this._options.ascent + "\"\n      descent=\"" + this._options.descent + "\"" + (this._options.fontWeight ? "\n      font-weight=\"" + this._options.fontWeight + "\"" : "") + (this._options.fontStyle ? "\n      font-style=\"" + this._options.fontStyle + "\"" : "") + " />\n    <missing-glyph horiz-adv-x=\"0\" />\n");
		this.glyphs.forEach((glyph) => {
			const ratio = this._options.normalize ? fontHeight / (this._options.preserveAspectRatio && glyph.width > glyph.height ? glyph.width : glyph.height) : fontHeight / maxGlyphHeight;
			if (!isFinite(ratio)) throw new YError("E_BAD_COMPUTED_RATIO", ratio);
			glyph.width *= ratio;
			glyph.height *= ratio;
			const glyphPath = new SVGPathData("");
			if (this._options.fixedWidth) glyph.width = fontWidth;
			const yOffset = glyph.height - this._options.descent;
			let glyphPathTransform = {
				a: 1,
				b: 0,
				c: 0,
				d: -1,
				e: 0,
				f: yOffset
			};
			if (1 !== ratio) glyphPathTransform = compose(glyphPathTransform, scale(ratio, ratio));
			(glyph.paths || []).forEach((path) => {
				glyphPath.commands.push(...path.toAbs().matrix(glyphPathTransform.a, glyphPathTransform.b, glyphPathTransform.c, glyphPathTransform.d, glyphPathTransform.e, glyphPathTransform.f).commands);
			});
			const bounds = (this._options.centerHorizontally || this._options.centerVertically) && glyphPath.getBounds();
			if (this._options.centerHorizontally && bounds && "maxX" in bounds) glyphPath.translate((glyph.width - (bounds.maxX - bounds.minX)) / 2 - bounds.minX);
			if (this._options.centerVertically && bounds && "maxX" in bounds) glyphPath.translate(0, (fontHeight - (bounds.maxY - bounds.minY)) / 2 - bounds.minY - this._options.descent);
			delete glyph.paths;
			const d$1 = glyphPath.round(this._options.round).encode();
			glyph.unicode.forEach((unicode, i) => {
				const unicodeStr = [...unicode].map((char) => "&#x" + char.codePointAt(0).toString(16).toUpperCase() + ";").join("");
				this.push("    <glyph glyph-name=\"" + glyph.name + (0 === i ? "" : "-" + i) + "\"\n      unicode=\"" + unicodeStr + "\"\n      horiz-adv-x=\"" + glyph.width + "\" d=\"" + d$1 + "\" />\n");
			});
		});
		this.push("  </font>\n</defs>\n</svg>\n");
		warn("✅ - Font created");
		if ("function" === typeof this._options.callback) this._options.callback(this.glyphs);
		svgFontFlushCallback();
	}
};

//#endregion
//#region src/utils.ts
const FileExtensions = [
	"eot",
	"ttf",
	"woff",
	"woff2",
	"svg",
	"css",
	"demoHTML"
];

//#endregion
//#region src/index.ts
async function SvgPacker({ icons,...options }) {
	const { fontName = "iconfont", cssPrefix = "iconfont", fileName = "iconfont", startCodepoint = 57345, fontHeight = 1e3, descent = 0, fixedWidth = false } = options ?? {};
	const parsedIcons = icons.map(({ svg, name, unicode }, i) => {
		return {
			svg,
			name,
			unicode: unicode ?? startCodepoint + i
		};
	});
	const iconStreams = parsedIcons.map(({ svg, unicode, name }) => {
		const iconStream = new PassThrough();
		iconStream.write(svg, "utf8");
		iconStream.end();
		iconStream.metadata = {
			unicode: [String.fromCharCode(unicode)],
			name
		};
		return iconStream;
	});
	const files = {};
	const zip = await downloadZip(generateZipEntries(iconStreams, {
		fontName,
		cssPrefix,
		fileName,
		startCodepoint,
		fontHeight,
		descent,
		fixedWidth,
		icons: parsedIcons
	}, files)).blob();
	return {
		files,
		zip: {
			name: `${options.fileName}.zip`,
			blob: zip,
			url: makeUrl(zip)
		}
	};
}
function addFile(files, filename, ext, data, mime = "text/plain") {
	const blob = new Blob([data], { type: mime });
	files[ext] = {
		name: filename,
		blob,
		url: makeUrl(blob)
	};
	return {
		name: filename,
		input: blob,
		url: makeUrl(blob)
	};
}
function makeUrl(blob) {
	if (typeof window === "undefined" || !window.URL || !window.URL.createObjectURL) return null;
	return window.URL.createObjectURL(blob);
}
function makeSVG(iconStreams, options) {
	return new Promise((resolve) => {
		const fontStream = new SVGIcons2SVGFontStream(options);
		const parts = [];
		const decoder = new StringDecoder("utf8");
		fontStream.on("data", (chunk) => {
			parts.push(decoder.write(chunk));
		});
		fontStream.on("finish", () => {
			resolve(parts.join(""));
		});
		iconStreams.forEach(fontStream.write.bind(fontStream));
		fontStream.end();
	});
}
function makeTTF(svgFont) {
	const ttfFontBuffer = svg2ttf(svgFont).buffer;
	return ttfFontBuffer;
}
function makeEOT(ttfFontBuffer) {
	const eotFontBuffer = ttf2eot(ttfFontBuffer).buffer;
	return eotFontBuffer;
}
function makeWOFF(ttfFontBuffer) {
	const woffFontBuffer = ttf2woff(new Uint8Array(ttfFontBuffer.buffer)).buffer;
	return woffFontBuffer;
}
async function browserPromise() {
	const [{ wasmUrl }, { initWasmBrowser, ttf2woff2 }] = await Promise.all([import("./ttf2woff2.wasm-D9pC94Jv.mjs"), import("./wasm-0jzfuaTN.mjs")]);
	await initWasmBrowser(wasmUrl);
	return ttf2woff2;
}
async function preloadWasm() {
	var _process$versions;
	const isNode = typeof process$1 < "u" && typeof process$1.stdout < "u" && !((_process$versions = process$1.versions) === null || _process$versions === void 0 ? void 0 : _process$versions.deno) && !globalThis.window;
	return isNode ? await import("ttf2woff2/jssrc/index.js").then((m$1) => {
		return m$1.default || m$1;
	}).catch((e) => {
		console.error("ERROR", e);
		Promise.reject(e);
	}) : await browserPromise();
}
async function makeWOFF2(ttfFontBuffer) {
	ttfFontBuffer = new Uint8Array(ttfFontBuffer);
	let buf = buffer.Buffer.alloc(ttfFontBuffer.length);
	for (let i = 0, j = ttfFontBuffer.length; i < j; i++) buf.writeUInt8(ttfFontBuffer[i], i);
	const ttf2woff2 = await preloadWasm();
	if (!ttf2woff2 || !(typeof ttf2woff2 === "function")) throw new Error("ttf2woff2 not found");
	if (ttf2woff2 instanceof Error) throw ttf2woff2;
	buf = ttf2woff2(buf);
	const woff2FontBuffer = new Uint8Array(buf.length);
	for (let i = 0, j = buf.length; i < j; i++) woff2FontBuffer[i] = buf.readUInt8(i);
	return woff2FontBuffer;
}
function makeCSS({ icons, fontName, fileName, cssPrefix }) {
	const css = `
@font-face {
  font-family: "${fontName}";
  src: url("./${fileName}.eot");
  src: url("./${fileName}.eot") format("embedded-opentype"),
       url("./${fileName}.ttf") format("truetype"),
       url("./${fileName}.woff") format("woff"),
       url("./${fileName}.woff2") format("woff2"),
       url("./${fileName}.svg") format("svg");
  font-weight: normal;
  font-style: normal;
}

.${cssPrefix} {
  font-family: "${fontName}" !important;
  font-size: 1em;
  font-style: normal;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

${icons.map(({ name, unicode }) => `
.${cssPrefix}.${name.replace(/:/g, "\\:")}:before {
content: "\\${unicode.toString(16)}";
}
`).join("")}
`;
	return css;
}
function makeDemoHTML({ icons, fontName, fileName, cssPrefix }) {
	return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>${fontName} Demo</title>
  <link rel="stylesheet" href="./${fileName}.css">
  <style>
html {
  font-size: 1.2em;
}
i {
  padding: 5px;
  color: #717171;
  display: inline-block;
}
  </style>
</head>
<body>
${icons.map(({ name }) => `<i class="${cssPrefix} ${name}"></i>`).join("")}
<!-- Generated by SVG Pack (https://github.com/antfu/svg-packer) -->
</body>
`;
}
async function* generateZipEntries(iconStreams, options, files) {
	const content = await makeSVG(iconStreams, options);
	yield addFile(files, `${options.fileName}.svg`, "svg", content, "image/svg+xml");
	const ttfFontBuffer = makeTTF(content);
	yield addFile(files, `${options.fileName}.ttf`, "ttf", ttfFontBuffer, "application/octet-stream");
	yield addFile(files, `${options.fileName}.eot`, "eot", makeEOT(ttfFontBuffer), "application/octet-stream");
	yield addFile(files, `${options.fileName}.woff`, "woff", makeWOFF(ttfFontBuffer), "application/octet-stream");
	yield addFile(files, `${options.fileName}.woff2`, "woff2", await makeWOFF2(ttfFontBuffer), "application/octet-stream");
	yield addFile(files, `${options.fileName}.css`, "css", makeCSS(options), "text/css");
	yield addFile(files, "_demo.html", "demoHTML", makeDemoHTML(options), "text/html");
}
if (typeof window !== "undefined") window.SvgPacker = SvgPacker;
if (typeof self !== "undefined") self.SvgPacker = SvgPacker;
if (typeof globalThis !== "undefined") globalThis.SvgPacker = SvgPacker;

//#endregion
export { FileExtensions, SvgPacker };